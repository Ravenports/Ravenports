# Buildsheet autogenerated by ravenadm tool -- Do not edit.

NAMEBASE=		wpa_supplicant
VERSION=		2.8
KEYWORDS=		security net
VARIANTS=		standard
SDESC[standard]=	Supplicant (client) for WPA/802.1x protocols
HOMEPAGE=		https://w1.fi/wpa_supplicant/
CONTACT=		nobody

DOWNLOAD_GROUPS=	main patchsite
SITES[main]=		https://w1.fi/releases/
SITES[patchsite]=	https://w1.fi/security/2018-1/
DISTFILE[1]=		wpa_supplicant-2.8.tar.gz:main
DF_INDEX=		1
SPKGS[standard]=	single

OPTIONS_AVAILABLE=	BSD WIRED NDIS TEST TLS PEAP TTLS MSCHAPV2 GTC LEAP
			OTP PSK FAST SIM PWD PAX AKA AKA_PRIME SAKE GPSK TNC
			IKEV2 EKE WPS PKCS SMARTCARD SYSLOG INTERWORKING
			HOTSPOT IEEE80211AC IEEE80211N IEEE80211R IEEE80211W
			DELAYED_MIC P2P TDLS NO_ROAMING HT_OVERRIDES
			VHT_OVERRIDES WPS_ER WPS_NOREG WPS_NFC
OPTIONS_STANDARD=	BSD WIRED NDIS TEST TLS PEAP TTLS MSCHAPV2 GTC LEAP
			OTP PSK FAST SIM PWD PAX AKA AKA_PRIME SAKE GPSK TNC
			IKEV2 EKE WPS PKCS SMARTCARD SYSLOG INTERWORKING
			HOTSPOT IEEE80211AC IEEE80211N IEEE80211R IEEE80211W
			DELAYED_MIC P2P TDLS NO_ROAMING HT_OVERRIDES
			VHT_OVERRIDES WPS_ER WPS_NOREG WPS_NFC
OPTGROUP_RESTRICTED=	DRIVERS EXTAP
OPTDESCR[EXTAP]=	Extensible Authentication Protocols
OPTDESCR[DRIVERS]=	Supported Drivers
OPTGROUP[EXTAP]=	TLS PEAP TTLS MSCHAPV2 GTC LEAP OTP PSK FAST SIM PWD
			PAX AKA AKA_PRIME SAKE GPSK TNC IKEV2 EKE
OPTGROUP[DRIVERS]=	BSD WIRED NDIS TEST
OPT_ON[freebsd]=	BSD
OPT_ON[all]=		WIRED NDIS TLS PEAP TTLS MSCHAPV2 GTC LEAP OTP PSK
			WPS PKCS SMARTCARD IEEE80211R SYSLOG INTERWORKING
			HOTSPOT
OPT_ON[dragonfly]=	BSD

BUILDRUN_DEPENDS=	libpcap:single:standard

USES=			cpe gmake readline ssl

LICENSE=		BSD3CLAUSE:single
LICENSE_FILE=		BSD3CLAUSE:{{WRKSRC}}/README
LICENSE_SCHEME=		solo

FPC_EQUIVALENT=		security/wpa_supplicant

PATCHFILES_STRIP=	-p1

BUILD_WRKSRC=		{{WRKSRC}}/wpa_supplicant
MAKE_ENV=		V=1

INSTALL_WRKSRC=		{{WRKSRC}}/src
SUB_FILES=		pkg-message-single-dragonfly
			pkg-message-single-freebsd

CFLAGS=			-I{{OPENSSLINC}}
LDFLAGS=		-L{{OPENSSLLIB}}
VAR_OPSYS[freebsd]=	LDFLAGS=-lutil
VAR_OPSYS[dragonfly]=	LDFLAGS=-lutil

[IEEE80211AC].DESCRIPTION=		Very High Throughput, AP mode (IEEE 802.11ac)
[IEEE80211AC].PREVENTS_ON=		IEEE80211N

[TDLS].DESCRIPTION=			Tunneled Direct Link Setup

[INTERWORKING].DESCRIPTION=		Improve ext. network interworking (IEEE 802.11u)

[TLS].DESCRIPTION=			Transport Layer Security

[WPS_ER].DESCRIPTION=			Enable WPS External Registrar

[FAST].DESCRIPTION=			Flexible Authentication via Secure Tunneling

[PKCS].DESCRIPTION=			PKCS#12 (PFS) support

[PSK].DESCRIPTION=			Pre-Shared key

[WPS_NOREG].DESCRIPTION=		Disable open network credentials when registrar

[TNC].DESCRIPTION=			Trusted Network Connect

[NO_ROAMING].DESCRIPTION=		Disable roaming

[IEEE80211N].DESCRIPTION=		High Throughput, AP mode (IEEE 802.11n)
[IEEE80211N].PREVENTS_ON=		IEEE80211AC

[SMARTCARD].DESCRIPTION=		Private key on smartcard support

[HT_OVERRIDES].DESCRIPTION=		Disable HT/HT40, mask MCS rates, etc

[GPSK].DESCRIPTION=			Generalized Pre-Shared Key

[LEAP].DESCRIPTION=			Lightweight Extensible Authentication Protocol

[IEEE80211R].DESCRIPTION=		Fast BSS Transition (IEEE 802.11r-2008)

[WPS].DESCRIPTION=			Wi-Fi Protected Setup

[EKE].DESCRIPTION=			Encrypted Key Exchange

[TTLS].DESCRIPTION=			Tunneled Transport Layer Security

[HOTSPOT].DESCRIPTION=			Hotspot 2.0

[SAKE].DESCRIPTION=			Shared-Secret Authentication & Key Establishment

[SIM].DESCRIPTION=			Subscriber Identity Module
[SIM].BUILDRUN_DEPENDS_ON=		pcsc-lite:primary:standard
[SIM].CFLAGS_ON=			-I{{LOCALBASE}}/include/PCSC

[IEEE80211W].DESCRIPTION=		Management Frame Protection (IEEE 802.11w)

[AKA].DESCRIPTION=			Authentication and Key Agreement (UMTS)
[AKA].BUILDRUN_DEPENDS_ON=		pcsc-lite:primary:standard
[AKA].CFLAGS_ON=			-I{{LOCALBASE}}/include/PCSC

[SYSLOG].DESCRIPTION=			Send debug messages to syslog instead of stdout

[PAX].DESCRIPTION=			Password Authenticated Exchange

[MSCHAPV2].DESCRIPTION=			Microsoft CHAP version 2 (RFC 2759)

[OTP].DESCRIPTION=			One-Time Password

[WIRED].DESCRIPTION=			Wired ethernet interface

[TEST].DESCRIPTION=			Development testing interface

[NDIS].DESCRIPTION=			Windows NDIS interface

[P2P].DESCRIPTION=			Peer-to-Peer support

[IKEV2].DESCRIPTION=			Internet Key Exchange version 2

[GTC].DESCRIPTION=			Generic Token Card

[BSD].DESCRIPTION=			BSD net80211 interface

[AKA_PRIME].DESCRIPTION=		AKA Prime variant (RFC 5448)
[AKA_PRIME].BUILDRUN_DEPENDS_ON=	pcsc-lite:primary:standard
[AKA_PRIME].CFLAGS_ON=			-I{{LOCALBASE}}/include/PCSC

[VHT_OVERRIDES].DESCRIPTION=		Disable VHT, mask MCS rates, etc

[DELAYED_MIC].DESCRIPTION=		Mitigate TKIP attack, random delay on MIC errors

[PWD].DESCRIPTION=			Shared password (RFC 5931)

[WPS_NFC].DESCRIPTION=			Near Field Communication (NFC) configuration

[PEAP].DESCRIPTION=			Protected Extensible Authentication Protocol

post-patch-NO_ROAMING-ON:
	${ECHO_CMD} CONFIG_NO_ROAMING=y >> ${BUILD_WRKSRC}/.config

post-patch:
.if ${PLIST_SUB:MSIM_ON=} || ${PLIST_SUB:MAKA_ON=} || ${PLIST_SUB:MAKA_PRIME_ON=}
	${ECHO_CMD} CONFIG_PCSC=y >> ${BUILD_WRKSRC}/.config
.endif
.if ${PLIST_SUB:MIEEE80211AC_ON=} || ${PLIST_SUB:MIEEE80211N_ON=}
	${ECHO_CMD} CONFIG_AP=y >> ${BUILD_WRKSRC}/.config
.endif
	${ECHO_CMD} CONFIG_OS=unix >> ${BUILD_WRKSRC}/.config
	${ECHO_CMD} CONFIG_CTRL_IFACE=unix >> ${BUILD_WRKSRC}/.config
	${ECHO_CMD} CONFIG_BACKEND=file >> ${BUILD_WRKSRC}/.config
	${ECHO_CMD} CONFIG_TLS=openssl >> ${BUILD_WRKSRC}/.config

post-patch-PWD-ON:
	${ECHO_CMD} CONFIG_EAP_PWD=y >> ${BUILD_WRKSRC}/.config

post-patch-GTC-ON:
	${ECHO_CMD} CONFIG_EAP_GTC=y >> ${BUILD_WRKSRC}/.config

post-patch-TDLS-ON:
	${ECHO_CMD} CONFIG_TDLS=y >> ${BUILD_WRKSRC}/.config

post-patch-WPS_NOREG-ON:
	${ECHO_CMD} CONFIG_WPS_REG_DISABLE_OPEN=y >> ${BUILD_WRKSRC}/.config

post-patch-MSCHAPV2-ON:
	${ECHO_CMD} CONFIG_EAP_MSCHAPv2=y >> ${BUILD_WRKSRC}/.config

post-patch-SYSLOG-ON:
	${ECHO_CMD} CONFIG_DEBUG_SYSLOG=y >> ${BUILD_WRKSRC}/.config

post-patch-WPS-ON:
	${ECHO_CMD} CONFIG_WPS=y >> ${BUILD_WRKSRC}/.config

post-patch-IEEE80211N-ON:
	${ECHO_CMD} CONFIG_IEEE80211N=y >> ${BUILD_WRKSRC}/.config

post-patch-linux:
	${ECHO_CMD} CONFIG_L2_PACKET=linux >> ${BUILD_WRKSRC}/.config

post-patch-OTP-ON:
	${ECHO_CMD} CONFIG_EAP_OTP=y >> ${BUILD_WRKSRC}/.config

post-patch-TEST-ON:
	${ECHO_CMD} CONFIG_DRIVER_TEST=y >> ${BUILD_WRKSRC}/.config

post-patch-TTLS-ON:
	${ECHO_CMD} CONFIG_EAP_TTLS=y >> ${BUILD_WRKSRC}/.config

post-patch-HOTSPOT-ON:
	${ECHO_CMD} CONFIG_HS20=y >> ${BUILD_WRKSRC}/.config

post-patch-WIRED-ON:
	${ECHO_CMD} CONFIG_DRIVER_WIRED=y >> ${BUILD_WRKSRC}/.config

post-patch-PEAP-ON:
	${ECHO_CMD} CONFIG_EAP_PEAP=y >> ${BUILD_WRKSRC}/.config

post-patch-dragonfly:
	${ECHO_CMD} CONFIG_L2_PACKET=freebsd >> ${BUILD_WRKSRC}/.config
	${CP} ${FILESDIR}/Packet32.[ch] ${FILESDIR}/ntddndis.h \
		${WRKSRC}/src/utils

post-patch-BSD-ON:
	${ECHO_CMD} CONFIG_DRIVER_BSD=y >> ${BUILD_WRKSRC}/.config

post-patch-DELAYED_MIC-ON:
	${ECHO_CMD} CONFIG_DELAYED_MIC_ERROR_REPORT=y >> ${BUILD_WRKSRC}/.config

post-patch-SAKE-ON:
	${ECHO_CMD} CONFIG_EAP_SAKE=y >> ${BUILD_WRKSRC}/.config

post-patch-TNC-ON:
	${ECHO_CMD} CONFIG_EAP_TNC=y >> ${BUILD_WRKSRC}/.config

post-patch-FAST-ON:
	${ECHO_CMD} CONFIG_EAP_FAST=y >> ${BUILD_WRKSRC}/.config

post-patch-VHT_OVERRIDES-ON:
	${ECHO_CMD} CONFIG_VHT_OVERRIDES=y >> ${BUILD_WRKSRC}/.config

post-patch-WPS_NFC-ON:
	${ECHO_CMD} CONFIG_WPS_NFC=y >> ${BUILD_WRKSRC}/.config

post-patch-GPSK-ON:
	${ECHO_CMD} CONFIG_EAP_GPSK=y >> ${BUILD_WRKSRC}/.config

post-patch-AKA-ON:
	${ECHO_CMD} CONFIG_EAP_AKA=y >> ${BUILD_WRKSRC}/.config

post-patch-PSK-ON:
	${ECHO_CMD} CONFIG_EAP_PSK=y >> ${BUILD_WRKSRC}/.config

post-patch-IEEE80211W-ON:
	${ECHO_CMD} CONFIG_IEEE80211W=y >> ${BUILD_WRKSRC}/.config

post-patch-IEEE80211R-ON:
	${ECHO_CMD} CONFIG_IEEE80211R=y >> ${BUILD_WRKSRC}/.config

post-patch-PAX-ON:
	${ECHO_CMD} CONFIG_EAP_PAX=y >> ${BUILD_WRKSRC}/.config

post-patch-EKE-ON:
	${ECHO_CMD} CONFIG_EAP_EKE=y >> ${BUILD_WRKSRC}/.config

post-patch-NDIS-ON:
	${ECHO_CMD} CONFIG_DRIVER_NDIS=y >> ${BUILD_WRKSRC}/.config

post-patch-P2P-ON:
	${ECHO_CMD} CONFIG_P2P=y >> ${BUILD_WRKSRC}/.config

post-patch-LEAP-ON:
	${ECHO_CMD} CONFIG_EAP_LEAP=y >> ${BUILD_WRKSRC}/.config

post-patch-SMARTCARD-ON:
	${ECHO_CMD} CONFIG_SMARTCARD=y >> ${BUILD_WRKSRC}/.config

post-patch-PKCS-ON:
	${ECHO_CMD} CONFIG_PKCS12=y >> ${BUILD_WRKSRC}/.config

post-patch-HT_OVERRIDES-ON:
	${ECHO_CMD} CONFIG_HT_OVERRIDES=y >> ${BUILD_WRKSRC}/.config

post-patch-INTERWORKING-ON:
	${ECHO_CMD} CONFIG_INTERWORKING=y >> ${BUILD_WRKSRC}/.config

do-install:
	(cd ${BUILD_WRKSRC} && \
		${INSTALL_PROGRAM} wpa_supplicant wpa_cli \
		wpa_passphrase ${STAGEDIR}${PREFIX}/sbin)
	${INSTALL_DATA} ${BUILD_WRKSRC}/wpa_supplicant.conf \
		${STAGEDIR}${PREFIX}/etc/wpa_supplicant.conf.sample

post-patch-freebsd:
	${ECHO_CMD} CONFIG_L2_PACKET=freebsd >> ${BUILD_WRKSRC}/.config
	${CP} ${FILESDIR}/Packet32.[ch] ${FILESDIR}/ntddndis.h \
		${WRKSRC}/src/utils

post-patch-TLS-ON:
	${ECHO_CMD} CONFIG_EAP_TLS=y >> ${BUILD_WRKSRC}/.config

post-patch-sunos:
	${ECHO_CMD} CONFIG_L2_PACKET=none >> ${BUILD_WRKSRC}/.config

post-patch-IEEE80211AC-ON:
	${ECHO_CMD} CONFIG_IEEE80211AC=y >> ${BUILD_WRKSRC}/.config

post-patch-IKEV2-ON:
	${ECHO_CMD} CONFIG_EAP_IKEv2=y >> ${BUILD_WRKSRC}/.config

post-patch-SIM-ON:
	${ECHO_CMD} CONFIG_EAP_SIM=y >> ${BUILD_WRKSRC}/.config

post-patch-WPS_ER-ON:
	${ECHO_CMD} CONFIG_WPS_ER=y >> ${BUILD_WRKSRC}/.config

[FILE:684:descriptions/desc.single]
wpa_supplicant is a client (supplicant) with support for WPA and WPA2
(IEEE 802.11i / RSN). It is suitable for both desktop/laptop computers and
embedded systems. Supplicant is the IEEE 802.1X/WPA component that is used
in the client stations. It implements key negotiation with a WPA
Authenticator and it controls the roaming and IEEE 802.11 authentication/
association of the wlan driver.

wpa_supplicant is designed to be a "daemon" program that runs in the
background and acts as the backend component controlling the wireless
connection. wpa_supplicant supports separate frontend programs and a
text-based frontend (wpa_cli) and a GUI (wpa_gui) are included with
wpa_supplicant.


[FILE:104:distinfo]
a689336a12a99151b9de5e25bfccadb88438f4f4438eb8db331cd94346fd3d96      3155904 wpa_supplicant-2.8.tar.gz


[FILE:86:manifests/plist.single]
@sample etc/wpa_supplicant.conf.sample
sbin/
 wpa_cli
 wpa_passphrase
 wpa_supplicant


[FILE:371:patches/patch-src-l2_packet-l2_packet_freebsd.c]
--- src/l2_packet/l2_packet_freebsd.c.orig	2019-04-21 07:10:22 UTC
+++ src/l2_packet/l2_packet_freebsd.c
@@ -8,7 +8,10 @@
  */
 
 #include "includes.h"
-#if defined(__APPLE__) || defined(__GLIBC__)
+#if defined(__FreeBSD__) \
+ || defined(__DragonFly__) \
+ || defined(__APPLE__) \
+ || defined(__GLIBC__)
 #include <net/bpf.h>
 #endif /* __APPLE__ */
 #include <pcap.h>


[FILE:851:patches/patch-src_drivers_driver__ndis.c]
--- src/drivers/driver_ndis.c.orig	2019-04-21 07:10:22 UTC
+++ src/drivers/driver_ndis.c
@@ -2106,7 +2106,11 @@ static int wpa_driver_ndis_get_names(str
 		dlen = dpos - desc;
 	else
 		dlen = os_strlen(desc);
-	drv->adapter_desc = dup_binstr(desc, dlen);
+	drv->adapter_desc = os_malloc(dlen + 1);
+	if (drv->adapter_desc) {
+		os_memcpy(drv->adapter_desc, desc, dlen);
+		drv->adapter_desc[dlen] = '\0';
+	}
 	os_free(b);
 	if (drv->adapter_desc == NULL)
 		return -1;
@@ -2274,7 +2278,11 @@ static int wpa_driver_ndis_get_names(str
 	} else {
 		dlen = os_strlen(desc[i]);
 	}
-	drv->adapter_desc = dup_binstr(desc[i], dlen);
+	drv->adapter_desc = os_malloc(dlen + 1);
+	if (drv->adapter_desc) {
+		os_memcpy(drv->adapter_desc, desc[i], dlen);
+		drv->adapter_desc[dlen] = '\0';
+	}
 	os_free(names);
 	if (drv->adapter_desc == NULL)
 		return -1;


[FILE:710:patches/patch-src_wps_wps__upnp.c]
--- src/wps/wps_upnp.c.orig	2019-04-21 07:10:22 UTC
+++ src/wps/wps_upnp.c
@@ -840,7 +840,8 @@ fail:
 }
 
 
-#if defined(__FreeBSD__) || defined(__FreeBSD_kernel__)
+#if defined(__FreeBSD__) || defined(__FreeBSD_kernel__) \
+ || defined(__DragonFly__)
 #include <sys/sysctl.h>
 #include <net/route.h>
 #include <net/if_dl.h>
@@ -927,7 +928,8 @@ int get_netif_info(const char *net_if, u
 		goto fail;
 	}
 	os_memcpy(mac, req.ifr_addr.sa_data, 6);
-#elif defined(__FreeBSD__) || defined(__FreeBSD_kernel__)
+#elif defined(__FreeBSD__) || defined(__FreeBSD_kernel__) \
+   || defined(__DragonFly__)
 	if (eth_get(net_if, mac) < 0) {
 		wpa_printf(MSG_ERROR, "WPS UPnP: Failed to get MAC address");
 		goto fail;


[FILE:1027:patches/patch-wpa__supplicant_scan.c]
--- wpa_supplicant/scan.c.orig	2019-04-21 07:10:22 UTC
+++ wpa_supplicant/scan.c
@@ -1951,7 +1951,7 @@ struct wpabuf * wpa_scan_get_vendor_ie_m
  * better. */
 static int wpa_scan_result_compar(const void *a, const void *b)
 {
-#define MIN(a,b) a < b ? a : b
+#define MINAB(a,b) a < b ? a : b
 	struct wpa_scan_res **_wa = (void *) a;
 	struct wpa_scan_res **_wb = (void *) b;
 	struct wpa_scan_res *wa = *_wa;
@@ -1980,9 +1980,9 @@ static int wpa_scan_result_compar(const
 
 	if (wa->flags & wb->flags & WPA_SCAN_LEVEL_DBM) {
 		snr_a_full = wa->snr;
-		snr_a = MIN(wa->snr, GREAT_SNR);
+		snr_a = MINAB(wa->snr, GREAT_SNR);
 		snr_b_full = wb->snr;
-		snr_b = MIN(wb->snr, GREAT_SNR);
+		snr_b = MINAB(wb->snr, GREAT_SNR);
 	} else {
 		/* Level is not in dBm, so we can't calculate
 		 * SNR. Just use raw level (units unknown). */
@@ -2008,7 +2008,7 @@ static int wpa_scan_result_compar(const
 	if (snr_b_full == snr_a_full)
 		return wb->qual - wa->qual;
 	return snr_b_full - snr_a_full;
-#undef MIN
+#undef MINAB
 }
 
 


[FILE:624:patches/patch-wpa__supplicant_wpa__priv.c]
--- wpa_supplicant/wpa_priv.c.orig	2019-04-21 07:10:22 UTC
+++ wpa_supplicant/wpa_priv.c
@@ -1197,6 +1197,7 @@ static void usage(void)
 int main(int argc, char *argv[])
 {
 	int c, i;
+	int eloop_initialized = 0;
 	int ret = -1;
 	char *pid_file = NULL;
 	int daemonize = 0;
@@ -1239,6 +1240,7 @@ int main(int argc, char *argv[])
 		usage();
 		goto out2;
 	}
+	else eloop_initialized = 1;
 
 	wpa_printf(MSG_DEBUG, "wpa_priv control directory: '%s'", ctrl_dir);
 
@@ -1272,7 +1274,8 @@ out:
 		wpa_priv_interface_deinit(prev);
 	}
 
-	eloop_destroy();
+	if (eloop_initialized)
+		eloop_destroy();
 
 out2:
 	if (daemonize)


[FILE:9504:files/Packet32.c]
/*-
 * Copyright (c) 2005
 *      Bill Paul <wpaul@windriver.com>.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by Bill Paul.
 * 4. Neither the name of the author nor the names of any co-contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY Bill Paul AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL Bill Paul OR THE VOICES IN HIS HEAD
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * This file implements a small portion of the Winpcap API for the
 * Windows NDIS interface in wpa_supplicant. It provides just enough
 * routines to fool wpa_supplicant into thinking it's really running
 * in a Windows environment.
 */

#include <sys/types.h>
#include <sys/param.h>
#include <sys/socket.h>
#include <sys/ioctl.h>
#include <sys/errno.h>
#include <sys/sysctl.h>
#include <sys/fcntl.h>
#include <net/if.h>
#include <net/if_dl.h>
#include <net/if_var.h>

#include <netinet/in.h>
#include <arpa/inet.h>
#include <netdb.h>
#include <net/route.h>

#ifdef __FreeBSD__
#include <net80211/ieee80211_ioctl.h>
#endif
#ifdef __DragonFly__
#include <netproto/802_11/ieee80211_ioctl.h>
#endif

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <pcap.h>

#include "Packet32.h"

#define OID_802_11_ADD_KEY      0x0d01011D

typedef ULONGLONG NDIS_802_11_KEY_RSC;
typedef UCHAR NDIS_802_11_MAC_ADDRESS[6];

typedef struct NDIS_802_11_KEY {
	ULONG Length;
	ULONG KeyIndex;
	ULONG KeyLength;
	NDIS_802_11_MAC_ADDRESS BSSID;
	NDIS_802_11_KEY_RSC KeyRSC;
	UCHAR KeyMaterial[1];
} NDIS_802_11_KEY;

typedef struct NDIS_802_11_KEY_COMPAT {
	ULONG Length;
	ULONG KeyIndex;
	ULONG KeyLength;
	NDIS_802_11_MAC_ADDRESS BSSID;
	UCHAR Pad[6]; /* Make struct layout match Windows. */
	NDIS_802_11_KEY_RSC KeyRSC;
#ifdef notdef
	UCHAR KeyMaterial[1];
#endif
} NDIS_802_11_KEY_COMPAT;

#define TRUE 1
#define FALSE 0

struct adapter {
	int			socket;
	char			name[IFNAMSIZ];
	int			prev_roaming;
};

PCHAR
PacketGetVersion(void)
{
	return("FreeBSD WinPcap compatibility shim v1.0");
}

void *
PacketOpenAdapter(CHAR *iface)
{
	struct adapter		*a;
	int			s;
	int			ifflags;
	struct ifreq		ifr;
	struct ieee80211req	ireq;

	s = socket(PF_INET, SOCK_DGRAM, 0);

	if (s == -1)
		return(NULL);

	a = malloc(sizeof(struct adapter));
	if (a == NULL)
		return(NULL);

	a->socket = s;
	if (strncmp(iface, "\\Device\\NPF_", 12) == 0)
		iface += 12;
	else if (strncmp(iface, "\\DEVICE\\", 8) == 0)
		iface += 8;
	snprintf(a->name, IFNAMSIZ, "%s", iface);

	/* Turn off net80211 roaming */
	bzero((char *)&ireq, sizeof(ireq));
	strncpy(ireq.i_name, iface, sizeof (ifr.ifr_name));
	ireq.i_type = IEEE80211_IOC_ROAMING;
	if (ioctl(a->socket, SIOCG80211, &ireq) == 0) {
		a->prev_roaming = ireq.i_val;
		ireq.i_val = IEEE80211_ROAMING_MANUAL;
		if (ioctl(a->socket, SIOCS80211, &ireq) < 0)
			fprintf(stderr,
			    "Could not set IEEE80211_ROAMING_MANUAL\n");
	}

	bzero((char *)&ifr, sizeof(ifr));
        strncpy(ifr.ifr_name, iface, sizeof (ifr.ifr_name));
        if (ioctl(a->socket, SIOCGIFFLAGS, (caddr_t)&ifr) < 0) {
		free(a);
		close(s);
		return(NULL);
        }
        ifr.ifr_flags |= IFF_UP;
        if (ioctl(a->socket, SIOCSIFFLAGS, (caddr_t)&ifr) < 0) {
		free(a);
		close(s);
		return(NULL);
        }

	return(a);
}

int
PacketRequest(void *iface, BOOLEAN set, PACKET_OID_DATA *oid)
{
	struct adapter		*a;
	uint32_t		retval;
	struct ifreq		ifr;
	NDIS_802_11_KEY		*old;
	NDIS_802_11_KEY_COMPAT	*new;
	PACKET_OID_DATA		*o = NULL;

	if (iface == NULL)
		return(-1);

	a = iface;
	bzero((char *)&ifr, sizeof(ifr));

	/*
	 * This hack is necessary to work around a difference
	 * betwee the GNU C and Microsoft C compilers. The NDIS_802_11_KEY
	 * structure has a uint64_t in it, right after an array of
	 * chars. The Microsoft compiler inserts padding right before
	 * the 64-bit value to align it on a 64-bit boundary, but
	 * GCC only aligns it on a 32-bit boundary. Trying to pass
	 * the GCC-formatted structure to an NDIS binary driver
	 * fails because some of the fields appear to be at the
	 * wrong offsets.
	 *
	 * To get around this, if we detect someone is trying to do
	 * a set operation on OID_802_11_ADD_KEY, we shuffle the data
	 * into a properly padded structure and pass that into the
	 * driver instead. This allows the driver_ndis.c code supplied
	 * with wpa_supplicant to work unmodified.
	 */

	if (set == TRUE && oid->Oid == OID_802_11_ADD_KEY) {
		old = (NDIS_802_11_KEY *)&oid->Data;
		o = malloc(sizeof(PACKET_OID_DATA) +
		    sizeof(NDIS_802_11_KEY_COMPAT) + old->KeyLength);
		if (o == NULL)
			return(0);
		bzero((char *)o, sizeof(PACKET_OID_DATA) +
		    sizeof(NDIS_802_11_KEY_COMPAT) + old->KeyLength);
		o->Oid = oid->Oid;
		o->Length = sizeof(NDIS_802_11_KEY_COMPAT) + old->KeyLength;
		new = (NDIS_802_11_KEY_COMPAT *)&o->Data;
		new->KeyRSC = old->KeyRSC;
		new->Length = o->Length;
		new->KeyIndex = old->KeyIndex;
		new->KeyLength = old->KeyLength;
		bcopy(old->BSSID, new->BSSID, sizeof(NDIS_802_11_MAC_ADDRESS));
		bcopy(old->KeyMaterial, (char *)new +
		    sizeof(NDIS_802_11_KEY_COMPAT), new->KeyLength);
        	ifr.ifr_data = (caddr_t)o;
	} else
        	ifr.ifr_data = (caddr_t)oid;

        strlcpy(ifr.ifr_name, a->name, sizeof(ifr.ifr_name));

	if (set == TRUE)
		retval = ioctl(a->socket, SIOCSDRVSPEC, &ifr);
	else
		retval = ioctl(a->socket, SIOCGDRVSPEC, &ifr);

	if (o != NULL)
		free(o);

	if (retval)
		return(0);

	return(1);
}

int
PacketGetAdapterNames(CHAR *namelist, ULONG *len)
{
	int			mib[6];
	size_t			needed;
	struct if_msghdr	*ifm;
	struct sockaddr_dl	*sdl;
	char			*buf, *lim, *next;
	char			*plist;
	int			spc;
	int			i, ifcnt = 0;

	plist = namelist;
	spc = 0;

	bzero(plist, *len);

	needed = 0;
	mib[0] = CTL_NET;
	mib[1] = PF_ROUTE;
	mib[2] = 0;             /* protocol */
	mib[3] = 0;             /* wildcard address family */
	mib[4] = NET_RT_IFLIST;
	mib[5] = 0;             /* no flags */

	if (sysctl (mib, 6, NULL, &needed, NULL, 0) < 0)
		return(FALSE);

	buf = malloc (needed);
	if (buf == NULL)
		return(FALSE);

	if (sysctl (mib, 6, buf, &needed, NULL, 0) < 0) {
		free(buf);
		return(FALSE);
	}

	lim = buf + needed;

	/* Generate interface name list. */

	next = buf;
	while (next < lim) {
		ifm = (struct if_msghdr *)next;
		if (ifm->ifm_type == RTM_IFINFO) {
			sdl = (struct sockaddr_dl *)(ifm + 1);
			if (strnstr(sdl->sdl_data, "wlan", sdl->sdl_nlen)) {
				if ((spc + sdl->sdl_nlen) > *len) {
					free(buf);
					return(FALSE);
				}
				strncpy(plist, sdl->sdl_data, sdl->sdl_nlen);
				plist += (sdl->sdl_nlen + 1);
				spc += (sdl->sdl_nlen + 1);
				ifcnt++;
			}
		}
		next += ifm->ifm_msglen;
	}


	/* Insert an extra "" as a spacer */

	plist++;
	spc++;

	/*
	 * Now generate the interface description list. There
	 * must be a unique description for each interface, and
	 * they have to match what the ndis_events program will
	 * feed in later. To keep this simple, we just repeat
	 * the interface list over again.
	 */

	next = buf;
	while (next < lim) {
		ifm = (struct if_msghdr *)next;
		if (ifm->ifm_type == RTM_IFINFO) {
			sdl = (struct sockaddr_dl *)(ifm + 1);
			if (strnstr(sdl->sdl_data, "wlan", sdl->sdl_nlen)) {
				if ((spc + sdl->sdl_nlen) > *len) {
					free(buf);
					return(FALSE);
				}
				strncpy(plist, sdl->sdl_data, sdl->sdl_nlen);
				plist += (sdl->sdl_nlen + 1);
				spc += (sdl->sdl_nlen + 1);
				ifcnt++;
			}
		}
		next += ifm->ifm_msglen;
	}

	free (buf);

	*len = spc + 1;

	return(TRUE);
}

void
PacketCloseAdapter(void *iface)
{	
	struct adapter		*a;
	struct ifreq		ifr;
	struct ieee80211req	ireq;

	if (iface == NULL)
		return;

	a = iface;

	/* Reset net80211 roaming */
	bzero((char *)&ireq, sizeof(ireq));
	strncpy(ireq.i_name, a->name, sizeof (ifr.ifr_name));
	ireq.i_type = IEEE80211_IOC_ROAMING;
	ireq.i_val = a->prev_roaming;
	ioctl(a->socket, SIOCS80211, &ireq);

	bzero((char *)&ifr, sizeof(ifr));
        strncpy(ifr.ifr_name, a->name, sizeof (ifr.ifr_name));
        ioctl(a->socket, SIOCGIFFLAGS, (caddr_t)&ifr);
        ifr.ifr_flags &= ~IFF_UP;
        ioctl(a->socket, SIOCSIFFLAGS, (caddr_t)&ifr);
	close(a->socket);
	free(a);

	return;
}


[FILE:2538:files/Packet32.h]
/*-
 * Copyright (c) 2005
 *      Bill Paul <wpaul@windriver.com>.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by Bill Paul.
 * 4. Neither the name of the author nor the names of any co-contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY Bill Paul AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL Bill Paul OR THE VOICES IN HIS HEAD
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 */

#ifndef _PACKET32_H_
#define _PACKET32_H_

#include <sys/types.h>
#include <ntddndis.h>

struct PACKET_OID_DATA {
	uint32_t		Oid;
	uint32_t		Length;
	uint8_t			Data[1];
};


typedef struct PACKET_OID_DATA PACKET_OID_DATA;

extern PCHAR PacketGetVersion(void);
extern void *PacketOpenAdapter(CHAR *);
extern int PacketRequest(void *, BOOLEAN, PACKET_OID_DATA *);
extern int PacketGetAdapterNames(CHAR *, ULONG *);
extern void PacketCloseAdapter(void *);

/*
 * This is for backwards compatibility on FreeBSD 5.
 */

#ifndef SIOCGDRVSPEC
#define SIOCSDRVSPEC	_IOW('i', 123, struct ifreq)	/* set driver-specific
								parameters */
#define SIOCGDRVSPEC	_IOWR('i', 123, struct ifreq)	/* get driver-specific
								parameters */
#endif

#endif /* _PACKET32_H_ */


[FILE:622:files/ntddndis.h]
#ifndef _NTDDNDIS_H_
#define _NTDDNDIS_H_

/*
 * Fake up some of the Windows type definitions so that the NDIS
 * interface module in wpa_supplicant will build.
 */

#define ULONG uint32_t
#define USHORT uint16_t
#define UCHAR uint8_t
#define LONG int32_t
#define SHORT int16_t
#define CHAR int8_t
#define ULONGLONG uint64_t
#define LONGLONG int64_t
#define BOOLEAN uint8_t
typedef void * LPADAPTER;
typedef char * PTSTR;
typedef char * PCHAR;

#define TRUE 1
#define FALSE 0

#define OID_802_3_CURRENT_ADDRESS               0x01010102
#define OID_802_3_MULTICAST_LIST                0x01010103

#endif /* _NTDDNDIS_H_ */


[FILE:148:files/pkg-message-single-dragonfly.in]
To use the ports version of WPA Supplicant instead of the base, add:

    wpa_supplicant_program="%%PREFIX%%/sbin/wpa_supplicant"

to /etc/rc.conf



[FILE:148:files/pkg-message-single-freebsd.in]
To use the ports version of WPA Supplicant instead of the base, add:

    wpa_supplicant_program="%%PREFIX%%/sbin/wpa_supplicant"

to /etc/rc.conf



[FILE:481:dragonfly/patch-wpa__supplicant_Makefile]
--- wpa_supplicant/Makefile.orig	2019-04-21 07:10:22 UTC
+++ wpa_supplicant/Makefile
@@ -131,6 +131,14 @@ OBJS += ../src/utils/os_$(CONFIG_OS).o
 OBJS_p += ../src/utils/os_$(CONFIG_OS).o
 OBJS_c += ../src/utils/os_$(CONFIG_OS).o
 
+ifdef CONFIG_DRIVER_NDIS
+OBJS += ../src/utils/Packet32.o
+ifdef CONFIG_PRIVSEP
+OBJS += ../src/drivers/driver_ndis.o
+endif
+OBJS_priv += ../src/utils/Packet32.o
+endif
+
 ifdef CONFIG_WPA_TRACE
 CFLAGS += -DWPA_TRACE
 OBJS += ../src/utils/trace.o


[FILE:1269:dragonfly/patch-wpa__supplicant_main.c]
--- wpa_supplicant/main.c.orig	2019-04-21 07:10:22 UTC
+++ wpa_supplicant/main.c
@@ -66,7 +66,7 @@ static void usage(void)
 	       "  -c = Configuration file\n"
 	       "  -C = ctrl_interface parameter (only used if -c is not)\n"
 	       "  -d = increase debugging verbosity (-dd even more)\n"
-	       "  -D = driver name (can be multiple drivers: nl80211,wext)\n"
+	       "  -D = driver name (can be multiple drivers: bsd,wired)\n"
 	       "  -e = entropy file\n"
 #ifdef CONFIG_DEBUG_FILE
 	       "  -f = log output to debug file instead of stdout\n"
@@ -105,8 +105,7 @@ static void usage(void)
 	       "  -W = wait for a control interface monitor before starting\n");
 
 	printf("example:\n"
-	       "  wpa_supplicant -D%s -iwlan0 -c/etc/wpa_supplicant.conf\n",
-	       wpa_drivers[0] ? wpa_drivers[0]->name : "nl80211");
+                "  wpa_supplicant -Dbsd -iwlan0 -c/etc/wpa_supplicant.conf\n");
 #endif /* CONFIG_NO_STDOUT_DEBUG */
 }
 
@@ -199,6 +198,11 @@ int main(int argc, char *argv[])
 
 	wpa_supplicant_fd_workaround(1);
 
+#ifdef CONFIG_DRIVER_NDIS
+	void driver_ndis_init_ops(void);
+	driver_ndis_init_ops();
+#endif /* CONFIG_DRIVER_NDIS */
+
 	for (;;) {
 		c = getopt(argc, argv,
 			   "b:Bc:C:D:de:f:g:G:hi:I:KLMm:No:O:p:P:qsTtuvW");


[FILE:328:dragonfly/patch-wpa__supplicant_wpa__supplicant.c]
--- wpa_supplicant/wpa_supplicant.c.orig	2019-04-21 07:10:22 UTC
+++ wpa_supplicant/wpa_supplicant.c
@@ -6357,7 +6357,7 @@ struct wpa_global * wpa_supplicant_init(
 	if (params == NULL)
 		return NULL;
 
-#ifdef CONFIG_DRIVER_NDIS
+#ifdef XXXCONFIG_DRIVER_NDIS
 	{
 		void driver_ndis_init_ops(void);
 		driver_ndis_init_ops();


[FILE:481:freebsd/patch-wpa__supplicant_Makefile]
--- wpa_supplicant/Makefile.orig	2019-04-21 07:10:22 UTC
+++ wpa_supplicant/Makefile
@@ -131,6 +131,14 @@ OBJS += ../src/utils/os_$(CONFIG_OS).o
 OBJS_p += ../src/utils/os_$(CONFIG_OS).o
 OBJS_c += ../src/utils/os_$(CONFIG_OS).o
 
+ifdef CONFIG_DRIVER_NDIS
+OBJS += ../src/utils/Packet32.o
+ifdef CONFIG_PRIVSEP
+OBJS += ../src/drivers/driver_ndis.o
+endif
+OBJS_priv += ../src/utils/Packet32.o
+endif
+
 ifdef CONFIG_WPA_TRACE
 CFLAGS += -DWPA_TRACE
 OBJS += ../src/utils/trace.o


[FILE:1269:freebsd/patch-wpa__supplicant_main.c]
--- wpa_supplicant/main.c.orig	2019-04-21 07:10:22 UTC
+++ wpa_supplicant/main.c
@@ -66,7 +66,7 @@ static void usage(void)
 	       "  -c = Configuration file\n"
 	       "  -C = ctrl_interface parameter (only used if -c is not)\n"
 	       "  -d = increase debugging verbosity (-dd even more)\n"
-	       "  -D = driver name (can be multiple drivers: nl80211,wext)\n"
+	       "  -D = driver name (can be multiple drivers: bsd,wired)\n"
 	       "  -e = entropy file\n"
 #ifdef CONFIG_DEBUG_FILE
 	       "  -f = log output to debug file instead of stdout\n"
@@ -105,8 +105,7 @@ static void usage(void)
 	       "  -W = wait for a control interface monitor before starting\n");
 
 	printf("example:\n"
-	       "  wpa_supplicant -D%s -iwlan0 -c/etc/wpa_supplicant.conf\n",
-	       wpa_drivers[0] ? wpa_drivers[0]->name : "nl80211");
+                "  wpa_supplicant -Dbsd -iwlan0 -c/etc/wpa_supplicant.conf\n");
 #endif /* CONFIG_NO_STDOUT_DEBUG */
 }
 
@@ -199,6 +198,11 @@ int main(int argc, char *argv[])
 
 	wpa_supplicant_fd_workaround(1);
 
+#ifdef CONFIG_DRIVER_NDIS
+	void driver_ndis_init_ops(void);
+	driver_ndis_init_ops();
+#endif /* CONFIG_DRIVER_NDIS */
+
 	for (;;) {
 		c = getopt(argc, argv,
 			   "b:Bc:C:D:de:f:g:G:hi:I:KLMm:No:O:p:P:qsTtuvW");


[FILE:328:freebsd/patch-wpa__supplicant_wpa__supplicant.c]
--- wpa_supplicant/wpa_supplicant.c.orig	2019-04-21 07:10:22 UTC
+++ wpa_supplicant/wpa_supplicant.c
@@ -6357,7 +6357,7 @@ struct wpa_global * wpa_supplicant_init(
 	if (params == NULL)
 		return NULL;
 
-#ifdef CONFIG_DRIVER_NDIS
+#ifdef XXXCONFIG_DRIVER_NDIS
 	{
 		void driver_ndis_init_ops(void);
 		driver_ndis_init_ops();

