# Buildsheet autogenerated by ravenadm tool -- Do not edit.

NAMEBASE=		edelib
VERSION=		2.1
KEYWORDS=		x11
VARIANTS=		standard
SDESC[standard]=	Component construction library for EDE
HOMEPAGE=		http://equinox-project.org/
CONTACT=		Michael_Reim[kraileth@elderlinux.org]

DOWNLOAD_GROUPS=	main
SITES[main]=		SF/ede/edelib/2.1/
DISTFILE[1]=		edelib-2.1.tar.gz:main
DF_INDEX=		1
SPKGS[standard]=	single

OPTIONS_AVAILABLE=	none
OPTIONS_STANDARD=	none

BUILD_DEPENDS=		jam:primary:standard
BUILDRUN_DEPENDS=	fltk:primary:standard
			dbus:single:standard

USES=			pkgconfig python:2.7 shebangfix

SHEBANG_FILES=		tools/edelib-mk-indextheme
			tools/edelib-convert-icontheme

MUST_CONFIGURE=		gnu

CFLAGS=			-fPIC
CXXFLAGS=		-fPIC

post-patch:
		${CP} ${FILESDIR}/scheme.h ${WRKSRC}/edelib/ts

post-stage:
		${RM} -r ${STAGEDIR}${PREFIX}/share/doc

do-build:
		(cd ${WRKSRC} && ${SETENV} ${MAKE_ENV} \
			jam)

do-install:
		(cd ${WRKSRC} && ${SETENV} ${MAKE_ENV} \
			prefix="${STAGEDIR}${PREFIX}" \
			jam install)

[FILE:235:descriptions/desc.single]
Edelib is the support library for Equinox Desktop Environment. It provides 
a collection of functions that do not fit in the toolkit FLTK but are 
necessary for a *nix DE. It might also be useful for other applications 
that use FLTK.


[FILE:96:distinfo]
38030d964affece5363edaf8e8f1ac2441f1a860472537a0501f6844e383f35c      1054649 edelib-2.1.tar.gz


[FILE:1307:manifests/plist.single]
include/edelib/
 DirWatch.h
 EdbusList.h
 Nls.h
 ForeignCallback.h
 EdbusConnection.h
 TableBase.h
 FontChooser.h
 Listener.h
 Ede.h
 edelib-global.h
 Directory.h
 Util.h
 PtyProcess.h
 Functional.h
 Theme.h
 ExpandableGroup.h
 DesktopFile.h
 Pty.h
 EdbusObjectPath.h
 Netwm.h
 Missing.h
 List.h
 XSettingsClient.h
 StrUtil.h
 SevenSeg.h
 IconChooser.h
 File.h
 Debug.h
include/edelib/ts/
 opdefines.h
 scheme-private.h
 scheme.h
include/edelib/
 Resource.h
 TempFile.h
 Scheme.h
 AnimateBox.h
 WindowUtils.h
 ColorDb.h
 MimeType.h
 Sipc.h
 FileTest.h
 Regex.h
 EdbusError.h
 MenuBase.h
 EdbusMessage.h
 MessageBox.h
 EdbusContainer.h
 for-each-macro.h
 XSettingsCommon.h
 EdbusData.h
 WindowXid.h
 MenuButton.h
 String.h
 DateTime.h
 Config.h
 FontCache.h
 XSettingsManager.h
 MenuBar.h
 TiXml.h
 SchemeEditor.h
 Run.h
 edelib-config.h
 IconTheme.h
 Color.h
 MenuTooltip.h
 Namespace.h
 Version.h
 IconLoader.h
 ThemeLoader.h
 Window.h
 EdbusDict.h
 MenuItem.h
bin/
 edelib-mk-indextheme
 edelib-dbus-explorer
 edelib-catchsegv
 edelib-update-font-cache
 edelib-convert-icontheme
 edelib-script
lib/
 libedelib_dbus.a
 libedelib_gui.a
 libedelib.a
lib/edelib/sslib/
 init-2.ss
 init.ss
 theme.ss
lib/pkgconfig/
 edelib.pc
 edelib-gui-no-images.pc
 edelib-gui.pc
 edelib-dbus.pc
share/edelib/colors/rgb.txt


[FILE:1380:patches/patch-src_WindowUtils.cpp]
--- src/WindowUtils.cpp.orig	2014-06-21 23:24:07.000000000 +0200
+++ src/WindowUtils.cpp	2017-10-18 12:26:55.886134000 +0200
@@ -1,5 +1,5 @@
 /*
- * $Id: WindowUtils.cpp 3106 2011-10-21 20:26:08Z karijes $
+ * $Id: WindowUtils.cpp 3592 2014-12-02 12:48:07Z karijes $
  *
  * Window utils
  * Copyright (c) 1998-2006 by Bill Spitzak and others
@@ -33,8 +33,10 @@
  * These are defined in FLTK as hidden variables for some internal hacks, but are used here.
  * XXX: possible changes in future FLTK versions
  */
+#if 0
 extern char fl_show_iconic;
 extern int  fl_disable_transient_for;
+#endif 
 
 EDELIB_NS_BEGIN
 
@@ -165,7 +167,7 @@
 			XChangeProperty(fl_display, xp->xid, XA_WM_CLASS, XA_STRING, 8, 0, (unsigned char *)buffer, p-buffer-1);
 		}
 
-		if(win->non_modal() && xp->next && !fl_disable_transient_for) {
+		if(win->non_modal() && xp->next /* && !fl_disable_transient_for */) {
 			// find some other window to be "transient for":
 			Fl_Window* wp = xp->next->w;
 			while(wp->parent()) 
@@ -193,13 +195,14 @@
 		XWMHints *hints = XAllocWMHints();
 		hints->input = True;
 		hints->flags = InputHint;
-
+#if 0 
 		if(fl_show_iconic) {
 			hints->flags |= StateHint;
 			hints->initial_state = IconicState;
 			fl_show_iconic = 0;
 			showit = 0;
 		}
+#endif 
 
 		// This is not removed so it can be used with windows inherited from Fl_Window
 		if(win->icon()) {


[FILE:7019:files/scheme.h]
/* SCHEME.H */

#ifndef _SCHEME_H
#define _SCHEME_H

#include <stdio.h>

#ifdef __cplusplus
extern "C" {
#endif

/*
 * Default values for #define'd symbols
 */

#define USE_INTERFACE 1
#define USE_MATH 0

/* If used as standalone interpreter */
#ifndef STANDALONE
# define STANDALONE 0
#endif

#ifndef _MSC_VER
# define USE_STRCASECMP 1
# ifndef USE_STRLWR
#   define USE_STRLWR 1
# endif
# define SCHEME_EXPORT
#else
# define USE_STRCASECMP 0
# define USE_STRLWR 0
# ifdef _SCHEME_SOURCE
#  define SCHEME_EXPORT __declspec(dllexport)
# else
#  define SCHEME_EXPORT __declspec(dllimport)
# endif
#endif

#if USE_NO_FEATURES
# define USE_MATH 0
# define USE_CHAR_CLASSIFIERS 0
# define USE_ASCII_NAMES 0
# define USE_STRING_PORTS 0
# define USE_ERROR_HOOK 0
# define USE_TRACING 0
# define USE_COLON_HOOK 0
# define USE_DL 0
# define USE_PLIST 0
#endif

/*
 * Leave it defined if you want continuations, and also for the Sharp Zaurus.
 * Undefine it if you only care about faster speed and not strict Scheme compatibility.
 */
#define USE_SCHEME_STACK

#if USE_DL
# define USE_INTERFACE 1
#endif


#ifndef USE_MATH         /* If math support is needed */
# define USE_MATH 1
#endif

#ifndef USE_CHAR_CLASSIFIERS  /* If char classifiers are needed */
# define USE_CHAR_CLASSIFIERS 1
#endif

#ifndef USE_ASCII_NAMES  /* If extended escaped characters are needed */
# define USE_ASCII_NAMES 1
#endif

#ifndef USE_STRING_PORTS      /* Enable string ports */
# define USE_STRING_PORTS 1
#endif

#ifndef USE_TRACING
# define USE_TRACING 1
#endif

#ifndef USE_PLIST
# define USE_PLIST 0
#endif

/* To force system errors through user-defined error handling (see *error-hook*) */
#ifndef USE_ERROR_HOOK
# define USE_ERROR_HOOK 1
#endif

#ifndef USE_COLON_HOOK   /* Enable qualified qualifier */
# define USE_COLON_HOOK 1
#endif

#ifndef USE_STRCASECMP   /* stricmp for Unix */
# define USE_STRCASECMP 0
#endif

#ifndef USE_STRLWR
# define USE_STRLWR 1
#endif

#ifndef STDIO_ADDS_CR    /* Define if DOS/Windows */
# define STDIO_ADDS_CR 0
#endif

#ifndef INLINE
# define INLINE
#endif

#ifndef USE_INTERFACE
# define USE_INTERFACE 0
#endif

#ifndef SHOW_ERROR_LINE   /* Show error line in file */
# define SHOW_ERROR_LINE 1
#endif

typedef struct scheme scheme;
typedef struct cell *pointer;

typedef void * (*func_alloc)(size_t);
typedef void (*func_dealloc)(void *);

/* num, for generic arithmetic */
typedef struct num {
     char is_fixnum;
     union {
          long ivalue;
          double rvalue;
     } value;
} num;

SCHEME_EXPORT scheme *scheme_init_new();
SCHEME_EXPORT scheme *scheme_init_new_custom_alloc(func_alloc malloc, func_dealloc free);
SCHEME_EXPORT int scheme_init(scheme *sc);
SCHEME_EXPORT int scheme_init_custom_alloc(scheme *sc, func_alloc, func_dealloc);
SCHEME_EXPORT void scheme_deinit(scheme *sc);
void scheme_set_input_port_file(scheme *sc, FILE *fin);
void scheme_set_input_port_string(scheme *sc, char *start, char *past_the_end);
SCHEME_EXPORT void scheme_set_output_port_file(scheme *sc, FILE *fin);
void scheme_set_output_port_string(scheme *sc, char *start, char *past_the_end);
SCHEME_EXPORT void scheme_load_file(scheme *sc, FILE *fin);
SCHEME_EXPORT void scheme_load_named_file(scheme *sc, FILE *fin, const char *filename);
SCHEME_EXPORT void scheme_load_string(scheme *sc, const char *cmd);
SCHEME_EXPORT pointer scheme_apply0(scheme *sc, const char *procname);
SCHEME_EXPORT pointer scheme_call(scheme *sc, pointer func, pointer args);
SCHEME_EXPORT pointer scheme_eval(scheme *sc, pointer obj);
void scheme_set_external_data(scheme *sc, void *p);
SCHEME_EXPORT void scheme_define(scheme *sc, pointer env, pointer symbol, pointer value);

typedef pointer (*foreign_func)(scheme *, pointer);

pointer _cons(scheme *sc, pointer a, pointer b, int immutable);
pointer mk_integer(scheme *sc, long num);
pointer mk_real(scheme *sc, double num);
pointer mk_symbol(scheme *sc, const char *name);
pointer gensym(scheme *sc);
pointer mk_string(scheme *sc, const char *str);
pointer mk_counted_string(scheme *sc, const char *str, int len);
pointer mk_empty_string(scheme *sc, int len, char fill);
pointer mk_character(scheme *sc, int c);
pointer mk_foreign_func(scheme *sc, foreign_func f);
void putstr(scheme *sc, const char *s);
int list_length(scheme *sc, pointer a);
int eqv(pointer a, pointer b);


#if USE_INTERFACE
struct scheme_interface {
  void (*scheme_define)(scheme *sc, pointer env, pointer symbol, pointer value);
  pointer (*cons)(scheme *sc, pointer a, pointer b);
  pointer (*immutable_cons)(scheme *sc, pointer a, pointer b);
  pointer (*reserve_cells)(scheme *sc, int n);
  pointer (*mk_integer)(scheme *sc, long num);
  pointer (*mk_real)(scheme *sc, double num);
  pointer (*mk_symbol)(scheme *sc, const char *name);
  pointer (*gensym)(scheme *sc);
  pointer (*mk_string)(scheme *sc, const char *str);
  pointer (*mk_counted_string)(scheme *sc, const char *str, int len);
  pointer (*mk_character)(scheme *sc, int c);
  pointer (*mk_vector)(scheme *sc, int len);
  pointer (*mk_foreign_func)(scheme *sc, foreign_func f);
  void (*putstr)(scheme *sc, const char *s);
  void (*putcharacter)(scheme *sc, int c);

  int (*is_string)(pointer p);
  char *(*string_value)(pointer p);
  int (*is_number)(pointer p);
  num (*nvalue)(pointer p);
  long (*ivalue)(pointer p);
  double (*rvalue)(pointer p);
  int (*is_integer)(pointer p);
  int (*is_real)(pointer p);
  int (*is_character)(pointer p);
  long (*charvalue)(pointer p);
  int (*is_list)(scheme *sc, pointer p);
  int (*is_vector)(pointer p);
  int (*list_length)(scheme *sc, pointer vec);
  long (*vector_length)(pointer vec);
  void (*fill_vector)(pointer vec, pointer elem);
  pointer (*vector_elem)(pointer vec, int ielem);
  pointer (*set_vector_elem)(pointer vec, int ielem, pointer newel);
  int (*is_port)(pointer p);

  int (*is_pair)(pointer p);
  pointer (*pair_car)(pointer p);
  pointer (*pair_cdr)(pointer p);
  pointer (*set_car)(pointer p, pointer q);
  pointer (*set_cdr)(pointer p, pointer q);

  int (*is_symbol)(pointer p);
  char *(*symname)(pointer p);

  int (*is_syntax)(pointer p);
  int (*is_proc)(pointer p);
  int (*is_foreign)(pointer p);
  char *(*syntaxname)(pointer p);
  int (*is_closure)(pointer p);
  int (*is_macro)(pointer p);
  pointer (*closure_code)(pointer p);
  pointer (*closure_env)(pointer p);

  int (*is_continuation)(pointer p);
  int (*is_promise)(pointer p);
  int (*is_environment)(pointer p);
  int (*is_immutable)(pointer p);
  void (*setimmutable)(pointer p);
  void (*load_file)(scheme *sc, FILE *fin);
  void (*load_string)(scheme *sc, const char *input);
};
#endif

#if !STANDALONE
typedef struct scheme_registerable
{
  foreign_func  f;
  char *        name;
}
scheme_registerable;

void scheme_register_foreign_func_list(scheme * sc,
                                       scheme_registerable * list,
                                       int n);

#endif /* !STANDALONE */

#ifdef __cplusplus
}
#endif

#endif


/*
Local variables:
c-file-style: "k&r"
End:
*/

