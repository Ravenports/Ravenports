# Buildsheet autogenerated by ravenadm tool -- Do not edit.

NAMEBASE=		xorg-server
VERSION=		21.1.7
REVISION=		1
KEYWORDS=		x11_servers
VARIANTS=		standard virtual xephyr nest
SDESC[xephyr]=		X server from X.Org based on kdrive
SDESC[virtual]=		X virtual framebuffer server from X.Org
SDESC[standard]=	X.Org X server and related programs
SDESC[nest]=		Nesting X server from X.Org
HOMEPAGE=		https://www.x.org/
CONTACT=		nobody

DOWNLOAD_GROUPS=	main
SITES[main]=		XORG/individual/xserver
DISTFILE[1]=		xorg-server-21.1.7.tar.xz:main
DF_INDEX=		1
SPKGS[xephyr]=		single
SPKGS[virtual]=		single
SPKGS[standard]=	single
SPKGS[nest]=		single

OPTIONS_AVAILABLE=	XORG VIRTUAL XEPHYR NEST DEVD SUID
OPTIONS_STANDARD=	XORG DEVD SUID
VOPTS[xephyr]=		XORG=OFF VIRTUAL=OFF XEPHYR=ON NEST=OFF DEVD=OFF
			SUID=OFF
VOPTS[virtual]=		XORG=OFF VIRTUAL=ON XEPHYR=OFF NEST=OFF DEVD=OFF
			SUID=OFF
VOPTS[nest]=		XORG=OFF VIRTUAL=OFF XEPHYR=OFF NEST=ON DEVD=OFF
			SUID=OFF
OPT_ON[all]=		XORG SUID

BUILD_DEPENDS=		libdrm:dev:standard
			libgpg-error:dev:standard
			xorg-fontutil:single:standard
			xorg-xkbfile:single:standard
BUILDRUN_DEPENDS=	xorg-xcvt:single:standard
RUN_DEPENDS=		xorg-xkeyboard-config:primary:standard
			xorg-xkbcomp:single:standard

USES=			cpe perl:build ssl solaris-funcs meson zlib:build
XORG_COMPONENTS=	xorgproto xtransproto pixman xshmfence xau xdmcp
			xfont2

LICENSE=		MIT:single
LICENSE_FILE=		MIT:{{WRKSRC}}/COPYING
LICENSE_SCHEME=		solo

CPE_VENDOR=		x.org
FPC_EQUIVALENT=		x11-servers/xorg-server
MESON_ARGS=		-Dxkb_dir="{{LOCALBASE}}/share/X11/xkb"
			-Ddefault_font_path="{{LOCALBASE}}/share/fonts"
			-Dglamor=true
			-Dxcsecurity=true
			-Ddtrace=false
			-Dhal=false
			-Dudev=false
			-Dudev_kms=false
SOL_FUNCTIONS=		strnlen:xkb/XKBGAlloc.c

VAR_OPSYS[sunos]=	CFLAGS=-DO_CLOEXEC=0
VAR_OPSYS[netbsd]=	CPPFLAGS=-D_OPENBSD_SOURCE
			CONFIGURE_ARGS=-Dsecure-rpc=false

[DEVD].DESCRIPTION=			Use devd for autoconfiguration of input devices

[NEST].DESCRIPTION=			Build as nesting X server
[NEST].BUILDRUN_DEPENDS_ON=		libglvnd:single:standard
[NEST].BUILD_DEPENDS_ON=		libepoxy:single:standard
					mesa:drivers:standard
					libglvnd:single:standard
[NEST].CONFIGURE_ARGS_OFF=		-Dxnest=false
[NEST].CONFIGURE_ARGS_ON=		-Dxnest=true
[NEST].XORG_COMPONENTS_ON=		x11
					xext

[XEPHYR].DESCRIPTION=			Build as kdrive-base X server
[XEPHYR].BUILDRUN_DEPENDS_ON=		libdrm:primary:standard
					libepoxy:single:standard
					libglvnd:single:standard
[XEPHYR].BUILD_DEPENDS_ON=		mesa:drivers:standard
[XEPHYR].CONFIGURE_ARGS_OFF=		-Dxephyr=false
[XEPHYR].CONFIGURE_ARGS_ON=		-Dxephyr=true
[XEPHYR].XORG_COMPONENTS_ON=		x11
					xcb
					xcb-util
					xcb-util-image
					xcb-util-wm
					xcb-util-keysyms
					xcb-render-util

[VIRTUAL].DESCRIPTION=			Build as virtual framebuffer server
[VIRTUAL].BUILDRUN_DEPENDS_ON=		libglvnd:single:standard
[VIRTUAL].BUILD_DEPENDS_ON=		libepoxy:single:standard
					mesa:drivers:standard
					libglvnd:single:standard
[VIRTUAL].CONFIGURE_ARGS_OFF=		-Dxvfb=false
[VIRTUAL].CONFIGURE_ARGS_ON=		-Dxvfb=true

[XORG].DESCRIPTION=			Build as X server (don't change setting!)
[XORG].BUILDRUN_DEPENDS_ON=		libdrm:primary:standard
					libepoxy:single:standard
					mesa:drivers:standard
[XORG].BUILD_DEPENDS_ON=		xmlto:single:standard
					xorg-sgml-doctools:single:standard
[XORG].CONFIGURE_ARGS_OFF=		-Ddocs=false
					-Ddevel-docs=false
					-Dxorg=false
[XORG].CONFIGURE_ARGS_ON=		-Ddocs=true
					-Ddevel-docs=true
					-Dxorg=true
					-Dlog_dir=/var/log
[XORG].XORG_COMPONENTS_ON=		pciaccess
					xfont2

[SUID].DESCRIPTION=			Install the Xorg server with setuid bit set

post-install-XORG-OFF:
	${RM} -r ${STAGEDIR}${PREFIX}/lib/xorg
	${RM} ${STAGEDIR}${PREFIX}/share/man/man1/Xserver.1

post-configure-DEVD-ON:
	${REINPLACE_CMD} -e 's|^/\* #undef CONFIG_UDEV \*/|#define CONFIG_DEVD 1|' \
		${WRKSRC}/include/dix-config.h

post-install-XORG-ON:
	${RM} -r ${STAGEDIR}${STD_DOCDIR}

[FILE:71:descriptions/desc.single.standard]
This package contains the X.Org X server and some associated programs.


[FILE:60:descriptions/desc.single.virtual]
This package contains Xvfb, a virtual framebuffer X server.


[FILE:173:descriptions/desc.single.xephyr]
Xephyr is a kdrive server that outputs to a window on a pre-existing
'host' X display.  Think Xnest but with support for modern extensions
like composite, damage and randr.


[FILE:78:descriptions/desc.single.nest]
This package contains Xnest, a nesting X Server that displays on an X
Server.


[FILE:104:distinfo]
d9c60b2dd0ec52326ca6ab20db0e490b1ff4f566f59ca742d6532e92795877bb      4933292 xorg-server-21.1.7.tar.xz


[FILE:2542:manifests/plist.single.standard]
%%ONLY-SUNOS%%include/xorg/solaris-amd64.il
%%SUID-OFF%%bin/Xorg
%%SUID-ON%%@(,,4555) bin/Xorg
bin/
 X
 gtf
etc/X11/xorg.conf.d/10-quirks.conf
include/xorg/
 XIstubs.h
 Xprintf.h
 callback.h
 client.h
 closestr.h
 closure.h
 colormap.h
 colormapst.h
 compiler.h
 compositeext.h
 cursor.h
 cursorstr.h
 damage.h
 damagestr.h
 dbestruct.h
 dgaproc.h
 displaymode.h
 dix.h
 dixaccess.h
 dixevents.h
 dixfont.h
 dixfontstr.h
 dixgrabs.h
 dixstruct.h
 dri.h
 dri2.h
 dri3.h
 dristruct.h
 edid.h
 events.h
 exa.h
 exevents.h
 extension.h
 extinit.h
 extnsionst.h
 fb.h
 fbdevhw.h
 fboverlay.h
 fbpict.h
 fbrop.h
 fourcc.h
 gc.h
 gcstruct.h
 geext.h
 geint.h
 glamor.h
 globals.h
 glx_extinit.h
 glxvndabi.h
 glyphstr.h
 hotplug.h
 i2c_def.h
 input.h
 inputstr.h
 list.h
 mi.h
 micmap.h
 micoord.h
 migc.h
 miline.h
 mioverlay.h
 mipict.h
 mipointer.h
 mipointrst.h
 misc.h
 miscstruct.h
 mistruct.h
 misync.h
 misyncfd.h
 misyncshm.h
 misyncstr.h
 mizerarc.h
 nonsdk_extinit.h
 opaque.h
 optionstr.h
 os.h
 panoramiX.h
 panoramiXsrv.h
 picture.h
 picturestr.h
 pixmap.h
 pixmapstr.h
 present.h
 presentext.h
 privates.h
 property.h
 propertyst.h
 ptrveloc.h
 randrstr.h
 region.h
 regionstr.h
 registry.h
 resource.h
 rgb.h
 rrtransform.h
 sarea.h
 screenint.h
 scrnintstr.h
 selection.h
 servermd.h
 shadow.h
 shadowfb.h
 shmint.h
 syncsdk.h
 validate.h
 vbe.h
 vbeModes.h
 vgaHW.h
 vndserver.h
 wfbrename.h
 window.h
 windowstr.h
 xaarop.h
 xace.h
 xacestr.h
 xf86-input-inputtest-protocol.h
 xf86.h
 xf86Crtc.h
 xf86Cursor.h
 xf86DDC.h
 xf86MatchDrivers.h
 xf86Modes.h
 xf86Module.h
 xf86Opt.h
 xf86Optionstr.h
 xf86Optrec.h
 xf86Parser.h
 xf86Pci.h
 xf86PciInfo.h
 xf86Priv.h
 xf86Privstr.h
 xf86RandR12.h
 xf86VGAarbiter.h
 xf86Xinput.h
 xf86_OSlib.h
 xf86_OSproc.h
 xf86cmap.h
 xf86fbman.h
 xf86i2c.h
 xf86int10.h
 xf86platformBus.h
 xf86sbusBus.h
 xf86str.h
 xf86xv.h
 xf86xvmc.h
 xf86xvpriv.h
 xisb.h
 xkbfile.h
 xkbrules.h
 xkbsrv.h
 xkbstr.h
 xorg-server.h
 xorgVersion.h
 xserver-properties.h
 xserver_poll.h
 xvdix.h
 xvmcext.h
lib/pkgconfig/xorg-server.pc
lib/xorg/protocol.txt
lib/xorg/modules/
 libexa.so
 libfbdevhw.so
 libglamoregl.so
 libint10.so
 libshadow.so
 libshadowfb.so
 libvgahw.so
 libwfb.so
lib/xorg/modules/drivers/modesetting_drv.so
lib/xorg/modules/extensions/libglx.so
lib/xorg/modules/input/inputtest_drv.so
share/aclocal/xorg-server.m4
share/man/man1/
 Xorg.1.gz
 Xserver.1.gz
 gtf.1.gz
share/man/man4/
 exa.4.gz
 fbdevhw.4.gz
 inputtestdrv.4.gz
 modesetting.4.gz
share/man/man5/
 xorg.conf.5.gz
 xorg.conf.d.5.gz


[FILE:34:manifests/plist.single.virtual]
bin/Xvfb
share/man/man1/Xvfb.1.gz


[FILE:38:manifests/plist.single.xephyr]
bin/Xephyr
share/man/man1/Xephyr.1.gz


[FILE:36:manifests/plist.single.nest]
bin/Xnest
share/man/man1/Xnest.1.gz


[FILE:293:patches/patch-config_config-backends.h]
--- config/config-backends.h.orig	2022-12-19 10:53:03 UTC
+++ config/config-backends.h
@@ -44,3 +44,8 @@ void config_hal_fini(void);
 int config_wscons_init(void);
 void config_wscons_fini(void);
 #endif
+
+#ifdef CONFIG_DEVD
+int config_devd_init(void);
+void config_devd_fini(void);
+#endif


[FILE:537:patches/patch-config_config.c]
--- config/config.c.orig	2022-12-19 10:53:03 UTC
+++ config/config.c
@@ -55,6 +55,9 @@ config_init(void)
 #elif defined(CONFIG_WSCONS)
     if (!config_wscons_init())
         ErrorF("[config] failed to initialise wscons\n");
+#elif defined(CONFIG_DEVD)
+    if (!config_devd_init())
+        ErrorF("[config] failed to initialise devd\n");
 #endif
 }
 
@@ -67,6 +70,8 @@ config_fini(void)
     config_hal_fini();
 #elif defined(CONFIG_WSCONS)
     config_wscons_fini();
+#elif defined(CONFIG_DEVD)
+    config_devd_fini();
 #endif
 }
 


[FILE:12171:patches/patch-config_devd.c]
--- /dev/null	2022-12-30 20:49:52 UTC
+++ config/devd.c
@@ -0,0 +1,532 @@
+/*
+ * Copyright (c) 2012 Baptiste Daroussin
+ * Copyright (c) 2013, 2014 Alex Kozlov
+ * Copyright (c) 2014 Robert Millan
+ * Copyright (c) 2014 Jean-Sebastien Pedron
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ *
+ * Author: Baptiste Daroussin <bapt@FreeBSD.org>
+ */
+
+#ifdef HAVE_DIX_CONFIG_H
+#include <dix-config.h>
+#endif
+
+#include <sys/types.h>
+#include <sys/kbio.h>
+#include <sys/socket.h>
+#include <sys/stat.h>
+#include <sys/sysctl.h>
+#include <sys/un.h>
+
+#include <ctype.h>
+#include <errno.h>
+#include <fcntl.h>
+#include <stdlib.h>
+#include <stdio.h>
+#include <stdbool.h>
+#include <unistd.h>
+
+#include "input.h"
+#include "inputstr.h"
+#include "hotplug.h"
+#include "config-backends.h"
+#include "os.h"
+
+#define DEVD_SOCK_PATH "/var/run/devd.pipe"
+
+#define DEVD_EVENT_ADD		'+'
+#define DEVD_EVENT_REMOVE	'-'
+
+#define RECONNECT_DELAY		5 * 1000
+
+static int sock_devd;
+static bool is_console_kbd = false;
+static bool is_kbdmux = false;
+static OsTimerPtr rtimer = NULL;
+
+struct hw_type {
+	const char *driver;
+	int flag;
+	const char *xdriver;
+};
+
+static struct hw_type hw_types[] = {
+	{ "ukbd", ATTR_KEYBOARD, "kbd" },
+	{ "atkbd", ATTR_KEYBOARD, "kbd" },
+	{ "kbdmux", ATTR_KEYBOARD, "kbd" },
+	{ "sysmouse", ATTR_POINTER, "mouse" },
+	{ "ums", ATTR_POINTER, "mouse" },
+	{ "psm", ATTR_POINTER, "mouse" },
+	{ "vboxguest", ATTR_POINTER, "vboxmouse" },
+	{ "joy", ATTR_JOYSTICK, NULL },
+	{ "atp", ATTR_TOUCHPAD, NULL },
+	{ "uep", ATTR_TOUCHSCREEN, NULL },
+	{ NULL, -1, NULL },
+};
+
+static bool
+sysctl_exists(const struct hw_type *device, int unit,
+	char *devname, size_t devname_len)
+{
+	char sysctlname[PATH_MAX];
+	size_t len;
+	int ret;
+
+	if (device == NULL || device->driver == NULL)
+		return false;
+
+	/* Check if a sysctl exists. */
+	snprintf(sysctlname, sizeof(sysctlname), "dev.%s.%i.%%desc",
+	    device->driver, unit);
+	ret = sysctlbyname(sysctlname, NULL, &len, NULL, 0);
+
+	if (ret == 0 && len > 0) {
+		snprintf(devname, devname_len, "%s%i", device->driver, unit);
+		return true;
+	}
+
+	return false;
+}
+
+static bool
+devpath_exists(const struct hw_type *device,
+	char *devname, size_t devname_len)
+{
+	char *devpath;
+	struct stat st;
+	int ret;
+
+	if (device == NULL || device->driver == NULL)
+		return false;
+
+	/* Check if /dev/$driver exists. */
+	asprintf(&devpath, "/dev/%s", device->driver);
+	if (devpath == NULL)
+		return false;
+
+	ret = stat(devpath, &st);
+	free(devpath);
+
+	if (ret == 0) {
+		strncpy(devname, device->driver, devname_len);
+		return true;
+	}
+
+	return false;
+}
+
+static char *
+sysctl_get_str(const char *sysctlname)
+{
+	char *dest = NULL;
+	size_t len;
+
+	if (sysctlname == NULL)
+		return NULL;
+
+	if (sysctlbyname(sysctlname, NULL, &len, NULL, 0) == 0) {
+		dest = malloc(len + 1);
+		if (dest) {
+			if (sysctlbyname(sysctlname, dest, &len, NULL, 0) == 0)
+				dest[len] = '\0';
+			else {
+				free(dest);
+				dest = NULL;
+			}
+		}
+	}
+
+	return dest;
+}
+
+static void
+device_added(const char *devname)
+{
+	char path[PATH_MAX];
+	char sysctlname[PATH_MAX];
+	char *vendor;
+	char *product = NULL;
+	char *config_info = NULL;
+	char *walk;
+	InputOption *options = NULL;
+	InputAttributes attrs = { };
+	DeviceIntPtr dev = NULL;
+	int i;
+	int fd;
+
+	for (i = 0; hw_types[i].driver != NULL; i++) {
+		size_t len;
+
+		len = strlen(hw_types[i].driver);
+		if (strcmp(devname, hw_types[i].driver) == 0 ||
+			(strncmp(devname, hw_types[i].driver, len) == 0 &&
+				isnumber(*(devname + len)))) {
+			attrs.flags |= hw_types[i].flag;
+			break;
+		}
+	}
+
+	if (hw_types[i].driver == NULL || hw_types[i].xdriver == NULL) {
+		LogMessage(X_INFO, "config/devd: ignoring device %s\n",
+				devname);
+		return;
+	}
+
+	/* Skip keyboard devices if kbdmux is enabled */
+	if (is_kbdmux && is_console_kbd && hw_types[i].flag & ATTR_KEYBOARD) {
+		LogMessage(X_INFO, "config/devd: kbdmux is enabled, ignoring device %s\n",
+				devname);
+		return;
+	}
+
+	snprintf(path, sizeof(path), "/dev/%s", devname);
+
+	options = input_option_new(NULL, "_source", "server/devd");
+	if (!options)
+		return;
+
+	snprintf(sysctlname, sizeof(sysctlname), "dev.%s.%s.%%desc",
+	    hw_types[i].driver, devname + strlen(hw_types[i].driver));
+	vendor = sysctl_get_str(sysctlname);
+	if (vendor == NULL) {
+		options = input_option_new(options, "name", devname);
+	}
+	else {
+		if ((walk = strchr(vendor, ' ')) != NULL) {
+			walk[0] = '\0';
+			walk++;
+			product = walk;
+			if ((walk = strchr(product, ',')) != NULL)
+				walk[0] = '\0';
+		}
+
+		attrs.vendor = strdup(vendor);
+		if (product) {
+			attrs.product = strdup(product);
+			options = input_option_new(options, "name", product);
+		}
+		else
+			options = input_option_new(options, "name", "(unnamed)");
+
+		free(vendor);
+	}
+
+	/* XXX implement usb_id */
+	attrs.usb_id = NULL;
+	attrs.device = strdup(path);
+	options = input_option_new(options, "driver", hw_types[i].xdriver);
+
+	fd = open(path, O_RDONLY);
+	if (fd > 0) {
+		close(fd);
+		options = input_option_new(options, "device", path);
+	}
+	else {
+		if (attrs.flags & ~ATTR_KEYBOARD) {
+			LogMessage(X_INFO, "config/devd: device %s already opened\n",
+					 path);
+
+			/*
+			 * Fail if cannot open device, it breaks AllowMouseOpenFail,
+			 * but it should not matter when config/devd enabled
+			 */
+			goto unwind;
+		}
+
+		if (is_console_kbd) {
+			/*
+			 * There can be only one keyboard attached to console and
+			 * it is already added.
+			 */
+			LogMessage(X_WARNING, "config/devd: console keyboard is "
+					"already added, ignoring %s (%s)\n",
+					attrs.product, path);
+			goto unwind;
+		}
+		else
+			/*
+			 * Don't pass "device" option if the keyboard is already
+			 * attached to the console (ie. open() fails).
+			 * This would activate a special logic in xf86-input-keyboard.
+			 * Prevent any other attached to console keyboards being
+			 * processed. There can be only one such device.
+			 */
+			is_console_kbd = true;
+	}
+
+	if (asprintf(&config_info, "devd:%s", devname) == -1) {
+		config_info = NULL;
+		goto unwind;
+	}
+
+	if (device_is_duplicate(config_info)) {
+		LogMessage(X_WARNING, "config/devd: device %s (%s) already added. "
+				"ignoring\n", attrs.product, path);
+		goto unwind;
+	}
+
+	options = input_option_new(options, "config_info", config_info);
+	LogMessage(X_INFO, "config/devd: adding input device %s (%s)\n",
+			attrs.product, path);
+
+	NewInputDeviceRequest(options, &attrs, &dev);
+
+unwind:
+	free(config_info);
+	input_option_free_list(&options);
+	free(attrs.usb_id);
+	free(attrs.product);
+	free(attrs.device);
+	free(attrs.vendor);
+}
+
+static void
+device_removed(char *devname)
+{
+	char *config_info;
+
+	if (asprintf(&config_info, "devd:%s", devname) == -1)
+		return;
+
+	remove_devices("devd", config_info);
+
+	free(config_info);
+}
+
+static bool is_kbdmux_enabled(void)
+{
+	/* Xorg uses /dev/ttyv0 as a console device */
+	/* const char device[]="/dev/console"; */
+	const char device[]="/dev/ttyv0";
+	keyboard_info_t info;
+	int fd;
+
+	fd = open(device, O_RDONLY);
+
+	if (fd < 0)
+		return false;
+
+	if (ioctl(fd, KDGKBINFO, &info) == -1) {
+		close(fd);
+		return false;
+	}
+
+	close(fd);
+
+	if (!strncmp(info.kb_name, "kbdmux", 6))
+		return true;
+
+	return false;
+}
+
+static void
+disconnect_devd(int sock)
+{
+	if (sock >= 0) {
+		RemoveGeneralSocket(sock);
+		close(sock);
+	}
+}
+
+static int
+connect_devd(void)
+{
+	struct sockaddr_un devd;
+	int sock;
+
+	sock = socket(AF_UNIX, SOCK_STREAM, 0);
+	if (sock < 0) {
+		LogMessage(X_ERROR, "config/devd: fail opening stream socket\n");
+		return -1;
+	}
+
+	devd.sun_family = AF_UNIX;
+	strlcpy(devd.sun_path, DEVD_SOCK_PATH, sizeof(devd.sun_path));
+
+	if (connect(sock, (struct sockaddr *) &devd, sizeof(devd)) < 0) {
+		close(sock);
+		LogMessage(X_ERROR, "config/devd: fail to connect to devd\n");
+		return -1;
+	}
+
+	AddGeneralSocket(sock);
+
+	return	sock;
+}
+
+static CARD32
+reconnect_handler(OsTimerPtr timer, CARD32 time, void *arg)
+{
+	int newsock;
+
+	if ((newsock = connect_devd()) > 0) {
+		sock_devd = newsock;
+		TimerFree(rtimer);
+		rtimer = NULL;
+		LogMessage(X_INFO, "config/devd: reopening devd socket\n");
+		return 0;
+	}
+
+	/* Try again after RECONNECT_DELAY */
+	return RECONNECT_DELAY;
+}
+
+static ssize_t
+socket_getline(int fd, char **out)
+{
+	char *buf, *newbuf;
+	ssize_t ret, cap, sz = 0;
+	char c;
+
+	cap = 1024;
+	buf = malloc(cap * sizeof(char));
+	if (!buf)
+		return -1;
+
+	for (;;) {
+		ret = read(sock_devd, &c, 1);
+		if (ret < 0) {
+			if (errno == EINTR)
+				continue;
+			free(buf);
+			return -1;
+		/* EOF - devd socket is lost */
+		} else if (ret == 0) {
+			disconnect_devd(sock_devd);
+			rtimer = TimerSet(NULL, 0, 1, reconnect_handler, NULL);
+			LogMessage(X_WARNING, "config/devd: devd socket is lost\n");
+			free(buf);
+			return -1;
+		}
+		if (c == '\n')
+			break;
+
+		if (sz + 1 >= cap) {
+			cap *= 2;
+			newbuf = realloc(buf, cap * sizeof(char));
+			if (!newbuf) {
+				free(buf);
+				return -1;
+			}
+			buf = newbuf;
+		}
+		buf[sz] = c;
+		sz++;
+	}
+
+	buf[sz] = '\0';
+	if (sz >= 0)
+		*out = buf;
+	else
+		free(buf);
+
+	/* Number of bytes in the line, not counting the line break */
+	return sz;
+}
+
+static void
+wakeup_handler(void *data, int err, void *read_mask)
+{
+	char *line = NULL;
+	char *walk;
+
+	if (err < 0)
+		return;
+
+	if (FD_ISSET(sock_devd, (fd_set *) read_mask)) {
+		if (socket_getline(sock_devd, &line) < 0)
+			return;
+
+		walk = strchr(line + 1, ' ');
+		if (walk != NULL)
+			walk[0] = '\0';
+
+		switch (*line) {
+		case DEVD_EVENT_ADD:
+			device_added(line + 1);
+			break;
+		case DEVD_EVENT_REMOVE:
+			device_removed(line + 1);
+			break;
+		default:
+			break;
+		}
+		free(line);
+	}
+}
+
+static void
+block_handler(void *data, struct timeval **tv, void *read_mask)
+{
+}
+
+int
+config_devd_init(void)
+{
+	char devicename[1024];
+	int i, j;
+
+	LogMessage(X_INFO, "config/devd: probing input devices...\n");
+
+	/*
+	 * Add fake keyboard and give up on keyboards management
+	 * if kbdmux is enabled
+	 */
+	if ((is_kbdmux = is_kbdmux_enabled()) == true)
+		device_added("kbdmux");
+
+	for (i = 0; hw_types[i].driver != NULL; i++) {
+		/* First scan the sysctl to determine the hardware */
+		for (j = 0; j < 16; j++) {
+			if (sysctl_exists(&hw_types[i], j,
+					devicename, sizeof(devicename)) != 0)
+				device_added(devicename);
+		}
+
+		if (devpath_exists(&hw_types[i], devicename, sizeof(devicename)) != 0)
+			device_added(devicename);
+	}
+
+	if ((sock_devd = connect_devd()) < 0)
+		return 0;
+
+	RegisterBlockAndWakeupHandlers(block_handler, wakeup_handler, NULL);
+
+	return 1;
+}
+
+void
+config_devd_fini(void)
+{
+	LogMessage(X_INFO, "config/devd: terminating backend...\n");
+
+	if (rtimer) {
+		TimerFree(rtimer);
+		rtimer = NULL;
+	}
+
+	disconnect_devd(sock_devd);
+
+	RemoveBlockAndWakeupHandlers(block_handler, wakeup_handler, NULL);
+
+	is_console_kbd = false;
+}


[FILE:391:patches/patch-config_meson.build]
--- config/meson.build.orig	2022-12-19 10:53:03 UTC
+++ config/meson.build
@@ -25,7 +25,7 @@ endif
 
 if build_xorg
     install_data('10-quirks.conf',
-                 install_dir: join_paths(get_option('datadir'), 'X11/xorg.conf.d'))
+                 install_dir: join_paths(get_option('prefix'), 'etc/X11/xorg.conf.d'))
 endif
 
 libxserver_config = static_library('libxserver_config',


[FILE:256:patches/patch-hw_kdrive_ephyr_hostx.c]
--- hw/kdrive/ephyr/hostx.c.orig	2022-12-19 10:53:03 UTC
+++ hw/kdrive/ephyr/hostx.c
@@ -36,7 +36,6 @@
 #include <string.h>             /* for memset */
 #include <errno.h>
 #include <time.h>
-#include <err.h>
 
 #include <sys/ipc.h>
 #include <sys/shm.h>


[FILE:765:patches/patch-hw_xfree86_common_xf86AutoConfig.c]
--- hw/xfree86/common/xf86AutoConfig.c.orig	2022-12-19 10:53:03 UTC
+++ hw/xfree86/common/xf86AutoConfig.c
@@ -294,7 +294,7 @@ listPossibleVideoDrivers(XF86MatchedDriv
     xf86PciMatchDriver(md);
 #endif
 
-#if defined(__linux__)
+#if defined(__linux__) || defined(__FreeBSD__) || defined(__DragonFly__)
     xf86AddMatchedDriver(md, "modesetting");
 #endif
 
@@ -302,8 +302,10 @@ listPossibleVideoDrivers(XF86MatchedDriv
     /* Fallback to platform default frame buffer driver */
 #if !defined(__linux__) && defined(__sparc__)
     xf86AddMatchedDriver(md, "wsfb");
-#else
+#elif defined(__linux__)
     xf86AddMatchedDriver(md, "fbdev");
+#elif defined(__FreeBSD__)
+    xf86AddMatchedDriver(md, "scfb");
 #endif
 #endif                          /* !__sun */
 


[FILE:700:patches/patch-hw_xfree86_common_xf86Config.c]
--- hw/xfree86/common/xf86Config.c.orig	2022-12-19 10:53:03 UTC
+++ hw/xfree86/common/xf86Config.c
@@ -1279,13 +1279,16 @@ checkCoreInputDevices(serverLayoutPtr se
     }
 
     if (!xf86Info.forceInputDevices && !(foundPointer && foundKeyboard)) {
-#if defined(CONFIG_HAL) || defined(CONFIG_UDEV) || defined(CONFIG_WSCONS)
+#if defined(CONFIG_HAL) || defined(CONFIG_UDEV) || defined(CONFIG_WSCONS) || \
+		defined(CONFIG_DEVD)
         const char *config_backend;
 
 #if defined(CONFIG_HAL)
         config_backend = "HAL";
 #elif defined(CONFIG_UDEV)
         config_backend = "udev";
+#elif defined(CONFIG_DEVD)
+        config_backend = "devd";
 #else
         config_backend = "wscons";
 #endif


[FILE:510:patches/patch-hw_xfree86_common_xf86Globals.c]
--- hw/xfree86/common/xf86Globals.c.orig	2022-12-19 10:53:03 UTC
+++ hw/xfree86/common/xf86Globals.c
@@ -118,7 +118,7 @@ xf86InfoRec xf86Info = {
     .miscModInDevEnabled = TRUE,
     .miscModInDevAllowNonLocal = FALSE,
     .pmFlag = TRUE,
-#if defined(CONFIG_HAL) || defined(CONFIG_UDEV) || defined(CONFIG_WSCONS)
+#if defined(CONFIG_HAL) || defined(CONFIG_UDEV) || defined(CONFIG_WSCONS) || defined(CONFIG_DEVD)
     .forceInputDevices = FALSE,
     .autoAddDevices = TRUE,
     .autoEnableDevices = TRUE,


[FILE:483:patches/patch-hw_xfree86_common_xf86Xinput.c]
--- hw/xfree86/common/xf86Xinput.c.orig	2022-12-19 10:53:03 UTC
+++ hw/xfree86/common/xf86Xinput.c
@@ -1065,6 +1065,7 @@ NewInputDeviceRequest(InputOption *optio
         if (strcmp(key, "_source") == 0 &&
             (strcmp(value, "server/hal") == 0 ||
              strcmp(value, "server/udev") == 0 ||
+             strcmp(value, "server/devd") == 0 ||
              strcmp(value, "server/wscons") == 0)) {
             is_auto = 1;
             if (!xf86Info.autoAddDevices) {


[FILE:450:patches/patch-hw_xfree86_os-support_bsd_bsd__init.c]
--- hw/xfree86/os-support/bsd/bsd_init.c.orig	2022-12-19 10:53:03 UTC
+++ hw/xfree86/os-support/bsd/bsd_init.c
@@ -230,6 +230,9 @@ xf86OpenConsole()
              * Add cases for other *BSD that behave the same.
              */
 #if defined(__FreeBSD__) || defined(__FreeBSD_kernel__)
+#if defined(__sparc64__)
+	    pci_system_init_dev_mem(fd);
+#endif
             uname(&uts);
             i = atof(uts.release) * 100;
             if (i >= 310)


[FILE:519:patches/patch-hw_xfree86_os-support_bsd_i386__video.c]
--- hw/xfree86/os-support/bsd/i386_video.c.orig	2022-12-19 10:53:03 UTC
+++ hw/xfree86/os-support/bsd/i386_video.c
@@ -32,6 +32,7 @@
 #include "xf86Priv.h"
 
 #include <errno.h>
+#include <sys/types.h>
 #include <sys/mman.h>
 
 #include "xf86_OSlib.h"
@@ -42,6 +43,9 @@
 #else
 #define MAP_FLAGS (MAP_FILE | MAP_SHARED)
 #endif
+#if defined(__NetBSD__) && defined(USE_AMD64_IOPL)
+#define amd64_iopl x86_64_iopl
+#endif
 
 #ifdef __OpenBSD__
 #define SYSCTL_MSG "\tCheck that you have set 'machdep.allowaperture=1'\n"\


[FILE:380:patches/patch-hw_xfree86_os-support_bsd_ppc__video.c]
--- hw/xfree86/os-support/bsd/ppc_video.c.orig	2022-12-19 10:53:03 UTC
+++ hw/xfree86/os-support/bsd/ppc_video.c
@@ -79,7 +79,11 @@ xf86DisableIO()
 {
 
     if (ioBase != MAP_FAILED) {
+#if defined(__FreeBSD__)
+        munmap(__DEVOLATILE(unsigned char *, ioBase), 0x10000);
+#else
         munmap(__UNVOLATILE(ioBase), 0x10000);
+#endif
         ioBase = MAP_FAILED;
     }
 }


[FILE:714:patches/patch-hw_xfree86_os-support_solaris_sun__init.c]
--- hw/xfree86/os-support/solaris/sun_init.c.orig	2022-12-19 10:53:03 UTC
+++ hw/xfree86/os-support/solaris/sun_init.c
@@ -54,6 +54,22 @@ static int xf86StartVT = -1;
 static int vtEnabled = 0;
 #endif
 
+#ifdef __sun__
+#define VTIOC		('V'<<8)
+#define VT_OPENQRY	(VTIOC|1)
+#define VT_SETMODE	(VTIOC|2)
+#define VT_GETMODE	(VTIOC|3)
+#define VT_ACTIVATE	(VTIOC|5)
+#define VT_WAITACTIVE	(VTIOC|6)
+#define VT_GETSTATE	(VTIOC|100)
+#define VT_ENABLED	(VTIOC|101)
+#define VT_SETDISPINFO	(VTIOC|103)
+#define VT_GET_CONSUSER	(VTIOC|108)
+#define VT_SET_CONSUSER	(VTIOC|109)
+
+enum { VT_AUTO = 0, VT_PROCESS };
+#endif
+
 /* Device to open as xf86Info.consoleFd */
 static char consoleDev[PATH_MAX] = "/dev/fb";
 


[FILE:459:patches/patch-include_meson.build]
--- include/meson.build.orig	2022-12-19 10:53:03 UTC
+++ include/meson.build
@@ -384,7 +384,7 @@ if host_machine.system() == 'freebsd' or
     endif
 elif host_machine.system() == 'netbsd'
     if host_machine.cpu_family() == 'x86' or host_machine.cpu_family() == 'x86_64'
-        xorg_data.set('USE_I386_IOPL', '1')
+        xorg_data.set('USE_AMD64_IOPL', '1')
     endif
 elif host_machine.system() == 'openbsd'
     if host_machine.cpu_family() == 'x86'


[FILE:193:patches/patch-os_backtrace.c]
--- os/backtrace.c.orig	2022-12-19 10:53:03 UTC
+++ os/backtrace.c
@@ -29,6 +29,7 @@
 #include "misc.h"
 #include <errno.h>
 #include <string.h>
+#include <unistd.h>
 
 #ifdef HAVE_LIBUNWIND
 


[FILE:1021:patches/patch-test_simple-xinit.c]
--- test/simple-xinit.c.orig	2022-12-19 10:53:03 UTC
+++ test/simple-xinit.c
@@ -34,6 +34,47 @@
 #include <sys/wait.h>
 #include <unistd.h>
 
+#ifdef __sun__
+#include <sys/varargs.h>
+static int
+vasprintf(char **strp, const char *fmt, va_list args)
+{
+    va_list args_copy;
+    int status, needed;
+
+    va_copy(args_copy, args);
+    needed = vsnprintf(NULL, 0, fmt, args_copy);
+    va_end(args_copy);
+    if (needed < 0) {
+        *strp = NULL;
+        return needed;
+    }
+    *strp = malloc(needed + 1);
+    if (*strp == NULL)
+        return -1;
+    status = vsnprintf(*strp, needed + 1, fmt, args);
+    if (status >= 0)
+        return status;
+    else {
+        free(*strp);
+        *strp = NULL;
+        return status;
+    }
+}
+
+static int
+asprintf(char **strp, const char *fmt, ...)
+{
+    va_list args;
+    int status;
+
+    va_start(args, fmt);
+    status = vasprintf(strp, fmt, args);
+    va_end(args);
+    return status;
+}
+#endif
+
 static void
 kill_server(int server_pid)
 {

