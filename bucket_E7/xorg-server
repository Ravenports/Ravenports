# Buildsheet autogenerated by ravenadm tool -- Do not edit.

NAMEBASE=		xorg-server
VERSION=		21.1.9
KEYWORDS=		x11_servers
VARIANTS=		standard virtual xephyr nest
SDESC[xephyr]=		X server from X.Org based on kdrive
SDESC[virtual]=		X virtual framebuffer server from X.Org
SDESC[standard]=	X.Org X server and related programs
SDESC[nest]=		Nesting X server from X.Org
HOMEPAGE=		https://www.x.org/
CONTACT=		nobody

DOWNLOAD_GROUPS=	main
SITES[main]=		XORG/individual/xserver
DISTFILE[1]=		xorg-server-21.1.9.tar.xz:main
DF_INDEX=		1
SPKGS[xephyr]=		complete
			primary
			man
SPKGS[virtual]=		complete
			primary
			man
SPKGS[standard]=	complete
			primary
			man
			dev
SPKGS[nest]=		complete
			primary
			man

OPTIONS_AVAILABLE=	XORG VIRTUAL XEPHYR NEST DEVD
OPTIONS_STANDARD=	XORG DEVD
VOPTS[xephyr]=		XORG=OFF VIRTUAL=OFF XEPHYR=ON NEST=OFF DEVD=OFF
VOPTS[virtual]=		XORG=OFF VIRTUAL=ON XEPHYR=OFF NEST=OFF DEVD=OFF
VOPTS[nest]=		XORG=OFF VIRTUAL=OFF XEPHYR=OFF NEST=ON DEVD=OFF
OPT_ON[all]=		XORG

BUILD_DEPENDS=		libdrm:dev:standard
			libgpg-error:dev:standard
BUILDRUN_DEPENDS=	xorg-xkbcomp:single:standard
RUN_DEPENDS=		xorg-xkeyboard-config:primary:standard
EXRUN[dev]=		xorg-pixman:dev:standard
			xorg-pciaccess:dev:standard

USES=			cpe perl:build ssl solaris-funcs meson zlib:build
XORG_COMPONENTS=	xorgproto xtransproto pixman xshmfence xau xdmcp
			xfont2 xkbfile

LICENSE=		MIT:primary
LICENSE_FILE=		MIT:{{WRKSRC}}/COPYING
LICENSE_SCHEME=		solo

CPE_VENDOR=		x.org
FPC_EQUIVALENT=		x11-servers/xorg-server
MESON_ARGS=		-Dxkb_dir="{{LOCALBASE}}/share/X11/xkb"
			-Ddefault_font_path="{{fontlist:ts,}}"
			-Dglamor=false
			-Dxcsecurity=true
			-Ddtrace=false
			-Dhal=false
			-Dudev_kms=false
			-Dxwin=false
			-Dxquartz=false
			-Dsystemd_logind=false
			-Dxselinux=false
			-Dfallback_input_driver=libinput
			-Dxkb_dir={{LOCALBASE}}/share/X11/xkb
			-Dxkb_output_dir=/var/lib/xkb
SOL_FUNCTIONS=		strnlen:xkb/XKBGAlloc.c

VAR_OPSYS[sunos]=	CFLAGS=-DO_CLOEXEC=0
VAR_OPSYS[netbsd]=	CPPFLAGS=-D_OPENBSD_SOURCE
			CONFIGURE_ARGS=-Dsecure-rpc=false

[DEVD].DESCRIPTION=			Use devd for autoconfiguration of input devices
[DEVD].BUILDRUN_DEPENDS_ON=		libudev-devd:primary:standard
[DEVD].BUILD_DEPENDS_ON=		libudev-devd:dev:standard
[DEVD].CONFIGURE_ARGS_OFF=		-Dudev=false
[DEVD].CONFIGURE_ARGS_ON=		-Dudev=true

[NEST].DESCRIPTION=			Build as nesting X server
[NEST].BUILDRUN_DEPENDS_ON=		libglvnd:primary:standard
[NEST].BUILD_DEPENDS_ON=		libepoxy:primary:standard
					libepoxy:dev:standard
					mesa:drivers:standard
					mesa:dev:standard
					libglvnd:dev:standard
[NEST].CONFIGURE_ARGS_OFF=		-Dxnest=false
[NEST].CONFIGURE_ARGS_ON=		-Dxnest=true
[NEST].XORG_COMPONENTS_ON=		x11
					xext

[XEPHYR].DESCRIPTION=			Build as kdrive-base X server
[XEPHYR].BUILDRUN_DEPENDS_ON=		libdrm:primary:standard
					libepoxy:primary:standard
					libglvnd:primary:standard
[XEPHYR].BUILD_DEPENDS_ON=		mesa:drivers:standard
					mesa:dev:standard
					libepoxy:dev:standard
					libglvnd:dev:standard
[XEPHYR].CONFIGURE_ARGS_OFF=		-Dxephyr=false
[XEPHYR].CONFIGURE_ARGS_ON=		-Dxephyr=true
[XEPHYR].XORG_COMPONENTS_ON=		x11
					xcb
					xcb-util
					xcb-util-image
					xcb-util-wm
					xcb-util-keysyms
					xcb-render-util

[VIRTUAL].DESCRIPTION=			Build as virtual framebuffer server
[VIRTUAL].BUILDRUN_DEPENDS_ON=		libglvnd:primary:standard
[VIRTUAL].BUILD_DEPENDS_ON=		libepoxy:primary:standard
					libepoxy:dev:standard
					mesa:drivers:standard
					mesa:dev:standard
					libglvnd:dev:standard
[VIRTUAL].CONFIGURE_ARGS_OFF=		-Dxvfb=false
[VIRTUAL].CONFIGURE_ARGS_ON=		-Dxvfb=true

[XORG].DESCRIPTION=			Build as X server (don't change setting!)
[XORG].BUILDRUN_DEPENDS_ON=		libdrm:primary:standard
					libepoxy:primary:standard
					mesa:drivers:standard
					xorg-xcvt:primary:standard
[XORG].BUILD_DEPENDS_ON=		xmlto:single:standard
					xorg-sgml-doctools:single:standard
					mesa:dev:standard
					libepoxy:dev:standard
					xorg-xcvt:dev:standard
[XORG].CONFIGURE_ARGS_OFF=		-Ddocs=false
					-Ddevel-docs=false
					-Dxorg=false
[XORG].CONFIGURE_ARGS_ON=		-Ddocs=true
					-Ddevel-docs=true
					-Dxorg=true
					-Dlog_dir=/var/log
					-Dsuid_wrapper=true
[XORG].XORG_COMPONENTS_ON=		pciaccess
					xfont2

post-install-XORG-OFF:
	${RM} -r ${STAGEDIR}${PREFIX}/lib/xorg
	${RM} ${STAGEDIR}${PREFIX}/share/man/man1/Xserver.1
	${MKDIR} ${STAGEDIR}/var/lib/xkb

post-install-XORG-ON:
	${RM} -r ${STAGEDIR}${STD_DOCDIR}
	${MKDIR} ${STAGEDIR}${PREFIX}/share/X11/xorg.conf.d
	${MKDIR} ${STAGEDIR}${PREFIX}/etc/X11/xorg.conf.d
	${MKDIR} ${STAGEDIR}${fontpathd}
	${MKDIR} ${STAGEDIR}/var/lib/xkb
	${INSTALL_DATA} ${FILESDIR}/20-evdev-kbd.conf \
		${STAGEDIR}${PREFIX}/share/X11/xorg.conf.d

[FILE:71:descriptions/desc.primary.standard]
This package contains the X.Org X server and some associated programs.


[FILE:60:descriptions/desc.primary.virtual]
This package contains Xvfb, a virtual framebuffer X server.


[FILE:173:descriptions/desc.primary.xephyr]
Xephyr is a kdrive server that outputs to a window on a pre-existing
'host' X display.  Think Xnest but with support for modern extensions
like composite, damage and randr.


[FILE:78:descriptions/desc.primary.nest]
This package contains Xnest, a nesting X Server that displays on an X
Server.


[FILE:104:distinfo]
ff697be2011b4c4966b7806929e51b7a08e9d33800d505305d26d9ccde4b533a      4935860 xorg-server-21.1.9.tar.xz


[FILE:432:manifests/plist.primary.standard]
bin/
 X
 Xorg
 gtf
etc/X11/xorg.conf.d/10-quirks.conf
lib/xorg/protocol.txt
lib/xorg/modules/
 libexa.so
 libfbdevhw.so
 libint10.so
 libshadow.so
 libshadowfb.so
 libvgahw.so
 libwfb.so
lib/xorg/modules/drivers/modesetting_drv.so
lib/xorg/modules/extensions/libglx.so
lib/xorg/modules/input/inputtest_drv.so
libexec/Xorg
@(,,4555) libexec/Xorg.wrap
share/X11/xorg.conf.d/20-evdev-kbd.conf
@dir /var/lib/xkb
@dir etc/X11/fontpath.d


[FILE:216:manifests/plist.man.standard]
share/man/man1/
 Xorg.1.gz
 Xorg.wrap.1.gz
 Xserver.1.gz
 gtf.1.gz
share/man/man4/
 exa.4.gz
 fbdevhw.4.gz
 inputtestdrv.4.gz
 modesetting.4.gz
share/man/man5/
 Xwrapper.config.5.gz
 xorg.conf.5.gz
 xorg.conf.d.5.gz


[FILE:1983:manifests/plist.dev.standard]
%%ONLY-SUNOS%%include/xorg/solaris-amd64.il
include/xorg/
 XIstubs.h
 Xprintf.h
 callback.h
 client.h
 closestr.h
 closure.h
 colormap.h
 colormapst.h
 compiler.h
 compositeext.h
 cursor.h
 cursorstr.h
 damage.h
 damagestr.h
 dbestruct.h
 dgaproc.h
 displaymode.h
 dix.h
 dixaccess.h
 dixevents.h
 dixfont.h
 dixfontstr.h
 dixgrabs.h
 dixstruct.h
 dri.h
 dri2.h
 dri3.h
 dristruct.h
 edid.h
 events.h
 exa.h
 exevents.h
 extension.h
 extinit.h
 extnsionst.h
 fb.h
 fbdevhw.h
 fboverlay.h
 fbpict.h
 fbrop.h
 fourcc.h
 gc.h
 gcstruct.h
 geext.h
 geint.h
 globals.h
 glx_extinit.h
 glxvndabi.h
 glyphstr.h
 hotplug.h
 i2c_def.h
 input.h
 inputstr.h
 list.h
 mi.h
 micmap.h
 micoord.h
 migc.h
 miline.h
 mioverlay.h
 mipict.h
 mipointer.h
 mipointrst.h
 misc.h
 miscstruct.h
 mistruct.h
 misync.h
 misyncfd.h
 misyncshm.h
 misyncstr.h
 mizerarc.h
 nonsdk_extinit.h
 opaque.h
 optionstr.h
 os.h
 panoramiX.h
 panoramiXsrv.h
 picture.h
 picturestr.h
 pixmap.h
 pixmapstr.h
 present.h
 presentext.h
 privates.h
 property.h
 propertyst.h
 ptrveloc.h
 randrstr.h
 region.h
 regionstr.h
 registry.h
 resource.h
 rgb.h
 rrtransform.h
 sarea.h
 screenint.h
 scrnintstr.h
 selection.h
 servermd.h
 shadow.h
 shadowfb.h
 shmint.h
 syncsdk.h
 validate.h
 vbe.h
 vbeModes.h
 vgaHW.h
 vndserver.h
 wfbrename.h
 window.h
 windowstr.h
 xaarop.h
 xace.h
 xacestr.h
 xf86-input-inputtest-protocol.h
 xf86.h
 xf86Crtc.h
 xf86Cursor.h
 xf86DDC.h
 xf86MatchDrivers.h
 xf86Modes.h
 xf86Module.h
 xf86Opt.h
 xf86Optionstr.h
 xf86Optrec.h
 xf86Parser.h
 xf86Pci.h
 xf86PciInfo.h
 xf86Priv.h
 xf86Privstr.h
 xf86RandR12.h
 xf86VGAarbiter.h
 xf86Xinput.h
 xf86_OSlib.h
 xf86_OSproc.h
 xf86cmap.h
 xf86fbman.h
 xf86i2c.h
 xf86int10.h
 xf86platformBus.h
 xf86sbusBus.h
 xf86str.h
 xf86xv.h
 xf86xvmc.h
 xf86xvpriv.h
 xisb.h
 xkbfile.h
 xkbrules.h
 xkbsrv.h
 xkbstr.h
 xorg-server.h
 xorgVersion.h
 xserver-properties.h
 xserver_poll.h
 xvdix.h
 xvmcext.h
lib/pkgconfig/xorg-server.pc
share/aclocal/xorg-server.m4


[FILE:27:manifests/plist.primary.virtual]
bin/Xvfb
@dir /var/lib/xkb


[FILE:25:manifests/plist.man.virtual]
share/man/man1/Xvfb.1.gz


[FILE:29:manifests/plist.primary.xephyr]
bin/Xephyr
@dir /var/lib/xkb


[FILE:27:manifests/plist.man.xephyr]
share/man/man1/Xephyr.1.gz


[FILE:28:manifests/plist.primary.nest]
bin/Xnest
@dir /var/lib/xkb


[FILE:26:manifests/plist.man.nest]
share/man/man1/Xnest.1.gz


[FILE:293:patches/patch-config_config-backends.h]
--- config/config-backends.h.orig	2023-10-25 01:40:28 UTC
+++ config/config-backends.h
@@ -44,3 +44,8 @@ void config_hal_fini(void);
 int config_wscons_init(void);
 void config_wscons_fini(void);
 #endif
+
+#ifdef CONFIG_DEVD
+int config_devd_init(void);
+void config_devd_fini(void);
+#endif


[FILE:537:patches/patch-config_config.c]
--- config/config.c.orig	2023-10-25 01:40:28 UTC
+++ config/config.c
@@ -55,6 +55,9 @@ config_init(void)
 #elif defined(CONFIG_WSCONS)
     if (!config_wscons_init())
         ErrorF("[config] failed to initialise wscons\n");
+#elif defined(CONFIG_DEVD)
+    if (!config_devd_init())
+        ErrorF("[config] failed to initialise devd\n");
 #endif
 }
 
@@ -67,6 +70,8 @@ config_fini(void)
     config_hal_fini();
 #elif defined(CONFIG_WSCONS)
     config_wscons_fini();
+#elif defined(CONFIG_DEVD)
+    config_devd_fini();
 #endif
 }
 


[FILE:12171:patches/patch-config_devd.c]
--- /dev/null	2023-10-26 04:56:17 UTC
+++ config/devd.c
@@ -0,0 +1,532 @@
+/*
+ * Copyright (c) 2012 Baptiste Daroussin
+ * Copyright (c) 2013, 2014 Alex Kozlov
+ * Copyright (c) 2014 Robert Millan
+ * Copyright (c) 2014 Jean-Sebastien Pedron
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ *
+ * Author: Baptiste Daroussin <bapt@FreeBSD.org>
+ */
+
+#ifdef HAVE_DIX_CONFIG_H
+#include <dix-config.h>
+#endif
+
+#include <sys/types.h>
+#include <sys/kbio.h>
+#include <sys/socket.h>
+#include <sys/stat.h>
+#include <sys/sysctl.h>
+#include <sys/un.h>
+
+#include <ctype.h>
+#include <errno.h>
+#include <fcntl.h>
+#include <stdlib.h>
+#include <stdio.h>
+#include <stdbool.h>
+#include <unistd.h>
+
+#include "input.h"
+#include "inputstr.h"
+#include "hotplug.h"
+#include "config-backends.h"
+#include "os.h"
+
+#define DEVD_SOCK_PATH "/var/run/devd.pipe"
+
+#define DEVD_EVENT_ADD		'+'
+#define DEVD_EVENT_REMOVE	'-'
+
+#define RECONNECT_DELAY		5 * 1000
+
+static int sock_devd;
+static bool is_console_kbd = false;
+static bool is_kbdmux = false;
+static OsTimerPtr rtimer = NULL;
+
+struct hw_type {
+	const char *driver;
+	int flag;
+	const char *xdriver;
+};
+
+static struct hw_type hw_types[] = {
+	{ "ukbd", ATTR_KEYBOARD, "kbd" },
+	{ "atkbd", ATTR_KEYBOARD, "kbd" },
+	{ "kbdmux", ATTR_KEYBOARD, "kbd" },
+	{ "sysmouse", ATTR_POINTER, "mouse" },
+	{ "ums", ATTR_POINTER, "mouse" },
+	{ "psm", ATTR_POINTER, "mouse" },
+	{ "vboxguest", ATTR_POINTER, "vboxmouse" },
+	{ "joy", ATTR_JOYSTICK, NULL },
+	{ "atp", ATTR_TOUCHPAD, NULL },
+	{ "uep", ATTR_TOUCHSCREEN, NULL },
+	{ NULL, -1, NULL },
+};
+
+static bool
+sysctl_exists(const struct hw_type *device, int unit,
+	char *devname, size_t devname_len)
+{
+	char sysctlname[PATH_MAX];
+	size_t len;
+	int ret;
+
+	if (device == NULL || device->driver == NULL)
+		return false;
+
+	/* Check if a sysctl exists. */
+	snprintf(sysctlname, sizeof(sysctlname), "dev.%s.%i.%%desc",
+	    device->driver, unit);
+	ret = sysctlbyname(sysctlname, NULL, &len, NULL, 0);
+
+	if (ret == 0 && len > 0) {
+		snprintf(devname, devname_len, "%s%i", device->driver, unit);
+		return true;
+	}
+
+	return false;
+}
+
+static bool
+devpath_exists(const struct hw_type *device,
+	char *devname, size_t devname_len)
+{
+	char *devpath;
+	struct stat st;
+	int ret;
+
+	if (device == NULL || device->driver == NULL)
+		return false;
+
+	/* Check if /dev/$driver exists. */
+	asprintf(&devpath, "/dev/%s", device->driver);
+	if (devpath == NULL)
+		return false;
+
+	ret = stat(devpath, &st);
+	free(devpath);
+
+	if (ret == 0) {
+		strncpy(devname, device->driver, devname_len);
+		return true;
+	}
+
+	return false;
+}
+
+static char *
+sysctl_get_str(const char *sysctlname)
+{
+	char *dest = NULL;
+	size_t len;
+
+	if (sysctlname == NULL)
+		return NULL;
+
+	if (sysctlbyname(sysctlname, NULL, &len, NULL, 0) == 0) {
+		dest = malloc(len + 1);
+		if (dest) {
+			if (sysctlbyname(sysctlname, dest, &len, NULL, 0) == 0)
+				dest[len] = '\0';
+			else {
+				free(dest);
+				dest = NULL;
+			}
+		}
+	}
+
+	return dest;
+}
+
+static void
+device_added(const char *devname)
+{
+	char path[PATH_MAX];
+	char sysctlname[PATH_MAX];
+	char *vendor;
+	char *product = NULL;
+	char *config_info = NULL;
+	char *walk;
+	InputOption *options = NULL;
+	InputAttributes attrs = { };
+	DeviceIntPtr dev = NULL;
+	int i;
+	int fd;
+
+	for (i = 0; hw_types[i].driver != NULL; i++) {
+		size_t len;
+
+		len = strlen(hw_types[i].driver);
+		if (strcmp(devname, hw_types[i].driver) == 0 ||
+			(strncmp(devname, hw_types[i].driver, len) == 0 &&
+				isnumber(*(devname + len)))) {
+			attrs.flags |= hw_types[i].flag;
+			break;
+		}
+	}
+
+	if (hw_types[i].driver == NULL || hw_types[i].xdriver == NULL) {
+		LogMessage(X_INFO, "config/devd: ignoring device %s\n",
+				devname);
+		return;
+	}
+
+	/* Skip keyboard devices if kbdmux is enabled */
+	if (is_kbdmux && is_console_kbd && hw_types[i].flag & ATTR_KEYBOARD) {
+		LogMessage(X_INFO, "config/devd: kbdmux is enabled, ignoring device %s\n",
+				devname);
+		return;
+	}
+
+	snprintf(path, sizeof(path), "/dev/%s", devname);
+
+	options = input_option_new(NULL, "_source", "server/devd");
+	if (!options)
+		return;
+
+	snprintf(sysctlname, sizeof(sysctlname), "dev.%s.%s.%%desc",
+	    hw_types[i].driver, devname + strlen(hw_types[i].driver));
+	vendor = sysctl_get_str(sysctlname);
+	if (vendor == NULL) {
+		options = input_option_new(options, "name", devname);
+	}
+	else {
+		if ((walk = strchr(vendor, ' ')) != NULL) {
+			walk[0] = '\0';
+			walk++;
+			product = walk;
+			if ((walk = strchr(product, ',')) != NULL)
+				walk[0] = '\0';
+		}
+
+		attrs.vendor = strdup(vendor);
+		if (product) {
+			attrs.product = strdup(product);
+			options = input_option_new(options, "name", product);
+		}
+		else
+			options = input_option_new(options, "name", "(unnamed)");
+
+		free(vendor);
+	}
+
+	/* XXX implement usb_id */
+	attrs.usb_id = NULL;
+	attrs.device = strdup(path);
+	options = input_option_new(options, "driver", hw_types[i].xdriver);
+
+	fd = open(path, O_RDONLY);
+	if (fd > 0) {
+		close(fd);
+		options = input_option_new(options, "device", path);
+	}
+	else {
+		if (attrs.flags & ~ATTR_KEYBOARD) {
+			LogMessage(X_INFO, "config/devd: device %s already opened\n",
+					 path);
+
+			/*
+			 * Fail if cannot open device, it breaks AllowMouseOpenFail,
+			 * but it should not matter when config/devd enabled
+			 */
+			goto unwind;
+		}
+
+		if (is_console_kbd) {
+			/*
+			 * There can be only one keyboard attached to console and
+			 * it is already added.
+			 */
+			LogMessage(X_WARNING, "config/devd: console keyboard is "
+					"already added, ignoring %s (%s)\n",
+					attrs.product, path);
+			goto unwind;
+		}
+		else
+			/*
+			 * Don't pass "device" option if the keyboard is already
+			 * attached to the console (ie. open() fails).
+			 * This would activate a special logic in xf86-input-keyboard.
+			 * Prevent any other attached to console keyboards being
+			 * processed. There can be only one such device.
+			 */
+			is_console_kbd = true;
+	}
+
+	if (asprintf(&config_info, "devd:%s", devname) == -1) {
+		config_info = NULL;
+		goto unwind;
+	}
+
+	if (device_is_duplicate(config_info)) {
+		LogMessage(X_WARNING, "config/devd: device %s (%s) already added. "
+				"ignoring\n", attrs.product, path);
+		goto unwind;
+	}
+
+	options = input_option_new(options, "config_info", config_info);
+	LogMessage(X_INFO, "config/devd: adding input device %s (%s)\n",
+			attrs.product, path);
+
+	NewInputDeviceRequest(options, &attrs, &dev);
+
+unwind:
+	free(config_info);
+	input_option_free_list(&options);
+	free(attrs.usb_id);
+	free(attrs.product);
+	free(attrs.device);
+	free(attrs.vendor);
+}
+
+static void
+device_removed(char *devname)
+{
+	char *config_info;
+
+	if (asprintf(&config_info, "devd:%s", devname) == -1)
+		return;
+
+	remove_devices("devd", config_info);
+
+	free(config_info);
+}
+
+static bool is_kbdmux_enabled(void)
+{
+	/* Xorg uses /dev/ttyv0 as a console device */
+	/* const char device[]="/dev/console"; */
+	const char device[]="/dev/ttyv0";
+	keyboard_info_t info;
+	int fd;
+
+	fd = open(device, O_RDONLY);
+
+	if (fd < 0)
+		return false;
+
+	if (ioctl(fd, KDGKBINFO, &info) == -1) {
+		close(fd);
+		return false;
+	}
+
+	close(fd);
+
+	if (!strncmp(info.kb_name, "kbdmux", 6))
+		return true;
+
+	return false;
+}
+
+static void
+disconnect_devd(int sock)
+{
+	if (sock >= 0) {
+		RemoveGeneralSocket(sock);
+		close(sock);
+	}
+}
+
+static int
+connect_devd(void)
+{
+	struct sockaddr_un devd;
+	int sock;
+
+	sock = socket(AF_UNIX, SOCK_STREAM, 0);
+	if (sock < 0) {
+		LogMessage(X_ERROR, "config/devd: fail opening stream socket\n");
+		return -1;
+	}
+
+	devd.sun_family = AF_UNIX;
+	strlcpy(devd.sun_path, DEVD_SOCK_PATH, sizeof(devd.sun_path));
+
+	if (connect(sock, (struct sockaddr *) &devd, sizeof(devd)) < 0) {
+		close(sock);
+		LogMessage(X_ERROR, "config/devd: fail to connect to devd\n");
+		return -1;
+	}
+
+	AddGeneralSocket(sock);
+
+	return	sock;
+}
+
+static CARD32
+reconnect_handler(OsTimerPtr timer, CARD32 time, void *arg)
+{
+	int newsock;
+
+	if ((newsock = connect_devd()) > 0) {
+		sock_devd = newsock;
+		TimerFree(rtimer);
+		rtimer = NULL;
+		LogMessage(X_INFO, "config/devd: reopening devd socket\n");
+		return 0;
+	}
+
+	/* Try again after RECONNECT_DELAY */
+	return RECONNECT_DELAY;
+}
+
+static ssize_t
+socket_getline(int fd, char **out)
+{
+	char *buf, *newbuf;
+	ssize_t ret, cap, sz = 0;
+	char c;
+
+	cap = 1024;
+	buf = malloc(cap * sizeof(char));
+	if (!buf)
+		return -1;
+
+	for (;;) {
+		ret = read(sock_devd, &c, 1);
+		if (ret < 0) {
+			if (errno == EINTR)
+				continue;
+			free(buf);
+			return -1;
+		/* EOF - devd socket is lost */
+		} else if (ret == 0) {
+			disconnect_devd(sock_devd);
+			rtimer = TimerSet(NULL, 0, 1, reconnect_handler, NULL);
+			LogMessage(X_WARNING, "config/devd: devd socket is lost\n");
+			free(buf);
+			return -1;
+		}
+		if (c == '\n')
+			break;
+
+		if (sz + 1 >= cap) {
+			cap *= 2;
+			newbuf = realloc(buf, cap * sizeof(char));
+			if (!newbuf) {
+				free(buf);
+				return -1;
+			}
+			buf = newbuf;
+		}
+		buf[sz] = c;
+		sz++;
+	}
+
+	buf[sz] = '\0';
+	if (sz >= 0)
+		*out = buf;
+	else
+		free(buf);
+
+	/* Number of bytes in the line, not counting the line break */
+	return sz;
+}
+
+static void
+wakeup_handler(void *data, int err, void *read_mask)
+{
+	char *line = NULL;
+	char *walk;
+
+	if (err < 0)
+		return;
+
+	if (FD_ISSET(sock_devd, (fd_set *) read_mask)) {
+		if (socket_getline(sock_devd, &line) < 0)
+			return;
+
+		walk = strchr(line + 1, ' ');
+		if (walk != NULL)
+			walk[0] = '\0';
+
+		switch (*line) {
+		case DEVD_EVENT_ADD:
+			device_added(line + 1);
+			break;
+		case DEVD_EVENT_REMOVE:
+			device_removed(line + 1);
+			break;
+		default:
+			break;
+		}
+		free(line);
+	}
+}
+
+static void
+block_handler(void *data, struct timeval **tv, void *read_mask)
+{
+}
+
+int
+config_devd_init(void)
+{
+	char devicename[1024];
+	int i, j;
+
+	LogMessage(X_INFO, "config/devd: probing input devices...\n");
+
+	/*
+	 * Add fake keyboard and give up on keyboards management
+	 * if kbdmux is enabled
+	 */
+	if ((is_kbdmux = is_kbdmux_enabled()) == true)
+		device_added("kbdmux");
+
+	for (i = 0; hw_types[i].driver != NULL; i++) {
+		/* First scan the sysctl to determine the hardware */
+		for (j = 0; j < 16; j++) {
+			if (sysctl_exists(&hw_types[i], j,
+					devicename, sizeof(devicename)) != 0)
+				device_added(devicename);
+		}
+
+		if (devpath_exists(&hw_types[i], devicename, sizeof(devicename)) != 0)
+			device_added(devicename);
+	}
+
+	if ((sock_devd = connect_devd()) < 0)
+		return 0;
+
+	RegisterBlockAndWakeupHandlers(block_handler, wakeup_handler, NULL);
+
+	return 1;
+}
+
+void
+config_devd_fini(void)
+{
+	LogMessage(X_INFO, "config/devd: terminating backend...\n");
+
+	if (rtimer) {
+		TimerFree(rtimer);
+		rtimer = NULL;
+	}
+
+	disconnect_devd(sock_devd);
+
+	RemoveBlockAndWakeupHandlers(block_handler, wakeup_handler, NULL);
+
+	is_console_kbd = false;
+}


[FILE:391:patches/patch-config_meson.build]
--- config/meson.build.orig	2023-10-25 01:40:28 UTC
+++ config/meson.build
@@ -25,7 +25,7 @@ endif
 
 if build_xorg
     install_data('10-quirks.conf',
-                 install_dir: join_paths(get_option('datadir'), 'X11/xorg.conf.d'))
+                 install_dir: join_paths(get_option('prefix'), 'etc/X11/xorg.conf.d'))
 endif
 
 libxserver_config = static_library('libxserver_config',


[FILE:3104:patches/patch-config_udev.c]
--- config/udev.c.orig	2023-10-25 01:40:28 UTC
+++ config/udev.c
@@ -29,6 +29,7 @@
 
 #include <libudev.h>
 #include <ctype.h>
+#include <fcntl.h>
 #include <unistd.h>
 
 #include "input.h"
@@ -67,6 +68,45 @@ config_udev_odev_setup_attribs(struct ud
 
 static char itoa_buf[16];
 
+#if defined(__DragonFly__)
+// Taken from FreeBSD's lib/libc/gen/feature_present.c
+
+#include <sys/cdefs.h>
+#include <sys/types.h>
+#include <sys/sysctl.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+
+int      feature_present(const char *);
+/*
+ * Returns true if the named feature is present in the currently
+ * running kernel.  A feature's presence is indicated by an integer
+ * sysctl node called kern.feature.<feature> that is non-zero.
+ */
+int
+feature_present(const char *feature)
+{
+	char *mib;
+	size_t len;
+	int i;
+
+	if (asprintf(&mib, "kern.features.%s", feature) < 0)
+		return (0);
+	len = sizeof(i);
+	if (sysctlbyname(mib, &i, &len, NULL, 0) < 0) {
+		free(mib);
+		return (0);
+	}
+	free(mib);
+	if (len != sizeof(i))
+		return (0);
+	return (i != 0);
+}
+
+// end of FreeBSD's lib/libc/gen/feature_present.c
+#endif
+
 static const char *itoa(int i)
 {
     snprintf(itoa_buf, sizeof(itoa_buf), "%d", i);
@@ -198,7 +238,21 @@ device_added(struct udev_device *udev_de
         attrs.product = strdup(name);
     input_options = input_option_new(input_options, "name", name);
     input_options = input_option_new(input_options, "path", path);
-    input_options = input_option_new(input_options, "device", path);
+    if(strstr(path, "kbdmux") != NULL) {
+        /*
+         * Don't pass "device" option if the keyboard is already attached
+         * to the console (ie. open() fails). This would activate a special
+         * logic in xf86-input-keyboard. Prevent any other attached to console
+         * keyboards being processed. There can be only one such device.
+         */
+        int fd = open(path, O_RDONLY);
+        if (fd > -1) {
+            close(fd);
+            input_options = input_option_new(input_options, "device", path);
+        }
+    }
+    else
+        input_options = input_option_new(input_options, "device", path);
     input_options = input_option_new(input_options, "major", itoa(major(devnum)));
     input_options = input_option_new(input_options, "minor", itoa(minor(devnum)));
     if (path)
@@ -280,6 +334,18 @@ device_added(struct udev_device *udev_de
         }
     }
 
+    if (attrs.flags & (ATTR_KEY | ATTR_KEYBOARD)) {
+        if (!feature_present("evdev_support"))
+            input_options = input_option_new(input_options, "driver", "kbd");
+    } else if (attrs.flags & ATTR_POINTER) {
+        if (strstr(path, "vbox"))
+            input_options = input_option_new(input_options, "driver", "vboxmouse");
+        else {
+            if (!feature_present("evdev_support"))
+                input_options = input_option_new(input_options, "driver", "mouse");
+        }
+    }
+
     input_options = input_option_new(input_options, "config_info", config_info);
 
     /* Default setting needed for non-seat0 seats */


[FILE:1646:patches/patch-configure]
--- configure.orig	2023-10-25 01:40:37 UTC
+++ configure
@@ -24707,14 +24707,14 @@ printf "%s\n" "#define USE_ALPHA_PIO 1"
   x86_64*|amd64*)
 	I386_VIDEO=yes
 	case $host_os in
-		*freebsd*)
+		*freebsd*|*midnight*)
 printf "%s\n" "#define USE_DEV_IO 1" >>confdefs.h
  ;;
 		*dragonfly*)
 printf "%s\n" "#define USE_DEV_IO 1" >>confdefs.h
  ;;
 		*netbsd*)
-printf "%s\n" "#define USE_I386_IOPL 1" >>confdefs.h
+printf "%s\n" "#define USE_AMD64_IOPL 1" >>confdefs.h
 
 				SYS_LIBS=-lx86_64
 				;;
@@ -24778,7 +24778,7 @@ fi
 
 DRI=no
 case $host_os in
-  *freebsd* | *dragonfly*)
+  *freebsd* | *dragonfly*| *midnight*)
 	case $host_os in
 		kfreebsd*-gnu) ;;
 		*)
@@ -26588,7 +26588,8 @@ case ${host_os} in
 	netbsd*)
 	# use libc stubs, don't link against libpthread, to allow
 	# dynamic loading
-	ax_pthread_flags=""
+	ax_pthread_flags="none"
+	ax_pthread_ok="yes"
 	;;
 esac
 
@@ -28097,7 +28098,7 @@ fi
 case "x$XTRANS_SEND_FDS" in
 xauto)
 	case "$host_os" in
-	linux*|solaris*|freebsd*|dragonfly*|openbsd*)
+	linux*|solaris*|freebsd*|dragonfly*|openbsd*|midnight*)
 		XTRANS_SEND_FDS=yes
 		;;
 	*)
@@ -30713,7 +30714,7 @@ printf "%s\n" "#define PCI_TXT_IDS_PATH
   test "$exec_prefix_NONE" && exec_prefix=NONE
 
 		case $host_os in
-		  gnu* | freebsd* | kfreebsd*-gnu | netbsd* | openbsd* | solaris* | dragonfly*)
+		  gnu* | freebsd* | kfreebsd*-gnu | netbsd* | openbsd* | solaris* | dragonfly* | midnight*)
 			xorg_bus_bsdpci="yes"
 			;;
 		esac
@@ -30763,7 +30764,7 @@ fi
 
 done
 		;;
-	  freebsd* | kfreebsd*-gnu | dragonfly*)
+	  freebsd* | kfreebsd*-gnu | dragonfly* | midnight*)
 		XORG_OS_SUBDIR="bsd"
 		;;
 	  netbsd*)


[FILE:256:patches/patch-hw_kdrive_ephyr_hostx.c]
--- hw/kdrive/ephyr/hostx.c.orig	2023-10-25 01:40:28 UTC
+++ hw/kdrive/ephyr/hostx.c
@@ -36,7 +36,6 @@
 #include <string.h>             /* for memset */
 #include <errno.h>
 #include <time.h>
-#include <err.h>
 
 #include <sys/ipc.h>
 #include <sys/shm.h>


[FILE:791:patches/patch-hw_xfree86_common_xf86AutoConfig.c]
--- hw/xfree86/common/xf86AutoConfig.c.orig	2023-10-25 01:40:28 UTC
+++ hw/xfree86/common/xf86AutoConfig.c
@@ -294,7 +294,7 @@ listPossibleVideoDrivers(XF86MatchedDriv
     xf86PciMatchDriver(md);
 #endif
 
-#if defined(__linux__)
+#if defined(__linux__) || defined(__FreeBSD__) || defined(__DragonFly__)
     xf86AddMatchedDriver(md, "modesetting");
 #endif
 
@@ -302,8 +302,10 @@ listPossibleVideoDrivers(XF86MatchedDriv
     /* Fallback to platform default frame buffer driver */
 #if !defined(__linux__) && defined(__sparc__)
     xf86AddMatchedDriver(md, "wsfb");
-#else
+#elif defined(__linux__)
     xf86AddMatchedDriver(md, "fbdev");
+#elif defined(__FreeBSD__) || defined(__DragonFly__)
+    xf86AddMatchedDriver(md, "scfb");
 #endif
 #endif                          /* !__sun */
 


[FILE:700:patches/patch-hw_xfree86_common_xf86Config.c]
--- hw/xfree86/common/xf86Config.c.orig	2023-10-25 01:40:28 UTC
+++ hw/xfree86/common/xf86Config.c
@@ -1279,13 +1279,16 @@ checkCoreInputDevices(serverLayoutPtr se
     }
 
     if (!xf86Info.forceInputDevices && !(foundPointer && foundKeyboard)) {
-#if defined(CONFIG_HAL) || defined(CONFIG_UDEV) || defined(CONFIG_WSCONS)
+#if defined(CONFIG_HAL) || defined(CONFIG_UDEV) || defined(CONFIG_WSCONS) || \
+		defined(CONFIG_DEVD)
         const char *config_backend;
 
 #if defined(CONFIG_HAL)
         config_backend = "HAL";
 #elif defined(CONFIG_UDEV)
         config_backend = "udev";
+#elif defined(CONFIG_DEVD)
+        config_backend = "devd";
 #else
         config_backend = "wscons";
 #endif


[FILE:510:patches/patch-hw_xfree86_common_xf86Globals.c]
--- hw/xfree86/common/xf86Globals.c.orig	2023-10-25 01:40:28 UTC
+++ hw/xfree86/common/xf86Globals.c
@@ -118,7 +118,7 @@ xf86InfoRec xf86Info = {
     .miscModInDevEnabled = TRUE,
     .miscModInDevAllowNonLocal = FALSE,
     .pmFlag = TRUE,
-#if defined(CONFIG_HAL) || defined(CONFIG_UDEV) || defined(CONFIG_WSCONS)
+#if defined(CONFIG_HAL) || defined(CONFIG_UDEV) || defined(CONFIG_WSCONS) || defined(CONFIG_DEVD)
     .forceInputDevices = FALSE,
     .autoAddDevices = TRUE,
     .autoEnableDevices = TRUE,


[FILE:483:patches/patch-hw_xfree86_common_xf86Xinput.c]
--- hw/xfree86/common/xf86Xinput.c.orig	2023-10-25 01:40:28 UTC
+++ hw/xfree86/common/xf86Xinput.c
@@ -1065,6 +1065,7 @@ NewInputDeviceRequest(InputOption *optio
         if (strcmp(key, "_source") == 0 &&
             (strcmp(value, "server/hal") == 0 ||
              strcmp(value, "server/udev") == 0 ||
+             strcmp(value, "server/devd") == 0 ||
              strcmp(value, "server/wscons") == 0)) {
             is_auto = 1;
             if (!xf86Info.autoAddDevices) {


[FILE:343:patches/patch-hw_xfree86_common_xf86str.h]
--- hw/xfree86/common/xf86str.h.orig	2023-10-25 01:40:28 UTC
+++ hw/xfree86/common/xf86str.h
@@ -249,7 +249,7 @@ typedef struct _DriverRec {
  */
 
 /* Tolerate prior #include <linux/input.h> */
-#if defined(__linux__)
+#if defined(__linux__) || defined(__FreeBSD__) || defined(__DragonFly__)
 #undef BUS_NONE
 #undef BUS_PCI
 #undef BUS_SBUS


[FILE:596:patches/patch-hw_xfree86_drivers_modesetting_driver.c]
--- hw/xfree86/drivers/modesetting/driver.c.orig	2023-10-25 01:40:28 UTC
+++ hw/xfree86/drivers/modesetting/driver.c
@@ -925,8 +925,12 @@ try_enable_glamor(ScrnInfoPtr pScrn)
     modesettingPtr ms = modesettingPTR(pScrn);
     const char *accel_method_str = xf86GetOptValString(ms->drmmode.Options,
                                                        OPTION_ACCEL_METHOD);
+#if defined(__DragonFly__)
+    Bool do_glamor = FALSE;
+#else
     Bool do_glamor = (!accel_method_str ||
                       strcmp(accel_method_str, "glamor") == 0);
+#endif
 
     ms->drmmode.glamor = FALSE;
 


[FILE:359:patches/patch-hw_xfree86_meson.build]
--- hw/xfree86/meson.build.orig	2023-10-25 01:40:28 UTC
+++ hw/xfree86/meson.build
@@ -152,7 +152,6 @@ if get_option('suid_wrapper')
         c_args: xorg_c_args,
         install: true,
         install_dir: get_option('libexecdir'),
-        install_mode: ['r-sr-xr-x', 0, 0],
     )
 
     # meson gets confused when there are two targets of the same name


[FILE:2566:patches/patch-hw_xfree86_os-support_bsd_bsd__init.c]
--- hw/xfree86/os-support/bsd/bsd_init.c.orig	2023-10-25 01:40:28 UTC
+++ hw/xfree86/os-support/bsd/bsd_init.c
@@ -48,6 +48,8 @@ static int devConsoleFd = -1;
 #if defined (SYSCONS_SUPPORT) || defined (PCVT_SUPPORT)
 static int VTnum = -1;
 static int initialVT = -1;
+static struct termios tty_attr;	/* tty state to restore */
+static int tty_mode;		/* kbd mode to restore */
 #endif
 
 #ifdef PCCONS_SUPPORT
@@ -230,6 +232,9 @@ xf86OpenConsole()
              * Add cases for other *BSD that behave the same.
              */
 #if defined(__FreeBSD__) || defined(__FreeBSD_kernel__)
+#if defined(__sparc64__)
+	    pci_system_init_dev_mem(fd);
+#endif
             uname(&uts);
             i = atof(uts.release) * 100;
             if (i >= 310)
@@ -253,6 +258,7 @@ xf86OpenConsole()
 #endif
  acquire_vt:
             if (!xf86Info.ShareVTs) {
+                struct termios nTty;
                 /*
                  * now get the VT
                  */
@@ -287,6 +293,26 @@ xf86OpenConsole()
                 if (ioctl(xf86Info.consoleFd, KDSETMODE, KD_GRAPHICS) < 0) {
                     FatalError("xf86OpenConsole: KDSETMODE KD_GRAPHICS failed");
                 }
+
+                tcgetattr(xf86Info.consoleFd, &tty_attr);
+                ioctl(xf86Info.consoleFd, KDGKBMODE, &tty_mode);
+
+                /* disable special keys */
+                if (ioctl(xf86Info.consoleFd, KDSKBMODE, K_RAW) < 0) {
+                    FatalError("xf86OpenConsole: KDSKBMODE K_RAW failed (%s)",
+                               strerror(errno));
+                }
+
+                nTty = tty_attr;
+                nTty.c_iflag = IGNPAR | IGNBRK;
+                nTty.c_oflag = 0;
+                nTty.c_cflag = CREAD | CS8;
+                nTty.c_lflag = 0;
+                nTty.c_cc[VTIME] = 0;
+                nTty.c_cc[VMIN] = 1;
+                cfsetispeed(&nTty, 9600);
+                cfsetospeed(&nTty, 9600);
+                tcsetattr(xf86Info.consoleFd, TCSANOW, &nTty);
             }
             else {              /* xf86Info.ShareVTs */
                 close(xf86Info.consoleFd);
@@ -594,6 +620,8 @@ xf86CloseConsole()
     case SYSCONS:
     case PCVT:
         ioctl(xf86Info.consoleFd, KDSETMODE, KD_TEXT);  /* Back to text mode */
+        ioctl(xf86Info.consoleFd, KDSKBMODE, tty_mode);
+        tcsetattr(xf86Info.consoleFd, TCSANOW, &tty_attr);
         if (ioctl(xf86Info.consoleFd, VT_GETMODE, &VT) != -1) {
             VT.mode = VT_AUTO;
             ioctl(xf86Info.consoleFd, VT_SETMODE, &VT); /* dflt vt handling */


[FILE:519:patches/patch-hw_xfree86_os-support_bsd_i386__video.c]
--- hw/xfree86/os-support/bsd/i386_video.c.orig	2023-10-25 01:40:28 UTC
+++ hw/xfree86/os-support/bsd/i386_video.c
@@ -32,6 +32,7 @@
 #include "xf86Priv.h"
 
 #include <errno.h>
+#include <sys/types.h>
 #include <sys/mman.h>
 
 #include "xf86_OSlib.h"
@@ -42,6 +43,9 @@
 #else
 #define MAP_FLAGS (MAP_FILE | MAP_SHARED)
 #endif
+#if defined(__NetBSD__) && defined(USE_AMD64_IOPL)
+#define amd64_iopl x86_64_iopl
+#endif
 
 #ifdef __OpenBSD__
 #define SYSCTL_MSG "\tCheck that you have set 'machdep.allowaperture=1'\n"\


[FILE:380:patches/patch-hw_xfree86_os-support_bsd_ppc__video.c]
--- hw/xfree86/os-support/bsd/ppc_video.c.orig	2023-10-25 01:40:28 UTC
+++ hw/xfree86/os-support/bsd/ppc_video.c
@@ -79,7 +79,11 @@ xf86DisableIO()
 {
 
     if (ioBase != MAP_FAILED) {
+#if defined(__FreeBSD__)
+        munmap(__DEVOLATILE(unsigned char *, ioBase), 0x10000);
+#else
         munmap(__UNVOLATILE(ioBase), 0x10000);
+#endif
         ioBase = MAP_FAILED;
     }
 }


[FILE:1280:patches/patch-hw_xfree86_os-support_meson.build]
--- hw/xfree86/os-support/meson.build.orig	2023-10-25 01:40:28 UTC
+++ hw/xfree86/os-support/meson.build
@@ -91,11 +91,12 @@ elif host_machine.system() == 'sunos'
         error('Unknown CPU family for Solaris build')
     endif
 
-elif host_machine.system().endswith('bsd')
+elif host_machine.system().endswith('bsd') or host_machine.system() == 'dragonfly'
     srcs_xorg_os_support += [
         'bsd/bsd_VTsw.c',
         'bsd/bsd_bell.c',
         'bsd/bsd_init.c',
+	'misc/SlowBcopy.c',
 	'shared/pm_noop.c'
     ]
 
@@ -120,14 +121,14 @@ elif host_machine.system().endswith('bsd
         srcs_xorg_os_support += 'shared/ioperm_noop.c'
     elif host_machine.cpu_family() == 'alpha'
         srcs_xorg_os_support += 'bsd/alpha_video.c'
-        if host_machine.system() == 'freebsd'
+        if host_machine.system() == 'freebsd' or host_machine.system() == 'midnightbsd'
             os_dep += cc.find_library('io')
         elif host_machine.system() == 'netbsd'
             os_c_args += '-DUSE_ALPHA_PIO'
         endif
     endif
 
-    if host_machine.system() == 'freebsd'
+    if ['freebsd', 'dragonfly', 'midnightbsd'].contains(host_machine.system())
         srcs_xorg_os_support += 'bsd/bsd_kmod.c'
     else
         srcs_xorg_os_support += 'shared/kmod_noop.c'


[FILE:714:patches/patch-hw_xfree86_os-support_solaris_sun__init.c]
--- hw/xfree86/os-support/solaris/sun_init.c.orig	2023-10-25 01:40:28 UTC
+++ hw/xfree86/os-support/solaris/sun_init.c
@@ -54,6 +54,22 @@ static int xf86StartVT = -1;
 static int vtEnabled = 0;
 #endif
 
+#ifdef __sun__
+#define VTIOC		('V'<<8)
+#define VT_OPENQRY	(VTIOC|1)
+#define VT_SETMODE	(VTIOC|2)
+#define VT_GETMODE	(VTIOC|3)
+#define VT_ACTIVATE	(VTIOC|5)
+#define VT_WAITACTIVE	(VTIOC|6)
+#define VT_GETSTATE	(VTIOC|100)
+#define VT_ENABLED	(VTIOC|101)
+#define VT_SETDISPINFO	(VTIOC|103)
+#define VT_GET_CONSUSER	(VTIOC|108)
+#define VT_SET_CONSUSER	(VTIOC|109)
+
+enum { VT_AUTO = 0, VT_PROCESS };
+#endif
+
 /* Device to open as xf86Info.consoleFd */
 static char consoleDev[PATH_MAX] = "/dev/fb";
 


[FILE:520:patches/patch-hw_xfree86_os-support_xf86__OSlib.h]
--- hw/xfree86/os-support/xf86_OSlib.h.orig	2023-10-25 01:40:28 UTC
+++ hw/xfree86/os-support/xf86_OSlib.h
@@ -241,7 +241,7 @@ extern _X_HIDDEN char xf86SolarisFbDev[P
 #ifdef SYSCONS_SUPPORT
 #define COMPAT_SYSCONS
 #if defined(__FreeBSD__) || defined(__FreeBSD_kernel__) || defined(__DragonFly__)
-#if defined(__DragonFly__)  || (__FreeBSD_kernel_version >= 410000)
+#if defined(__DragonFly__)  || (__FreeBSD_kernel_version >= 410000) || defined(__MidnightBSD__)
 #include <sys/consio.h>
 #include <sys/kbio.h>
 #else


[FILE:1986:patches/patch-hw_xfree86_xorg-wrapper.c]
* Skip the detection of root rights requirement, the assumption that presence
* of KMS drivers removes the root requirement is only valid for Linux

--- hw/xfree86/xorg-wrapper.c.orig	2023-10-25 01:40:28 UTC
+++ hw/xfree86/xorg-wrapper.c
@@ -39,7 +39,7 @@
 #include <sys/sysmacros.h>
 #endif
 #include <sys/types.h>
-#if defined(__FreeBSD__) || defined(__FreeBSD_kernel__)
+#if defined(__FreeBSD__) || defined(__FreeBSD_kernel__) || defined(__DragonFly__)
 #include <sys/consio.h>
 #endif
 #include <unistd.h>
@@ -170,7 +170,7 @@ static int on_console(int fd)
     r = fstat(fd, &st);
     if (r == 0 && S_ISCHR(st.st_mode) && major(st.st_rdev) == 4)
       return 1;
-#elif defined(__FreeBSD__) || defined(__FreeBSD_kernel__)
+#elif defined(__FreeBSD__) || defined(__FreeBSD_kernel__) || defined(__DragonFly__)
     int idx;
 
     if (ioctl(fd, VT_GETINDEX, &idx) != -1)
@@ -191,7 +191,7 @@ static int on_console(int fd)
 
 int main(int argc, char *argv[])
 {
-#ifdef WITH_LIBDRM
+#if defined(WITH_LIBDRM) && defined(__linux__)
     struct drm_mode_card_res res;
 #endif
     char buf[PATH_MAX];
@@ -230,7 +230,7 @@ int main(int argc, char *argv[])
         }
     }
 
-#ifdef WITH_LIBDRM
+#if defined(WITH_LIBDRM) && defined(__linux__)
     /* Detect if we need root rights, except when overridden by the config */
     if (needs_root_rights == -1) {
         for (i = 0; i < 16; i++) {
@@ -256,6 +256,8 @@ int main(int argc, char *argv[])
         gid_t realgid = getgid();
         uid_t realuid = getuid();
 
+#if !defined(__NetBSD__)
+	/* setresgid and setresuid are not implemented on NetBSD */
         if (setresgid(-1, realgid, realgid) != 0) {
             fprintf(stderr, "%s: Could not drop setgid privileges: %s\n",
                 progname, strerror(errno));
@@ -266,6 +268,7 @@ int main(int argc, char *argv[])
                 progname, strerror(errno));
             exit(1);
         }
+#endif
     }
 
     snprintf(buf, sizeof(buf), "%s/Xorg", SUID_WRAPPER_DIR);


[FILE:1214:patches/patch-include_meson.build]
--- include/meson.build.orig	2023-10-25 01:40:28 UTC
+++ include/meson.build
@@ -278,7 +278,7 @@ supports_syscons = false
 supports_wscons = false
 csrg_based = false
 
-if host_machine.system() == 'freebsd' or host_machine.system() == 'dragonfly'
+if ['freebsd', 'dragonfly', 'midnightbsd'].contains(host_machine.system())
   supports_pccons = true
   supports_pcvt = true
   supports_syscons = true
@@ -377,13 +377,13 @@ xorg_data.set('HAVE_STROPTS_H', cc.has_h
 xorg_data.set('HAVE_SYS_KD_H', cc.has_header('sys/kd.h') ? '1' : false)
 xorg_data.set('HAVE_SYS_VT_H', cc.has_header('sys/vt.h') ? '1' : false)
 
-if host_machine.system() == 'freebsd' or host_machine.system() == 'dragonfly'
+if ['freebsd', 'dragonfly', 'midnightbsd'].contains(host_machine.system())
     if host_machine.cpu_family() == 'x86' or host_machine.cpu_family() == 'x86_64'
         xorg_data.set('USE_DEV_IO', '1')
     endif
 elif host_machine.system() == 'netbsd'
     if host_machine.cpu_family() == 'x86' or host_machine.cpu_family() == 'x86_64'
-        xorg_data.set('USE_I386_IOPL', '1')
+        xorg_data.set('USE_AMD64_IOPL', '1')
     endif
 elif host_machine.system() == 'openbsd'
     if host_machine.cpu_family() == 'x86'


[FILE:193:patches/patch-os_backtrace.c]
--- os/backtrace.c.orig	2023-10-25 01:40:28 UTC
+++ os/backtrace.c
@@ -29,6 +29,7 @@
 #include "misc.h"
 #include <errno.h>
 #include <string.h>
+#include <unistd.h>
 
 #ifdef HAVE_LIBUNWIND
 


[FILE:1021:patches/patch-test_simple-xinit.c]
--- test/simple-xinit.c.orig	2023-10-25 01:40:28 UTC
+++ test/simple-xinit.c
@@ -34,6 +34,47 @@
 #include <sys/wait.h>
 #include <unistd.h>
 
+#ifdef __sun__
+#include <sys/varargs.h>
+static int
+vasprintf(char **strp, const char *fmt, va_list args)
+{
+    va_list args_copy;
+    int status, needed;
+
+    va_copy(args_copy, args);
+    needed = vsnprintf(NULL, 0, fmt, args_copy);
+    va_end(args_copy);
+    if (needed < 0) {
+        *strp = NULL;
+        return needed;
+    }
+    *strp = malloc(needed + 1);
+    if (*strp == NULL)
+        return -1;
+    status = vsnprintf(*strp, needed + 1, fmt, args);
+    if (status >= 0)
+        return status;
+    else {
+        free(*strp);
+        *strp = NULL;
+        return status;
+    }
+}
+
+static int
+asprintf(char **strp, const char *fmt, ...)
+{
+    va_list args;
+    int status;
+
+    va_start(args, fmt);
+    status = vasprintf(strp, fmt, args);
+    va_end(args);
+    return status;
+}
+#endif
+
 static void
 kill_server(int server_pid)
 {


[FILE:1943:patches/patch-xephyr_Dont_check_for_SeatId_anymore.patch]
From 4c03b67d334b05b814239420776f2fdd4c4a98ac Mon Sep 17 00:00:00 2001
From: nerdopolis <bluescreen_avenger@verizon.net>
Date: Tue, 11 Jan 2022 18:41:42 -0500
Subject: [PATCH] xephyr: Don't check for SeatId anymore

After a change for the xserver to automatically determine the seat
based on the XDG_SEAT variable, xephyr stopped working. This was
because of an old feature where xephyr used to handle evdev
directly. This was dropped some time ago, and now this check is
not needed
---
 hw/kdrive/ephyr/ephyrinit.c | 34 ++++++++++++++++------------------
 1 file changed, 16 insertions(+), 18 deletions(-)

--- hw/kdrive/ephyr/ephyrinit.c.orig	2023-10-25 01:40:28 UTC
+++ hw/kdrive/ephyr/ephyrinit.c
@@ -70,25 +70,23 @@ InitInput(int argc, char **argv)
     KdKeyboardInfo *ki;
     KdPointerInfo *pi;
 
-    if (!SeatId) {
-        KdAddKeyboardDriver(&EphyrKeyboardDriver);
-        KdAddPointerDriver(&EphyrMouseDriver);
+    KdAddKeyboardDriver(&EphyrKeyboardDriver);
+    KdAddPointerDriver(&EphyrMouseDriver);
 
-        if (!kdHasKbd) {
-            ki = KdNewKeyboard();
-            if (!ki)
-                FatalError("Couldn't create Xephyr keyboard\n");
-            ki->driver = &EphyrKeyboardDriver;
-            KdAddKeyboard(ki);
-        }
+    if (!kdHasKbd) {
+        ki = KdNewKeyboard();
+        if (!ki)
+            FatalError("Couldn't create Xephyr keyboard\n");
+        ki->driver = &EphyrKeyboardDriver;
+        KdAddKeyboard(ki);
+    }
 
-        if (!kdHasPointer) {
-            pi = KdNewPointer();
-            if (!pi)
-                FatalError("Couldn't create Xephyr pointer\n");
-            pi->driver = &EphyrMouseDriver;
-            KdAddPointer(pi);
-        }
+    if (!kdHasPointer) {
+        pi = KdNewPointer();
+        if (!pi)
+            FatalError("Couldn't create Xephyr pointer\n");
+        pi->driver = &EphyrMouseDriver;
+        KdAddPointer(pi);
     }
 
     KdInitInput();


[FILE:152:files/20-evdev-kbd.conf]
Section "InputClass"
	Identifier		"Evdev keyboard"
	MatchDevicePath		"/dev/input/event*"
	MatchIsKeyboard		"on"
	Option			"XkbRules" "evdev"
EndSection


[FILE:251:files/special.mk]
sharefonts=	${LOCALBASE}/share/fonts
fontpathd=	${PREFIX}/etc/X11/fontpath.d

fontlist=	${sharefonts}/misc \
		${sharefonts}/TTF \
		${sharefonts}/OTF \
		${sharefonts}/Type1 \
		${sharefonts}/100dpi \
		${sharefonts}/75dpi \
		catalogue:${fontpathd}

