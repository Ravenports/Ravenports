# Buildsheet autogenerated by ravenadm tool -- Do not edit.

NAMEBASE=		t1lib
VERSION=		5.1.2
REVISION=		1
KEYWORDS=		devel
VARIANTS=		standard
SDESC[standard]=	Adobe Type 1 font rasterizing library
HOMEPAGE=		https://www.t1lib.org
CONTACT=		Michael_Reim[kraileth@elderlinux.org]

DOWNLOAD_GROUPS=	main
SITES[main]=		http://www.ibiblio.org/pub/Linux/libs/graphics/
DISTFILE[1]=		t1lib-5.1.2.tar.gz:main
DF_INDEX=		1
SPKGS[standard]=	complete
			primary
			x11
			docs

OPTIONS_AVAILABLE=	none
OPTIONS_STANDARD=	none

USES=			cpe libtool fbsd10fix
XORG_COMPONENTS=	xaw

LICENSE=		LGPL20:primary MIT:primary
LICENSE_TERMS=		primary:{{WRKDIR}}/TERMS
LICENSE_FILE=		LGPL20:{{WRKSRC}}/LGPL
			MIT:{{WRKDIR}}/MIT
LICENSE_AWK=		TERMS:"^$$"
			MIT:"^$$"
LICENSE_SOURCE=		TERMS:{{WRKSRC}}/lib/t1lib/t1lib.h
			MIT:{{WRKSRC}}/lib/type1/type1.c
LICENSE_SCHEME=		multi

FPC_EQUIVALENT=		devel/t1lib

MUST_CONFIGURE=		gnu
CONFIGURE_ARGS=		"--with-x"

BUILD_TARGET=		"without_doc"

INSTALL_REQ_TOOLCHAIN=	yes
SOVERSION=		5.1.2

post-install:
	${STRIP_CMD} ${STAGEDIR}${PREFIX}/lib/*.so

[FILE:707:descriptions/desc.primary]
T1lib is an open source library developed by Rainer Menzner and is 
distributed under the GNU General Public Library License. t1lib is written 
in the C programming language allowing a programmer to generate/rasterize 
bitmaps from Adobe (TM) Type 1 fonts quite easily. t1lib is based on the 
code of the X11 rasterizer which was donated by IBM to the X11 project.

The bitmaps created by t1lib are returned in a data structure with type 
GLYPH. This special GLYPH-type is also used in the X11 window system to 
describe character bitmaps. It contains the bitmap data as well as some 
metric information. But t1lib is in itself entirely independent of the 
X11-system or any other graphical user interface.


[FILE:65:descriptions/desc.x11]
These are the X11-related components of the t1lib-standard port.


[FILE:97:distinfo]
821328b5054f7890a0d0cd2f52825270705df3641dbd476d58d17e56ed957b59      1872534 t1lib-5.1.2.tar.gz


[FILE:183:manifests/plist.primary]
bin/type1afm
include/t1lib.h
lib/
 libt1.a
 libt1.so
 libt1.so.%%SOMAJOR%%
 libt1.so.%%SOVERSION%%
 libt1x.so
 libt1x.so.%%SOMAJOR%%
 libt1x.so.%%SOVERSION%%
share/t1lib/t1lib.config


[FILE:41:manifests/plist.x11]
bin/xglyph
include/t1libx.h
lib/libt1x.a


[FILE:30:manifests/plist.docs]
share/t1lib/doc/t1lib_doc.pdf


[FILE:762:patches/patch-lib_t1lib_parseAFM.c]
--- lib/t1lib/parseAFM.c.orig	2007-12-23 16:49:42.000000000 +0100
+++ lib/t1lib/parseAFM.c	2019-06-06 15:53:38.250925000 +0200
@@ -199,7 +199,7 @@
     idx = 0;
     
     while (ch != EOF && ch != ' ' && ch != CR  && ch != LF &&
-	   ch != CTRL_Z && ch != '\t' && ch != ':' && ch != ';'){
+	   ch != CTRL_Z && ch != '\t' && ch != ':' && ch != ';' && idx < (MAX_NAME - 1)){
       ident[idx++] = ch;
       ch = fgetc(stream);
     } /* while */
@@ -235,7 +235,7 @@
     while ((ch = fgetc(stream)) == ' ' || ch == '\t' ); 
     
     idx = 0;
-    while (ch != EOF && ch != CR  && ch != LF && ch != CTRL_Z) 
+    while (ch != EOF && ch != CR  && ch != LF && ch != CTRL_Z && idx < (MAX_NAME - 1)) 
     {
         ident[idx++] = ch;
         ch = fgetc(stream);


[FILE:709:patches/patch-lib_type1_lines.c]
--- lib/type1/lines.c.orig	2007-12-23 16:49:42.000000000 +0100
+++ lib/type1/lines.c	2019-06-06 15:25:33.521481000 +0200
@@ -67,6 +67,10 @@
 None.
 */
  
+#define  BITS         (sizeof(LONG)*8)
+#define  HIGHTEST(p)  (((p)>>(BITS-2)) != 0)  /* includes sign bit */
+#define  TOOBIG(xy)   ((xy < 0) ? HIGHTEST(-xy) : HIGHTEST(xy))
+
 /*
 :h2.StepLine() - Produces Run Ends for a Line After Checks
  
@@ -84,6 +88,9 @@
        IfTrace4((LineDebug > 0), ".....StepLine: (%d,%d) to (%d,%d)\n",
                                             x1, y1, x2, y2);
  
+      if (TOOBIG(x1) || TOOBIG(x2) || TOOBIG(y1) || TOOBIG(y2))
+              abort("Lines this big not supported", 49);
+
        dy = y2 - y1;
  
 /*


[FILE:624:patches/patch-lib_type1_objects.c]
--- lib/type1/objects.c.orig	2007-12-23 16:49:42.000000000 +0100
+++ lib/type1/objects.c	2019-06-06 15:23:45.191036000 +0200
@@ -1137,12 +1137,13 @@
     "Context:  out of them", /* 46 */
     "MatrixInvert:  can't", /* 47 */
     "xiStub called", /* 48 */
-    "Illegal access type1 abort() message" /* 49 */
+    "Lines this big not supported", /* 49 */
+    "Illegal access type1 abort() message" /* 50 */
   };
 
-  /* no is valid from 1 to 48 */
-  if ( (number<1)||(number>48))
-    number=49;
+  /* no is valid from 1 to 49 */
+  if ( (number<1)||(number>49))
+    number=50;
   return( err_msgs[number-1]);
     
 }


[FILE:3110:patches/patch-lib_type1_type1.c]
--- lib/type1/type1.c.orig	2007-12-23 16:49:42.000000000 +0100
+++ lib/type1/type1.c	2019-06-06 15:20:11.590036000 +0200
@@ -1012,6 +1012,7 @@
   double nextdtana = 0.0;   /* tangent of post-delta against horizontal line */ 
   double nextdtanb = 0.0;   /* tangent of post-delta against vertical line */ 
   
+  if (ppoints == NULL || numppoints < 1) Error0v("FindStems: No previous point!\n");
  
   /* setup default hinted position */
   ppoints[numppoints-1].ax     = ppoints[numppoints-1].x;
@@ -1289,7 +1290,7 @@
 static int DoRead(CodeP)
   int *CodeP;
 {
-  if (strindex >= CharStringP->len) return(FALSE); /* end of string */
+  if (!CharStringP || strindex >= CharStringP->len) return(FALSE); /* end of string */
   /* We handle the non-documented Adobe convention to use lenIV=-1 to
      suppress charstring encryption. */
   if (blues->lenIV==-1) {
@@ -1700,6 +1701,7 @@
   long pindex = 0;
   
   /* compute hinting for previous segment! */
+  if (ppoints == NULL || numppoints < 2 ) Error0i("RLineTo: No previous point!\n");
   FindStems( currx, curry, currx-ppoints[numppoints-2].x, curry-ppoints[numppoints-2].y, dx, dy);
 
   /* Allocate a new path point and pre-setup data */
@@ -1728,6 +1730,7 @@
   long pindex = 0;
   
   /* compute hinting for previous point! */
+  if (ppoints == NULL || numppoints < 2) Error0i("RRCurveTo: No previous point!\n");
   FindStems( currx, curry, currx-ppoints[numppoints-2].x, curry-ppoints[numppoints-2].y, dx1, dy1);
 
   /* Allocate three new path points and pre-setup data */
@@ -1786,7 +1789,9 @@
   long tmpind;
   double deltax = 0.0;
   double deltay = 0.0;
-  
+ 
+  if (ppoints == NULL || numppoints < 1) Error0i("DoClosePath: No previous point!");
+ 
   /* If this ClosePath command together with the starting point of this
      path completes to a segment aligned to a stem, we would miss
      hinting for this point. --> Check and explicitly care for this! */
@@ -1801,6 +1806,7 @@
     deltax = ppoints[i].x - ppoints[numppoints-1].x;
     deltay = ppoints[i].y - ppoints[numppoints-1].y;
 
+    if (ppoints == NULL || numppoints <= i + 1) Error0i("DoClosePath: No previous point!");
     /* save nummppoints and reset to move point */
     tmpind = numppoints;
     numppoints = i + 1;
@@ -1903,6 +1909,7 @@
     FindStems( currx, curry, 0, 0, dx, dy);
   }
   else {
+    if (ppoints == NULL || numppoints < 2) Error0i("RMoveTo: No previous point!\n");
     FindStems( currx, curry, ppoints[numppoints-2].x, ppoints[numppoints-2].y, dx, dy);
   }
   
@@ -2152,6 +2159,7 @@
   DOUBLE cx, cy;
   DOUBLE ex, ey;
 
+  if (ppoints == NULL || numppoints < 8) Error0v("FlxProc: No previous point!");
 
   /* Our PPOINT list now contains 7 moveto commands which
      are about to be consumed by the Flex mechanism. --> Remove these
@@ -2321,6 +2329,7 @@
 /*   Returns currentpoint on stack          */
 static void FlxProc2()
 {
+  if (ppoints == NULL || numppoints < 1) Error0v("FlxProc2: No previous point!");
   /* Push CurrentPoint on fake PostScript stack */
   PSFakePush( ppoints[numppoints-1].x);
   PSFakePush( ppoints[numppoints-1].y);

