# Buildsheet autogenerated by ravenadm tool -- Do not edit.

NAMEBASE=		python-rq
VERSION=		2.6.1
KEYWORDS=		python
VARIANTS=		v13 v14
SDESC[v13]=		Library for procesing background jobs (3.13)
SDESC[v14]=		Library for procesing background jobs (3.14)
HOMEPAGE=		https://python-rq.org/
CONTACT=		Python_Automaton[python@ironwolf.systems]

DOWNLOAD_GROUPS=	main
SITES[main]=		PYPIWHL/4b/cc/919ccbf0c9b4f8b0f68c3f53e6d8e1e94af4d74cee4e6d3cb2e81f7d0da9
DISTFILE[1]=		rq-2.6.1-py3-none-any.whl:main
DIST_SUBDIR=		python-src
DF_INDEX=		1
SPKGS[v13]=		single
SPKGS[v14]=		single

OPTIONS_AVAILABLE=	PY313 PY314
OPTIONS_STANDARD=	none
VOPTS[v13]=		PY313=ON PY314=OFF
VOPTS[v14]=		PY313=OFF PY314=ON

DISTNAME=		rq-2.6.1.dist-info

GENERATED=		yes

[PY313].RUN_DEPENDS_ON=			python-click:single:v13
					python-croniter:single:v13
					python-redis:single:v13
[PY313].USES_ON=			python:v13,wheel

[PY314].RUN_DEPENDS_ON=			python-click:single:v14
					python-croniter:single:v14
					python-redis:single:v14
[PY314].USES_ON=			python:v14,wheel

[FILE:2524:descriptions/desc.single]
RQ (_Redis Queue_) is a simple Python library for queueing jobs and
processing
them in the background with workers. It is backed by Redis or Valkey and is
designed
to have a low barrier to entry while scaling incredibly well for large
applications.
It can be integrated into your web stack easily, making it suitable for
projects
of any size—from simple applications to high-volume enterprise systems.

RQ requires Redis >= 5 or Valkey >= 7.2.

[Build status]
[PyPI]
[Coverage]
[![Code style: Ruff]](https://github.com/astral-sh/ruff)

Full documentation can be found [here][d].

## Support RQ

If you find RQ useful, please consider supporting this project via
[Tidelift].

## Getting started

First, run a Redis server, of course:

```console
$ redis-server
```

To put jobs on queues, you don't have to do anything special, just define
your typically lengthy or blocking function:

```python
import requests

def count_words_at_url(url):
    """Just an example function that's called async."""
    resp = requests.get(url)
    return len(resp.text.split())
```

Then, create an RQ queue:

```python
from redis import Redis
from rq import Queue

queue = Queue(connection=Redis())
```

And enqueue the function call:

```python
from my_module import count_words_at_url
job = queue.enqueue(count_words_at_url, 'https://stamps.id')
```

## Job Prioritization

By default, jobs are added to the end of a single queue. RQ offers two ways
to give certain jobs higher priority:

#### 1. Enqueue at the front

You can enqueue a job at the front of its queue so it’s picked up before
other jobs:

```python
job = queue.enqueue(count_words_at_url, 'https://stamps.id', at_front=True)
```

#### 2. Use multiple queues
You can create multiple queues and enqueue jobs into different queues based
on their priority:

```python
from rq import Queue
high_priority_queue = Queue('high', connection=Redis())
low_priority_queue = Queue('low', connection=Redis())

# This job will be picked up before jobs in the low priority queue
# even if it was enqueued later
high_priority_queue.enqueue(urgent_task)
low_priority_queue.enqueue(non_urgent_task)
```

Then start workers with a prioritized queue list:
```console
$ rq worker high low
```
This command starts a worker that listens to both `high` and `low` queues.
The worker will process
jobs from the `high` queue first, followed by the `low` queue. You can also
run different workers
for different queues, allowing you to scale your workers based on the
number of jobs in each queue.



[FILE:115:distinfo]
5cc88d3bb5263a407fb2ba2dc6fe8dc710dae94b6f74396cdfe1b32beded9408       112578 python-src/rq-2.6.1-py3-none-any.whl

