# Buildsheet autogenerated by ravenadm tool -- Do not edit.

NAMEBASE=		webrtc-audio-processing
VERSION=		2.1
KEYWORDS=		audio
VARIANTS=		std
SDESC[std]=		AudioProcessing module from the WebRTC project
HOMEPAGE=		https://freedesktop.org/software/pulseaudio/webrtc-audio-processing/
CONTACT=		nobody

DOWNLOAD_GROUPS=	main
SITES[main]=		https://freedesktop.org/software/pulseaudio/webrtc-audio-processing/
DISTFILE[1]=		webrtc-audio-processing-2.1.tar.xz:main
DF_INDEX=		1
SPKGS[std]=		set
			primary
			dev

OPTIONS_AVAILABLE=	none
OPTIONS_STANDARD=	none

BUILD_DEPENDS=		abseil-cpp:dev:std
BUILDRUN_DEPENDS=	abseil-cpp:primary:std

USES=			meson pkgconfig

LICENSE=		BSD3CLAUSE:primary
LICENSE_FILE=		BSD3CLAUSE:{{WRKSRC}}/COPYING
LICENSE_SCHEME=		solo

FPC_EQUIVALENT=		audio/webrtc-audio-processing2

[FILE:293:descriptions/desc.primary]
Audio processing routines extracted from WebRTC project into a
standalone library. It provides the following features:

- Acoustic echo cancellation
- Acoustic echo control for mobile
- Automatic gain control
- High-pass filter
- Level estimator
- Noise suppression
- Voice activity detection


[FILE:113:distinfo]
ae9302824b2038d394f10213cab05312c564a038434269f11dbf68f511f9f9fe       604192 webrtc-audio-processing-2.1.tar.xz


[FILE:38:manifests/plist.primary]
lib/libwebrtc-audio-processing-2.so.1


[FILE:1057:manifests/plist.dev]
include/webrtc-audio-processing-2/api/
 array_view.h
 location.h
 ref_count.h
 scoped_refptr.h
include/webrtc-audio-processing-2/api/audio/
 audio_processing.h
 audio_processing_statistics.h
 echo_canceller3_config.h
 echo_control.h
include/webrtc-audio-processing-2/api/task_queue/task_queue_base.h
include/webrtc-audio-processing-2/api/units/time_delta.h
include/webrtc-audio-processing-2/modules/audio_processing/include/
 audio_processing.h
 audio_processing_statistics.h
include/webrtc-audio-processing-2/rtc_base/
 arraysize.h
 checks.h
 ref_count.h
 thread_annotations.h
 type_traits.h
include/webrtc-audio-processing-2/rtc_base/numerics/
 divide_round.h
 safe_compare.h
 safe_conversions.h
 safe_conversions_impl.h
include/webrtc-audio-processing-2/rtc_base/system/
 file_wrapper.h
 inline.h
 rtc_export.h
include/webrtc-audio-processing-2/rtc_base/units/unit_base.h
include/webrtc-audio-processing-2/system_wrappers/include/
 cpu_features_wrapper.h
 metrics.h
 sleep.h
lib/libwebrtc-audio-processing-2.so
lib/pkgconfig/webrtc-audio-processing-2.pc


[FILE:11659:patches/patch-fix-build-with-newer-absl]
From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Reilly Brogan <reilly@reillybrogan.com>
Date: Tue, 19 Aug 2025 14:47:03 -0500
Subject: [PATCH] Fix build with abseil-cpp 202508

---
 webrtc/api/audio/audio_processing.h           | 12 +++++++++
 webrtc/api/make_ref_counted.h                 | 13 ++++++++++
 webrtc/api/scoped_refptr.h                    | 15 +++++++++++
 .../aec_dump/aec_dump_factory.h               | 15 +++++++++++
 .../aec_dump/null_aec_dump_factory.cc         | 25 +++++++++++++++++++
 .../audio_processing/audio_processing_impl.cc |  9 +++++++
 .../audio_processing/audio_processing_impl.h  |  9 +++++++
 7 files changed, 98 insertions(+)

--- webrtc/api/audio/audio_processing.h.orig
+++ webrtc/api/audio/audio_processing.h
@@ -28,6 +28,7 @@
 #include <string>
 #include <utility>
 
+#include "absl/base/config.h"
 #include "absl/base/nullability.h"
 #include "absl/strings/string_view.h"
 #include "api/array_view.h"
@@ -632,14 +633,25 @@ class RTC_EXPORT AudioProcessing : public RefCountInterface {
   // return value of true indicates that the file has been
   // sucessfully opened, while a value of false indicates that
   // opening the file failed.
+#if defined(ABSL_LTS_RELEASE_VERSION) && ABSL_LTS_RELEASE_VERSION < 20250512
   virtual bool CreateAndAttachAecDump(
       absl::string_view file_name,
       int64_t max_log_size_bytes,
       absl::Nonnull<TaskQueueBase*> worker_queue) = 0;
   virtual bool CreateAndAttachAecDump(
       absl::Nonnull<FILE*> handle,
       int64_t max_log_size_bytes,
       absl::Nonnull<TaskQueueBase*> worker_queue) = 0;
+#else
+  virtual bool CreateAndAttachAecDump(absl::string_view file_name,
+                                      int64_t max_log_size_bytes,
+                                      TaskQueueBase* absl_nonnull
+                                          worker_queue) = 0;
+  virtual bool CreateAndAttachAecDump(FILE* absl_nonnull handle,
+                                      int64_t max_log_size_bytes,
+                                      TaskQueueBase* absl_nonnull
+                                          worker_queue) = 0;
+#endif
 
   // TODO(webrtc:5298) Deprecated variant.
   // Attaches provided webrtc::AecDump for recording debugging
--- webrtc/api/make_ref_counted.h
+++ webrtc/api/make_ref_counted.h
@@ -13,6 +13,7 @@
 #include <type_traits>
 #include <utility>
 
+#include "absl/base/config.h"
 #include "absl/base/nullability.h"
 #include "api/ref_count.h"
 #include "api/scoped_refptr.h"
@@ -86,34 +87,46 @@ template <
     typename std::enable_if<std::is_convertible_v<T*, RefCountInterface*> &&
                                 std::is_abstract_v<T>,
                             T>::type* = nullptr>
+#if defined(ABSL_LTS_RELEASE_VERSION) && ABSL_LTS_RELEASE_VERSION < 20250512
 absl::Nonnull<scoped_refptr<T>> make_ref_counted(Args&&... args) {
+#else
+absl_nonnull scoped_refptr<T> make_ref_counted(Args&&... args) {
+#endif
   return scoped_refptr<T>(new RefCountedObject<T>(std::forward<Args>(args)...));
 }
 
 // `make_ref_counted` for complete classes that are not convertible to
 // RefCountInterface and already carry a ref count.
 template <
     typename T,
     typename... Args,
     typename std::enable_if<
         !std::is_convertible_v<T*, RefCountInterface*> &&
             webrtc_make_ref_counted_internal::HasAddRefAndRelease<T>::value,
         T>::type* = nullptr>
+#if defined(ABSL_LTS_RELEASE_VERSION) && ABSL_LTS_RELEASE_VERSION < 20250512
 absl::Nonnull<scoped_refptr<T>> make_ref_counted(Args&&... args) {
+#else
+absl_nonnull scoped_refptr<T> make_ref_counted(Args&&... args) {
+#endif
   return scoped_refptr<T>(new T(std::forward<Args>(args)...));
 }
 
 // `make_ref_counted` for complete classes that are not convertible to
 // RefCountInterface and have no ref count of their own.
 template <
     typename T,
     typename... Args,
     typename std::enable_if<
         !std::is_convertible_v<T*, RefCountInterface*> &&
             !webrtc_make_ref_counted_internal::HasAddRefAndRelease<T>::value,
 
         T>::type* = nullptr>
+#if defined(ABSL_LTS_RELEASE_VERSION) && ABSL_LTS_RELEASE_VERSION < 20250512
 absl::Nonnull<scoped_refptr<FinalRefCountedObject<T>>> make_ref_counted(
+#else
+absl_nonnull scoped_refptr<FinalRefCountedObject<T>> make_ref_counted(
+#endif
     Args&&... args) {
   return scoped_refptr<FinalRefCountedObject<T>>(
       new FinalRefCountedObject<T>(std::forward<Args>(args)...));
--- webrtc/api/scoped_refptr.h.orig
+++ webrtc/api/scoped_refptr.h
@@ -66,20 +66,27 @@
 #include <cstddef>
 #include <utility>
 
+#include "absl/base/config.h"
 #include "absl/base/nullability.h"
 
 namespace webrtc {
 
 template <class T>
 class ABSL_NULLABILITY_COMPATIBLE scoped_refptr {
  public:
+#if defined(ABSL_LTS_RELEASE_VERSION) && ABSL_LTS_RELEASE_VERSION < 20250512
   using absl_nullability_compatible = void;
+#endif
   using element_type = T;
 
   scoped_refptr() : ptr_(nullptr) {}
   scoped_refptr(std::nullptr_t) : ptr_(nullptr) {}  // NOLINT(runtime/explicit)
 
+#if defined(ABSL_LTS_RELEASE_VERSION) && ABSL_LTS_RELEASE_VERSION < 20250512
   explicit scoped_refptr(absl::Nullable<T*> p) : ptr_(p) {
+#else
+  explicit scoped_refptr(T* absl_nullable p) : ptr_(p) {
+#endif
     if (ptr_)
       ptr_->AddRef();
   }
@@ -122,7 +129,11 @@ class ABSL_NULLABILITY_COMPATIBLE scoped_refptr {
     return retVal;
   }
 
+#if defined(ABSL_LTS_RELEASE_VERSION) && ABSL_LTS_RELEASE_VERSION < 20250512
   scoped_refptr<T>& operator=(absl::Nullable<T*> p) {
+#else
+  scoped_refptr<T>& operator=(T* absl_nullable p) {
+#endif
     // AddRef first so that self assignment should work
     if (p)
       p->AddRef();
@@ -152,7 +163,11 @@ class ABSL_NULLABILITY_COMPATIBLE scoped_refptr {
     return *this;
   }
 
+#if defined(ABSL_LTS_RELEASE_VERSION) && ABSL_LTS_RELEASE_VERSION < 20250512
   void swap(absl::Nonnull<T**> pp) noexcept {
+#else
+  void swap(T** absl_nonnull pp) noexcept {
+#endif
     T* p = ptr_;
     ptr_ = *pp;
     *pp = p;
--- webrtc/modules/audio_processing/aec_dump/aec_dump_factory.h.orig
+++ webrtc/modules/audio_processing/aec_dump/aec_dump_factory.h
@@ -29,18 +29,33 @@ class RTC_EXPORT AecDumpFactory {
   // The AecDump takes responsibility for `handle` and closes it in the
   // destructor. A non-null return value indicates that the file has been
   // sucessfully opened.
+#if defined(ABSL_LTS_RELEASE_VERSION) && ABSL_LTS_RELEASE_VERSION < 20250512
   static absl::Nullable<std::unique_ptr<AecDump>> Create(
       FileWrapper file,
       int64_t max_log_size_bytes,
       absl::Nonnull<TaskQueueBase*> worker_queue);
   static absl::Nullable<std::unique_ptr<AecDump>> Create(
       absl::string_view file_name,
       int64_t max_log_size_bytes,
       absl::Nonnull<TaskQueueBase*> worker_queue);
   static absl::Nullable<std::unique_ptr<AecDump>> Create(
       absl::Nonnull<FILE*> handle,
       int64_t max_log_size_bytes,
       absl::Nonnull<TaskQueueBase*> worker_queue);
+#else
+  static absl_nullable std::unique_ptr<AecDump> Create(
+      FileWrapper file,
+      int64_t max_log_size_bytes,
+      TaskQueueBase* absl_nonnull worker_queue);
+  static absl_nullable std::unique_ptr<AecDump> Create(
+      absl::string_view file_name,
+      int64_t max_log_size_bytes,
+      TaskQueueBase* absl_nonnull worker_queue);
+  static absl_nullable std::unique_ptr<AecDump> Create(
+      FILE* absl_nonnull handle,
+      int64_t max_log_size_bytes,
+      TaskQueueBase* absl_nonnull worker_queue);
+#endif
 };
 
 }  // namespace webrtc
--- webrtc/modules/audio_processing/aec_dump/null_aec_dump_factory.cc.orig
+++ webrtc/modules/audio_processing/aec_dump/null_aec_dump_factory.cc
@@ -16,24 +16,49 @@
 
 namespace webrtc {
 
+#if defined(ABSL_LTS_RELEASE_VERSION) && ABSL_LTS_RELEASE_VERSION < 20250512
 absl::Nullable<std::unique_ptr<AecDump>> AecDumpFactory::Create(
     FileWrapper file,
     int64_t max_log_size_bytes,
     absl::Nonnull<TaskQueueBase*> worker_queue) {
   return nullptr;
 }
 
 absl::Nullable<std::unique_ptr<AecDump>> AecDumpFactory::Create(
     absl::string_view file_name,
     int64_t max_log_size_bytes,
     absl::Nonnull<TaskQueueBase*> worker_queue) {
   return nullptr;
 }
 
 absl::Nullable<std::unique_ptr<AecDump>> AecDumpFactory::Create(
     absl::Nonnull<FILE*> handle,
     int64_t max_log_size_bytes,
     absl::Nonnull<TaskQueueBase*> worker_queue) {
   return nullptr;
 }
 }  // namespace webrtc
+#else
+absl_nullable std::unique_ptr<AecDump> AecDumpFactory::Create(
+    FileWrapper file,
+    int64_t max_log_size_bytes,
+    TaskQueueBase* absl_nonnull worker_queue) {
+  return nullptr;
+}
+
+absl_nullable std::unique_ptr<AecDump> AecDumpFactory::Create(
+    absl::string_view file_name,
+    int64_t max_log_size_bytes,
+    TaskQueueBase* absl_nonnull worker_queue) {
+  return nullptr;
+}
+
+absl_nullable std::unique_ptr<AecDump> AecDumpFactory::Create(
+    FILE* absl_nonnull handle,
+    int64_t max_log_size_bytes,
+    TaskQueueBase* absl_nonnull worker_queue) {
+  return nullptr;
+}
+}  // namespace webrtc
+
+#endif
--- webrtc/modules/audio_processing/audio_processing_impl.cc.orig
+++ webrtc/modules/audio_processing/audio_processing_impl.cc
@@ -19,6 +19,7 @@
 #include <type_traits>
 #include <utility>
 
+#include "absl/base/config.h"
 #include "absl/base/nullability.h"
 #include "absl/strings/match.h"
 #include "absl/strings/string_view.h"
@@ -1787,21 +1788,29 @@ void AudioProcessingImpl::UpdateRecommendedInputVolumeLocked() {
 bool AudioProcessingImpl::CreateAndAttachAecDump(
     absl::string_view file_name,
     int64_t max_log_size_bytes,
+#if defined(ABSL_LTS_RELEASE_VERSION) && ABSL_LTS_RELEASE_VERSION < 20250512
     absl::Nonnull<TaskQueueBase*> worker_queue) {
+#else
+    TaskQueueBase* absl_nonnull worker_queue) {
+#endif
   std::unique_ptr<AecDump> aec_dump =
       AecDumpFactory::Create(file_name, max_log_size_bytes, worker_queue);
   if (!aec_dump) {
     return false;
   }
 
   AttachAecDump(std::move(aec_dump));
   return true;
 }
 
 bool AudioProcessingImpl::CreateAndAttachAecDump(
     FILE* handle,
     int64_t max_log_size_bytes,
+#if defined(ABSL_LTS_RELEASE_VERSION) && ABSL_LTS_RELEASE_VERSION < 20250512
     absl::Nonnull<TaskQueueBase*> worker_queue) {
+#else
+    TaskQueueBase* absl_nonnull worker_queue) {
+#endif
   std::unique_ptr<AecDump> aec_dump =
       AecDumpFactory::Create(handle, max_log_size_bytes, worker_queue);
   if (!aec_dump) {
--- webrtc/modules/audio_processing/audio_processing_impl.h.orig
+++ webrtc/modules/audio_processing/audio_processing_impl.h
@@ -20,6 +20,7 @@
 #include <string>
 #include <vector>
 
+#include "absl/base/config.h"
 #include "absl/base/nullability.h"
 #include "absl/strings/string_view.h"
 #include "api/array_view.h"
@@ -74,11 +75,19 @@ class AudioProcessingImpl : public AudioProcessing {
   bool CreateAndAttachAecDump(
       absl::string_view file_name,
       int64_t max_log_size_bytes,
+#if defined(ABSL_LTS_RELEASE_VERSION) && ABSL_LTS_RELEASE_VERSION < 20250512
       absl::Nonnull<TaskQueueBase*> worker_queue) override;
+#else
+      TaskQueueBase* absl_nonnull worker_queue) override;
+#endif
   bool CreateAndAttachAecDump(
       FILE* handle,
       int64_t max_log_size_bytes,
+#if defined(ABSL_LTS_RELEASE_VERSION) && ABSL_LTS_RELEASE_VERSION < 20250512
       absl::Nonnull<TaskQueueBase*> worker_queue) override;
+#else
+      TaskQueueBase* absl_nonnull worker_queue) override;
+#endif
   // TODO(webrtc:5298) Deprecated variant.
   void AttachAecDump(std::unique_ptr<AecDump> aec_dump) override;
   void DetachAecDump() override;


[FILE:401:patches/patch-meson.build]
--- meson.build.orig	2025-01-22 22:32:18 UTC
+++ meson.build
@@ -90,6 +90,7 @@ elif host_system == 'linux'
   os_deps += [dependency('threads')]
   have_posix = true
 elif (host_system == 'dragonfly' or host_system == 'freebsd' or
+      host_system == 'midnightbsd' or
       host_system == 'netbsd' or host_system == 'openbsd')
   os_cflags += ['-DWEBRTC_BSD']
   os_deps += [dependency('threads')]

