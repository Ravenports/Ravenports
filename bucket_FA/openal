# Buildsheet autogenerated by ravenadm tool -- Do not edit.

NAMEBASE=		openal
VERSION=		1.19.0
KEYWORDS=		audio
VARIANTS=		standard
SDESC[standard]=	Cross-platform 3D audio API
HOMEPAGE=		http://kcat.strangesoft.net/openal.html
CONTACT=		Leonid_Bobrov[mazocomp@disroot.org]

DOWNLOAD_GROUPS=	main
SITES[main]=		GITHUB/kcat:openal-soft:openal-soft-1.19.0
DISTFILE[1]=		generated:main
DF_INDEX=		1
SPKGS[standard]=	single

OPTIONS_AVAILABLE=	none
OPTIONS_STANDARD=	none

BUILDRUN_DEPENDS=	sndio:single:standard

USES=			cclibs:single cmake:outsource

LICENSE=		LGPL20+:single
LICENSE_TERMS=		single:{{WRKDIR}}/TERMS
LICENSE_FILE=		LGPL20+:{{WRKSRC}}/COPYING
LICENSE_AWK=		TERMS:"^\#include"
LICENSE_SOURCE=		TERMS:{{WRKSRC}}/Alc/ALc.c
LICENSE_SCHEME=		solo

CMAKE_BUILD_TYPE=	Release
FPC_EQUIVALENT=		audio/openal-soft

SOVERSION=		1.19.0

CMAKE_ARGS=		-DALSOFT_DLOPEN=Off
			-DALSOFT_UTILS=On
			-DALSOFT_EXAMPLES=Off
			-DALSOFT_REQUIRE_SNDIO=On
			-DALSOFT_BACKEND_WAVE=Off
			-DALSOFT_CPUEXT_SSE=Off
			-DALSOFT_CPUEXT_SSE2=Off
			-DALSOFT_CPUEXT_SSE3=Off
			-DALSOFT_CPUEXT_SSE4_1=Off
			-DCMAKE_DISABLE_FIND_PACKAGE_ALSA:Bool=Yes
			-DCMAKE_DISABLE_FIND_PACKAGE_AudioIO:Bool=Yes
			-DCMAKE_DISABLE_FIND_PACKAGE_JACK:Bool=Yes
			-DCMAKE_DISABLE_FIND_PACKAGE_OSS:Bool=Yes
			-DCMAKE_DISABLE_FIND_PACKAGE_PortAudio:Bool=Yes
			-DCMAKE_DISABLE_FIND_PACKAGE_PulseAudio:Bool=Yes
			-DCMAKE_DISABLE_FIND_PACKAGE_QSA:Bool=Yes
			-DALSOFT_NO_CONFIG_UTIL=On

post-patch:
	${REINPLACE_CMD} 's|/etc/openal|${PREFIX}/etc/openal|' \
	${WRKSRC}/Alc/alconfig.c

[FILE:389:descriptions/desc.single]
OpenAL provides capabilities for playing audio in a virtual 3D
environment.  Distance attenuation, doppler shift, and directional
sound emitters are among the features handled by the API.  More
advanced effects, including air absorption, low-pass filters, and
reverb, are available through the EFX extension.  It also facilitates
streaming audio, multi-channel buffers, and audio capture.


[FILE:121:distinfo]
bb26bc1d40010f059b3cffd336a09bf07f428b1115f00869ff995eb094a382b9       678348 kcat-openal-soft-openal-soft-1.19.0.tar.gz


[FILE:497:manifests/plist.single]
bin/
 altonegen
 makehrtf
 openal-info
include/AL/
 al.h
 alc.h
 alext.h
 efx-creative.h
 efx-presets.h
 efx.h
lib/
 libopenal.so
 libopenal.so.%%SOMAJOR%%
 libopenal.so.%%SOVERSION%%
lib/cmake/OpenAL/
 OpenALConfig-release.cmake
 OpenALConfig.cmake
lib/pkgconfig/openal.pc
share/openal/alsoftrc.sample
share/openal/hrtf/
 default-44100.mhr
 default-48000.mhr
share/openal/presets/
 3D7.1.ambdec
 hexagon.ambdec
 itu5.1-nocenter.ambdec
 itu5.1.ambdec
 presets.txt
 rectangle.ambdec
 square.ambdec


[FILE:1645:patches/patch-Alc_ALc.c]
--- Alc/ALc.c.orig	2018-09-06 21:35:18 UTC
+++ Alc/ALc.c
@@ -79,7 +79,7 @@ static struct BackendInfo BackendList[]
     { "solaris", ALCsolarisBackendFactory_getFactory },
 #endif
 #ifdef HAVE_SNDIO
-    { "sndio", ALCsndioBackendFactory_getFactory },
+    { "sndio", SndioBackendFactory_getFactory },
 #endif
 #ifdef HAVE_OSS
     { "oss", ALCossBackendFactory_getFactory },
@@ -656,9 +656,9 @@ static const struct {
 
     DECL(AL_DEDICATED_GAIN),
 
-    DECL(AL_AUTOWAH_ATTACK_TIME),
-    DECL(AL_AUTOWAH_RELEASE_TIME),
-    DECL(AL_AUTOWAH_RESONANCE),
+    DECL(AL_AUTOWAH_ATTACK_TIME),
+    DECL(AL_AUTOWAH_RELEASE_TIME),
+    DECL(AL_AUTOWAH_RESONANCE),
     DECL(AL_AUTOWAH_PEAK_GAIN),
 
     DECL(AL_NUM_RESAMPLERS_SOFT),
@@ -1314,7 +1314,7 @@ static void ProbeDevices(al_string *list
     if(backendinfo->getFactory)
     {
         ALCbackendFactory *factory = backendinfo->getFactory();
-        V(factory,probe)(type);
+        V(factory,probe)(type, list);
     }
 
     UnlockLists();
@@ -1324,17 +1324,6 @@ static void ProbeAllDevicesList(void)
 static void ProbeCaptureDeviceList(void)
 { ProbeDevices(&alcCaptureDeviceList, &CaptureBackend, CAPTURE_DEVICE_PROBE); }
 
-static void AppendDevice(const ALCchar *name, al_string *devnames)
-{
-    size_t len = strlen(name);
-    if(len > 0)
-        alstr_append_range(devnames, name, name+len+1);
-}
-void AppendAllDevicesList(const ALCchar *name)
-{ AppendDevice(name, &alcAllDevicesList); }
-void AppendCaptureDeviceList(const ALCchar *name)
-{ AppendDevice(name, &alcCaptureDeviceList); }
-
 
 /************************************************
  * Device format information


[FILE:1784:patches/patch-Alc_backends_alsa.c]
--- Alc/backends/alsa.c.orig	2018-09-06 21:35:18 UTC
+++ Alc/backends/alsa.c
@@ -1375,11 +1375,6 @@ static ClockLatency ALCcaptureAlsa_getCl
 }
 
 
-static inline void AppendAllDevicesList2(const DevMap *entry)
-{ AppendAllDevicesList(alstr_get_cstr(entry->name)); }
-static inline void AppendCaptureDeviceList2(const DevMap *entry)
-{ AppendCaptureDeviceList(alstr_get_cstr(entry->name)); }
-
 typedef struct ALCalsaBackendFactory {
     DERIVE_FROM_TYPE(ALCbackendFactory);
 } ALCalsaBackendFactory;
@@ -1417,19 +1412,25 @@ static ALCboolean ALCalsaBackendFactory_
     return ALC_FALSE;
 }
 
-static void ALCalsaBackendFactory_probe(ALCalsaBackendFactory* UNUSED(self), enum DevProbe type)
+static void ALCalsaBackendFactory_probe(ALCalsaBackendFactory* UNUSED(self), enum DevProbe type, al_string *outnames)
 {
     switch(type)
     {
+#define APPEND_OUTNAME(i) do {                                                \
+    if(!alstr_empty((i)->name))                                               \
+        alstr_append_range(outnames, VECTOR_BEGIN((i)->name),                 \
+                           VECTOR_END((i)->name)+1);                          \
+} while(0)
         case ALL_DEVICE_PROBE:
             probe_devices(SND_PCM_STREAM_PLAYBACK, &PlaybackDevices);
-            VECTOR_FOR_EACH(const DevMap, PlaybackDevices, AppendAllDevicesList2);
+            VECTOR_FOR_EACH(const DevMap, PlaybackDevices, APPEND_OUTNAME);
             break;
 
         case CAPTURE_DEVICE_PROBE:
             probe_devices(SND_PCM_STREAM_CAPTURE, &CaptureDevices);
-            VECTOR_FOR_EACH(const DevMap, CaptureDevices, AppendCaptureDeviceList2);
+            VECTOR_FOR_EACH(const DevMap, CaptureDevices, APPEND_OUTNAME);
             break;
+#undef APPEND_OUTNAME
     }
 }
 


[FILE:1868:patches/patch-Alc_backends_base.h]
--- Alc/backends/base.h.orig	2018-09-06 21:35:18 UTC
+++ Alc/backends/base.h
@@ -3,6 +3,7 @@
 
 #include "alMain.h"
 #include "threads.h"
+#include "alstring.h"
 
 
 #ifdef __cplusplus
@@ -115,7 +116,7 @@ struct ALCbackendFactoryVtable {
 
     ALCboolean (*const querySupport)(ALCbackendFactory *self, ALCbackend_Type type);
 
-    void (*const probe)(ALCbackendFactory *self, enum DevProbe type);
+    void (*const probe)(ALCbackendFactory *self, enum DevProbe type, al_string *outnames);
 
     ALCbackend* (*const createBackend)(ALCbackendFactory *self, ALCdevice *device, ALCbackend_Type type);
 };
@@ -124,7 +125,7 @@ struct ALCbackendFactoryVtable {
 DECLARE_THUNK(T, ALCbackendFactory, ALCboolean, init)                         \
 DECLARE_THUNK(T, ALCbackendFactory, void, deinit)                             \
 DECLARE_THUNK1(T, ALCbackendFactory, ALCboolean, querySupport, ALCbackend_Type) \
-DECLARE_THUNK1(T, ALCbackendFactory, void, probe, enum DevProbe)              \
+DECLARE_THUNK2(T, ALCbackendFactory, void, probe, enum DevProbe, al_string*)  \
 DECLARE_THUNK2(T, ALCbackendFactory, ALCbackend*, createBackend, ALCdevice*, ALCbackend_Type) \
                                                                               \
 static const struct ALCbackendFactoryVtable T##_ALCbackendFactory_vtable = {  \
@@ -142,7 +143,7 @@ ALCbackendFactory *ALCcoreAudioBackendFa
 ALCbackendFactory *ALCossBackendFactory_getFactory(void);
 ALCbackendFactory *ALCjackBackendFactory_getFactory(void);
 ALCbackendFactory *ALCsolarisBackendFactory_getFactory(void);
-ALCbackendFactory *ALCsndioBackendFactory_getFactory(void);
+ALCbackendFactory *SndioBackendFactory_getFactory(void);
 ALCbackendFactory *ALCqsaBackendFactory_getFactory(void);
 ALCbackendFactory *ALCwasapiBackendFactory_getFactory(void);
 ALCbackendFactory *ALCdsoundBackendFactory_getFactory(void);


[FILE:1511:patches/patch-Alc_backends_coreaudio.c]
--- Alc/backends/coreaudio.c.orig	2018-09-06 21:35:18 UTC
+++ Alc/backends/coreaudio.c
@@ -752,7 +752,7 @@ ALCbackendFactory *ALCcoreAudioBackendFa
 static ALCboolean ALCcoreAudioBackendFactory_init(ALCcoreAudioBackendFactory *self);
 static DECLARE_FORWARD(ALCcoreAudioBackendFactory, ALCbackendFactory, void, deinit)
 static ALCboolean ALCcoreAudioBackendFactory_querySupport(ALCcoreAudioBackendFactory *self, ALCbackend_Type type);
-static void ALCcoreAudioBackendFactory_probe(ALCcoreAudioBackendFactory *self, enum DevProbe type);
+static void ALCcoreAudioBackendFactory_probe(ALCcoreAudioBackendFactory *self, enum DevProbe type, al_string *outnames);
 static ALCbackend* ALCcoreAudioBackendFactory_createBackend(ALCcoreAudioBackendFactory *self, ALCdevice *device, ALCbackend_Type type);
 DEFINE_ALCBACKENDFACTORY_VTABLE(ALCcoreAudioBackendFactory);
 
@@ -776,15 +776,13 @@ static ALCboolean ALCcoreAudioBackendFac
     return ALC_FALSE;
 }
 
-static void ALCcoreAudioBackendFactory_probe(ALCcoreAudioBackendFactory* UNUSED(self), enum DevProbe type)
+static void ALCcoreAudioBackendFactory_probe(ALCcoreAudioBackendFactory* UNUSED(self), enum DevProbe type, al_string *outnames)
 {
     switch(type)
     {
         case ALL_DEVICE_PROBE:
-            AppendAllDevicesList(ca_device);
-            break;
         case CAPTURE_DEVICE_PROBE:
-            AppendCaptureDeviceList(ca_device);
+            alstr_append_range(outnames, ca_device, ca_device+sizeof(ca_device));
             break;
     }
 }


[FILE:3023:patches/patch-Alc_backends_dsound.c]
--- Alc/backends/dsound.c.orig	2018-09-06 21:35:18 UTC
+++ Alc/backends/dsound.c
@@ -969,11 +969,6 @@ done:
 }
 
 
-static inline void AppendAllDevicesList2(const DevMap *entry)
-{ AppendAllDevicesList(alstr_get_cstr(entry->name)); }
-static inline void AppendCaptureDeviceList2(const DevMap *entry)
-{ AppendCaptureDeviceList(alstr_get_cstr(entry->name)); }
-
 typedef struct ALCdsoundBackendFactory {
     DERIVE_FROM_TYPE(ALCbackendFactory);
 } ALCdsoundBackendFactory;
@@ -984,7 +979,7 @@ ALCbackendFactory *ALCdsoundBackendFacto
 static ALCboolean ALCdsoundBackendFactory_init(ALCdsoundBackendFactory *self);
 static void ALCdsoundBackendFactory_deinit(ALCdsoundBackendFactory *self);
 static ALCboolean ALCdsoundBackendFactory_querySupport(ALCdsoundBackendFactory *self, ALCbackend_Type type);
-static void ALCdsoundBackendFactory_probe(ALCdsoundBackendFactory *self, enum DevProbe type);
+static void ALCdsoundBackendFactory_probe(ALCdsoundBackendFactory *self, enum DevProbe type, al_string *outnames);
 static ALCbackend* ALCdsoundBackendFactory_createBackend(ALCdsoundBackendFactory *self, ALCdevice *device, ALCbackend_Type type);
 DEFINE_ALCBACKENDFACTORY_VTABLE(ALCdsoundBackendFactory);
 
@@ -1028,7 +1023,7 @@ static ALCboolean ALCdsoundBackendFactor
     return ALC_FALSE;
 }
 
-static void ALCdsoundBackendFactory_probe(ALCdsoundBackendFactory* UNUSED(self), enum DevProbe type)
+static void ALCdsoundBackendFactory_probe(ALCdsoundBackendFactory* UNUSED(self), enum DevProbe type, al_string *outnames)
 {
     HRESULT hr, hrcom;
 
@@ -1036,12 +1031,17 @@ static void ALCdsoundBackendFactory_prob
     hrcom = CoInitialize(NULL);
     switch(type)
     {
+#define APPEND_OUTNAME(e) do {                                                \
+    if(!alstr_empty((e)->name))                                               \
+        alstr_append_range(outnames, VECTOR_BEGIN((e)->name),                 \
+                           VECTOR_END((e)->name)+1);                          \
+} while(0)
         case ALL_DEVICE_PROBE:
             clear_devlist(&PlaybackDevices);
             hr = DirectSoundEnumerateW(DSoundEnumDevices, &PlaybackDevices);
             if(FAILED(hr))
                 ERR("Error enumerating DirectSound playback devices (0x%lx)!\n", hr);
-            VECTOR_FOR_EACH(const DevMap, PlaybackDevices, AppendAllDevicesList2);
+            VECTOR_FOR_EACH(const DevMap, PlaybackDevices, APPEND_OUTNAME);
             break;
 
         case CAPTURE_DEVICE_PROBE:
@@ -1049,8 +1049,9 @@ static void ALCdsoundBackendFactory_prob
             hr = DirectSoundCaptureEnumerateW(DSoundEnumDevices, &CaptureDevices);
             if(FAILED(hr))
                 ERR("Error enumerating DirectSound capture devices (0x%lx)!\n", hr);
-            VECTOR_FOR_EACH(const DevMap, CaptureDevices, AppendCaptureDeviceList2);
+            VECTOR_FOR_EACH(const DevMap, CaptureDevices, APPEND_OUTNAME);
             break;
+#undef APPEND_OUTNAME
     }
     if(SUCCEEDED(hrcom))
         CoUninitialize();


[FILE:636:patches/patch-Alc_backends_jack.c]
--- Alc/backends/jack.c.orig	2018-09-06 21:35:18 UTC
+++ Alc/backends/jack.c
@@ -571,12 +571,12 @@ static ALCboolean ALCjackBackendFactory_
     return ALC_FALSE;
 }
 
-static void ALCjackBackendFactory_probe(ALCjackBackendFactory* UNUSED(self), enum DevProbe type)
+static void ALCjackBackendFactory_probe(ALCjackBackendFactory* UNUSED(self), enum DevProbe type, al_string *outnames)
 {
     switch(type)
     {
         case ALL_DEVICE_PROBE:
-            AppendAllDevicesList(jackDevice);
+            alstr_append_range(outnames, jackDevice, jackDevice+sizeof(jackDevice));
             break;
 
         case CAPTURE_DEVICE_PROBE:


[FILE:1085:patches/patch-Alc_backends_loopback.c]
--- Alc/backends/loopback.c.orig	2018-09-06 21:35:18 UTC
+++ Alc/backends/loopback.c
@@ -87,7 +87,7 @@ ALCbackendFactory *ALCloopbackFactory_ge
 static ALCboolean ALCloopbackFactory_init(ALCloopbackFactory *self);
 static DECLARE_FORWARD(ALCloopbackFactory, ALCbackendFactory, void, deinit)
 static ALCboolean ALCloopbackFactory_querySupport(ALCloopbackFactory *self, ALCbackend_Type type);
-static void ALCloopbackFactory_probe(ALCloopbackFactory *self, enum DevProbe type);
+static void ALCloopbackFactory_probe(ALCloopbackFactory *self, enum DevProbe type, al_string *outnames);
 static ALCbackend* ALCloopbackFactory_createBackend(ALCloopbackFactory *self, ALCdevice *device, ALCbackend_Type type);
 DEFINE_ALCBACKENDFACTORY_VTABLE(ALCloopbackFactory);
 
@@ -110,7 +110,7 @@ static ALCboolean ALCloopbackFactory_que
     return ALC_FALSE;
 }
 
-static void ALCloopbackFactory_probe(ALCloopbackFactory* UNUSED(self), enum DevProbe UNUSED(type))
+static void ALCloopbackFactory_probe(ALCloopbackFactory* UNUSED(self), enum DevProbe UNUSED(type), al_string* UNUSED(outnames))
 {
 }
 


[FILE:1376:patches/patch-Alc_backends_null.c]
--- Alc/backends/null.c.orig	2018-09-06 21:35:18 UTC
+++ Alc/backends/null.c
@@ -171,7 +171,7 @@ ALCbackendFactory *ALCnullBackendFactory
 static ALCboolean ALCnullBackendFactory_init(ALCnullBackendFactory *self);
 static DECLARE_FORWARD(ALCnullBackendFactory, ALCbackendFactory, void, deinit)
 static ALCboolean ALCnullBackendFactory_querySupport(ALCnullBackendFactory *self, ALCbackend_Type type);
-static void ALCnullBackendFactory_probe(ALCnullBackendFactory *self, enum DevProbe type);
+static void ALCnullBackendFactory_probe(ALCnullBackendFactory *self, enum DevProbe type, al_string *outnames);
 static ALCbackend* ALCnullBackendFactory_createBackend(ALCnullBackendFactory *self, ALCdevice *device, ALCbackend_Type type);
 DEFINE_ALCBACKENDFACTORY_VTABLE(ALCnullBackendFactory);
 
@@ -195,14 +195,13 @@ static ALCboolean ALCnullBackendFactory_
     return ALC_FALSE;
 }
 
-static void ALCnullBackendFactory_probe(ALCnullBackendFactory* UNUSED(self), enum DevProbe type)
+static void ALCnullBackendFactory_probe(ALCnullBackendFactory* UNUSED(self), enum DevProbe type, al_string *outnames)
 {
     switch(type)
     {
         case ALL_DEVICE_PROBE:
-            AppendAllDevicesList(nullDevice);
-            break;
         case CAPTURE_DEVICE_PROBE:
+            alstr_append_range(outnames, nullDevice, nullDevice+sizeof(nullDevice));
             break;
     }
 }


[FILE:745:patches/patch-Alc_backends_opensl.c]
--- Alc/backends/opensl.c.orig	2018-09-06 21:35:18 UTC
+++ Alc/backends/opensl.c
@@ -1030,16 +1030,13 @@ static ALCboolean ALCopenslBackendFactor
     return ALC_FALSE;
 }
 
-static void ALCopenslBackendFactory_probe(ALCopenslBackendFactory* UNUSED(self), enum DevProbe type)
+static void ALCopenslBackendFactory_probe(ALCopenslBackendFactory* UNUSED(self), enum DevProbe type, al_string *outnames)
 {
     switch(type)
     {
         case ALL_DEVICE_PROBE:
-            AppendAllDevicesList(opensl_device);
-            break;
-
         case CAPTURE_DEVICE_PROBE:
-            AppendCaptureDeviceList(opensl_device);
+            alstr_append_range(outnames, opensl_device, opensl_device+sizeof(opensl_device));
             break;
     }
 }


[FILE:2315:patches/patch-Alc_backends_oss.c]
--- Alc/backends/oss.c.orig	2018-09-06 21:35:18 UTC
+++ Alc/backends/oss.c
@@ -786,7 +786,7 @@ ALCbackendFactory *ALCossBackendFactory_
 static ALCboolean ALCossBackendFactory_init(ALCossBackendFactory *self);
 static void ALCossBackendFactory_deinit(ALCossBackendFactory *self);
 static ALCboolean ALCossBackendFactory_querySupport(ALCossBackendFactory *self, ALCbackend_Type type);
-static void ALCossBackendFactory_probe(ALCossBackendFactory *self, enum DevProbe type);
+static void ALCossBackendFactory_probe(ALCossBackendFactory *self, enum DevProbe type, al_string *outnames);
 static ALCbackend* ALCossBackendFactory_createBackend(ALCossBackendFactory *self, ALCdevice *device, ALCbackend_Type type);
 DEFINE_ALCBACKENDFACTORY_VTABLE(ALCossBackendFactory);
 
@@ -820,40 +820,31 @@ ALCboolean ALCossBackendFactory_querySup
     return ALC_FALSE;
 }
 
-void ALCossBackendFactory_probe(ALCossBackendFactory* UNUSED(self), enum DevProbe type)
+void ALCossBackendFactory_probe(ALCossBackendFactory* UNUSED(self), enum DevProbe type, al_string *outnames)
 {
-    struct oss_device *cur;
+    struct oss_device *cur = NULL;
     switch(type)
     {
         case ALL_DEVICE_PROBE:
             ALCossListFree(&oss_playback);
             ALCossListPopulate(&oss_playback, DSP_CAP_OUTPUT);
             cur = &oss_playback;
-            while(cur != NULL)
-            {
-#ifdef HAVE_STAT
-                struct stat buf;
-                if(stat(cur->path, &buf) == 0)
-#endif
-                    AppendAllDevicesList(cur->handle);
-                cur = cur->next;
-            }
             break;
 
         case CAPTURE_DEVICE_PROBE:
             ALCossListFree(&oss_capture);
             ALCossListPopulate(&oss_capture, DSP_CAP_INPUT);
             cur = &oss_capture;
-            while(cur != NULL)
-            {
+            break;
+    }
+    while(cur != NULL)
+    {
 #ifdef HAVE_STAT
-                struct stat buf;
-                if(stat(cur->path, &buf) == 0)
+        struct stat buf;
+        if(stat(cur->path, &buf) == 0)
 #endif
-                    AppendCaptureDeviceList(cur->handle);
-                cur = cur->next;
-            }
-            break;
+            alstr_append_range(outnames, cur->handle, cur->handle+strlen(cur->handle)+1);
+        cur = cur->next;
     }
 }
 


[FILE:1425:patches/patch-Alc_backends_portaudio.c]
--- Alc/backends/portaudio.c.orig	2018-09-06 21:35:18 UTC
+++ Alc/backends/portaudio.c
@@ -484,9 +484,8 @@ typedef struct ALCportBackendFactory {
 static ALCboolean ALCportBackendFactory_init(ALCportBackendFactory *self);
 static void ALCportBackendFactory_deinit(ALCportBackendFactory *self);
 static ALCboolean ALCportBackendFactory_querySupport(ALCportBackendFactory *self, ALCbackend_Type type);
-static void ALCportBackendFactory_probe(ALCportBackendFactory *self, enum DevProbe type);
+static void ALCportBackendFactory_probe(ALCportBackendFactory *self, enum DevProbe type, al_string *outnames);
 static ALCbackend* ALCportBackendFactory_createBackend(ALCportBackendFactory *self, ALCdevice *device, ALCbackend_Type type);
-
 DEFINE_ALCBACKENDFACTORY_VTABLE(ALCportBackendFactory);
 
 
@@ -518,15 +517,13 @@ static ALCboolean ALCportBackendFactory_
     return ALC_FALSE;
 }
 
-static void ALCportBackendFactory_probe(ALCportBackendFactory* UNUSED(self), enum DevProbe type)
+static void ALCportBackendFactory_probe(ALCportBackendFactory* UNUSED(self), enum DevProbe type, al_string *outnames)
 {
     switch(type)
     {
         case ALL_DEVICE_PROBE:
-            AppendAllDevicesList(pa_device);
-            break;
         case CAPTURE_DEVICE_PROBE:
-            AppendCaptureDeviceList(pa_device);
+            alstr_append_range(outnames, pa_device, pa_device+sizeof(pa_device));
             break;
     }
 }


[FILE:2638:patches/patch-Alc_backends_pulseaudio.c]
--- Alc/backends/pulseaudio.c.orig	2018-09-06 21:35:18 UTC
+++ Alc/backends/pulseaudio.c
@@ -1760,9 +1760,8 @@ typedef struct ALCpulseBackendFactory {
 static ALCboolean ALCpulseBackendFactory_init(ALCpulseBackendFactory *self);
 static void ALCpulseBackendFactory_deinit(ALCpulseBackendFactory *self);
 static ALCboolean ALCpulseBackendFactory_querySupport(ALCpulseBackendFactory *self, ALCbackend_Type type);
-static void ALCpulseBackendFactory_probe(ALCpulseBackendFactory *self, enum DevProbe type);
+static void ALCpulseBackendFactory_probe(ALCpulseBackendFactory *self, enum DevProbe type, al_string *outnames);
 static ALCbackend* ALCpulseBackendFactory_createBackend(ALCpulseBackendFactory *self, ALCdevice *device, ALCbackend_Type type);
-
 DEFINE_ALCBACKENDFACTORY_VTABLE(ALCpulseBackendFactory);
 
 
@@ -1835,23 +1834,25 @@ static ALCboolean ALCpulseBackendFactory
     return ALC_FALSE;
 }
 
-static void ALCpulseBackendFactory_probe(ALCpulseBackendFactory* UNUSED(self), enum DevProbe type)
+static void ALCpulseBackendFactory_probe(ALCpulseBackendFactory* UNUSED(self), enum DevProbe type, al_string *outnames)
 {
     switch(type)
     {
+#define APPEND_OUTNAME(e) do {                                                \
+    if(!alstr_empty((e)->name))                                               \
+        alstr_append_range(outnames, VECTOR_BEGIN((e)->name),                 \
+                           VECTOR_END((e)->name)+1);                          \
+} while(0)
         case ALL_DEVICE_PROBE:
             ALCpulsePlayback_probeDevices();
-#define APPEND_ALL_DEVICES_LIST(e)  AppendAllDevicesList(alstr_get_cstr((e)->name))
-            VECTOR_FOR_EACH(const DevMap, PlaybackDevices, APPEND_ALL_DEVICES_LIST);
-#undef APPEND_ALL_DEVICES_LIST
+            VECTOR_FOR_EACH(const DevMap, PlaybackDevices, APPEND_OUTNAME);
             break;
 
         case CAPTURE_DEVICE_PROBE:
             ALCpulseCapture_probeDevices();
-#define APPEND_CAPTURE_DEVICE_LIST(e) AppendCaptureDeviceList(alstr_get_cstr((e)->name))
-            VECTOR_FOR_EACH(const DevMap, CaptureDevices, APPEND_CAPTURE_DEVICE_LIST);
-#undef APPEND_CAPTURE_DEVICE_LIST
+            VECTOR_FOR_EACH(const DevMap, CaptureDevices, APPEND_OUTNAME);
             break;
+#undef APPEND_OUTNAME
     }
 }
 
@@ -1899,7 +1900,7 @@ static ALCboolean ALCpulseBackendFactory
     return ALC_FALSE;
 }
 
-static void ALCpulseBackendFactory_probe(ALCpulseBackendFactory* UNUSED(self), enum DevProbe UNUSED(type))
+static void ALCpulseBackendFactory_probe(ALCpulseBackendFactory* UNUSED(self), enum DevProbe UNUSED(type), al_string* UNUSED(outnames))
 {
 }
 


[FILE:2891:patches/patch-Alc_backends_qsa.c]
--- Alc/backends/qsa.c.orig	2018-09-06 21:35:18 UTC
+++ Alc/backends/qsa.c
@@ -119,6 +119,9 @@ static void deviceList(int type, vector_
     if(max_cards < 0)
         return;
 
+#define FREE_NAME(iter) free((iter)->name)
+    VECTOR_FOR_EACH(DevMap, *devmap, FREE_NAME);
+#undef FREE_NAME
     VECTOR_RESIZE(*devmap, 0, max_cards+1);
 
     entry.name = strdup(qsaDevice);
@@ -989,7 +992,7 @@ typedef struct ALCqsaBackendFactory {
 static ALCboolean ALCqsaBackendFactory_init(ALCqsaBackendFactory* UNUSED(self));
 static void ALCqsaBackendFactory_deinit(ALCqsaBackendFactory* UNUSED(self));
 static ALCboolean ALCqsaBackendFactory_querySupport(ALCqsaBackendFactory* UNUSED(self), ALCbackend_Type type);
-static void ALCqsaBackendFactory_probe(ALCqsaBackendFactory* UNUSED(self), enum DevProbe type);
+static void ALCqsaBackendFactory_probe(ALCqsaBackendFactory* UNUSED(self), enum DevProbe type, al_string *outnames);
 static ALCbackend* ALCqsaBackendFactory_createBackend(ALCqsaBackendFactory* UNUSED(self), ALCdevice *device, ALCbackend_Type type);
 DEFINE_ALCBACKENDFACTORY_VTABLE(ALCqsaBackendFactory);
 
@@ -1016,33 +1019,25 @@ static ALCboolean ALCqsaBackendFactory_q
     return ALC_FALSE;
 }
 
-static void ALCqsaBackendFactory_probe(ALCqsaBackendFactory* UNUSED(self), enum DevProbe type)
+static void ALCqsaBackendFactory_probe(ALCqsaBackendFactory* UNUSED(self), enum DevProbe type, al_string *outnames)
 {
     switch (type)
     {
+#define APPEND_OUTNAME(e) do {                                                \
+    const char *n_ = (e)->name;                                               \
+    if(n_ && n_[0])                                                           \
+        alstr_append_range(outnames, n_, n_+strlen(n_)+1);                    \
+} while(0)
         case ALL_DEVICE_PROBE:
-#define FREE_NAME(iter) free((iter)->name)
-            VECTOR_FOR_EACH(DevMap, DeviceNameMap, FREE_NAME);
-            VECTOR_RESIZE(DeviceNameMap, 0, 0);
-#undef FREE_NAME
-
             deviceList(SND_PCM_CHANNEL_PLAYBACK, &DeviceNameMap);
-#define APPEND_DEVICE(iter) AppendAllDevicesList((iter)->name)
-            VECTOR_FOR_EACH(const DevMap, DeviceNameMap, APPEND_DEVICE);
-#undef APPEND_DEVICE
+            VECTOR_FOR_EACH(const DevMap, DeviceNameMap, APPEND_OUTNAME);
             break;
 
         case CAPTURE_DEVICE_PROBE:
-#define FREE_NAME(iter) free((iter)->name)
-            VECTOR_FOR_EACH(DevMap, CaptureNameMap, FREE_NAME);
-            VECTOR_RESIZE(CaptureNameMap, 0, 0);
-#undef FREE_NAME
-
             deviceList(SND_PCM_CHANNEL_CAPTURE, &CaptureNameMap);
-#define APPEND_DEVICE(iter) AppendCaptureDeviceList((iter)->name)
-            VECTOR_FOR_EACH(const DevMap, CaptureNameMap, APPEND_DEVICE);
-#undef APPEND_DEVICE
+            VECTOR_FOR_EACH(const DevMap, CaptureNameMap, APPEND_OUTNAME);
             break;
+#undef APPEND_OUTNAME
     }
 }
 


[FILE:1795:patches/patch-Alc_backends_sdl2.c]
--- Alc/backends/sdl2.c.orig	2018-09-06 21:35:18 UTC
+++ Alc/backends/sdl2.c
@@ -221,7 +221,7 @@ ALCbackendFactory *ALCsdl2BackendFactory
 static ALCboolean ALCsdl2BackendFactory_init(ALCsdl2BackendFactory *self);
 static void ALCsdl2BackendFactory_deinit(ALCsdl2BackendFactory *self);
 static ALCboolean ALCsdl2BackendFactory_querySupport(ALCsdl2BackendFactory *self, ALCbackend_Type type);
-static void ALCsdl2BackendFactory_probe(ALCsdl2BackendFactory *self, enum DevProbe type);
+static void ALCsdl2BackendFactory_probe(ALCsdl2BackendFactory *self, enum DevProbe type, al_string *outnames);
 static ALCbackend* ALCsdl2BackendFactory_createBackend(ALCsdl2BackendFactory *self, ALCdevice *device, ALCbackend_Type type);
 DEFINE_ALCBACKENDFACTORY_VTABLE(ALCsdl2BackendFactory);
 
@@ -252,7 +252,7 @@ static ALCboolean ALCsdl2BackendFactory_
     return ALC_FALSE;
 }
 
-static void ALCsdl2BackendFactory_probe(ALCsdl2BackendFactory* UNUSED(self), enum DevProbe type)
+static void ALCsdl2BackendFactory_probe(ALCsdl2BackendFactory* UNUSED(self), enum DevProbe type, al_string *outnames)
 {
     int num_devices, i;
     al_string name;
@@ -263,12 +263,13 @@ static void ALCsdl2BackendFactory_probe(
     AL_STRING_INIT(name);
     num_devices = SDL_GetNumAudioDevices(SDL_FALSE);
 
-    AppendAllDevicesList(defaultDeviceName);
+    alstr_append_range(outnames, defaultDeviceName, defaultDeviceName+sizeof(defaultDeviceName));
     for(i = 0;i < num_devices;++i)
     {
         alstr_copy_cstr(&name, DEVNAME_PREFIX);
         alstr_append_cstr(&name, SDL_GetAudioDeviceName(i, SDL_FALSE));
-        AppendAllDevicesList(alstr_get_cstr(name));
+        if(!alstr_empty(name))
+            alstr_append_range(outnames, VECTOR_BEGIN(name), VECTOR_END(name)+1);
     }
     alstr_reset(&name);
 }


[FILE:17404:patches/patch-Alc_backends_sndio.c]
--- Alc/backends/sndio.c.orig	2018-09-06 21:35:18 UTC
+++ Alc/backends/sndio.c
@@ -27,15 +27,17 @@
 #include "alMain.h"
 #include "alu.h"
 #include "threads.h"
+#include "ringbuffer.h"
 
 #include "backends/base.h"
 
 #include <sndio.h>
 
 
+static const ALCchar sndio_device[] = "SndIO Default";
 
 
-typedef struct ALCsndioBackend {
+typedef struct SndioPlayback {
     DERIVE_FROM_TYPE(ALCbackend);
 
     struct sio_hdl *sndHandle;
@@ -45,40 +47,37 @@ typedef struct ALCsndioBackend {
 
     ATOMIC(int) killNow;
     althrd_t thread;
-} ALCsndioBackend;
-
-static int ALCsndioBackend_mixerProc(void *ptr);
-
-static void ALCsndioBackend_Construct(ALCsndioBackend *self, ALCdevice *device);
-static void ALCsndioBackend_Destruct(ALCsndioBackend *self);
-static ALCenum ALCsndioBackend_open(ALCsndioBackend *self, const ALCchar *name);
-static ALCboolean ALCsndioBackend_reset(ALCsndioBackend *self);
-static ALCboolean ALCsndioBackend_start(ALCsndioBackend *self);
-static void ALCsndioBackend_stop(ALCsndioBackend *self);
-static DECLARE_FORWARD2(ALCsndioBackend, ALCbackend, ALCenum, captureSamples, void*, ALCuint)
-static DECLARE_FORWARD(ALCsndioBackend, ALCbackend, ALCuint, availableSamples)
-static DECLARE_FORWARD(ALCsndioBackend, ALCbackend, ClockLatency, getClockLatency)
-static DECLARE_FORWARD(ALCsndioBackend, ALCbackend, void, lock)
-static DECLARE_FORWARD(ALCsndioBackend, ALCbackend, void, unlock)
-DECLARE_DEFAULT_ALLOCATORS(ALCsndioBackend)
+} SndioPlayback;
 
-DEFINE_ALCBACKEND_VTABLE(ALCsndioBackend);
+static int SndioPlayback_mixerProc(void *ptr);
 
+static void SndioPlayback_Construct(SndioPlayback *self, ALCdevice *device);
+static void SndioPlayback_Destruct(SndioPlayback *self);
+static ALCenum SndioPlayback_open(SndioPlayback *self, const ALCchar *name);
+static ALCboolean SndioPlayback_reset(SndioPlayback *self);
+static ALCboolean SndioPlayback_start(SndioPlayback *self);
+static void SndioPlayback_stop(SndioPlayback *self);
+static DECLARE_FORWARD2(SndioPlayback, ALCbackend, ALCenum, captureSamples, void*, ALCuint)
+static DECLARE_FORWARD(SndioPlayback, ALCbackend, ALCuint, availableSamples)
+static DECLARE_FORWARD(SndioPlayback, ALCbackend, ClockLatency, getClockLatency)
+static DECLARE_FORWARD(SndioPlayback, ALCbackend, void, lock)
+static DECLARE_FORWARD(SndioPlayback, ALCbackend, void, unlock)
+DECLARE_DEFAULT_ALLOCATORS(SndioPlayback)
 
-static const ALCchar sndio_device[] = "SndIO Default";
+DEFINE_ALCBACKEND_VTABLE(SndioPlayback);
 
 
-static void ALCsndioBackend_Construct(ALCsndioBackend *self, ALCdevice *device)
+static void SndioPlayback_Construct(SndioPlayback *self, ALCdevice *device)
 {
     ALCbackend_Construct(STATIC_CAST(ALCbackend, self), device);
-    SET_VTABLE2(ALCsndioBackend, ALCbackend, self);
+    SET_VTABLE2(SndioPlayback, ALCbackend, self);
 
     self->sndHandle = NULL;
     self->mix_data = NULL;
     ATOMIC_INIT(&self->killNow, AL_TRUE);
 }
 
-static void ALCsndioBackend_Destruct(ALCsndioBackend *self)
+static void SndioPlayback_Destruct(SndioPlayback *self)
 {
     if(self->sndHandle)
         sio_close(self->sndHandle);
@@ -91,9 +90,9 @@ static void ALCsndioBackend_Destruct(ALC
 }
 
 
-static int ALCsndioBackend_mixerProc(void *ptr)
+static int SndioPlayback_mixerProc(void *ptr)
 {
-    ALCsndioBackend *self = (ALCsndioBackend*)ptr;
+    SndioPlayback *self = (SndioPlayback*)ptr;
     ALCdevice *device = STATIC_CAST(ALCbackend, self)->mDevice;
     ALsizei frameSize;
     size_t wrote;
@@ -109,9 +108,9 @@ static int ALCsndioBackend_mixerProc(voi
         ALsizei len = self->data_size;
         ALubyte *WritePtr = self->mix_data;
 
-        ALCsndioBackend_lock(self);
+        SndioPlayback_lock(self);
         aluMixData(device, WritePtr, len/frameSize);
-        ALCsndioBackend_unlock(self);
+        SndioPlayback_unlock(self);
         while(len > 0 && !ATOMIC_LOAD(&self->killNow, almemory_order_acquire))
         {
             wrote = sio_write(self->sndHandle, WritePtr, len);
@@ -133,7 +132,7 @@ static int ALCsndioBackend_mixerProc(voi
 }
 
 
-static ALCenum ALCsndioBackend_open(ALCsndioBackend *self, const ALCchar *name)
+static ALCenum SndioPlayback_open(SndioPlayback *self, const ALCchar *name)
 {
     ALCdevice *device = STATIC_CAST(ALCbackend,self)->mDevice;
 
@@ -154,7 +153,7 @@ static ALCenum ALCsndioBackend_open(ALCs
     return ALC_NO_ERROR;
 }
 
-static ALCboolean ALCsndioBackend_reset(ALCsndioBackend *self)
+static ALCboolean SndioPlayback_reset(SndioPlayback *self)
 {
     ALCdevice *device = STATIC_CAST(ALCbackend,self)->mDevice;
     struct sio_par par;
@@ -239,7 +238,7 @@ static ALCboolean ALCsndioBackend_reset(
     return ALC_TRUE;
 }
 
-static ALCboolean ALCsndioBackend_start(ALCsndioBackend *self)
+static ALCboolean SndioPlayback_start(SndioPlayback *self)
 {
     ALCdevice *device = STATIC_CAST(ALCbackend,self)->mDevice;
 
@@ -256,7 +255,7 @@ static ALCboolean ALCsndioBackend_start(
     }
 
     ATOMIC_STORE(&self->killNow, AL_FALSE, almemory_order_release);
-    if(althrd_create(&self->thread, ALCsndioBackend_mixerProc, self) != althrd_success)
+    if(althrd_create(&self->thread, SndioPlayback_mixerProc, self) != althrd_success)
     {
         sio_stop(self->sndHandle);
         return ALC_FALSE;
@@ -265,7 +264,7 @@ static ALCboolean ALCsndioBackend_start(
     return ALC_TRUE;
 }
 
-static void ALCsndioBackend_stop(ALCsndioBackend *self)
+static void SndioPlayback_stop(SndioPlayback *self)
 {
     int res;
 
@@ -281,59 +280,318 @@ static void ALCsndioBackend_stop(ALCsndi
 }
 
 
-typedef struct ALCsndioBackendFactory {
-    DERIVE_FROM_TYPE(ALCbackendFactory);
-} ALCsndioBackendFactory;
-#define ALCSNDIOBACKENDFACTORY_INITIALIZER { { GET_VTABLE2(ALCsndioBackendFactory, ALCbackendFactory) } }
+typedef struct SndioCapture {
+    DERIVE_FROM_TYPE(ALCbackend);
+
+    struct sio_hdl *sndHandle;
+
+    ll_ringbuffer_t *ring;
+
+    ATOMIC(int) killNow;
+    althrd_t thread;
+} SndioCapture;
+
+static int SndioCapture_recordProc(void *ptr);
 
-ALCbackendFactory *ALCsndioBackendFactory_getFactory(void);
+static void SndioCapture_Construct(SndioCapture *self, ALCdevice *device);
+static void SndioCapture_Destruct(SndioCapture *self);
+static ALCenum SndioCapture_open(SndioCapture *self, const ALCchar *name);
+static DECLARE_FORWARD(SndioCapture, ALCbackend, ALCboolean, reset)
+static ALCboolean SndioCapture_start(SndioCapture *self);
+static void SndioCapture_stop(SndioCapture *self);
+static ALCenum SndioCapture_captureSamples(SndioCapture *self, void *buffer, ALCuint samples);
+static ALCuint SndioCapture_availableSamples(SndioCapture *self);
+static DECLARE_FORWARD(SndioCapture, ALCbackend, ClockLatency, getClockLatency)
+static DECLARE_FORWARD(SndioCapture, ALCbackend, void, lock)
+static DECLARE_FORWARD(SndioCapture, ALCbackend, void, unlock)
+DECLARE_DEFAULT_ALLOCATORS(SndioCapture)
 
-static ALCboolean ALCsndioBackendFactory_init(ALCsndioBackendFactory *self);
-static DECLARE_FORWARD(ALCsndioBackendFactory, ALCbackendFactory, void, deinit)
-static ALCboolean ALCsndioBackendFactory_querySupport(ALCsndioBackendFactory *self, ALCbackend_Type type);
-static void ALCsndioBackendFactory_probe(ALCsndioBackendFactory *self, enum DevProbe type);
-static ALCbackend* ALCsndioBackendFactory_createBackend(ALCsndioBackendFactory *self, ALCdevice *device, ALCbackend_Type type);
-DEFINE_ALCBACKENDFACTORY_VTABLE(ALCsndioBackendFactory);
+DEFINE_ALCBACKEND_VTABLE(SndioCapture);
 
 
-ALCbackendFactory *ALCsndioBackendFactory_getFactory(void)
+static void SndioCapture_Construct(SndioCapture *self, ALCdevice *device)
 {
-    static ALCsndioBackendFactory factory = ALCSNDIOBACKENDFACTORY_INITIALIZER;
-    return STATIC_CAST(ALCbackendFactory, &factory);
+    ALCbackend_Construct(STATIC_CAST(ALCbackend, self), device);
+    SET_VTABLE2(SndioCapture, ALCbackend, self);
+
+    self->sndHandle = NULL;
+    self->ring = NULL;
+    ATOMIC_INIT(&self->killNow, AL_TRUE);
+}
+
+static void SndioCapture_Destruct(SndioCapture *self)
+{
+    if(self->sndHandle)
+        sio_close(self->sndHandle);
+    self->sndHandle = NULL;
+
+    ll_ringbuffer_free(self->ring);
+    self->ring = NULL;
+
+    ALCbackend_Destruct(STATIC_CAST(ALCbackend, self));
+}
+
+
+static int SndioCapture_recordProc(void* ptr)
+{
+    SndioCapture *self = (SndioCapture*)ptr;
+    ALCdevice *device = STATIC_CAST(ALCbackend, self)->mDevice;
+    ALsizei frameSize;
+
+    SetRTPriority();
+    althrd_setname(althrd_current(), RECORD_THREAD_NAME);
+
+    frameSize = FrameSizeFromDevFmt(device->FmtChans, device->FmtType, device->AmbiOrder);
+
+    while(!ATOMIC_LOAD(&self->killNow, almemory_order_acquire) &&
+          ATOMIC_LOAD(&device->Connected, almemory_order_acquire))
+    {
+        ll_ringbuffer_data_t data[2];
+        size_t total, todo;
+
+        ll_ringbuffer_get_write_vector(self->ring, data);
+        todo = data[0].len + data[1].len;
+        if(todo == 0)
+        {
+            static char junk[4096];
+            sio_read(self->sndHandle, junk, minz(sizeof(junk)/frameSize, device->UpdateSize)*frameSize);
+            continue;
+        }
+
+        total = 0;
+        data[0].len *= frameSize;
+        data[1].len *= frameSize;
+        todo = minz(todo, device->UpdateSize) * frameSize;
+        while(total < todo)
+        {
+            size_t got;
+
+            if(!data[0].len)
+                data[0] = data[1];
+
+            got = sio_read(self->sndHandle, data[0].buf, minz(todo-total, data[0].len));
+            if(!got)
+            {
+                SndioCapture_lock(self);
+                aluHandleDisconnect(device, "Failed to read capture samples");
+                SndioCapture_unlock(self);
+                break;
+            }
+
+            data[0].buf += got;
+            data[0].len -= got;
+            total += got;
+        }
+        ll_ringbuffer_write_advance(self->ring, total / frameSize);
+    }
+
+    return 0;
+}
+
+
+static ALCenum SndioCapture_open(SndioCapture *self, const ALCchar *name)
+{
+    ALCdevice *device = STATIC_CAST(ALCbackend,self)->mDevice;
+    struct sio_par par;
+
+    if(!name)
+        name = sndio_device;
+    else if(strcmp(name, sndio_device) != 0)
+        return ALC_INVALID_VALUE;
+
+    self->sndHandle = sio_open(NULL, SIO_REC, 0);
+    if(self->sndHandle == NULL)
+    {
+        ERR("Could not open device\n");
+        return ALC_INVALID_VALUE;
+    }
+
+    sio_initpar(&par);
+
+    switch(device->FmtType)
+    {
+        case DevFmtByte:
+            par.bps = 1;
+            par.sig = 1;
+            break;
+        case DevFmtUByte:
+            par.bps = 1;
+            par.sig = 0;
+            break;
+        case DevFmtShort:
+            par.bps = 2;
+            par.sig = 1;
+            break;
+        case DevFmtUShort:
+            par.bps = 2;
+            par.sig = 0;
+            break;
+        case DevFmtInt:
+            par.bps = 4;
+            par.sig = 1;
+            break;
+        case DevFmtUInt:
+            par.bps = 4;
+            par.sig = 0;
+            break;
+        case DevFmtFloat:
+            ERR("%s capture samples not supported\n", DevFmtTypeString(device->FmtType));
+            return ALC_INVALID_VALUE;
+    }
+    par.bits = par.bps * 8;
+    par.le = SIO_LE_NATIVE;
+    par.msb = SIO_LE_NATIVE ? 0 : 1;
+    par.rchan = ChannelsFromDevFmt(device->FmtChans, device->AmbiOrder);
+    par.rate = device->Frequency;
+
+    par.appbufsz = maxu(device->UpdateSize*device->NumUpdates, (device->Frequency+9)/10);
+    par.round = clampu(par.appbufsz/device->NumUpdates, (device->Frequency+99)/100,
+                       (device->Frequency+19)/20);
+
+    device->UpdateSize = par.round;
+    device->NumUpdates = maxu(par.appbufsz/par.round, 1);
+
+    if(!sio_setpar(self->sndHandle, &par) || !sio_getpar(self->sndHandle, &par))
+    {
+        ERR("Failed to set device parameters\n");
+        return ALC_INVALID_VALUE;
+    }
+
+    if(par.bits != par.bps*8)
+    {
+        ERR("Padded samples not supported (%u of %u bits)\n", par.bits, par.bps*8);
+        return ALC_INVALID_VALUE;
+    }
+
+    if(!((device->FmtType == DevFmtByte && par.bits == 8 && par.sig != 0) ||
+         (device->FmtType == DevFmtUByte && par.bits == 8 && par.sig == 0) ||
+         (device->FmtType == DevFmtShort && par.bits == 16 && par.sig != 0) ||
+         (device->FmtType == DevFmtUShort && par.bits == 16 && par.sig == 0) ||
+         (device->FmtType == DevFmtInt && par.bits == 32 && par.sig != 0) ||
+         (device->FmtType == DevFmtUInt && par.bits == 32 && par.sig == 0)) ||
+       ChannelsFromDevFmt(device->FmtChans, device->AmbiOrder) != (ALsizei)par.rchan ||
+       device->Frequency != par.rate)
+    {
+        ERR("Failed to set format %s %s %uhz, got %c%u %u-channel %uhz instead\n",
+            DevFmtTypeString(device->FmtType), DevFmtChannelsString(device->FmtChans),
+            device->Frequency, par.sig?'s':'u', par.bits, par.rchan, par.rate);
+        return ALC_INVALID_VALUE;
+    }
+
+    self->ring = ll_ringbuffer_create(device->UpdateSize*device->NumUpdates, par.bps*par.rchan, 0);
+    if(!self->ring)
+    {
+        ERR("Failed to allocate %u-byte ringbuffer\n",
+            device->UpdateSize*device->NumUpdates*par.bps*par.rchan);
+        return ALC_OUT_OF_MEMORY;
+    }
+
+    SetDefaultChannelOrder(device);
+
+    alstr_copy_cstr(&device->DeviceName, name);
+
+    return ALC_NO_ERROR;
+}
+
+static ALCboolean SndioCapture_start(SndioCapture *self)
+{
+    if(!sio_start(self->sndHandle))
+    {
+        ERR("Error starting playback\n");
+        return ALC_FALSE;
+    }
+
+    ATOMIC_STORE(&self->killNow, AL_FALSE, almemory_order_release);
+    if(althrd_create(&self->thread, SndioCapture_recordProc, self) != althrd_success)
+    {
+        sio_stop(self->sndHandle);
+        return ALC_FALSE;
+    }
+
+    return ALC_TRUE;
+}
+
+static void SndioCapture_stop(SndioCapture *self)
+{
+    int res;
+
+    if(ATOMIC_EXCHANGE(&self->killNow, AL_TRUE, almemory_order_acq_rel))
+        return;
+    althrd_join(self->thread, &res);
+
+    if(!sio_stop(self->sndHandle))
+        ERR("Error stopping device\n");
+}
+
+static ALCenum SndioCapture_captureSamples(SndioCapture *self, void *buffer, ALCuint samples)
+{
+    ll_ringbuffer_read(self->ring, buffer, samples);
+    return ALC_NO_ERROR;
 }
 
+static ALCuint SndioCapture_availableSamples(SndioCapture *self)
+{
+    return ll_ringbuffer_read_space(self->ring);
+}
+
+
+typedef struct SndioBackendFactory {
+    DERIVE_FROM_TYPE(ALCbackendFactory);
+} SndioBackendFactory;
+#define SNDIOBACKENDFACTORY_INITIALIZER { { GET_VTABLE2(SndioBackendFactory, ALCbackendFactory) } }
+
+ALCbackendFactory *SndioBackendFactory_getFactory(void);
 
-static ALCboolean ALCsndioBackendFactory_init(ALCsndioBackendFactory* UNUSED(self))
+static ALCboolean SndioBackendFactory_init(SndioBackendFactory *self);
+static DECLARE_FORWARD(SndioBackendFactory, ALCbackendFactory, void, deinit)
+static ALCboolean SndioBackendFactory_querySupport(SndioBackendFactory *self, ALCbackend_Type type);
+static void SndioBackendFactory_probe(SndioBackendFactory *self, enum DevProbe type, al_string *outnames);
+static ALCbackend* SndioBackendFactory_createBackend(SndioBackendFactory *self, ALCdevice *device, ALCbackend_Type type);
+DEFINE_ALCBACKENDFACTORY_VTABLE(SndioBackendFactory);
+
+ALCbackendFactory *SndioBackendFactory_getFactory(void)
+{
+    static SndioBackendFactory factory = SNDIOBACKENDFACTORY_INITIALIZER;
+    return STATIC_CAST(ALCbackendFactory, &factory);
+}
+
+static ALCboolean SndioBackendFactory_init(SndioBackendFactory* UNUSED(self))
 {
     /* No dynamic loading */
     return ALC_TRUE;
 }
 
-static ALCboolean ALCsndioBackendFactory_querySupport(ALCsndioBackendFactory* UNUSED(self), ALCbackend_Type type)
+static ALCboolean SndioBackendFactory_querySupport(SndioBackendFactory* UNUSED(self), ALCbackend_Type type)
 {
-    if(type == ALCbackend_Playback)
+    if(type == ALCbackend_Playback || type == ALCbackend_Capture)
         return ALC_TRUE;
     return ALC_FALSE;
 }
 
-static void ALCsndioBackendFactory_probe(ALCsndioBackendFactory* UNUSED(self), enum DevProbe type)
+static void SndioBackendFactory_probe(SndioBackendFactory* UNUSED(self), enum DevProbe type, al_string *outnames)
 {
     switch(type)
     {
         case ALL_DEVICE_PROBE:
-            AppendAllDevicesList(sndio_device);
-            break;
         case CAPTURE_DEVICE_PROBE:
+            alstr_append_range(outnames, sndio_device, sndio_device+sizeof(sndio_device));
             break;
     }
 }
 
-static ALCbackend* ALCsndioBackendFactory_createBackend(ALCsndioBackendFactory* UNUSED(self), ALCdevice *device, ALCbackend_Type type)
+static ALCbackend* SndioBackendFactory_createBackend(SndioBackendFactory* UNUSED(self), ALCdevice *device, ALCbackend_Type type)
 {
     if(type == ALCbackend_Playback)
     {
-        ALCsndioBackend *backend;
-        NEW_OBJ(backend, ALCsndioBackend)(device);
+        SndioPlayback *backend;
+        NEW_OBJ(backend, SndioPlayback)(device);
+        if(!backend) return NULL;
+        return STATIC_CAST(ALCbackend, backend);
+    }
+    if(type == ALCbackend_Capture)
+    {
+        SndioCapture *backend;
+        NEW_OBJ(backend, SndioCapture)(device);
         if(!backend) return NULL;
         return STATIC_CAST(ALCbackend, backend);
     }


[FILE:1511:patches/patch-Alc_backends_solaris.c]
--- Alc/backends/solaris.c.orig	2018-09-06 21:35:18 UTC
+++ Alc/backends/solaris.c
@@ -302,7 +302,7 @@ ALCbackendFactory *ALCsolarisBackendFact
 static ALCboolean ALCsolarisBackendFactory_init(ALCsolarisBackendFactory *self);
 static DECLARE_FORWARD(ALCsolarisBackendFactory, ALCbackendFactory, void, deinit)
 static ALCboolean ALCsolarisBackendFactory_querySupport(ALCsolarisBackendFactory *self, ALCbackend_Type type);
-static void ALCsolarisBackendFactory_probe(ALCsolarisBackendFactory *self, enum DevProbe type);
+static void ALCsolarisBackendFactory_probe(ALCsolarisBackendFactory *self, enum DevProbe type, al_string *outnames);
 static ALCbackend* ALCsolarisBackendFactory_createBackend(ALCsolarisBackendFactory *self, ALCdevice *device, ALCbackend_Type type);
 DEFINE_ALCBACKENDFACTORY_VTABLE(ALCsolarisBackendFactory);
 
@@ -327,7 +327,7 @@ static ALCboolean ALCsolarisBackendFacto
     return ALC_FALSE;
 }
 
-static void ALCsolarisBackendFactory_probe(ALCsolarisBackendFactory* UNUSED(self), enum DevProbe type)
+static void ALCsolarisBackendFactory_probe(ALCsolarisBackendFactory* UNUSED(self), enum DevProbe type, al_string *outnames)
 {
     switch(type)
     {
@@ -337,7 +337,7 @@ static void ALCsolarisBackendFactory_pro
             struct stat buf;
             if(stat(solaris_driver, &buf) == 0)
 #endif
-                AppendAllDevicesList(solaris_device);
+                alstr_append_range(outnames, solaris_device, solaris_device+sizeof(solaris_device));
         }
         break;
 


[FILE:2633:patches/patch-Alc_backends_wasapi.c]
--- Alc/backends/wasapi.c.orig	2018-09-06 21:35:18 UTC
+++ Alc/backends/wasapi.c
@@ -1919,11 +1919,6 @@ ALCenum ALCwasapiCapture_captureSamples(
 }
 
 
-static inline void AppendAllDevicesList2(const DevMap *entry)
-{ AppendAllDevicesList(alstr_get_cstr(entry->name)); }
-static inline void AppendCaptureDeviceList2(const DevMap *entry)
-{ AppendCaptureDeviceList(alstr_get_cstr(entry->name)); }
-
 typedef struct ALCwasapiBackendFactory {
     DERIVE_FROM_TYPE(ALCbackendFactory);
 } ALCwasapiBackendFactory;
@@ -1932,7 +1927,7 @@ typedef struct ALCwasapiBackendFactory {
 static ALCboolean ALCwasapiBackendFactory_init(ALCwasapiBackendFactory *self);
 static void ALCwasapiBackendFactory_deinit(ALCwasapiBackendFactory *self);
 static ALCboolean ALCwasapiBackendFactory_querySupport(ALCwasapiBackendFactory *self, ALCbackend_Type type);
-static void ALCwasapiBackendFactory_probe(ALCwasapiBackendFactory *self, enum DevProbe type);
+static void ALCwasapiBackendFactory_probe(ALCwasapiBackendFactory *self, enum DevProbe type, al_string *outnames);
 static ALCbackend* ALCwasapiBackendFactory_createBackend(ALCwasapiBackendFactory *self, ALCdevice *device, ALCbackend_Type type);
 
 DEFINE_ALCBACKENDFACTORY_VTABLE(ALCwasapiBackendFactory);
@@ -1989,7 +1984,7 @@ static ALCboolean ALCwasapiBackendFactor
     return ALC_FALSE;
 }
 
-static void ALCwasapiBackendFactory_probe(ALCwasapiBackendFactory* UNUSED(self), enum DevProbe type)
+static void ALCwasapiBackendFactory_probe(ALCwasapiBackendFactory* UNUSED(self), enum DevProbe type, al_string *outnames)
 {
     ThreadRequest req = { NULL, 0 };
 
@@ -2003,13 +1998,19 @@ static void ALCwasapiBackendFactory_prob
             hr = WaitForResponse(&req);
         if(SUCCEEDED(hr)) switch(type)
         {
+#define APPEND_OUTNAME(e) do {                                                \
+    if(!alstr_empty((e)->name))                                               \
+        alstr_append_range(outnames, VECTOR_BEGIN((e)->name),                 \
+                           VECTOR_END((e)->name)+1);                          \
+} while(0)
         case ALL_DEVICE_PROBE:
-            VECTOR_FOR_EACH(const DevMap, PlaybackDevices, AppendAllDevicesList2);
+            VECTOR_FOR_EACH(const DevMap, PlaybackDevices, APPEND_OUTNAME);
             break;
 
         case CAPTURE_DEVICE_PROBE:
-            VECTOR_FOR_EACH(const DevMap, CaptureDevices, AppendCaptureDeviceList2);
+            VECTOR_FOR_EACH(const DevMap, CaptureDevices, APPEND_OUTNAME);
             break;
+#undef APPEND_OUTNAME
         }
         CloseHandle(req.FinishedEvt);
         req.FinishedEvt = NULL;


[FILE:1366:patches/patch-Alc_backends_wave.c]
--- Alc/backends/wave.c.orig	2018-09-06 21:35:18 UTC
+++ Alc/backends/wave.c
@@ -403,7 +403,7 @@ ALCbackendFactory *ALCwaveBackendFactory
 static ALCboolean ALCwaveBackendFactory_init(ALCwaveBackendFactory *self);
 static DECLARE_FORWARD(ALCwaveBackendFactory, ALCbackendFactory, void, deinit)
 static ALCboolean ALCwaveBackendFactory_querySupport(ALCwaveBackendFactory *self, ALCbackend_Type type);
-static void ALCwaveBackendFactory_probe(ALCwaveBackendFactory *self, enum DevProbe type);
+static void ALCwaveBackendFactory_probe(ALCwaveBackendFactory *self, enum DevProbe type, al_string *outnames);
 static ALCbackend* ALCwaveBackendFactory_createBackend(ALCwaveBackendFactory *self, ALCdevice *device, ALCbackend_Type type);
 DEFINE_ALCBACKENDFACTORY_VTABLE(ALCwaveBackendFactory);
 
@@ -427,12 +427,12 @@ static ALCboolean ALCwaveBackendFactory_
     return ALC_FALSE;
 }
 
-static void ALCwaveBackendFactory_probe(ALCwaveBackendFactory* UNUSED(self), enum DevProbe type)
+static void ALCwaveBackendFactory_probe(ALCwaveBackendFactory* UNUSED(self), enum DevProbe type, al_string *outnames)
 {
     switch(type)
     {
         case ALL_DEVICE_PROBE:
-            AppendAllDevicesList(waveDevice);
+            alstr_append_range(outnames, waveDevice, waveDevice+sizeof(waveDevice));
             break;
         case CAPTURE_DEVICE_PROBE:
             break;


[FILE:2438:patches/patch-Alc_backends_winmm.c]
--- Alc/backends/winmm.c.orig	2018-09-06 21:35:18 UTC
+++ Alc/backends/winmm.c
@@ -700,17 +700,6 @@ static ALCuint ALCwinmmCapture_available
 }
 
 
-static inline void AppendAllDevicesList2(const al_string *name)
-{
-    if(!alstr_empty(*name))
-        AppendAllDevicesList(alstr_get_cstr(*name));
-}
-static inline void AppendCaptureDeviceList2(const al_string *name)
-{
-    if(!alstr_empty(*name))
-        AppendCaptureDeviceList(alstr_get_cstr(*name));
-}
-
 typedef struct ALCwinmmBackendFactory {
     DERIVE_FROM_TYPE(ALCbackendFactory);
 } ALCwinmmBackendFactory;
@@ -719,7 +708,7 @@ typedef struct ALCwinmmBackendFactory {
 static ALCboolean ALCwinmmBackendFactory_init(ALCwinmmBackendFactory *self);
 static void ALCwinmmBackendFactory_deinit(ALCwinmmBackendFactory *self);
 static ALCboolean ALCwinmmBackendFactory_querySupport(ALCwinmmBackendFactory *self, ALCbackend_Type type);
-static void ALCwinmmBackendFactory_probe(ALCwinmmBackendFactory *self, enum DevProbe type);
+static void ALCwinmmBackendFactory_probe(ALCwinmmBackendFactory *self, enum DevProbe type, al_string *outnames);
 static ALCbackend* ALCwinmmBackendFactory_createBackend(ALCwinmmBackendFactory *self, ALCdevice *device, ALCbackend_Type type);
 
 DEFINE_ALCBACKENDFACTORY_VTABLE(ALCwinmmBackendFactory);
@@ -749,19 +738,24 @@ static ALCboolean ALCwinmmBackendFactory
     return ALC_FALSE;
 }
 
-static void ALCwinmmBackendFactory_probe(ALCwinmmBackendFactory* UNUSED(self), enum DevProbe type)
+static void ALCwinmmBackendFactory_probe(ALCwinmmBackendFactory* UNUSED(self), enum DevProbe type, al_string *outnames)
 {
     switch(type)
     {
+#define APPEND_OUTNAME(n) do {                                                \
+    if(!alstr_empty(*(n)))                                                    \
+        alstr_append_range(outnames, VECTOR_BEGIN(*(n)), VECTOR_END(*(n))+1); \
+} while(0)
         case ALL_DEVICE_PROBE:
             ProbePlaybackDevices();
-            VECTOR_FOR_EACH(const al_string, PlaybackDevices, AppendAllDevicesList2);
+            VECTOR_FOR_EACH(const al_string, PlaybackDevices, APPEND_OUTNAME);
             break;
 
         case CAPTURE_DEVICE_PROBE:
             ProbeCaptureDevices();
-            VECTOR_FOR_EACH(const al_string, CaptureDevices, AppendCaptureDeviceList2);
+            VECTOR_FOR_EACH(const al_string, CaptureDevices, APPEND_OUTNAME);
             break;
+#undef APPEND_OUTNAME
     }
 }
 


[FILE:395:patches/patch-OpenAL32_Include_alMain.h]
--- OpenAL32/Include/alMain.h.orig	2018-09-06 21:35:18 UTC
+++ OpenAL32/Include/alMain.h
@@ -856,9 +856,6 @@ void ALCcontext_ProcessUpdates(ALCcontex
 
 void AllocateVoices(ALCcontext *context, ALsizei num_voices, ALsizei old_sends);
 
-void AppendAllDevicesList(const ALCchar *name);
-void AppendCaptureDeviceList(const ALCchar *name);
-
 
 extern ALint RTPrioLevel;
 void SetRTPriority(void);


[FILE:382:patches/patch-OpenAL32_alBuffer.c]
--- OpenAL32/alBuffer.c.orig	2018-09-06 21:35:18 UTC
+++ OpenAL32/alBuffer.c
@@ -1118,7 +1118,7 @@ static ALboolean DecomposeUserFormat(ALe
         { AL_FORMAT_BFORMAT3D_FLOAT32, UserFmtBFormat3D, UserFmtFloat },
         { AL_FORMAT_BFORMAT3D_MULAW,   UserFmtBFormat3D, UserFmtMulaw },
     };
-    ALuint i;
+    volatile ALuint i;
 
     for(i = 0;i < COUNTOF(list);i++)
     {

