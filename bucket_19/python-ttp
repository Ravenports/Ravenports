# Buildsheet autogenerated by ravenadm tool -- Do not edit.

NAMEBASE=		python-ttp
VERSION=		0.10.0
KEYWORDS=		python
VARIANTS=		v12 v13
SDESC[v12]=		Template Text Parser (3.12)
SDESC[v13]=		Template Text Parser (3.13)
HOMEPAGE=		https://github.com/dmulyalin/ttp
CONTACT=		Python_Automaton[python@ironwolf.systems]

DOWNLOAD_GROUPS=	main
SITES[main]=		PYPIWHL/b3/c3/60abb45bd8eb973997f133eb76949523478d35dfc551a0dbd8906b6a8075
DISTFILE[1]=		ttp-0.10.0-py3-none-any.whl:main
DIST_SUBDIR=		python-src
DF_INDEX=		1
SPKGS[v12]=		single
SPKGS[v13]=		single

OPTIONS_AVAILABLE=	PY312 PY313
OPTIONS_STANDARD=	none
VOPTS[v12]=		PY312=ON PY313=OFF
VOPTS[v13]=		PY312=OFF PY313=ON

DISTNAME=		ttp-0.10.0.dist-info

GENERATED=		yes

[PY312].USES_ON=			python:v12,wheel

[PY313].USES_ON=			python:v13,wheel

[FILE:2346:descriptions/desc.single]
[Downloads]
[PyPI versions]
[Documentation status]

# Template Text Parser

TTP is a Python library for semi-structured text parsing using templates.

## Why?

To save ones time on transforming raw text into structured data and beyond.

## How?

Regexes, regexes everywhere... but, dynamically formed out of TTP templates
with added capabilities to simplify the  process of getting desired
outcome.

## What?

In essence TTP can help to:
  - Prepare, sort and load text data for parsing
  - Parse text using regexes dynamically derived out of templates
  - Process matches on the fly using broad set of built-in or custom
functions
  - Combine match results in a structure with arbitrary hierarchy
  - Transform results in desired format to ease consumption by humans or
machines
  - Return results to various destinations for storage or further
processing

Reference [documentation] for more information.

TTP [Networktocode Slack channel]

Collection of [TTP Templates]

## Example - as simple as it can be

Simple interfaces configuration parsing example

<details><summary>Code</summary>

```python
from ttp import ttp
import pprint

data = """
interface Loopback0
 description Router-id-loopback
 ip address 192.168.0.113/24
!
interface Vlan778
 description CPE_Acces_Vlan
 ip address 2002::fd37/124
 ip vrf CPE1
!
"""

template = """
interface {{ interface }}
 ip address {{ ip }}/{{ mask }}
 description {{ description }}
 ip vrf {{ vrf }}
"""

parser = ttp(data, template)
parser.parse()
pprint.pprint(parser.result(), width=100)

# prints:
# [[[{'description': 'Router-id-loopback',
#     'interface': 'Loopback0',
#     'ip': '192.168.0.113',
#     'mask': '24'},
#    {'description': 'CPE_Acces_Vlan',
#     'interface': 'Vlan778',
#     'ip': '2002::fd37',
#     'mask': '124',
#     'vrf': 'CPE1'}]]]
```
</details>

## Example - a bit more complicated

For this example lets say we want to parse BGP peerings output, but combine
state with configuration data, at the end we want to get pretty looking
text table printed to screen.

<details><summary>Code</summary>

```python
template="""
<doc>
This template first parses "show bgp vrf CUST-1 vpnv4 unicast summary"
commands
output, forming results for "bgp_state" dictionary, where peer ip is a key.

Following that, "show run | section bgp" output parsed by group "bgp_cfg".
That


[FILE:117:distinfo]
9985e0ca414e85d41493a6291a924624b9a08c48c78d2d01477cc60ba2a347c1        84287 python-src/ttp-0.10.0-py3-none-any.whl

