# Buildsheet autogenerated by ravenadm tool -- Do not edit.

NAMEBASE=		mg
VERSION=		20180824
KEYWORDS=		editors
VARIANTS=		standard
SDESC[standard]=	Microscopic GNU Emacs clone
HOMEPAGE=		https://github.com/hboetes/mg
CONTACT=		nobody

DOWNLOAD_GROUPS=	main
SITES[main]=		GITHUB/hboetes:mg:20180824
DISTFILE[1]=		generated:main
DF_INDEX=		1
SPKGS[standard]=	single

OPTIONS_AVAILABLE=	none
OPTIONS_STANDARD=	none

USES=			cmake:outsource ncurses

LICENSE=		PUBDOM:single
LICENSE_FILE=		PUBDOM:{{WRKDIR}}/LICENSE
LICENSE_AWK=		PUBDOM:"^\#include"
LICENSE_SOURCE=		PUBDOM:{{WRKSRC}}/main.c
LICENSE_SCHEME=		solo

FPC_EQUIVALENT=		editors/mg

CFLAGS=			-I{{NCURSESINC}}
VAR_OPSYS[dragonfly]=	CFLAGS=-DMAXNAMLEN=255

post-extract:
	${CP} ${FILESDIR}/reallocarray.c ${WRKSRC}
	${CP} ${FILESDIR}/CMakeLists.txt ${WRKSRC}

do-install:
	${INSTALL_PROGRAM} ${WRKDIR}/.build/mg ${STAGEDIR}${PREFIX}/bin
	${INSTALL_MAN} ${WRKSRC}/mg.1 ${STAGEDIR}${MAN1PREFIX}/man/man1

[FILE:232:descriptions/desc.single]
Mg is a small, fast, portable, and free (public domain) Emacs-like
editor maintained by the OpenBSD Project.  It is intended for people
who can't, or don't want to, run the real GNU Emacs, or are not
familiar with the vi(1) editor.


[FILE:105:distinfo]
a51a6ee77a1601cb3003504609a881ee9da8743efd3ddc0a8cf1371b0f93cb9c       142487 hboetes-mg-20180824.tar.gz


[FILE:30:manifests/plist.single]
bin/mg
share/man/man1/mg.1.gz


[FILE:501:patches/patch-def.h]
--- def.h.orig	2018-07-13 09:16:01 UTC
+++ def.h
@@ -15,7 +15,7 @@
 
 #include	"chrdef.h"
 
-#if defined(__APPLE__) || defined(__FreeBSD__)
+#if defined(__APPLE__) || defined(__FreeBSD__) || defined(__DragonFly__)
 #  define LOGIN_NAME_MAX _POSIX_LOGIN_NAME_MAX
 #endif
 
@@ -328,6 +328,10 @@ struct undo_rec {
  * Prototypes.
  */
 
+#if defined __DragonFly__ || defined __FreeBSD__
+void		 *reallocarray(void*, size_t, size_t);
+#endif
+
 /* tty.c X */
 void		 ttinit(void);
 void		 ttreinit(void);


[FILE:379:patches/patch-dired.c]
--- dired.c.orig	2018-07-13 09:16:01 UTC
+++ dired.c
@@ -956,7 +956,11 @@ redelete(struct buffer *bp)
 			continue;
 		}
 		plen = strlen(p);
+#ifdef __DragonFly__
+		SLIST_FOREACH_MUTABLE(d1, &delhead, entry, dt) {
+#else
 		SLIST_FOREACH_SAFE(d1, &delhead, entry, dt) {
+#endif
 			fnlen = strlen(d1->fn);
 			if ((plen == fnlen) && 
 			    (strncmp(p, d1->fn, plen) == 0)) {


[FILE:319:patches/patch-main.c]
--- main.c.orig	2018-07-13 09:16:01 UTC
+++ main.c
@@ -34,6 +34,10 @@ struct mgwin	*curwp;				/* current windo
 struct mgwin	*wheadp;			/* MGWIN listhead	*/
 char		 pat[NPAT];			/* pattern		*/
 
+#ifndef __dead
+#define __dead __dead2
+#endif
+
 static void	 edinit(struct buffer *);
 static __dead void usage(void);
 


[FILE:601:patches/patch-tags.c]
--- tags.c.orig	2018-07-13 09:16:01 UTC
+++ tags.c
@@ -18,7 +18,7 @@
 #include <stdlib.h>
 #include <string.h>
 #include <unistd.h>
-#if defined(LIBBSD_OVERLAY) || defined(__FreeBSD__) || defined(__GLIBC__)
+#if defined(LIBBSD_OVERLAY) || defined(__FreeBSD__) || defined(__DragonFly__) || defined(__GLIBC__)
 #  include <libutil.h>
 #else
 #include <util.h>
@@ -53,6 +53,9 @@ struct ctag {
 	char *pat;
 };
 RB_HEAD(tagtree, ctag) tags = RB_INITIALIZER(&tags);
+#ifdef __DragonFly__
+RB_PROTOTYPE(tagtree, ctag, entry, ctagcmp);
+#endif
 RB_GENERATE(tagtree, ctag, entry, ctagcmp);
 
 struct tagpos {


[FILE:384:patches/patch-undo.c]
--- undo.c.orig	2018-07-13 09:16:01 UTC
+++ undo.c
@@ -246,7 +246,11 @@ undo_add_modified(void)
 {
 	struct undo_rec *rec, *trec;
 
+#ifdef __DragonFly__
+	TAILQ_FOREACH_MUTABLE(rec, &curbp->b_undo, next, trec)
+#else
 	TAILQ_FOREACH_SAFE(rec, &curbp->b_undo, next, trec)
+#endif
 		if (rec->type == MODIFIED) {
 			TAILQ_REMOVE(&curbp->b_undo, rec, next);
 			free_undo_record(rec);


[FILE:603:files/CMakeLists.txt]
cmake_minimum_required (VERSION 3.5)
project (mg)

set (CMAKE_C_FLAGS "-Wall -DREGEX")
set (MG_SRC autoexec.c basic.c bell.c buffer.c cinfo.c dir.c display.c
	echo.c extend.c file.c fileio.c funmap.c help.c kbd.c keymap.c
	line.c macro.c main.c match.c modes.c paragraph.c
	re_search.c region.c search.c spawn.c tty.c ttyio.c ttykbd.c
	undo.c util.c version.c window.c word.c yank.c
	cmode.c cscope.c dired.c grep.c tags.c
)

if(CMAKE_SYSTEM_NAME MATCHES "FreeBSD|DragonFly")
set (REALLOC_SRC reallocarray.c)
endif()

add_executable (mg ${MG_SRC} ${REALLOC_SRC})
target_link_libraries (mg ncurses util)


[FILE:1364:files/reallocarray.c]
/*	$OpenBSD: reallocarray.c,v 1.3 2015/09/13 08:31:47 guenther Exp $	*/
/*
 * Copyright (c) 2008 Otto Moerbeek <otto@drijf.net>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>
#include <errno.h>
#include <stdint.h>
#include <stdlib.h>

/*
 * This is sqrt(SIZE_MAX+1), as s1*s2 <= SIZE_MAX
 * if both s1 < MUL_NO_OVERFLOW and s2 < MUL_NO_OVERFLOW
 */
#define MUL_NO_OVERFLOW	((size_t)1 << (sizeof(size_t) * 4))

void *
reallocarray(void *optr, size_t nmemb, size_t size)
{
	if ((nmemb >= MUL_NO_OVERFLOW || size >= MUL_NO_OVERFLOW) &&
	    nmemb > 0 && SIZE_MAX / nmemb < size) {
		errno = ENOMEM;
		return NULL;
	}
	return realloc(optr, size * nmemb);
}


