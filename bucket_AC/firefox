# Buildsheet autogenerated by ravenadm tool -- Do not edit.

NAMEBASE=		firefox
VERSION=		82.0.2
KEYWORDS=		www
VARIANTS=		standard
SDESC[standard]=	Mozilla web browser
HOMEPAGE=		https://www.mozilla.org/en-US/firefox/
CONTACT=		nobody

DOWNLOAD_GROUPS=	main
SITES[main]=		MOZILLA/firefox/releases/82.0.2/source
DISTFILE[1]=		firefox-82.0.2.source.tar.xz:main
DF_INDEX=		1
SPKGS[standard]=	single

OPTIONS_AVAILABLE=	none
OPTIONS_STANDARD=	none

BUILD_DEPENDS=		autoconf213:single:standard
			cbindgen:single:standard
			nodejs:primary:standard
			rust:single:standard
			yasm:single:standard
			nasm:primary:standard
			zip:single:standard
			clang:compiler:standard
			python-sqlite3:single:python_used
			autoselect-python:single:standard
BUILDRUN_DEPENDS=	dbus-glib:primary:standard
			ffmpeg:primary:standard
			harfbuzz:primary:standard
			icu:single:standard
			libcanberra:primary:standard
			libevent:single:standard
			libffi:single:standard
			libnotify:primary:standard
			libproxy:single:standard
			libdrm:single:standard
			nss:primary:standard

USES=			cpe desktop-utils:single gmake jpeg perl:build
			pkgconfig png python:build zlib
GNOME_COMPONENTS=	gdkpixbuf gtk2 gtk3
XORG_COMPONENTS=	pixman xcb

LICENSE=		MPL:single
LICENSE_TERMS=		single:{{WRKSRC}}/toolkit/content/license.html
LICENSE_FILE=		MPL:stock
LICENSE_SCHEME=		solo

CPE_VENDOR=		mozilla
FPC_EQUIVALENT=		www/firefox

MUST_CONFIGURE=		yes
CONFIGURE_OUTSOURCE=	yes
CONFIGURE_ENV=		PYTHON3={{PYTHON_CMD}}
			SETUPTOOLS_USE_DISTUTILS=stdlib

MAKE_ENV=		PYTHON3={{PYTHON_CMD}}
			CXXSTDLIB="stdc++"

QMAKE_ARGS=		--enable-application=browser
			--enable-chrome-format=omni
			--enable-default-toolkit=cairo-gtk3
			--enable-install-strip
			--enable-official-branding
			--enable-optimize
			--enable-release
			--enable-strip
			--enable-libproxy
			--enable-system-ffi
			--enable-system-pixman
			--disable-alsa
			--disable-debug
			--disable-debug-symbols
			--disable-dtrace
			--disable-jack
			--disable-profiling
			--disable-pulseaudio
			--disable-tests
			--disable-updater
			--disable-webrtc
			--disable-hardening
			--prefix="{{PREFIX}}"
			--with-intl-api
			--with-system-graphite2
			--with-system-harfbuzz
			--with-system-icu
			--with-system-jpeg="{{LOCALBASE}}"
			--with-system-libevent
			--with-system-nspr
			--with-system-nss
			--with-system-png="{{LOCALBASE}}"
			--with-system-zlib
VAR_OPSYS[freebsd]=	CONFIGURE_ARGS=--enable-jemalloc
VAR_OPSYS[linux]=	QMAKE_ARGS=--disable-elf-hack

post-patch:
	${REINPLACE_CMD} -e 's|%%LOCALBASE%%|${LOCALBASE}|g' \
		${WRKSRC}/browser/app/nsBrowserApp.cpp
	${REINPLACE_CMD} -e 's/%u/%U/' -e '/X-MultipleArgs/d' \
		-e '/^Icon/s/=.*/=firefox/' \
		${WRKSRC}/taskcluster/docker/firefox-snap/firefox.desktop
	(cd ${WRKSRC}/gfx/angle/checkout/src/compiler/translator && \
		${REINPLACE_CMD} -e 's|<math.h>|<cmath>|' \
		InfoSink.h IntermNode.cpp)
	# disable SCTP
	${REINPLACE_CMD} -e 's|MOZ_SCTP|MOZ_DISABLE_SCTP|' \
		${WRKSRC}/netwerk/moz.build
	# disable rust checksums
	${REINPLACE_CMD} -e 's/"files":{[^}]*}/"files":{}/' \
		 ${WRKSRC}/third_party/rust/libc/.cargo-checksum.json
	# Set mozilla options
	@${ECHO_CMD} "--=> Setting configuration <=--"
	@for arg in ${QMAKE_ARGS}; do \
		${ECHO_CMD} ".mozconfig <<  $$arg" ;\
		${ECHO_CMD} ac_add_options $$arg >> ${WRKSRC}/.mozconfig ;\
	done
	@${ECHO_CMD} LDFLAGS=\"-Wl,-rpath,${PREFIX}/lib/firefox\" \
		>> ${WRKSRC}/.mozconfig

post-install:
	@${MKDIR} ${STAGEDIR}${PREFIX}/share/pixmaps \
		${STAGEDIR}${PREFIX}/share/applications
	${INSTALL_DATA} ${WRKSRC}/taskcluster/docker/firefox-snap/firefox.desktop \
		${STAGEDIR}${PREFIX}/share/applications/
	${LN} -sf ${PREFIX}/lib/firefox/browser/chrome/icons/default/default48.png \
		${STAGEDIR}${PREFIX}/share/pixmaps/firefox.png

pre-configure:
	(cd ${WRKSRC} && ${LOCALBASE}/bin/autoconf-2.13)
	(cd ${WRKSRC}/js/src/ && ${LOCALBASE}/bin/autoconf-2.13)

[FILE:527:descriptions/desc.single]
Firefox is a full-featured standard-compliant web browser, built on the
Mozilla codebase by thousands of contributors around the world.
It is extensible through thousands of user-contributed extensions, and
features:
 * Improved Security;
 * Improved Tabbed Browsing, with tab grouping;
 * Private Browsing;
 * Spell Checking;
 * Search Suggestions;
 * Session Restore;
 * Web Feeds (RSS);
 * Live Titles;
 * Integrated Search;
 * Live Bookmarks;
 * Pop-up Blocker;
 * Phishing Protection;
 * Themes;
 * Search Engine Manager.


[FILE:107:distinfo]
8851cae2df9923844c3dc97a4f77f6f3c86cc6f298b888b38949fbf74fcf2ca9    341015640 firefox-82.0.2.source.tar.xz


[FILE:984:manifests/plist.single]
%%ONLY-LINUX%%lib/firefox/
 Throbber-small.gif
 crashreporter
 crashreporter.ini
 libmozsandbox.so
 minidump-analyzer
%%ONLY-LINUX%%lib/firefox/browser/crashreporter-override.ini
lib/firefox/
 libmozsqlite3.so
lib/firefox/fonts/TwemojiMozilla.ttf
bin/firefox
 application.ini
 dependentlibs.list
 firefox
 firefox-bin
 liblgpllibs.so
 libmozavcodec.so
 libmozavutil.so
 libmozgtk.so
 libxul.so
 omni.ja
 pingsender
 platform.ini
 plugin-container
 removed-files
lib/firefox/browser/omni.ja
lib/firefox/browser/chrome/icons/default/
 default128.png
 default16.png
 default32.png
 default48.png
 default64.png
lib/firefox/browser/features/
 doh-rollout@mozilla.org.xpi
 formautofill@mozilla.org.xpi
 screenshots@mozilla.org.xpi
 webcompat-reporter@mozilla.org.xpi
 webcompat@mozilla.org.xpi
lib/firefox/defaults/pref/channel-prefs.js
lib/firefox/gmp-clearkey/0.1/
 libclearkey.so
 manifest.json
lib/firefox/gtk2/libmozgtk.so
share/applications/firefox.desktop
share/pixmaps/firefox.png


[FILE:4594:patches/patch-addon-search]
https://github.com/mozilla/addons/issues/708
https://github.com/mozilla/addons-frontend/issues/4610

diff --git browser/app/profile/firefox.js browser/app/profile/firefox.js
index 75c2c5e435e35..4d8c09c02759b 100644
--- browser/app/profile/firefox.js
+++ browser/app/profile/firefox.js
@@ -37,7 +37,7 @@ pref("extensions.webextOptionalPermissionPrompts", true);
 // Preferences for AMO integration
 pref("extensions.getAddons.cache.enabled", true);
 pref("extensions.getAddons.get.url", "https://services.addons.mozilla.org/api/v3/addons/search/?guid=%IDS%&lang=%LOCALE%");
-pref("extensions.getAddons.search.browseURL", "https://addons.mozilla.org/%LOCALE%/firefox/search?q=%TERMS%&platform=%OS%&appver=%VERSION%");
+pref("extensions.getAddons.search.browseURL", "https://addons.mozilla.org/%LOCALE%/firefox/search?q=%TERMS%&platform=Linux&appver=%VERSION%");
 pref("extensions.getAddons.link.url", "https://addons.mozilla.org/%LOCALE%/firefox/");
 pref("extensions.getAddons.langpacks.url", "https://services.addons.mozilla.org/api/v3/addons/language-tools/?app=firefox&type=language&appversion=%VERSION%");
 pref("extensions.getAddons.discovery.api_url", "https://services.addons.mozilla.org/api/v4/discovery/?lang=%LOCALE%&edition=%DISTRIBUTION%");
@@ -168,8 +168,8 @@ pref("app.update.staging.enabled", true);
 //  .. etc ..
 //
 pref("extensions.update.enabled", true);
-pref("extensions.update.url", "https://versioncheck.addons.mozilla.org/update/VersionCheck.php?reqVersion=%REQ_VERSION%&id=%ITEM_ID%&version=%ITEM_VERSION%&maxAppVersion=%ITEM_MAXAPPVERSION%&status=%ITEM_STATUS%&appID=%APP_ID%&appVersion=%APP_VERSION%&appOS=%APP_OS%&appABI=%APP_ABI%&locale=%APP_LOCALE%&currentAppVersion=%CURRENT_APP_VERSION%&updateType=%UPDATE_TYPE%&compatMode=%COMPATIBILITY_MODE%");
-pref("extensions.update.background.url", "https://versioncheck-bg.addons.mozilla.org/update/VersionCheck.php?reqVersion=%REQ_VERSION%&id=%ITEM_ID%&version=%ITEM_VERSION%&maxAppVersion=%ITEM_MAXAPPVERSION%&status=%ITEM_STATUS%&appID=%APP_ID%&appVersion=%APP_VERSION%&appOS=%APP_OS%&appABI=%APP_ABI%&locale=%APP_LOCALE%&currentAppVersion=%CURRENT_APP_VERSION%&updateType=%UPDATE_TYPE%&compatMode=%COMPATIBILITY_MODE%");
+pref("extensions.update.url", "https://versioncheck.addons.mozilla.org/update/VersionCheck.php?reqVersion=%REQ_VERSION%&id=%ITEM_ID%&version=%ITEM_VERSION%&maxAppVersion=%ITEM_MAXAPPVERSION%&status=%ITEM_STATUS%&appID=%APP_ID%&appVersion=%APP_VERSION%&appOS=Linux&appABI=%APP_ABI%&locale=%APP_LOCALE%&currentAppVersion=%CURRENT_APP_VERSION%&updateType=%UPDATE_TYPE%&compatMode=%COMPATIBILITY_MODE%");
+pref("extensions.update.background.url", "https://versioncheck-bg.addons.mozilla.org/update/VersionCheck.php?reqVersion=%REQ_VERSION%&id=%ITEM_ID%&version=%ITEM_VERSION%&maxAppVersion=%ITEM_MAXAPPVERSION%&status=%ITEM_STATUS%&appID=%APP_ID%&appVersion=%APP_VERSION%&appOS=Linux&appABI=%APP_ABI%&locale=%APP_LOCALE%&currentAppVersion=%CURRENT_APP_VERSION%&updateType=%UPDATE_TYPE%&compatMode=%COMPATIBILITY_MODE%");
 pref("extensions.update.interval", 86400);  // Check for updates to Extensions and
                                             // Themes every day
 
diff --git toolkit/mozapps/extensions/internal/AddonRepository.jsm toolkit/mozapps/extensions/internal/AddonRepository.jsm
index f70fd8d7e3bd8..81e8cd7764fdf 100644
--- toolkit/mozapps/extensions/internal/AddonRepository.jsm
+++ toolkit/mozapps/extensions/internal/AddonRepository.jsm
@@ -602,7 +602,7 @@ var AddonRepository = {
       addon.version = String(aEntry.current_version.version);
       if (Array.isArray(aEntry.current_version.files)) {
         for (let file of aEntry.current_version.files) {
-          if (file.platform == "all" || file.platform == PLATFORM) {
+          if (file.platform == "all" || file.platform == "linux" || file.platform == PLATFORM) {
             if (file.url) {
               addon.sourceURI = NetUtil.newURI(file.url);
             }
diff --git toolkit/mozapps/extensions/internal/XPIDatabase.jsm toolkit/mozapps/extensions/internal/XPIDatabase.jsm
index f70fd8d7e3bd8..81e8cd7764fdf 100644
--- toolkit/mozapps/extensions/internal/XPIDatabase.jsm
+++ toolkit/mozapps/extensions/internal/XPIDatabase.jsm
@@ -355,7 +355,7 @@ class AddonInternal {
     // Something is causing errors in here
     try {
       for (let platform of this.targetPlatforms) {
-        if (platform.os == Services.appinfo.OS) {
+        if (platform.os == "Linux" || platform.os == Services.appinfo.OS) {
           if (platform.abi) {
             needsABI = true;
             if (platform.abi === abi)


[FILE:445:patches/patch-browser_app_nsBrowserApp.cpp]
--- browser/app/nsBrowserApp.cpp.orig	2016-09-19 16:19:28 UTC
+++ browser/app/nsBrowserApp.cpp
@@ -324,6 +324,9 @@ int main(int argc, char* argv[], char* e
 {
   mozilla::TimeStamp start = mozilla::TimeStamp::Now();
 
+  setenv("MOZ_GMP_PATH", "%%LOCALBASE%%/lib/browser_plugins/symlinks/gecko", 0);
+  setenv("MOZ_PLUGIN_PATH", "%%LOCALBASE%%/lib/browser_plugins/symlinks/gecko", 0);
+
 #ifdef HAS_DLL_BLOCKLIST
   DllBlocklist_Initialize();
 


[FILE:1817:patches/patch-bug1288587]
diff --git a/build/moz.configure/init.configure b/build/moz.configure/init.configure
index 855214a..1e91d51 100644
--- build/moz.configure/init.configure
+++ build/moz.configure/init.configure
@@ -240,6 +240,7 @@ option(env='VIRTUALENV_NAME', nargs=1, default='init_p
 @imports(_from='mozbuild.pythonutil', _import='find_python3_executable')
 @imports(_from='mozbuild.pythonutil', _import='python_executable_version')
 @imports(_from='six', _import='ensure_text')
+@imports(_from='__builtin__', _import='KeyError')
 def virtualenv_python3(env_python, virtualenv_name, build_env, mozconfig, help):
     # Avoid re-executing python when running configure --help.
     if help:
@@ -273,6 +274,12 @@ def virtualenv_python3(env_python, virtualenv_name, bu
             python = mozconfig['vars']['added']['PYTHON3']
         elif 'PYTHON3' in mozconfig['vars']['modified']:
             python = mozconfig['vars']['modified']['PYTHON3'][1]
+        for i in ('env', 'vars'):
+            for j in ('added', 'modified'):
+                try:
+                    del mozconfig[i][j]['PYTHON3']
+                except KeyError:
+                    pass
 
     log.debug("python3: executable from configuration: %r" % python)
 
@@ -358,7 +365,10 @@ def virtualenv_python3(env_python, virtualenv_name, bu
             sys.executable, manager.python_path))
         log.info('Re-executing in the virtualenv')
         if env_python:
-            del os.environ['PYTHON3']
+                try:
+                    del os.environ['PYTHON3']
+                except KeyError:
+                    pass
         # Homebrew on macOS will change Python's sys.executable to a custom
         # value which messes with mach's virtualenv handling code. Override
         # Homebrew's changes with the correct sys.executable value.


[FILE:2599:patches/patch-bug1550891]
commit 965eb33c5e86
Author: Greg V <greg@unrelenting.technology>
Date:   Wed Jan 8 15:06:00 2020 -0800

    Bug 1550891 - re-add SHM_ANON support in IPC shared memory, freezing via capabilities
---
 config/system-headers.mozbuild               |  1 +
 ipc/chromium/src/base/shared_memory_posix.cc | 20 +++++++++++++++++---
 2 files changed, 18 insertions(+), 3 deletions(-)

diff --git config/system-headers.mozbuild config/system-headers.mozbuild
index 88afca1070f86..beff3e2542c9f 100644
--- config/system-headers.mozbuild
+++ config/system-headers.mozbuild
@@ -816,6 +816,7 @@ system_headers = [
     'sys/bitypes.h',
     'sys/byteorder.h',
     'syscall.h',
+    'sys/capsicum.h',
     'sys/cdefs.h',
     'sys/cfgodm.h',
     'sys/elf.h',
diff --git ipc/chromium/src/base/shared_memory_posix.cc ipc/chromium/src/base/shared_memory_posix.cc
index 0be9cce0b4bed..89e67483e4c16 100644
--- ipc/chromium/src/base/shared_memory_posix.cc
+++ ipc/chromium/src/base/shared_memory_posix.cc
@@ -16,6 +16,10 @@
 #  include "mozilla/Ashmem.h"
 #endif
 
+#ifdef __FreeBSD__
+#  include <sys/capsicum.h>
+#endif
+
 #include "base/eintr_wrapper.h"
 #include "base/logging.h"
 #include "base/string_util.h"
@@ -77,7 +81,7 @@ SharedMemoryHandle SharedMemory::NULLHandle() { return SharedMemoryHandle(); }
 
 // static
 bool SharedMemory::AppendPosixShmPrefix(std::string* str, pid_t pid) {
-#if defined(ANDROID)
+#if defined(ANDROID) || defined(__FreeBSD__)
   return false;
 #else
   *str += '/';
@@ -103,7 +107,7 @@ bool SharedMemory::AppendPosixShmPrefix(std::string* str, pid_t pid) {
   // enough for this.
   StringAppendF(str, "org.mozilla.ipc.%d.", static_cast<int>(pid));
   return true;
-#endif    // !ANDROID
+#endif    // !ANDROID && !__FreeBSD__
 }
 
 bool SharedMemory::CreateInternal(size_t size, bool freezeable) {
@@ -125,6 +129,9 @@ bool SharedMemory::CreateInternal(size_t size, bool freezeable) {
     return false;
   }
   needs_truncate = false;
+#elif defined(__FreeBSD__)
+  // FreeBSD supports anonymous shm_open
+  fd.reset(shm_open(SHM_ANON, O_RDWR, 0600));
 #else
   // Generic Unix: shm_open + shm_unlink
   do {
@@ -224,6 +231,14 @@ bool SharedMemory::ReadOnlyCopy(SharedMemory* ro_out) {
     return false;
   }
   ro_file = mapped_file_;
+#elif defined(__FreeBSD__)
+  cap_rights_t rights;
+  cap_rights_init(&rights, CAP_MMAP_R);
+  if (cap_rights_limit(mapped_file_, &rights) != 0) {
+    CHROMIUM_LOG(WARNING) << "failed to freeze shm: " << strerror(errno);
+    return false;
+  }
+  ro_file = mapped_file_;
 #else
   DCHECK(frozen_file_ >= 0);
   DCHECK(mapped_file_ >= 0);


[FILE:3590:patches/patch-bug1559213]
commit 717bba28411c
Author: Jory A. Pratt <anarchy@gentoo.org>
Date:   Thu Jun 13 11:53:00 2019 -0700

    Bug 1559213 - Allow to use system av1 libs instead of bundled.
---
 config/external/moz.build      |  5 +++--
 config/system-headers.mozbuild |  8 ++++++++
 dom/media/platforms/moz.build  |  5 +++++
 toolkit/moz.configure          | 19 ++++++++++++++++++-
 4 files changed, 34 insertions(+), 3 deletions(-)

diff --git config/external/moz.build config/external/moz.build
index 03e4fa143bd1..a67d10b11fe6 100644
--- config/external/moz.build
+++ config/external/moz.build
@@ -37,8 +37,9 @@ if not CONFIG['MOZ_SYSTEM_LIBVPX']:
     external_dirs += ['media/libvpx']
 
 if CONFIG['MOZ_AV1']:
-    external_dirs += ['media/libaom']
-    external_dirs += ['media/libdav1d']
+    if not CONFIG['MOZ_SYSTEM_AV1']:
+        external_dirs += ['media/libaom']
+        external_dirs += ['media/libdav1d']
 
 if not CONFIG['MOZ_SYSTEM_PNG']:
     external_dirs += ['media/libpng']
diff --git config/system-headers.mozbuild config/system-headers.mozbuild
index bcf5c4925564..48964a999a9b 100644
--- config/system-headers.mozbuild
+++ config/system-headers.mozbuild
@@ -1304,6 +1304,14 @@ if CONFIG['MOZ_ENABLE_CONTENTMANAGER']:
         'SelectSingleContentItemPage.h',
     ]
 
+if CONFIG['MOZ_SYSTEM_AV1']:
+    system_headers += [
+        'aom/aom_decoder.h',
+        'aom/aomdx.h',
+        'aom/aom_image.h',
+        'dav1d/dav1d.h',
+    ]
+
 if CONFIG['MOZ_SYSTEM_LIBVPX']:
     system_headers += [
         'vpx_mem/vpx_mem.h',
diff --git dom/media/platforms/moz.build dom/media/platforms/moz.build
index 092cee0c9b66..38e45de5b5f0 100644
--- dom/media/platforms/moz.build
+++ dom/media/platforms/moz.build
@@ -80,6 +80,11 @@ if CONFIG['MOZ_AV1']:
         'agnostic/AOMDecoder.cpp',
         'agnostic/DAV1DDecoder.cpp',
     ]
+    if CONFIG['MOZ_SYSTEM_AV1']:
+        CXXFLAGS += CONFIG['MOZ_SYSTEM_LIBAOM_CFLAGS']
+        OS_LIBS += CONFIG['MOZ_SYSTEM_LIBAOM_LIBS']
+        CXXFLAGS += CONFIG['MOZ_SYSTEM_LIBDAV1D_CFLAGS']
+        OS_LIBS += CONFIG['MOZ_SYSTEM_LIBDAV1D_LIBS']
 
 if CONFIG['MOZ_OMX']:
     EXPORTS += [
diff --git toolkit/moz.configure toolkit/moz.configure
index 82b5a59acf42..e2329560b42b 100644
--- toolkit/moz.configure
+++ toolkit/moz.configure
@@ -441,7 +441,23 @@ def av1(value):
     if value:
         return True
 
-@depends(target, nasm_version, when=av1 & compile_environment)
+option('--with-system-av1',
+       help="Use system av1 (located with pkgconfig)")
+
+system_libaom_info = pkg_check_modules('MOZ_SYSTEM_LIBAOM', 'aom >= 1.0.0',
+                                       when='--with-system-av1')
+
+system_libdav1d_info = pkg_check_modules('MOZ_SYSTEM_LIBDAV1D', 'dav1d >= 0.1.1',
+                                         when='--with-system-av1')
+
+@depends(system_libaom_info, system_libdav1d_info)
+def system_av1(system_libaom_info, system_libdav1d_info):
+    has_av1_libs = False
+    if system_libaom_info and system_libdav1d_info:
+        has_av1_libs = True
+    return has_av1_libs
+
+@depends(target, nasm_version, when=av1 & depends(system_av1)(lambda v: not v) & compile_environment)
 def dav1d_asm(target, nasm_version):
     if target.os != 'Android':
         if target.cpu == 'aarch64':
@@ -457,6 +473,7 @@ set_config('MOZ_DAV1D_ASM', dav1d_asm)
 set_define('MOZ_DAV1D_ASM', dav1d_asm)
 set_config('MOZ_AV1', av1)
 set_define('MOZ_AV1', av1)
+set_config('MOZ_SYSTEM_AV1', depends_if(system_av1)(lambda _: True))
 
 # Built-in fragmented MP4 support.
 # ==============================================================


[FILE:1254:patches/patch-bug1618914]
[Wayland] Fall back to ftruncate if posix_fallocate isn't supported by filesystem.

diff --git widget/gtk/WindowSurfaceWayland.cpp widget/gtk/WindowSurfaceWayland.cpp
index 9a73326399bd5..9e42a7f1c5d18 100644
--- widget/gtk/WindowSurfaceWayland.cpp
+++ widget/gtk/WindowSurfaceWayland.cpp
@@ -222,20 +222,21 @@ static int WaylandAllocateShmMemory(int aSize) {
 #ifdef HAVE_POSIX_FALLOCATE
   do {
     ret = posix_fallocate(fd, 0, aSize);
   } while (ret == EINTR);
-  if (ret != 0) {
+  if (ret == 0) {
+    return fd;
+  } else if (ret != ENODEV && ret != EINVAL && ret != EOPNOTSUPP) {
     close(fd);
     MOZ_CRASH("posix_fallocate() fails to allocate shm memory");
   }
-#else
+#endif
   do {
     ret = ftruncate(fd, aSize);
   } while (ret < 0 && errno == EINTR);
   if (ret < 0) {
     close(fd);
     MOZ_CRASH("ftruncate() fails to allocate shm memory");
   }
-#endif
 
   return fd;
 }
@@ -265,8 +266,8 @@ bool WaylandShmPool::Resize(int aSize) {
 #ifdef HAVE_POSIX_FALLOCATE
   do {
     errno = posix_fallocate(mShmPoolFd, 0, aSize);
   } while (errno == EINTR);
-  if (errno != 0) return false;
+  if (errno != 0 && errno != ENODEV && errno != EINVAL && errno != EOPNOTSUPP) return false;
 #endif
 
   wl_shm_pool_resize(mShmPool, aSize);


[FILE:2015:patches/patch-bug1659612]
media/libcubeb/src/cubeb_alsa.c:613:9: error: implicitly declaring library function 'snprintf' with type 'int (char *, unsigned int, const char *, ...)' [-Werror,-Wimplicit-function-declaration]
    r = snprintf(node_name, sizeof(node_name), "pcm.%s", string);
        ^
media/libcubeb/src/cubeb_alsa.c:613:9: note: include the header <stdio.h> or explicitly provide a declaration for 'snprintf'
media/libcubeb/src/cubeb_alsa.c:1168:3: error: implicitly declaring library function 'alloca' with type 'void *(unsigned int)' [-Werror,-Wimplicit-function-declaration]
  snd_pcm_hw_params_alloca(&hw_params);
  ^
/usr/local/include/alsa/pcm.h:737:39: note: expanded from macro 'snd_pcm_hw_params_alloca'
#define snd_pcm_hw_params_alloca(ptr) __snd_alloca(ptr, snd_pcm_hw_params)
                                      ^
/usr/local/include/alsa/global.h:106:57: note: expanded from macro '__snd_alloca'
#define __snd_alloca(ptr,type) do { *ptr = (type##_t *) alloca(type##_sizeof()); memset(*ptr, 0, type##_sizeof()); } while (0)
                                                        ^
media/libcubeb/src/cubeb_alsa.c:1168:3: note: include the header <stdlib.h> or explicitly provide a declaration for 'alloca'
/usr/local/include/alsa/pcm.h:737:39: note: expanded from macro 'snd_pcm_hw_params_alloca'
#define snd_pcm_hw_params_alloca(ptr) __snd_alloca(ptr, snd_pcm_hw_params)
                                      ^
/usr/local/include/alsa/global.h:106:57: note: expanded from macro '__snd_alloca'
#define __snd_alloca(ptr,type) do { *ptr = (type##_t *) alloca(type##_sizeof()); memset(*ptr, 0, type##_sizeof()); } while (0)
                                                        ^
2 errors generated.

--- media/libcubeb/src/cubeb_alsa.c~
+++ media/libcubeb/src/cubeb_alsa.c
@@ -5,9 +5,7 @@
  * accompanying file LICENSE for details.
  */
 #undef NDEBUG
-#define _DEFAULT_SOURCE
-#define _BSD_SOURCE
-#define _XOPEN_SOURCE 500
+#define _GNU_SOURCE 1
 #include <pthread.h>
 #include <sys/time.h>
 #include <assert.h>


[FILE:9904:patches/patch-bug847568]
# Allow building against system-wide graphite2/harfbuzz.

diff --git config/system-headers.mozbuild config/system-headers.mozbuild
index 7620b4d00623..09d3db5ca8c0 100644
--- config/system-headers.mozbuild
+++ config/system-headers.mozbuild
@@ -1299,6 +1299,19 @@ if CONFIG['MOZ_ENABLE_LIBPROXY']:
         'proxy.h',
     ]
 
+if CONFIG['MOZ_SYSTEM_GRAPHITE2']:
+    system_headers += [
+        'graphite2/Font.h',
+        'graphite2/Segment.h',
+    ]
+
+if CONFIG['MOZ_SYSTEM_HARFBUZZ']:
+    system_headers += [
+        'harfbuzz/hb-glib.h',
+        'harfbuzz/hb-ot.h',
+        'harfbuzz/hb.h',
+    ]
+
 if CONFIG['MOZ_SYSTEM_LIBVPX']:
     system_headers += [
         'vpx_mem/vpx_mem.h',
diff --git dom/base/moz.build dom/base/moz.build
index 8e19020315ae..2fcdbb6f7b42 100644
--- dom/base/moz.build
+++ dom/base/moz.build
@@ -543,6 +543,9 @@ if CONFIG['MOZ_BUILD_APP'] in ['browser', 'mobile/android', 'xulrunner']:
 if CONFIG['MOZ_X11']:
     CXXFLAGS += CONFIG['TK_CFLAGS']
 
+if CONFIG['MOZ_SYSTEM_HARFBUZZ']:
+    CXXFLAGS += CONFIG['MOZ_HARFBUZZ_CFLAGS']
+
 GeneratedFile('UseCounterList.h', script='gen-usecounters.py',
               entry_point='use_counter_list', inputs=['UseCounters.conf'])
 
diff --git gfx/graphite2/geckoextra/moz.build gfx/graphite2/geckoextra/moz.build
new file mode 100644
index 0000000000000..24e8d7a03274a
--- /dev/null
+++ gfx/graphite2/geckoextra/moz.build
@@ -0,0 +1,21 @@
+# -*- Mode: python; indent-tabs-mode: nil; tab-width: 40 -*-
+# vim: set filetype=python:
+# This Source Code Form is subject to the terms of the Mozilla Public
+# License, v. 2.0. If a copy of the MPL was not distributed with this
+# file, You can obtain one at http://mozilla.org/MPL/2.0/.
+
+EXPORTS.graphite2 += [
+    'include/GraphiteExtra.h',
+    'include/GraphiteStructsForRLBox.h',
+]
+
+UNIFIED_SOURCES += [
+    '../geckoextra/src/GraphiteExtra.cpp',
+]
+
+CXXFLAGS += CONFIG['MOZ_GRAPHITE2_CFLAGS']
+
+# Match bundled graphite2 configuration
+AllowCompilerWarnings()
+
+FINAL_LIBRARY = 'gkmedias'
diff --git gfx/graphite2/moz-gr-update.sh gfx/graphite2/moz-gr-update.sh
index faaab1b17971..04eff5f09882 100644
--- gfx/graphite2/moz-gr-update.sh
+++ gfx/graphite2/moz-gr-update.sh
@@ -1,6 +1,7 @@
 #!/bin/bash
 
 # Script used to update the Graphite2 library in the mozilla source tree
+# and bump version for --with-system-graphite2
 
 # This script lives in gfx/graphite2, along with the library source,
 # but must be run from the top level of the mozilla-central tree.
@@ -37,12 +38,16 @@ echo "See" $0 "for update procedure." >> gfx/graphite2/README.mozilla
 #find gfx/graphite2/ -name "*.cpp" -exec perl -p -i -e "s/<cstdio>/<stdio.h>/;s/Windows.h/windows.h/;" {} \;
 #find gfx/graphite2/ -name "*.h" -exec perl -p -i -e "s/<cstdio>/<stdio.h>/;s/Windows.h/windows.h/;" {} \;
 
+# chase version for --with-system-graphite2
+perl -p -i -e "s/[0-9]+\,[0-9]+\,[0-9]+/$RELEASE/ and tr/./,/ \
+  if /GR2_VERSION_REQUIRE/" old-configure.in
+
 # summarize what's been touched
 echo Updated to $RELEASE.
 echo Here is what changed in the gfx/graphite2 directory:
 echo
 
-hg stat gfx/graphite2
+hg stat old-configure.in gfx/graphite2
 
 echo
 echo If gfx/graphite2/src/files.mk has changed, please make corresponding
diff --git gfx/harfbuzz/README-mozilla gfx/harfbuzz/README-mozilla
index 22c76a7df020..a01490bd49ee 100644
--- gfx/harfbuzz/README-mozilla
+++ gfx/harfbuzz/README-mozilla
@@ -15,3 +15,8 @@ from within the gfx/harfbuzz directory.
 
 If the collection of source files changes, manual updates to moz.build may be
 needed as we don't use the upstream makefiles.
+
+The in-tree copy may be omitted during build by --with-system-harfbuzz.
+Make sure to keep pkg-config version check within toolkit/moz.configure in sync
+with checkout version or increment latest tag by one if it's not based
+on upstream release.
diff --git gfx/moz.build gfx/moz.build
index 771f652e837a..3b358d84e384 100644
--- gfx/moz.build
+++ gfx/moz.build
@@ -13,6 +13,14 @@ with Files('wr/**'):
 if CONFIG['MOZ_TREE_CAIRO']:
     DIRS += ['cairo']
 
+if CONFIG['MOZ_SYSTEM_GRAPHITE2']:
+    DIRS += ['graphite2/geckoextra']
+else:
+    DIRS += ['graphite2/src' ]
+
+if not CONFIG['MOZ_SYSTEM_HARFBUZZ']:
+    DIRS += ['harfbuzz/src']
+
 DIRS += [
     '2d',
     'ycbcr',
@@ -21,8 +29,6 @@ DIRS += [
     'qcms',
     'gl',
     'layers',
-    'graphite2/src',
-    'harfbuzz/src',
     'ots/src',
     'thebes',
     'ipc',
diff --git gfx/skia/generate_mozbuild.py gfx/skia/generate_mozbuild.py
index e06ae3457a47..93faa61594a3 100755
--- gfx/skia/generate_mozbuild.py
+++ gfx/skia/generate_mozbuild.py
@@ -117,6 +117,9 @@ if CONFIG['CC_TYPE'] in ('clang', 'clang-cl'):
         '-Wno-unused-private-field',
     ]
 
+if CONFIG['MOZ_SYSTEM_HARFBUZZ']:
+    CXXFLAGS += CONFIG['MOZ_HARFBUZZ_CFLAGS']
+
 if CONFIG['MOZ_WIDGET_TOOLKIT'] in ('gtk', 'android'):
     CXXFLAGS += CONFIG['MOZ_CAIRO_CFLAGS']
     CXXFLAGS += CONFIG['CAIRO_FT_CFLAGS']
diff --git gfx/skia/moz.build gfx/skia/moz.build
index 2118677ca3a8..e4978b413784 100644
--- gfx/skia/moz.build
+++ gfx/skia/moz.build
@@ -493,6 +493,9 @@ if CONFIG['CC_TYPE'] in ('clang', 'clang-cl'):
         '-Wno-unused-private-field',
     ]
 
+if CONFIG['MOZ_SYSTEM_HARFBUZZ']:
+    CXXFLAGS += CONFIG['MOZ_HARFBUZZ_CFLAGS']
+
 if CONFIG['MOZ_WIDGET_TOOLKIT'] in ('gtk', 'android'):
     CXXFLAGS += CONFIG['MOZ_CAIRO_CFLAGS']
     CXXFLAGS += CONFIG['CAIRO_FT_CFLAGS']
diff --git gfx/thebes/moz.build gfx/thebes/moz.build
index 56f1b9fe3f4b..0ac1100b0df3 100644
--- gfx/thebes/moz.build
+++ gfx/thebes/moz.build
@@ -284,7 +284,13 @@ if CONFIG['MOZ_WAYLAND']:
 
 LOCAL_INCLUDES += CONFIG['SKIA_INCLUDES']
 
-DEFINES['GRAPHITE2_STATIC'] = True
+if CONFIG['MOZ_SYSTEM_GRAPHITE2']:
+    CXXFLAGS += CONFIG['MOZ_GRAPHITE2_CFLAGS']
+else:
+    DEFINES['GRAPHITE2_STATIC'] = True
+
+if CONFIG['MOZ_SYSTEM_HARFBUZZ']:
+    CXXFLAGS += CONFIG['MOZ_HARFBUZZ_CFLAGS']
 
 if CONFIG['CC_TYPE'] == 'clang':
     # Suppress warnings from Skia header files.
diff --git intl/unicharutil/util/moz.build intl/unicharutil/util/moz.build
index cb1233c56d7e..06fb1f9f174b 100644
--- intl/unicharutil/util/moz.build
+++ intl/unicharutil/util/moz.build
@@ -25,4 +25,7 @@ UNIFIED_SOURCES += [
     'nsUnicodeProperties.cpp',
 ]
 
+if CONFIG['MOZ_SYSTEM_HARFBUZZ']:
+    CXXFLAGS += CONFIG['MOZ_HARFBUZZ_CFLAGS']
+
 FINAL_LIBRARY = 'xul'
diff --git netwerk/dns/moz.build netwerk/dns/moz.build
index 79c26e3e7001..c4d93bc5f7dc 100644
--- netwerk/dns/moz.build
+++ netwerk/dns/moz.build
@@ -86,3 +86,6 @@ USE_LIBS += ['icu']
 
 if CONFIG['CC_TYPE'] in ('clang', 'gcc'):
     CXXFLAGS += ['-Wno-error=shadow']
+
+if CONFIG['MOZ_SYSTEM_HARFBUZZ']:
+    CXXFLAGS += CONFIG['MOZ_HARFBUZZ_CFLAGS']
diff --git old-configure.in old-configure.in
index 95a58b634593..b614eef85c89 100644
--- old-configure.in
+++ old-configure.in
@@ -2639,6 +2639,27 @@ dnl ========================================================
 
 AC_SUBST(MOZ_LINUX_32_SSE2_STARTUP_ERROR)
 
+dnl ========================================================
+dnl Check for graphite2
+dnl ========================================================
+if test -n "$MOZ_SYSTEM_GRAPHITE2"; then
+    dnl graphite2.pc has bogus version, check manually
+    _SAVE_CFLAGS=$CFLAGS
+    CFLAGS="$CFLAGS $MOZ_GRAPHITE2_CFLAGS"
+    AC_TRY_COMPILE([ #include <graphite2/Font.h>
+                     #define GR2_VERSION_REQUIRE(major,minor,bugfix)  \
+                             ( GR2_VERSION_MAJOR * 10000 + GR2_VERSION_MINOR \
+                               * 100 + GR2_VERSION_BUGFIX >= \
+                               (major) * 10000 + (minor) * 100 + (bugfix) )
+                   ], [
+                     #if !GR2_VERSION_REQUIRE(1,3,14)
+                     #error "Insufficient graphite2 version."
+                     #endif
+                   ], [],
+                   [AC_MSG_ERROR([--with-system-graphite2 requested but no working libgraphite2 found])])
+    CFLAGS=$_SAVE_CFLAGS
+fi
+
 dnl ========================================================
 dnl Check for pixman and cairo
 dnl ========================================================
diff --git toolkit/library/moz.build toolkit/library/moz.build
index 24f940e1ed7e..079a575adec3 100644
--- toolkit/library/moz.build
+++ toolkit/library/moz.build
@@ -248,6 +248,12 @@ if CONFIG['MOZ_SYSTEM_PNG']:
 if CONFIG['MOZ_SYSTEM_WEBP']:
     OS_LIBS += CONFIG['MOZ_WEBP_LIBS']
 
+if CONFIG['MOZ_SYSTEM_GRAPHITE2']:
+    OS_LIBS += CONFIG['MOZ_GRAPHITE2_LIBS']
+
+if CONFIG['MOZ_SYSTEM_HARFBUZZ']:
+    OS_LIBS += CONFIG['MOZ_HARFBUZZ_LIBS']
+
 if CONFIG['MOZ_SYSTEM_LIBEVENT']:
     OS_LIBS += CONFIG['MOZ_LIBEVENT_LIBS']
 
diff --git toolkit/moz.configure toolkit/moz.configure
index 9297e4d6f501..d8e273887e4b 100644
--- toolkit/moz.configure
+++ toolkit/moz.configure
@@ -937,6 +937,25 @@ add_old_configure_assignment('FT2_LIBS',
 add_old_configure_assignment('FT2_CFLAGS',
                              ft2_info.cflags)
 
+# Graphite2
+# ==============================================================
+option('--with-system-graphite2',
+       help="Use system graphite2 (located with pkgconfig)")
+
+system_graphite2 = pkg_check_modules('MOZ_GRAPHITE2', 'graphite2',
+                                     when='--with-system-graphite2')
+
+set_config('MOZ_SYSTEM_GRAPHITE2', depends_if(system_graphite2)(lambda _: True))
+
+# HarfBuzz
+# ==============================================================
+option('--with-system-harfbuzz',
+       help="Use system harfbuzz (located with pkgconfig)")
+
+system_harfbuzz = pkg_check_modules('MOZ_HARFBUZZ', 'harfbuzz >= 2.6.8',
+                                    when='--with-system-harfbuzz')
+
+set_config('MOZ_SYSTEM_HARFBUZZ', depends_if(system_harfbuzz)(lambda _: True))
 
 # Remote agent (part of CDP based remote protocol)
 # ==============================================================


[FILE:335:patches/patch-config_makefiles_rust.mk]
--- config/makefiles/rust.mk.orig	2020-07-08 19:27:08 UTC
+++ config/makefiles/rust.mk
@@ -61,7 +61,7 @@ ifndef MOZ_DEBUG_RUST
 # Enable link-time optimization for release builds, but not when linking
 # gkrust_gtest.
 ifeq (,$(findstring gkrust_gtest,$(RUST_LIBRARY_FILE)))
-cargo_rustc_flags += -Clto
+do_nada =
 endif
 endif
 endif


[FILE:32650:patches/patch-cubeb-oss]
https://github.com/kinetiknz/cubeb/pull/600

--- dom/media/CubebUtils.cpp.orig	2020-08-19 02:08:51 UTC
+++ dom/media/CubebUtils.cpp
@@ -126,7 +126,7 @@ const char kBrandBundleURL[] = "chrome://branding/locale/brand.properties";
 
 const char* AUDIOSTREAM_BACKEND_ID_STR[] = {
     "jack",  "pulse",       "alsa",  "audiounit", "audioqueue", "wasapi",
-    "winmm", "directsound", "sndio", "opensl",    "audiotrack", "kai"};
+    "winmm", "directsound", "sndio", "opensl", "oss", "audiotrack", "kai"};
 /* Index for failures to create an audio stream the first time. */
 const int CUBEB_BACKEND_INIT_FAILURE_FIRST =
     ArrayLength(AUDIOSTREAM_BACKEND_ID_STR);
--- media/libcubeb/src/moz.build.orig	2020-08-19 02:09:19 UTC
+++ media/libcubeb/src/moz.build
@@ -40,6 +40,12 @@ if CONFIG['MOZ_JACK']:
     ]
     DEFINES['USE_JACK'] = True
 
+if CONFIG['OS_ARCH'] in ('DragonFly', 'FreeBSD', 'SunOS'):
+    SOURCES += [
+        'cubeb_oss.c',
+    ]
+    DEFINES['USE_OSS'] = True
+
 if CONFIG['OS_ARCH'] == 'OpenBSD':
     SOURCES += [
         'cubeb_sndio.c',
--- media/libcubeb/src/cubeb.c.orig	2020-08-19 02:09:26 UTC
+++ media/libcubeb/src/cubeb.c
@@ -60,6 +60,9 @@ int sun_init(cubeb ** context, char const * context_name);
 #if defined(USE_OPENSL)
 int opensl_init(cubeb ** context, char const * context_name);
 #endif
+#if defined(USE_OSS)
+int oss_init(cubeb ** context, char const * context_name);
+#endif
 #if defined(USE_AUDIOTRACK)
 int audiotrack_init(cubeb ** context, char const * context_name);
 #endif
@@ -165,6 +168,10 @@ cubeb_init(cubeb ** context, char const * context_name, char const * backend_nam
 #if defined(USE_OPENSL)
       init_oneshot = opensl_init;
 #endif
+    } else if (!strcmp(backend_name, "oss")) {
+#if defined(USE_OSS)
+      init_oneshot = oss_init;
+#endif
     } else if (!strcmp(backend_name, "audiotrack")) {
 #if defined(USE_AUDIOTRACK)
       init_oneshot = audiotrack_init;
@@ -200,6 +207,9 @@ cubeb_init(cubeb ** context, char const * context_name, char const * backend_nam
 #if defined(USE_ALSA)
     alsa_init,
 #endif
+#if defined (USE_OSS)
+    oss_init,
+#endif
 #if defined(USE_AUDIOUNIT_RUST)
     audiounit_rust_init,
 #endif
--- /dev/null
+++ media/libcubeb/src/cubeb_oss.c
@@ -0,0 +1,1130 @@
+/*
+ * Copyright © 2019-2020 Nia Alarie <nia@NetBSD.org>
+ * Copyright © 2020 Ka Ho Ng <khng300@gmail.com>
+ *
+ * This program is made available under an ISC-style license.  See the
+ * accompanying file LICENSE for details.
+ */
+
+#if defined(__FreeBSD__) && __FreeBSD__ < 12
+#define _WITH_GETLINE
+#endif
+#include <assert.h>
+#include <ctype.h>
+#include <errno.h>
+#include <sys/types.h>
+#include <sys/soundcard.h>
+#include <sys/ioctl.h>
+#include <fcntl.h>
+#include <unistd.h>
+#include <pthread.h>
+#include <stdbool.h>
+#include <stdlib.h>
+#include <stdio.h>
+#include <string.h>
+#include <poll.h>
+#include "cubeb/cubeb.h"
+#include "cubeb_mixer.h"
+#include "cubeb_strings.h"
+#include "cubeb-internal.h"
+
+/* Supported well by most hardware. */
+#ifndef OSS_PREFER_RATE
+#define OSS_PREFER_RATE (48000)
+#endif
+
+/* Standard acceptable minimum. */
+#ifndef OSS_LATENCY_MS
+#define OSS_LATENCY_MS (40)
+#endif
+
+#ifndef OSS_DEFAULT_DEVICE
+#define OSS_DEFAULT_DEVICE "/dev/dsp"
+#endif
+
+#ifndef OSS_DEFAULT_MIXER
+#define OSS_DEFAULT_MIXER "/dev/mixer"
+#endif
+
+#ifndef OSS_DEFAULT_NFRAMES
+#define OSS_DEFAULT_NFRAMES (32)
+#endif
+
+#define ENV_AUDIO_DEVICE "AUDIO_DEVICE"
+
+#ifndef OSS_MAX_CHANNELS
+# if defined(__FreeBSD__) || defined(__DragonFly__)
+/*
+ * The current maximum number of channels supported
+ * on FreeBSD is 8.
+ *
+ * Reference: FreeBSD 12.1-RELEASE
+ */
+#  define OSS_MAX_CHANNELS (8)
+# elif defined(__sun__)
+/*
+ * The current maximum number of channels supported
+ * on Illumos is 16.
+ *
+ * Reference: PSARC 2008/318
+ */
+#  define OSS_MAX_CHANNELS (16)
+# else
+#  define OSS_MAX_CHANNELS (2)
+# endif
+#endif
+
+#if defined(__FreeBSD__) || defined(__DragonFly__)
+#define SNDSTAT_BEGIN_STR "Installed devices:"
+#define SNDSTAT_USER_BEGIN_STR "Installed devices from userspace:"
+#define SNDSTAT_FV_BEGIN_STR "File Versions:"
+#endif
+
+static struct cubeb_ops const oss_ops;
+
+struct cubeb {
+  struct cubeb_ops const * ops;
+
+  /* Our intern string store */
+  cubeb_strings *devid_strs;
+};
+
+struct oss_stream {
+  oss_devnode_t name;
+  int fd;
+  void * buf;
+
+  struct stream_info {
+    int channels;
+    int sample_rate;
+    int fmt;
+    int precision;
+  } info;
+
+  unsigned int frame_size; /* precision in bytes * channels */
+  bool floating;
+};
+
+struct cubeb_stream {
+  struct cubeb * context;
+  void * user_ptr;
+  pthread_t thread;
+  pthread_mutex_t mutex; /* protects running, volume, frames_written */
+  bool running;
+  float volume;
+  struct oss_stream play;
+  struct oss_stream record;
+  cubeb_data_callback data_cb;
+  cubeb_state_callback state_cb;
+  uint64_t frames_written;
+  unsigned int nfr; /* Number of frames allocated */
+};
+
+int
+oss_init(cubeb **context, char const *context_name) {
+  cubeb * c;
+
+  (void)context_name;
+  if ((c = calloc(1, sizeof(cubeb))) == NULL) {
+    return CUBEB_ERROR;
+  }
+  if (cubeb_strings_init(&c->devid_strs) == CUBEB_ERROR) {
+    free(c);
+    return CUBEB_ERROR;
+  }
+  c->ops = &oss_ops;
+  *context = c;
+  return CUBEB_OK;
+}
+
+static void
+oss_destroy(cubeb * context)
+{
+  cubeb_strings_destroy(context->devid_strs);
+  free(context);
+}
+
+static char const *
+oss_get_backend_id(cubeb * context)
+{
+  return "oss";
+}
+
+static int
+oss_get_preferred_sample_rate(cubeb * context, uint32_t * rate)
+{
+  (void)context;
+
+  *rate = OSS_PREFER_RATE;
+  return CUBEB_OK;
+}
+
+static int
+oss_get_max_channel_count(cubeb * context, uint32_t * max_channels)
+{
+  (void)context;
+
+  *max_channels = OSS_MAX_CHANNELS;
+  return CUBEB_OK;
+}
+
+static int
+oss_get_min_latency(cubeb * context, cubeb_stream_params params,
+                    uint32_t * latency_frames)
+{
+  (void)context;
+
+  *latency_frames = OSS_LATENCY_MS * params.rate / 1000;
+  return CUBEB_OK;
+}
+
+static void
+oss_free_cubeb_device_info_strings(cubeb_device_info *cdi)
+{
+  free((char *)cdi->device_id);
+  free((char *)cdi->friendly_name);
+  free((char *)cdi->group_id);
+  cdi->device_id = NULL;
+  cdi->friendly_name = NULL;
+  cdi->group_id = NULL;
+}
+
+#if defined(__FreeBSD__) || defined(__DragonFly__)
+/*
+ * Check if the specified DSP is okay for the purpose specified
+ * in type. Here type can only specify one operation each time
+ * this helper is called.
+ *
+ * Return 0 if OK, otherwise 1.
+ */
+static int
+oss_probe_open(const char *dsppath, cubeb_device_type type,
+               int *fdp, oss_audioinfo *resai)
+{
+  oss_audioinfo ai;
+  int error;
+  int oflags = (type == CUBEB_DEVICE_TYPE_INPUT) ? O_RDONLY : O_WRONLY;
+  int dspfd = open(dsppath, oflags);
+  if (dspfd == -1)
+    return 1;
+
+  ai.dev = -1;
+  error = ioctl(dspfd, SNDCTL_AUDIOINFO, &ai);
+  if (error < 0) {
+    close(dspfd);
+    return 1;
+  }
+
+  if (resai)
+    *resai = ai;
+  if (fdp)
+    *fdp = dspfd;
+  else
+    close(dspfd);
+  return 0;
+}
+
+struct sndstat_info {
+  oss_devnode_t devname;
+  const char *desc;
+  cubeb_device_type type;
+  int preferred;
+};
+
+static int
+oss_sndstat_line_parse(char *line, int is_ud, struct sndstat_info *sinfo)
+{
+    char *matchptr = line, *n = NULL;
+    struct sndstat_info res;
+
+    memset(&res, 0, sizeof(res));
+
+    n = strchr(matchptr, ':');
+    if (n == NULL)
+      goto fail;
+    if (is_ud == 0) {
+      unsigned int devunit;
+
+      if (sscanf(matchptr, "pcm%u: ", &devunit) < 1)
+        goto fail;
+
+      if (snprintf(res.devname, sizeof(res.devname), "/dev/dsp%u", devunit) < 1)
+        goto fail;
+    } else {
+      if (n - matchptr >= (ssize_t)(sizeof(res.devname) - strlen("/dev/")))
+        goto fail;
+
+      strlcpy(res.devname, "/dev/", sizeof(res.devname));
+      strncat(res.devname, matchptr, n - matchptr);
+    }
+    matchptr = n + 1;
+
+    n = strchr(matchptr, '<');
+    if (n == NULL)
+      goto fail;
+    matchptr = n + 1;
+    n = strrchr(matchptr, '>');
+    if (n == NULL)
+      goto fail;
+    *n = 0;
+    res.desc = matchptr;
+    matchptr = n + 1;
+
+    n = strchr(matchptr, '(');
+    if (n == NULL)
+      goto fail;
+    matchptr = n + 1;
+    n = strrchr(matchptr, ')');
+    if (n == NULL)
+      goto fail;
+    *n = 0;
+    if (!isdigit(matchptr[0])) {
+      if (strstr(matchptr, "play") != NULL)
+        res.type |= CUBEB_DEVICE_TYPE_OUTPUT;
+      if (strstr(matchptr, "rec") != NULL)
+        res.type |= CUBEB_DEVICE_TYPE_INPUT;
+    } else {
+      int p, r;
+      if (sscanf(matchptr, "%dp:%*dv/%dr:%*dv", &p, &r) != 2)
+        goto fail;
+      if (p > 0)
+        res.type |= CUBEB_DEVICE_TYPE_OUTPUT;
+      if (r > 0)
+        res.type |= CUBEB_DEVICE_TYPE_INPUT;
+    }
+    matchptr = n + 1;
+    if (strstr(matchptr, "default") != NULL)
+      res.preferred = 1;
+
+    *sinfo = res;
+    return 0;
+
+fail:
+    return 1;
+}
+
+/*
+ * XXX: On FreeBSD we have to rely on SNDCTL_CARDINFO to get all
+ * the usable audio devices currently, as SNDCTL_AUDIOINFO will
+ * never return directly usable audio device nodes.
+ */
+static int
+oss_enumerate_devices(cubeb * context, cubeb_device_type type,
+                      cubeb_device_collection * collection)
+{
+  cubeb_device_info *devinfop = NULL;
+  char *line = NULL;
+  size_t linecap = 0;
+  FILE *sndstatfp = NULL;
+  int collection_cnt = 0;
+  int is_ud = 0;
+  int skipall = 0;
+
+  devinfop = calloc(1, sizeof(cubeb_device_info));
+  if (devinfop == NULL)
+    goto fail;
+
+  sndstatfp = fopen("/dev/sndstat", "r");
+  if (sndstatfp == NULL)
+    goto fail;
+  while (getline(&line, &linecap, sndstatfp) > 0) {
+    const char *devid = NULL;
+    struct sndstat_info sinfo;
+    oss_audioinfo ai;
+
+    if (!strncmp(line, SNDSTAT_FV_BEGIN_STR, strlen(SNDSTAT_FV_BEGIN_STR))) {
+      skipall = 1;
+      continue;
+    }
+    if (!strncmp(line, SNDSTAT_BEGIN_STR, strlen(SNDSTAT_BEGIN_STR))) {
+      is_ud = 0;
+      skipall = 0;
+      continue;
+    }
+    if (!strncmp(line, SNDSTAT_USER_BEGIN_STR, strlen(SNDSTAT_USER_BEGIN_STR))) {
+      is_ud = 1;
+      skipall = 0;
+      continue;
+    }
+    if (skipall || isblank(line[0]))
+      continue;
+
+    if (oss_sndstat_line_parse(line, is_ud, &sinfo))
+      continue;
+
+    devinfop[collection_cnt].type = 0;
+    switch (sinfo.type) {
+    case CUBEB_DEVICE_TYPE_INPUT:
+      if (type & CUBEB_DEVICE_TYPE_OUTPUT)
+        continue;
+      break;
+    case CUBEB_DEVICE_TYPE_OUTPUT:
+      if (type & CUBEB_DEVICE_TYPE_INPUT)
+        continue;
+      break;
+    case 0:
+      continue;
+    }
+
+    if (oss_probe_open(sinfo.devname, type, NULL, &ai))
+      continue;
+
+    devid = cubeb_strings_intern(context->devid_strs, sinfo.devname);
+    if (devid == NULL)
+      continue;
+
+    devinfop[collection_cnt].device_id = strdup(sinfo.devname);
+    asprintf((char **)&devinfop[collection_cnt].friendly_name, "%s: %s",
+             sinfo.devname, sinfo.desc);
+    devinfop[collection_cnt].group_id = strdup(sinfo.devname);
+    devinfop[collection_cnt].vendor_name = NULL;
+    if (devinfop[collection_cnt].device_id == NULL ||
+        devinfop[collection_cnt].friendly_name == NULL ||
+        devinfop[collection_cnt].group_id == NULL) {
+      oss_free_cubeb_device_info_strings(&devinfop[collection_cnt]);
+      continue;
+    }
+
+    devinfop[collection_cnt].type = type;
+    devinfop[collection_cnt].devid = devid;
+    devinfop[collection_cnt].state = CUBEB_DEVICE_STATE_ENABLED;
+    devinfop[collection_cnt].preferred =
+        (sinfo.preferred) ? CUBEB_DEVICE_PREF_ALL : CUBEB_DEVICE_PREF_NONE;
+    devinfop[collection_cnt].format = CUBEB_DEVICE_FMT_S16NE;
+    devinfop[collection_cnt].default_format = CUBEB_DEVICE_FMT_S16NE;
+    devinfop[collection_cnt].max_channels = ai.max_channels;
+    devinfop[collection_cnt].default_rate = OSS_PREFER_RATE;
+    devinfop[collection_cnt].max_rate = ai.max_rate;
+    devinfop[collection_cnt].min_rate = ai.min_rate;
+    devinfop[collection_cnt].latency_lo = 0;
+    devinfop[collection_cnt].latency_hi = 0;
+
+    collection_cnt++;
+
+    void *newp = reallocarray(devinfop, collection_cnt + 1,
+                              sizeof(cubeb_device_info));
+    if (newp == NULL)
+      goto fail;
+    devinfop = newp;
+  }
+
+  free(line);
+  fclose(sndstatfp);
+
+  collection->count = collection_cnt;
+  collection->device = devinfop;
+
+  return CUBEB_OK;
+
+fail:
+  free(line);
+  if (sndstatfp)
+    fclose(sndstatfp);
+  free(devinfop);
+  return CUBEB_ERROR;
+}
+
+#else
+
+static int
+oss_enumerate_devices(cubeb * context, cubeb_device_type type,
+                      cubeb_device_collection * collection)
+{
+  oss_sysinfo si;
+  int error, i;
+  cubeb_device_info *devinfop = NULL;
+  int collection_cnt = 0;
+  int mixer_fd = -1;
+
+  mixer_fd = open(OSS_DEFAULT_MIXER, O_RDWR);
+  if (mixer_fd == -1) {
+    LOG("Failed to open mixer %s. errno: %d", OSS_DEFAULT_MIXER, errno);
+    return CUBEB_ERROR;
+  }
+
+  error = ioctl(mixer_fd, SNDCTL_SYSINFO, &si);
+  if (error) {
+    LOG("Failed to run SNDCTL_SYSINFO on mixer %s. errno: %d", OSS_DEFAULT_MIXER, errno);
+    goto fail;
+  }
+
+  devinfop = calloc(si.numaudios, sizeof(cubeb_device_info));
+  if (devinfop == NULL)
+    goto fail;
+
+  collection->count = 0;
+  for (i = 0; i < si.numaudios; i++) {
+    oss_audioinfo ai;
+    cubeb_device_info cdi = { 0 };
+    const char *devid = NULL;
+
+    ai.dev = i;
+    error = ioctl(mixer_fd, SNDCTL_AUDIOINFO, &ai);
+    if (error)
+      goto fail;
+
+    assert(ai.dev < si.numaudios);
+    if (!ai.enabled)
+      continue;
+
+    cdi.type = 0;
+    switch (ai.caps & DSP_CAP_DUPLEX) {
+    case DSP_CAP_INPUT:
+      if (type & CUBEB_DEVICE_TYPE_OUTPUT)
+        continue;
+      break;
+    case DSP_CAP_OUTPUT:
+      if (type & CUBEB_DEVICE_TYPE_INPUT)
+        continue;
+      break;
+    case 0:
+      continue;
+    }
+    cdi.type = type;
+
+    devid = cubeb_strings_intern(context->devid_strs, ai.devnode);
+    cdi.device_id = strdup(ai.name);
+    cdi.friendly_name = strdup(ai.name);
+    cdi.group_id = strdup(ai.name);
+    if (devid == NULL || cdi.device_id == NULL || cdi.friendly_name == NULL ||
+        cdi.group_id == NULL) {
+      oss_free_cubeb_device_info_strings(&cdi);
+      continue;
+    }
+
+    cdi.devid = devid;
+    cdi.vendor_name = NULL;
+    cdi.state = CUBEB_DEVICE_STATE_ENABLED;
+    cdi.preferred = CUBEB_DEVICE_PREF_NONE;
+    cdi.format = CUBEB_DEVICE_FMT_S16NE;
+    cdi.default_format = CUBEB_DEVICE_FMT_S16NE;
+    cdi.max_channels = ai.max_channels;
+    cdi.default_rate = OSS_PREFER_RATE;
+    cdi.max_rate = ai.max_rate;
+    cdi.min_rate = ai.min_rate;
+    cdi.latency_lo = 0;
+    cdi.latency_hi = 0;
+
+    devinfop[collection_cnt++] = cdi;
+  }
+
+  collection->count = collection_cnt;
+  collection->device = devinfop;
+
+  if (mixer_fd != -1)
+    close(mixer_fd);
+  return CUBEB_OK;
+
+fail:
+  if (mixer_fd != -1)
+    close(mixer_fd);
+  free(devinfop);
+  return CUBEB_ERROR;
+}
+
+#endif
+
+static int
+oss_device_collection_destroy(cubeb * context,
+                              cubeb_device_collection * collection)
+{
+  size_t i;
+  for (i = 0; i < collection->count; i++) {
+    oss_free_cubeb_device_info_strings(&collection->device[i]);
+  }
+  free(collection->device);
+  collection->device = NULL;
+  collection->count = 0;
+  return 0;
+}
+
+static unsigned int
+oss_chn_from_cubeb(cubeb_channel chn)
+{
+  switch (chn) {
+    case CHANNEL_FRONT_LEFT:
+      return CHID_L;
+    case CHANNEL_FRONT_RIGHT:
+      return CHID_R;
+    case CHANNEL_FRONT_CENTER:
+      return CHID_C;
+    case CHANNEL_LOW_FREQUENCY:
+      return CHID_LFE;
+    case CHANNEL_BACK_LEFT:
+      return CHID_LR;
+    case CHANNEL_BACK_RIGHT:
+      return CHID_RR;
+    case CHANNEL_SIDE_LEFT:
+      return CHID_LS;
+    case CHANNEL_SIDE_RIGHT:
+      return CHID_RS;
+    default:
+      return CHID_UNDEF;
+  }
+}
+
+static unsigned long long
+oss_cubeb_layout_to_chnorder(cubeb_channel_layout layout)
+{
+  unsigned int i, nchns = 0;
+  unsigned long long chnorder = 0;
+
+  for (i = 0; layout; i++, layout >>= 1) {
+    unsigned long long chid = oss_chn_from_cubeb((layout & 1) << i);
+    if (chid == CHID_UNDEF)
+      continue;
+
+    chnorder |= (chid & 0xf) << nchns * 4;
+    nchns++;
+  }
+
+  return chnorder;
+}
+
+static int
+oss_copy_params(int fd, cubeb_stream * stream, cubeb_stream_params * params,
+                struct stream_info * sinfo)
+{
+  unsigned long long chnorder;
+
+  sinfo->channels = params->channels;
+  sinfo->sample_rate = params->rate;
+  switch (params->format) {
+  case CUBEB_SAMPLE_S16LE:
+    sinfo->fmt = AFMT_S16_LE;
+    sinfo->precision = 16;
+    break;
+  case CUBEB_SAMPLE_S16BE:
+    sinfo->fmt = AFMT_S16_BE;
+    sinfo->precision = 16;
+    break;
+  case CUBEB_SAMPLE_FLOAT32NE:
+    sinfo->fmt = AFMT_S32_NE;
+    sinfo->precision = 32;
+    break;
+  default:
+    LOG("Unsupported format");
+    return CUBEB_ERROR_INVALID_FORMAT;
+  }
+  if (ioctl(fd, SNDCTL_DSP_CHANNELS, &sinfo->channels) == -1) {
+    return CUBEB_ERROR;
+  }
+  if (ioctl(fd, SNDCTL_DSP_SETFMT, &sinfo->fmt) == -1) {
+    return CUBEB_ERROR;
+  }
+  if (ioctl(fd, SNDCTL_DSP_SPEED, &sinfo->sample_rate) == -1) {
+    return CUBEB_ERROR;
+  }
+  /* Mono layout is an exception */
+  if (params->layout != CUBEB_LAYOUT_UNDEFINED && params->layout != CUBEB_LAYOUT_MONO) {
+    chnorder = oss_cubeb_layout_to_chnorder(params->layout);
+    if (ioctl(fd, SNDCTL_DSP_SET_CHNORDER, &chnorder) == -1)
+      LOG("Non-fatal error %d occured when setting channel order.", errno);
+  }
+  return CUBEB_OK;
+}
+
+static int
+oss_stream_stop(cubeb_stream * s)
+{
+  pthread_mutex_lock(&s->mutex);
+  if (s->running) {
+    s->running = false;
+    pthread_mutex_unlock(&s->mutex);
+    pthread_join(s->thread, NULL);
+  } else {
+    pthread_mutex_unlock(&s->mutex);
+  }
+  return CUBEB_OK;
+}
+
+static void
+oss_stream_destroy(cubeb_stream * s)
+{
+  oss_stream_stop(s);
+  pthread_mutex_destroy(&s->mutex);
+  if (s->play.fd != -1) {
+    close(s->play.fd);
+  }
+  if (s->record.fd != -1) {
+    close(s->record.fd);
+  }
+  free(s->play.buf);
+  free(s->record.buf);
+  free(s);
+}
+
+static void
+oss_float_to_linear32(void * buf, unsigned sample_count, float vol)
+{
+  float * in = buf;
+  int32_t * out = buf;
+  int32_t * tail = out + sample_count;
+
+  while (out < tail) {
+    int64_t f = *(in++) * vol * 0x80000000LL;
+    if (f < -INT32_MAX)
+      f = -INT32_MAX;
+    else if (f > INT32_MAX)
+      f = INT32_MAX;
+    *(out++) = f;
+  }
+}
+
+static void
+oss_linear32_to_float(void * buf, unsigned sample_count)
+{
+  int32_t * in = buf;
+  float * out = buf;
+  float * tail = out + sample_count;
+
+  while (out < tail) {
+    *(out++) = (1.0 / 0x80000000LL) * *(in++);
+  }
+}
+
+static void
+oss_linear16_set_vol(int16_t * buf, unsigned sample_count, float vol)
+{
+  unsigned i;
+  int32_t multiplier = vol * 0x8000;
+
+  for (i = 0; i < sample_count; ++i) {
+    buf[i] = (buf[i] * multiplier) >> 15;
+  }
+}
+
+static void *
+oss_io_routine(void * arg)
+{
+  cubeb_stream *s = arg;
+  cubeb_state state = CUBEB_STATE_STARTED;
+  size_t to_read = 0;
+  size_t to_write = 0;
+  long cb_nfr = 0;
+  size_t write_ofs = 0;
+  size_t read_ofs = 0;
+  int drain = 0;
+  int trig = 0;
+
+  s->state_cb(s, s->user_ptr, CUBEB_STATE_STARTED);
+
+  if (s->record.fd != -1) {
+    if (ioctl(s->record.fd, SNDCTL_DSP_SETTRIGGER, &trig)) {
+      LOG("Error %d occured when setting trigger on record fd", errno);
+      state = CUBEB_STATE_ERROR;
+      goto out;
+    }
+  }
+
+  while (state == CUBEB_STATE_STARTED) {
+    pthread_mutex_lock(&s->mutex);
+    if (!s->running) {
+      pthread_mutex_unlock(&s->mutex);
+      state = CUBEB_STATE_STOPPED;
+      break;
+    }
+    pthread_mutex_unlock(&s->mutex);
+    if (s->play.fd == -1 && s->record.fd == -1) {
+      /*
+       * Stop here if the stream is not play & record stream,
+       * play-only stream or record-only stream
+       */
+
+      state = CUBEB_STATE_STOPPED;
+      break;
+    }
+    if (s->record.fd != -1 && s->record.floating) {
+      oss_linear32_to_float(s->record.buf,
+                            s->record.info.channels * s->nfr);
+    }
+    cb_nfr = s->data_cb(s, s->user_ptr, s->record.buf, s->play.buf, s->nfr);
+    if (cb_nfr == CUBEB_ERROR) {
+      state = CUBEB_STATE_ERROR;
+      break;
+    }
+    if (s->play.fd != -1) {
+      float vol;
+
+      pthread_mutex_lock(&s->mutex);
+      vol = s->volume;
+      pthread_mutex_unlock(&s->mutex);
+
+      if (s->play.floating) {
+        oss_float_to_linear32(s->play.buf,
+                              s->play.info.channels * cb_nfr, vol);
+      } else {
+        oss_linear16_set_vol(s->play.buf,
+                             s->play.info.channels * cb_nfr, vol);
+      }
+    }
+    if (cb_nfr < (long)s->nfr) {
+      if (s->play.fd != -1) {
+        drain = 1;
+      } else {
+        /*
+         * This is a record-only stream and number of frames
+         * returned from data_cb() is smaller than number
+         * of frames required to read. Stop here.
+         */
+
+        state = CUBEB_STATE_STOPPED;
+        break;
+      }
+    }
+
+    if (s->record.fd != -1 && !trig) {
+      trig |= PCM_ENABLE_INPUT;
+      if (ioctl(s->record.fd, SNDCTL_DSP_SETTRIGGER, &trig)) {
+        LOG("Error %d occured when setting trigger on record fd", errno);
+        state = CUBEB_STATE_ERROR;
+        break;
+      }
+    }
+
+    to_write = s->play.fd != -1 ? cb_nfr : 0;
+    to_read = s->record.fd != -1 ? s->nfr : 0;
+    write_ofs = 0;
+    read_ofs = 0;
+    while (to_write > 0 || to_read > 0) {
+      size_t bytes;
+      ssize_t n, frames;
+      struct pollfd pfds[2];
+
+      pfds[0].fd = s->play.fd;
+      pfds[0].events = POLLOUT;
+      pfds[0].revents = 0;
+      pfds[1].fd = s->record.fd;
+      pfds[1].events = POLLIN;
+      pfds[1].revents = 0;
+
+      if (to_write > 0 && to_read > 0) {
+        int nfds;
+
+        nfds = poll(pfds, 2, 10000);
+        if (nfds == -1) {
+          if (errno == EINTR)
+            continue;
+          LOG("Error %d occured when polling playback and record fd", errno);
+          state = CUBEB_STATE_ERROR;
+          break;
+        } else if (nfds == 0)
+          continue;
+
+        if ((pfds[0].revents & (POLLERR|POLLHUP)) ||
+            (pfds[1].revents & (POLLERR|POLLHUP))) {
+          LOG("Error occured on playback or record fds", errno);
+          state = CUBEB_STATE_ERROR;
+          break;
+        }
+      } else if (to_write > 0) {
+        pfds[0].revents = POLLOUT;
+      } else {
+        pfds[1].revents = POLLIN;
+      }
+
+      if (to_write > 0 && pfds[0].revents) {
+        bytes = to_write * s->play.frame_size;
+        if ((n = write(s->play.fd, (uint8_t *)s->play.buf + write_ofs, bytes)) < 0) {
+          state = CUBEB_STATE_ERROR;
+          break;
+        }
+        frames = n / s->play.frame_size;
+        pthread_mutex_lock(&s->mutex);
+        s->frames_written += frames;
+        pthread_mutex_unlock(&s->mutex);
+        to_write -= frames;
+        write_ofs += n;
+      }
+      if (to_read > 0 && pfds[1].revents) {
+        bytes = to_read * s->record.frame_size;
+        if ((n = read(s->record.fd, (uint8_t *)s->record.buf + read_ofs, bytes)) < 0) {
+          state = CUBEB_STATE_ERROR;
+          break;
+        }
+        frames = n / s->record.frame_size;
+        to_read -= frames;
+        read_ofs += n;
+      }
+    }
+    if (drain && state != CUBEB_STATE_ERROR) {
+      state = CUBEB_STATE_DRAINED;
+      break;
+    }
+  }
+out:
+  if (s->record.fd != -1)
+    ioctl(s->record.fd, SNDCTL_DSP_HALT_INPUT, NULL);
+  s->state_cb(s, s->user_ptr, state);
+  return NULL;
+}
+
+static int
+oss_calc_frag_params(unsigned int frames, unsigned int frame_size)
+{
+  int n = 4;
+  int blksize = OSS_DEFAULT_NFRAMES * frame_size;
+  int nblks = (frames * frame_size + blksize - 1) / blksize;
+  while ((1 << n) < blksize)
+    n++;
+  return nblks << 16 | n;
+}
+
+static int
+oss_stream_init(cubeb * context,
+                cubeb_stream ** stream,
+                char const * stream_name,
+                cubeb_devid input_device,
+                cubeb_stream_params * input_stream_params,
+                cubeb_devid output_device,
+                cubeb_stream_params * output_stream_params,
+                unsigned latency_frames,
+                cubeb_data_callback data_callback,
+                cubeb_state_callback state_callback,
+                void * user_ptr)
+{
+  int ret = CUBEB_OK;
+  unsigned int playnfr = 1;
+  unsigned int recnfr = 1;
+  cubeb_stream *s = NULL;
+  const char *defdsp;
+
+  if (!(defdsp = getenv(ENV_AUDIO_DEVICE)) || *defdsp == '\0')
+    defdsp = OSS_DEFAULT_DEVICE;
+
+  (void)stream_name;
+  if ((s = calloc(1, sizeof(cubeb_stream))) == NULL) {
+    ret = CUBEB_ERROR;
+    goto error;
+  }
+  s->record.fd = -1;
+  s->play.fd = -1;
+  s->nfr = OSS_DEFAULT_NFRAMES;
+  if (input_device != NULL) {
+    strlcpy(s->record.name, input_device, sizeof(s->record.name));
+  } else {
+    strlcpy(s->record.name, defdsp, sizeof(s->record.name));
+  }
+  if (output_device != NULL) {
+    strlcpy(s->play.name, output_device, sizeof(s->play.name));
+  } else {
+    strlcpy(s->play.name, defdsp, sizeof(s->play.name));
+  }
+  if (input_stream_params != NULL) {
+    unsigned int nb_channels;
+    if (input_stream_params->prefs & CUBEB_STREAM_PREF_LOOPBACK) {
+      LOG("Loopback not supported");
+      ret = CUBEB_ERROR_NOT_SUPPORTED;
+      goto error;
+    }
+    nb_channels = cubeb_channel_layout_nb_channels(input_stream_params->layout);
+    if (input_stream_params->layout != CUBEB_LAYOUT_UNDEFINED &&
+        nb_channels != input_stream_params->channels) {
+      LOG("input_stream_params->layout does not match input_stream_params->channels");
+      ret = CUBEB_ERROR_INVALID_PARAMETER;
+      goto error;
+    }
+    if (s->record.fd == -1) {
+      if ((s->record.fd = open(s->record.name, O_RDONLY)) == -1) {
+        LOG("Audio device \"%s\" could not be opened as read-only",
+            s->record.name);
+        ret = CUBEB_ERROR_DEVICE_UNAVAILABLE;
+        goto error;
+      }
+    }
+    if ((ret = oss_copy_params(s->record.fd, s, input_stream_params,
+                               &s->record.info)) != CUBEB_OK) {
+      LOG("Setting record params failed");
+      goto error;
+    }
+    s->record.floating = (input_stream_params->format == CUBEB_SAMPLE_FLOAT32NE);
+  }
+  if (output_stream_params != NULL) {
+    unsigned int nb_channels;
+    if (output_stream_params->prefs & CUBEB_STREAM_PREF_LOOPBACK) {
+      LOG("Loopback not supported");
+      ret = CUBEB_ERROR_NOT_SUPPORTED;
+      goto error;
+    }
+    nb_channels = cubeb_channel_layout_nb_channels(output_stream_params->layout);
+    if (output_stream_params->layout != CUBEB_LAYOUT_UNDEFINED &&
+        nb_channels != output_stream_params->channels) {
+      LOG("output_stream_params->layout does not match output_stream_params->channels");
+      ret = CUBEB_ERROR_INVALID_PARAMETER;
+      goto error;
+    }
+    if (s->play.fd == -1) {
+      if ((s->play.fd = open(s->play.name, O_WRONLY)) == -1) {
+        LOG("Audio device \"%s\" could not be opened as write-only",
+            s->play.name);
+        ret = CUBEB_ERROR_DEVICE_UNAVAILABLE;
+        goto error;
+      }
+    }
+    if ((ret = oss_copy_params(s->play.fd, s, output_stream_params,
+                               &s->play.info)) != CUBEB_OK) {
+      LOG("Setting play params failed");
+      goto error;
+    }
+    s->play.floating = (output_stream_params->format == CUBEB_SAMPLE_FLOAT32NE);
+  }
+  s->context = context;
+  s->volume = 1.0;
+  s->state_cb = state_callback;
+  s->data_cb = data_callback;
+  s->user_ptr = user_ptr;
+  if (pthread_mutex_init(&s->mutex, NULL) != 0) {
+    LOG("Failed to create mutex");
+    goto error;
+  }
+  s->play.frame_size = s->play.info.channels *
+                      (s->play.info.precision / 8);
+  if (s->play.fd != -1) {
+    audio_buf_info bi;
+    int frag = oss_calc_frag_params(latency_frames, s->play.frame_size);
+    if (ioctl(s->play.fd, SNDCTL_DSP_SETFRAGMENT, &frag))
+      LOG("Failed to set play fd with SNDCTL_DSP_SETFRAGMENT. frag: 0x%x", frag);
+    if (ioctl(s->play.fd, SNDCTL_DSP_GETOSPACE, &bi) == 0) {
+      unsigned int nfr = bi.fragsize / s->play.frame_size;
+      if (playnfr < nfr) {
+        playnfr = nfr;
+      }
+    }
+  }
+  s->record.frame_size = s->record.info.channels *
+                        (s->record.info.precision / 8);
+  if (s->record.fd != -1) {
+    audio_buf_info bi;
+    int frag = oss_calc_frag_params(latency_frames, s->record.frame_size);
+    if (ioctl(s->record.fd, SNDCTL_DSP_SETFRAGMENT, &frag))
+      LOG("Failed to set record fd with SNDCTL_DSP_SETFRAGMENT. frag: 0x%x",
+          frag);
+    if (ioctl(s->record.fd, SNDCTL_DSP_GETISPACE, &bi) == 0) {
+      unsigned int nfr = bi.fragsize / s->record.frame_size;
+      if (recnfr < nfr) {
+        recnfr = nfr;
+      }
+    }
+  }
+  if (s->play.fd != -1 && s->record.fd != -1)
+    s->nfr = (playnfr < recnfr) ? playnfr : recnfr;
+  else if (s->play.fd != -1)
+    s->nfr = playnfr;
+  else if (s->record.fd != -1)
+    s->nfr = recnfr;
+
+  if (s->play.fd != -1) {
+    if ((s->play.buf = calloc(s->nfr, s->play.frame_size)) == NULL) {
+      ret = CUBEB_ERROR;
+      goto error;
+    }
+  }
+  if (s->record.fd != -1) {
+    if ((s->record.buf = calloc(s->nfr, s->record.frame_size)) == NULL) {
+      ret = CUBEB_ERROR;
+      goto error;
+    }
+  }
+
+  *stream = s;
+  return CUBEB_OK;
+error:
+  if (s != NULL) {
+    oss_stream_destroy(s);
+  }
+  return ret;
+}
+
+static int
+oss_stream_start(cubeb_stream * s)
+{
+  s->running = true;
+  if (pthread_create(&s->thread, NULL, oss_io_routine, s) != 0) {
+    LOG("Couldn't create thread");
+    return CUBEB_ERROR;
+  }
+  return CUBEB_OK;
+}
+
+static int
+oss_stream_get_position(cubeb_stream * s, uint64_t * position)
+{
+  pthread_mutex_lock(&s->mutex);
+  *position = s->frames_written;
+  pthread_mutex_unlock(&s->mutex);
+  return CUBEB_OK;
+}
+
+static int
+oss_stream_get_latency(cubeb_stream * s, uint32_t * latency)
+{
+  int delay;
+
+  if (ioctl(s->play.fd, SNDCTL_DSP_GETODELAY, &delay) == -1) {
+    return CUBEB_ERROR;
+  }
+
+  /* Return number of frames there */
+  *latency = delay / s->play.frame_size;
+  return CUBEB_OK;
+}
+
+static int
+oss_stream_set_volume(cubeb_stream * stream, float volume)
+{
+  if (volume < 0.0)
+    volume = 0.0;
+  else if (volume > 1.0)
+    volume = 1.0;
+  pthread_mutex_lock(&stream->mutex);
+  stream->volume = volume;
+  pthread_mutex_unlock(&stream->mutex);
+  return CUBEB_OK;
+}
+
+static int
+oss_get_current_device(cubeb_stream * stream, cubeb_device ** const device)
+{
+  *device = calloc(1, sizeof(cubeb_device));
+  if (*device == NULL) {
+    return CUBEB_ERROR;
+  }
+  (*device)->input_name = stream->record.fd != -1 ?
+    strdup(stream->record.name) : NULL;
+  (*device)->output_name = stream->play.fd != -1 ?
+    strdup(stream->play.name) : NULL;
+  return CUBEB_OK;
+}
+
+static int
+oss_stream_device_destroy(cubeb_stream * stream, cubeb_device * device)
+{
+  (void)stream;
+  free(device->input_name);
+  free(device->output_name);
+  free(device);
+  return CUBEB_OK;
+}
+
+static struct cubeb_ops const oss_ops = {
+    .init = oss_init,
+    .get_backend_id = oss_get_backend_id,
+    .get_max_channel_count = oss_get_max_channel_count,
+    .get_min_latency = oss_get_min_latency,
+    .get_preferred_sample_rate = oss_get_preferred_sample_rate,
+    .enumerate_devices = oss_enumerate_devices,
+    .device_collection_destroy = oss_device_collection_destroy,
+    .destroy = oss_destroy,
+    .stream_init = oss_stream_init,
+    .stream_destroy = oss_stream_destroy,
+    .stream_start = oss_stream_start,
+    .stream_stop = oss_stream_stop,
+    .stream_reset_default_device = NULL,
+    .stream_get_position = oss_stream_get_position,
+    .stream_get_latency = oss_stream_get_latency,
+    .stream_get_input_latency = NULL,
+    .stream_set_volume = oss_stream_set_volume,
+    .stream_get_current_device = oss_get_current_device,
+    .stream_device_destroy = oss_stream_device_destroy,
+    .stream_register_device_changed_callback = NULL,
+    .register_device_collection_changed = NULL};


[FILE:853:patches/patch-dom_media_flac_FlacDecoder.cpp]
Enable FLAC on platforms without ffvpx like powerpc*

diff --git dom/media/flac/FlacDecoder.cpp dom/media/flac/FlacDecoder.cpp
index 53fc3c9937f7..b23771ab80fa 100644
--- dom/media/flac/FlacDecoder.cpp
+++ dom/media/flac/FlacDecoder.cpp
@@ -7,6 +7,7 @@
 #include "FlacDecoder.h"
 #include "MediaContainerType.h"
 #include "mozilla/StaticPrefs_media.h"
+#include "PDMFactory.h"
 
 namespace mozilla {
 
@@ -14,6 +15,11 @@ namespace mozilla {
 bool FlacDecoder::IsEnabled() {
 #ifdef MOZ_FFVPX
   return StaticPrefs::media_flac_enabled();
+#elif defined(MOZ_FFMPEG)
+  RefPtr<PDMFactory> platform = new PDMFactory();
+  return StaticPrefs::media_flac_enabled() &&
+         platform->SupportsMimeType("audio/flac"_ns,
+                                    /* DecoderDoctorDiagnostics* */ nullptr);
 #else
   // Until bug 1295886 is fixed.
   return false;


[FILE:893:patches/patch-env-api-keys]
# Accept API keys from environment like before bug 1294585

--- build/moz.configure/keyfiles.configure.orig	2020-04-29 20:59:50 UTC
+++ build/moz.configure/keyfiles.configure
@@ -18,6 +18,7 @@ def keyfile(desc, default=None, help=Non
     @checking('for the %s key' % desc, lambda x: x and x is not no_key)
     @imports(_from='__builtin__', _import='open')
     @imports(_from='__builtin__', _import='IOError')
+    @imports(_from='os', _import='environ')
     def keyfile(value):
         if value:
             try:
@@ -28,7 +29,7 @@ def keyfile(desc, default=None, help=Non
                     raise FatalCheckError("'%s' is empty." % value[0])
             except IOError as e:
                 raise FatalCheckError("'%s': %s." % (value[0], e.strerror))
-        return no_key
+        return environ.get('MOZ_%s_KEY' % desc.upper().replace(' ', '_')) or no_key
 
     return keyfile
 


[FILE:2142:patches/patch-freebsd11.3]
Drop after FreeBSD 11.3 EOL around 2020-09-20.
https://svnweb.freebsd.org/changeset/base/351766

mozglue/baseprofiler/core/shared-libraries-linux.cc:374:34: error: use of undeclared
      identifier 'NT_GNU_BUILD_ID'
      if (note_header->n_type == NT_GNU_BUILD_ID) break;
                                 ^
In file included from Unified_cpp_mozglue_baseprofiler0.cpp:137:
mozglue/baseprofiler/lul/LulElf.cpp:762:32: error: use of undeclared identifier
      'NT_GNU_BUILD_ID'
    if (note_header->n_type == NT_GNU_BUILD_ID) break;
                               ^
In file included from Unified_cpp_tools_profiler1.cpp:38:
tools/profiler/lul/LulElf.cpp:776:32: error: use of undeclared identifier
      'NT_GNU_BUILD_ID'
    if (note_header->n_type == NT_GNU_BUILD_ID) break;
                               ^

--- mozglue/baseprofiler/core/shared-libraries-linux.cc.orig	2020-06-25 17:04:48 UTC
+++ mozglue/baseprofiler/core/shared-libraries-linux.cc
@@ -50,6 +50,11 @@ extern "C" MOZ_EXPORT __attribute__((weak)) int dl_ite
 #  define ElfW(type) Elf_##type
 #endif
 
+#if defined(GP_OS_freebsd) && !defined(NT_GNU_BUILD_ID)
+// FreeBSD < 11.4 doesn't define NT_GNU_BUILD_ID
+#  define NT_GNU_BUILD_ID 3
+#endif
+
 // ----------------------------------------------------------------------------
 // Starting imports from toolkit/crashreporter/google-breakpad/, as needed by
 // this file when moved to mozglue.
--- mozglue/baseprofiler/lul/LulElf.cpp.orig	2020-06-25 17:04:48 UTC
+++ mozglue/baseprofiler/lul/LulElf.cpp
@@ -79,6 +79,11 @@
 #  define EM_AARCH64 183
 #endif
 
+#if defined(GP_OS_freebsd) && !defined(NT_GNU_BUILD_ID)
+// FreeBSD < 11.4 doesn't define NT_GNU_BUILD_ID
+#  define NT_GNU_BUILD_ID 3
+#endif
+
 // This namespace contains helper functions.
 namespace {
 
--- tools/profiler/lul/LulElf.cpp.orig	2020-06-25 17:05:05 UTC
+++ tools/profiler/lul/LulElf.cpp
@@ -84,6 +84,11 @@
 #  define EM_AARCH64 183
 #endif
 
+#if defined(GP_OS_freebsd) && !defined(NT_GNU_BUILD_ID)
+// FreeBSD < 11.4 doesn't define NT_GNU_BUILD_ID
+#  define NT_GNU_BUILD_ID 3
+#endif
+
 // This namespace contains helper functions.
 namespace {
 


[FILE:890:patches/patch-gfx_skia_skia_src_core_SkCpu.cpp]
Regressed by https://svnweb.freebsd.org/changeset/base/324815

gfx/skia/skia/src/core/SkCpu.cpp:81:27: error: use of undeclared identifier 'getauxval'
        uint32_t hwcaps = getauxval(AT_HWCAP);
                          ^

--- gfx/skia/skia/src/core/SkCpu.cpp.orig	2020-04-29 20:59:56 UTC
+++ gfx/skia/skia/src/core/SkCpu.cpp
@@ -72,6 +72,20 @@
         return features;
     }
 
+#elif defined(SK_CPU_ARM64) && defined(__FreeBSD__)
+    #include <machine/armreg.h>
+
+    static uint32_t read_cpu_features() {
+        uint32_t features = 0;
+        uint64_t id_aa64isar0;
+
+        id_aa64isar0 = READ_SPECIALREG(ID_AA64ISAR0_EL1);
+        if (ID_AA64ISAR0_CRC32(id_aa64isar0) == ID_AA64ISAR0_CRC32_BASE) {
+            features |= SkCpu::CRC32;
+        }
+        return features;
+    }
+
 #elif defined(SK_CPU_ARM64) && __has_include(<sys/auxv.h>)
     #include <sys/auxv.h>
 


[FILE:228:patches/patch-image_imgFrame.h]
--- image/imgFrame.h.orig	2020-04-29 21:55:18 UTC
+++ image/imgFrame.h
@@ -8,6 +8,7 @@
 #define mozilla_image_imgFrame_h
 
 #include <utility>
+#include <functional>
 
 #include "AnimationParams.h"
 #include "MainThreadUtils.h"


[FILE:316:patches/patch-ipc_chromium_src_base_platform__thread__posix.cc]
--- ipc/chromium/src/base/platform_thread_posix.cc.orig	2020-04-29 20:59:57 UTC
+++ ipc/chromium/src/base/platform_thread_posix.cc
@@ -16,6 +16,8 @@
 #elif defined(OS_LINUX)
 #  include <sys/syscall.h>
 #  include <sys/prctl.h>
+#elif defined(OS_DRAGONFLY)
+#  include <sys/lwp.h>
 #endif
 
 #if !defined(OS_MACOSX)


[FILE:615:patches/patch-ipc_chromium_src_base_shared__memory__posix.cc]
--- ipc/chromium/src/base/shared_memory_posix.cc.orig	2020-04-29 20:59:57 UTC
+++ ipc/chromium/src/base/shared_memory_posix.cc
@@ -182,6 +182,11 @@ bool SharedMemory::AppendPosixShmPrefix(
     StringAppendF(str, "snap.%s.", kSnap);
   }
 #  endif  // OS_LINUX
+#  ifdef OS_DRAGONFLY
+  // DragonFly BSD has a userland IPC implementation, we need to prefix the
+  // path to shm_open(3), preferably with '/tmp'
+  StringAppendF(str, "tmp/");
+#  endif
   // Hopefully the "implementation defined" name length limit is long
   // enough for this.
   StringAppendF(str, "org.mozilla.ipc.%d.", static_cast<int>(pid));


[FILE:575:patches/patch-js_src_old-configure.in]
--- js/src/old-configure.in.orig	2020-04-29 21:00:01 UTC
+++ js/src/old-configure.in
@@ -786,7 +786,7 @@ dnl Checks for header files.
 dnl ========================================================
 AC_HEADER_DIRENT
 case "$target_os" in
-freebsd*)
+freebsd*|dragonfly*)
 # for stuff like -lXshm
     CPPFLAGS="${CPPFLAGS} ${X_CFLAGS}"
     ;;
@@ -905,7 +905,7 @@ then
     fi
 
 	case "$target" in
-	    *-*-freebsd*)
+	    *-*-freebsd*|*-*-dragonfly*)
 			AC_DEFINE(_REENTRANT)
 			AC_DEFINE(_THREAD_SAFE)
 			dnl -pthread links in -lpthread, so don't specify it explicitly.


[FILE:297:patches/patch-media_libcubeb_src_cubeb__jack.cpp]
--- media/libcubeb/src/cubeb_jack.cpp.orig	2020-04-29 21:00:35 UTC
+++ media/libcubeb/src/cubeb_jack.cpp
@@ -8,7 +8,7 @@
  */
 #define _DEFAULT_SOURCE
 #define _BSD_SOURCE
-#ifndef __FreeBSD__
+#if !(defined __FreeBSD__ || defined __DragonFly__)
 #define _POSIX_SOURCE
 #endif
 #include <dlfcn.h>


[FILE:3831:patches/patch-third__party_rust_libc_src_unix_bsd_freebsdlike_dragonfly_mod.rs]
--- third_party/rust/libc/src/unix/bsd/freebsdlike/dragonfly/mod.rs.orig	2020-09-17 00:32:52 UTC
+++ third_party/rust/libc/src/unix/bsd/freebsdlike/dragonfly/mod.rs
@@ -8,6 +8,8 @@ pub type nlink_t = u32;
 pub type blksize_t = i64;
 pub type clockid_t = ::c_ulong;
 
+pub type shmatt_t = ::c_uint;
+
 pub type c_long = i64;
 pub type c_ulong = u64;
 pub type time_t = i64;
@@ -21,6 +23,10 @@ pub type fsfilcnt_t = u64;
 pub type mqd_t = ::c_int;
 pub type sem_t = *mut sem;
 
+pub type key_t = ::c_long;
+pub type msglen_t = ::c_ulong;
+pub type msgqnum_t = ::c_ulong;
+
 #[cfg_attr(feature = "extra_traits", derive(Debug))]
 pub enum sem {}
 impl ::Copy for sem {}
@@ -238,6 +244,48 @@ s_no_extra_traits! {
         __unused3: *mut ::c_void        //actually a function pointer
     }
 
+    pub struct ipc_perm {
+        pub cuid: ::uid_t,
+        pub cgid: ::gid_t,
+        pub uid: ::uid_t,
+        pub gid: ::gid_t,
+        pub mode: ::mode_t,
+        pub seq: ::c_ushort,
+        pub key: ::key_t,
+    }
+
+    pub struct msqid_ds {
+        pub msg_perm: ::ipc_perm,
+        __unused1: *mut ::c_void,
+        __unused2: *mut ::c_void,
+        pub msg_cbytes: ::msglen_t,
+        pub msg_qnum: ::msgqnum_t,
+        pub msg_qbytes: ::msglen_t,
+        pub msg_lspid: ::pid_t,
+        pub msg_lrpid: ::pid_t,
+        pub msg_stime: ::time_t,
+	__unused3: ::c_long,
+        pub msg_rtime: ::time_t,
+	__unused4: ::c_long,
+        pub msg_ctime: ::time_t,
+	__unused5: ::c_long,
+	__unused6: ::c_long,
+	__unused7: ::c_long,
+	__unused8: ::c_long,
+	__unused9: ::c_long,
+    }
+
+    pub struct shmid_ds {
+        pub shm_perm: ::ipc_perm,
+        pub shm_segsz: ::size_t,
+        pub shm_lpid: ::pid_t,
+        pub shm_cpid: ::pid_t,
+        pub shm_nattch: ::shmatt_t,
+        pub shm_atime: ::time_t,
+        pub shm_dtime: ::time_t,
+        pub shm_ctime: ::time_t,
+	pub shm_internal: *mut ::c_void,
+    }
 }
 
 cfg_if! {
@@ -929,6 +977,23 @@ pub const NET_RT_FLAGS: ::c_int = 2;
 pub const NET_RT_IFLIST: ::c_int = 3;
 pub const NET_RT_MAXID: ::c_int = 4;
 
+// System V IPC
+pub const IPC_PRIVATE: ::key_t = 0;
+pub const IPC_CREAT: ::c_int = 0o1000;
+pub const IPC_EXCL: ::c_int = 0o2000;
+pub const IPC_NOWAIT: ::c_int = 0o4000;
+pub const IPC_RMID: ::c_int = 0;
+pub const IPC_SET: ::c_int = 1;
+pub const IPC_STAT: ::c_int = 2;
+pub const IPC_R: ::c_int = 0o400;
+pub const IPC_W: ::c_int = 0o200;
+pub const IPC_M: ::c_int = 0o10000;
+pub const MSG_NOERROR: ::c_int = 0o10000;
+pub const SHM_RDONLY: ::c_int = 0o10000;
+pub const SHM_RND: ::c_int = 0o20000;
+pub const SHM_R: ::c_int = 0o400;
+pub const SHM_W: ::c_int = 0o200;
+
 pub const SOMAXOPT_SIZE: ::c_int = 65536;
 
 pub const MSG_UNUSED09: ::c_int = 0x00000200;
@@ -1059,6 +1124,7 @@ f! {
 }
 
 extern "C" {
+    pub fn __errno_location() -> *mut ::c_int;
     pub fn setgrent();
     pub fn mprotect(
         addr: *mut ::c_void,
@@ -1072,6 +1138,30 @@ extern "C" {
         tp: *const ::timespec,
     ) -> ::c_int;
 
+    pub fn shmget(key: ::key_t, size: ::size_t, shmflg: ::c_int) -> ::c_int;
+    pub fn shmat(
+        shmid: ::c_int,
+        addr: *const ::c_void,
+        flag: ::c_int,
+    ) -> *mut ::c_void;
+    pub fn shmdt(shmaddr: *const ::c_void) -> ::c_int;
+    pub fn shmctl(
+        shmid: ::c_int,
+        cmd: ::c_int,
+        buf: *mut ::shmid_ds,
+    ) -> ::c_int;
+    pub fn msgctl(
+        msqid: ::c_int,
+        cmd: ::c_int,
+        buf: *mut ::msqid_ds,
+    ) -> ::c_int;
+    pub fn msgget(key: ::key_t, msgflg: ::c_int) -> ::c_int;
+    pub fn msgsnd(
+        msqid: ::c_int,
+        msgp: *const ::c_void,
+        msgsz: ::size_t,
+        msgflg: ::c_int,
+    ) -> ::c_int;
     pub fn setutxdb(_type: ::c_uint, file: *mut ::c_char) -> ::c_int;
 
     pub fn aio_waitcomplete(


[FILE:779:patches/patch-toolkit_xre_nsAppRunner.cpp]
--- toolkit/xre/nsAppRunner.cpp.orig	2020-09-17 00:32:53 UTC
+++ toolkit/xre/nsAppRunner.cpp
@@ -5156,15 +5156,10 @@ bool BrowserTabsRemoteAutostart() {
     gBrowserTabsRemoteAutostart = true;
   }
 
-  // Uber override pref for emergency blocking
-  if (gBrowserTabsRemoteAutostart) {
-    const char* forceDisable = PR_GetEnv("MOZ_FORCE_DISABLE_E10S");
-    // The environment variable must match the application version to apply.
-    if (forceDisable && gAppData && !strcmp(forceDisable, gAppData->version)) {
+  // Disable MultiProcessing for DragonFly. Slowness and many crashes that require
+  // quite some debugging and investigation.
       gBrowserTabsRemoteAutostart = false;
       status = kE10sForceDisabled;
-    }
-  }
 
   gBrowserTabsRemoteStatus = status;
 


[FILE:231:files/pkg-message-single]
==========================================================================

  If Firefox segfaults, try setting MOZ_FORCE_DISABLE_E10S=1 in
  environment.

==========================================================================

