# Buildsheet autogenerated by ravenadm tool -- Do not edit.

NAMEBASE=		mutt
VERSION=		2.1.1
KEYWORDS=		mail
VARIANTS=		standard
SDESC[standard]=	Powerful mail client
HOMEPAGE=		http://www.mutt.org/
CONTACT=		Leonid_Bobrov[goleo@disroot.org]

DOWNLOAD_GROUPS=	main
SITES[main]=		ftp://ftp.mutt.org/pub/mutt/
DISTFILE[1]=		mutt-2.1.1.tar.gz:main
DF_INDEX=		1
SPKGS[standard]=	complete
			primary
			docs
			nls

OPTIONS_AVAILABLE=	none
OPTIONS_STANDARD=	none

BUILD_DEPENDS=		docbook-xsl:primary:standard
			lynx:primary:standard
			gdbm:primary:static
BUILDRUN_DEPENDS=	cyrus-sasl:primary:standard
			gettext:runtime:standard
			libidn2:primary:standard
RUN_DEPENDS=		media-types:single:standard

USES=			cpe ncurses perl shebangfix ssl zlib iconv:translit

LICENSE=		GPLv2+:primary
LICENSE_TERMS=		primary:{{WRKSRC}}/COPYRIGHT
LICENSE_FILE=		GPLv2+:stock
LICENSE_SCHEME=		solo

FPC_EQUIVALENT=		mail/mutt
SHEBANG_FILES=		contrib/smime_keys_test.pl
			doc/gen-map-doc
			smime_keys.pl

MUST_CONFIGURE=		gnu
CONFIGURE_ARGS=		--disable-debug
			--disable-flock
			--enable-compressed
			--enable-external_dotlock
			--enable-fcntl
			--disable-gpgme
			--enable-hcache
			--enable-imap
			--enable-nls
			--enable-pop
			--enable-sidebar
			--enable-smtp
			--mandir={{MANPREFIX}}/man
			--prefix={{PREFIX}}
			--sysconfdir={{PREFIX}}/etc
			--with-docdir={{PREFIX}}/share/doc/mutt
			--with-curses
			--with-gdbm
			--with-idn2
			--with-sasl={{LOCALBASE}}
			--with-ssl
			--with-libiconv-prefix={{LOCALBASE}}
			--without-kyotocabinet
			--without-tokyocabinet
			--without-qdbm

CFLAGS=			-I{{NCURSESINC}}

post-install:
	${RM} ${STAGEDIR}${PREFIX}/etc/mime.types

[FILE:414:descriptions/desc.primary]
Mutt is a small but very powerful text-based mail client for Unix-like
operating systems. Features include support for multiple mailbox formats
(including IMAP, POP3, mbox, MMDF, MH, Maildir), MIME/RFC2047, message
threading, encryption and signing with PGP/GPG and S/MIME, and many
operations can use regular expressions. It's highly customizable with
many options for colours, key bindings, display formats etc.


[FILE:96:distinfo]
4ae6d60f7f19854c375cc1c27b5768b71e9f450c2adc10c22e45de8a27de524a      5406187 mutt-2.1.1.tar.gz


[FILE:288:manifests/plist.primary]
@sample etc/Muttrc.sample
bin/
 flea
 mutt
@(,mail,2755) bin/mutt_dotlock
 mutt_pgpring
 muttbug
 pgpewrap
 smime_keys
share/info/mutt.info
share/man/man1/
 mutt.1.gz
 mutt_dotlock.1.gz
 mutt_pgpring.1.gz
 pgpewrap.1.gz
 smime_keys.1.gz
share/man/man5/
 mbox.5.gz
 mmdf.5.gz
 muttrc.5.gz


[FILE:1089:manifests/plist.nls]
share/locale/bg/LC_MESSAGES/mutt.mo
share/locale/ca/LC_MESSAGES/mutt.mo
share/locale/cs/LC_MESSAGES/mutt.mo
share/locale/da/LC_MESSAGES/mutt.mo
share/locale/de/LC_MESSAGES/mutt.mo
share/locale/el/LC_MESSAGES/mutt.mo
share/locale/eo/LC_MESSAGES/mutt.mo
share/locale/es/LC_MESSAGES/mutt.mo
share/locale/et/LC_MESSAGES/mutt.mo
share/locale/eu/LC_MESSAGES/mutt.mo
share/locale/fi/LC_MESSAGES/mutt.mo
share/locale/fr/LC_MESSAGES/mutt.mo
share/locale/ga/LC_MESSAGES/mutt.mo
share/locale/gl/LC_MESSAGES/mutt.mo
share/locale/hu/LC_MESSAGES/mutt.mo
share/locale/id/LC_MESSAGES/mutt.mo
share/locale/it/LC_MESSAGES/mutt.mo
share/locale/ja/LC_MESSAGES/mutt.mo
share/locale/ko/LC_MESSAGES/mutt.mo
share/locale/lt/LC_MESSAGES/mutt.mo
share/locale/nl/LC_MESSAGES/mutt.mo
share/locale/pl/LC_MESSAGES/mutt.mo
share/locale/pt_BR/LC_MESSAGES/mutt.mo
share/locale/ru/LC_MESSAGES/mutt.mo
share/locale/sk/LC_MESSAGES/mutt.mo
share/locale/sv/LC_MESSAGES/mutt.mo
share/locale/tr/LC_MESSAGES/mutt.mo
share/locale/uk/LC_MESSAGES/mutt.mo
share/locale/zh_CN/LC_MESSAGES/mutt.mo
share/locale/zh_TW/LC_MESSAGES/mutt.mo


[FILE:1301:patches/patch-Makefile.in]
--- Makefile.in.orig	2021-07-12 17:56:40 UTC
+++ Makefile.in
@@ -322,7 +322,7 @@ am__define_uniq_tagged_files = \
 ETAGS = etags
 CTAGS = ctags
 CSCOPE = cscope
-DIST_SUBDIRS = m4 po doc contrib imap autocrypt
+DIST_SUBDIRS = m4 po contrib imap autocrypt doc
 am__DIST_COMMON = $(srcdir)/Makefile.in $(srcdir)/config.h.in \
 	$(top_srcdir)/flymake.am ABOUT-NLS ChangeLog INSTALL NEWS \
 	README TODO compile config.guess config.rpath config.sub \
@@ -1677,18 +1677,9 @@ install-exec-hook:
 		rm -f $(DESTDIR)$(bindir)/mutt.dotlock ;		\
 		ln -sf $(DESTDIR)$(bindir)/mutt_dotlock $(DESTDIR)$(bindir)/mutt.dotlock ; \
 	fi
-	if test -f $(DESTDIR)$(bindir)/mutt_dotlock && test x$(DOTLOCK_GROUP) != x ; then \
-		chgrp $(DOTLOCK_GROUP) $(DESTDIR)$(bindir)/mutt_dotlock && \
-		chmod $(DOTLOCK_PERMISSION) $(DESTDIR)$(bindir)/mutt_dotlock || \
-		{ echo "Can't fix mutt_dotlock's permissions!  This is required to lock mailboxes in the mail spool directory." >&2 ; exit 1 ; } \
-	fi
 
 install-data-local:
 	$(MKDIR_P) $(DESTDIR)$(sysconfdir)
-	$(INSTALL) -m 644 $(srcdir)/mime.types $(DESTDIR)$(sysconfdir)/mime.types.dist
-	-if [ ! -f $(DESTDIR)$(sysconfdir)/mime.types ]; then \
-		$(INSTALL) -m 644 $(srcdir)/mime.types $(DESTDIR)$(sysconfdir); \
-	fi
 
 uninstall-local:
 	for i in mime.types ; do \


[FILE:2188:patches/patch-browser.c]
--- browser.c.orig	2021-06-12 18:01:35 UTC
+++ browser.c
@@ -99,6 +99,12 @@ static int browser_compare_subject (cons
   struct folder_file *pa = (struct folder_file *) a;
   struct folder_file *pb = (struct folder_file *) b;
 
+  /* Always keep '..' in first menu position */
+  if (!strncmp(pa->display_name, "..", 2))
+	  return(-1);
+  if (!strncmp(pb->display_name, "..", 2))
+	  return(1);
+
   int r = mutt_strcoll (pa->display_name, pb->display_name);
 
   return (sort_reverse_flag ? -r : r);
@@ -109,6 +115,12 @@ static int browser_compare_date (const v
   struct folder_file *pa = (struct folder_file *) a;
   struct folder_file *pb = (struct folder_file *) b;
 
+  /* Always keep '..' in first menu position */
+  if (!strncmp(pa->display_name, "..", 2))
+	  return(-1);
+  if (!strncmp(pb->display_name, "..", 2))
+	  return(1);
+
   int r = pa->mtime - pb->mtime;
 
   return (sort_reverse_flag ? -r : r);
@@ -119,6 +131,12 @@ static int browser_compare_size (const v
   struct folder_file *pa = (struct folder_file *) a;
   struct folder_file *pb = (struct folder_file *) b;
 
+  /* Always keep '..' in first menu position */
+  if (!strncmp(pa->display_name, "..", 2))
+	  return(-1);
+  if (!strncmp(pb->display_name, "..", 2))
+	  return(1);
+
   int r = pa->size - pb->size;
 
   return (sort_reverse_flag ? -r : r);
@@ -129,6 +147,12 @@ static int browser_compare_count (const
   struct folder_file *pa = (struct folder_file *) a;
   struct folder_file *pb = (struct folder_file *) b;
 
+  /* Always keep '..' in first menu position */
+  if (!strncmp(pa->display_name, "..", 2))
+	  return(-1);
+  if (!strncmp(pb->display_name, "..", 2))
+	  return(1);
+
   int r = pa->msg_count - pb->msg_count;
 
   return (sort_reverse_flag ? -r : r);
@@ -139,6 +163,12 @@ static int browser_compare_unread (const
   struct folder_file *pa = (struct folder_file *) a;
   struct folder_file *pb = (struct folder_file *) b;
 
+  /* Always keep '..' in first menu position */
+  if (!strncmp(pa->display_name, "..", 2))
+	  return(-1);
+  if (!strncmp(pb->display_name, "..", 2))
+	  return(1);
+
   int r = pa->msg_unread - pb->msg_unread;
 
   return (sort_reverse_flag ? -r : r);


[FILE:422:patches/patch-commands.c]
--- commands.c.orig	2021-06-12 18:01:35 UTC
+++ commands.c
@@ -302,7 +302,7 @@ int mutt_display_message (HEADER *cur)
     {
       if (cur->security & GOODSIGN)
       {
-	if (!crypt_smime_verify_sender(cur))
+	if (option(OPTSMIMENOSENDER) || !crypt_smime_verify_sender(cur))
 	  mutt_message ( _("S/MIME signature successfully verified."));
 	else
 	  mutt_error ( _("S/MIME certificate owner does not match sender."));


[FILE:521:patches/patch-contrib_Makefile.in]
--- contrib/Makefile.in.orig	2021-07-12 17:56:40 UTC
+++ contrib/Makefile.in
@@ -277,7 +277,7 @@ top_build_prefix = @top_build_prefix@
 top_builddir = @top_builddir@
 top_srcdir = @top_srcdir@
 subdir = contrib
-SAMPLES = Mush.rc Pine.rc gpg.rc pgp2.rc pgp5.rc pgp6.rc Tin.rc \
+SAMPLES = Mush.rc Pine.rc gpg.rc pgp2.rc pgp6.rc Tin.rc \
 	sample.mailcap sample.muttrc sample.muttrc-sidebar sample.muttrc-tlr \
 	sample.muttrc-compress sample.muttrc-starter \
 	sample.vimrc-sidebar colors.default colors.linux smime.rc \


[FILE:1341:patches/patch-doc_Makefile.in]
--- doc/Makefile.in.orig	2021-07-12 17:56:40 UTC
+++ doc/Makefile.in
@@ -579,14 +579,7 @@ install-data-local: makedoc-all instdoc
 	    $(INSTALL) -m 644 $(srcdir)/$$f $(DESTDIR)$(docdir) ; \
 	  fi \
 	done
-	$(INSTALL) -m 644 Muttrc $(DESTDIR)$(sysconfdir)/Muttrc.dist
-	-if [ -f $(DESTDIR)$(pkgdatadir)/Muttrc ] ; then \
-		mv $(DESTDIR)$(pkgdatadir)/Muttrc* $(DESTDIR)$(sysconfdir) ; \
-	elif [ -f $(DESTDIR)$(pkgdatadir)/../Muttrc ] ; then \
-	 	mv $(DESTDIR)$(pkgdatadir)/../Muttrc* $(DESTDIR)$(sysconfdir) ; \
-	elif [ ! -f $(DESTDIR)$(sysconfdir)/Muttrc ] ; then \
-		$(INSTALL) -m 644 Muttrc $(DESTDIR)$(sysconfdir) ; \
-	fi
+	$(INSTALL) -m 644 $(srcdir)/Muttrc $(DESTDIR)$(sysconfdir)/Muttrc.sample
 	-if [ -f mutt.info ] ; then \
 	  $(MKDIR_P) $(DESTDIR)$(infodir) ; \
 	  $(INSTALL) -m 644 mutt.info $(DESTDIR)$(infodir) ; \
@@ -628,9 +621,7 @@ uninstall-local:
 
 check:
 manual.txt: manual.html
-	-LC_ALL=C lynx -localhost -dump -nolist -nonumbers -with_backspaces -display_charset=us-ascii manual.html > $@ || \
-	LC_ALL=C w3m -T text/html -I utf-8 -O utf-8 -dump < manual.html > $@ || \
-	LC_ALL=C elinks -dump -no-numbering -no-references manual.html | sed -e 's,\\001, ,g' > $@
+       LC_ALL=C lynx -localhost -dump -nolist -nonumbers -with_backspaces -display_charset=us-ascii manual.html > $@
 
 Muttrc: stamp-doc-rc
 


[FILE:4313:patches/patch-hdrline.c]
--- hdrline.c.orig	2020-07-25 18:22:53 UTC
+++ hdrline.c
@@ -248,6 +248,89 @@ static char *apply_subject_mods (ENVELOP
  * %Y = `x-label:' field (if present, tree unfolded, and != parent's x-label)
  * %Z = status flags	*/
 
+static void
+format_smartdate( char *buf, size_t max, struct tm *tm, smartdate_type type )
+{
+    char *strftime_fmt = NULL;
+
+    switch( type ) {
+        case FUTURE:        /* Date in the future */
+            strftime_fmt = "%d%h%y!";
+            break;
+        case SMARTTIME:     /* Today */
+            strftime_fmt = "%I:%M %p";
+            break;
+        case YESTERDAY:     /* Yesterday */
+            strncpy( buf, "Yesterday", max );
+            break;
+        case WEEKDAY:       /* Within the last 7 days */
+            strftime_fmt = "%A";
+            break;
+        case STANDARD:      /* Within the last six months */
+            strftime_fmt = "%h %d";
+            break;
+        case ANCIENT:       /* Older than 6 months */
+            strftime_fmt = "%h %Y";
+            break;
+    }
+
+    if( strftime_fmt != NULL ) {
+        strftime( buf, max, strftime_fmt, tm );
+    }
+}
+
+static void
+smartdate( char *buf, size_t max, struct tm *tm )
+{
+    smartdate_type type = 0;
+
+    struct tm now;
+
+    time_t sse = mktime( tm );   /* Seconds since epoch */
+    time_t sse_now = time(NULL); /* Seconds since epoch until now */
+
+    int dse = 0;            /* Days since epoch */
+    int dse_now = 0;        /* Days since epoch until today */
+
+    /* Calculate the number of days since epoch */
+    dse = sse / (60*60*24);
+    dse_now = sse_now / (60*60*24);
+
+    /* Default display type */
+    type = STANDARD;
+
+    /* Check if the date is in the future */
+    if( dse > dse_now ) {
+        type = FUTURE;
+    }
+    else {
+        int diff = dse_now - dse;
+        if( diff == 0 ) type = SMARTTIME;
+        else if( diff == 1 ) type = YESTERDAY;
+        else if( diff < 7 ) type = WEEKDAY;
+        else if( diff > 215 ) type = ANCIENT;  /* Surely older than six
+                                                  months */
+        else if( diff > 180 ) {
+            /*
+             * Slightly heavy calculation to check if the date is more
+             * than six months in the past.  This calculation uses
+             * calendar months and not the exact number of days.  So,
+             * January 31, 2003 would be considered more than six months
+             * old whether today's date is August 1 or August 31, 2003
+             */
+            int monthdiff;
+            localtime_r( &sse_now, &now );
+            monthdiff = ( now.tm_mon - tm->tm_mon )
+                + ( ( now.tm_year - tm->tm_year ) * 12 );
+            if( monthdiff > 6 ) {
+                type = ANCIENT;
+            }
+        }
+    }
+
+    format_smartdate( buf, max, tm, type );
+}
+
 static const char *
 hdr_format_str (char *dest,
 		size_t destlen,
@@ -344,6 +427,53 @@ hdr_format_str (char *dest,
       const char *cp;
       struct tm *tm;
       time_t T;
+	int i = 0, invert = 0;
+
+	if (optional && (op == '[' || op == '(')) {
+	  char *is;
+	  T = time(NULL);
+	  T -= (op == '(') ? hdr->received : hdr->date_sent;
+
+	  is = (char *)prefix;
+	  if( *is == '>' ) {
+	    invert = 1;
+	    ++is;
+	  }
+
+	  while( *is && *is != '?' ) {
+	    int t = strtol (is, &is, 10);
+	    switch (*(is++)) {
+	      case '?':
+		break;
+	      case 'y':
+		t *= 365 * 24 * 60 * 60;
+		break;
+	      case 'M':
+		t *= 30 * 24 * 60 * 60;
+		break;
+	      case 'w':
+		t *= 7 * 24 * 60 * 60;
+		break;
+	      case 'd':
+		t *= 24 * 60 * 60;
+		break;
+	      case 'h':
+		t *= 60 * 60;
+		break;
+	      case 'm':
+		t *= 60;
+		break;
+	    }
+	    i += t;
+	  }
+
+	  if (i < 0)
+	    i *= -1;
+
+	  if( (T > i || T < -1*i) ^ invert )
+	    optional = 0;
+	  break;
+	}
 
       p = dest;
 
@@ -421,7 +551,13 @@ hdr_format_str (char *dest,
 
       if (!do_locales)
         setlocale (LC_TIME, "C");
-      strftime (buf2, sizeof (buf2), dest, tm);
+		/* Identify the non-strftime smartdate pattern (%@) */
+		if( strncmp( dest, "%@", 2 ) == 0 ) {
+			smartdate( buf2, sizeof( buf2 ), tm );
+		}
+		else {
+			strftime (buf2, sizeof (buf2), dest, tm);
+		}
       if (!do_locales)
         setlocale (LC_TIME, "");
 


[FILE:1222:patches/patch-init.h]
--- init.h.orig	2021-07-12 17:43:55 UTC
+++ init.h
@@ -1261,6 +1261,11 @@ struct option_t MuttVars[] = {
   ** sent to both the list and your address, resulting in two copies
   ** of the same email for you.
   */
+  { "force_base64",   DT_BOOL, R_NONE, {.l=OPTFORCEBASE64}, {.l=0} },
+  /*
+  ** .pp
+  ** If you need to encode all text parts to base64, set this option.
+  */
   { "force_name",	DT_BOOL, R_NONE, {.l=OPTFORCENAME}, {.l=0} },
   /*
   ** .pp
@@ -3799,6 +3804,15 @@ struct option_t MuttVars[] = {
   ** to determine the key to use. It will ask you to supply a key, if it can't find one.
   ** (S/MIME only)
   */
+  { "smime_dont_check_sender",	DT_BOOL, R_NONE, {.l=OPTSMIMENOSENDER}, {.l=0} },
+  /*
+  ** .pp
+  ** This flag controls wether you want the skip the check for the sender's
+  ** email address against the email address stored in the certificate. 
+  ** This can be useful if most of your email senders use SMIMEv3 which no
+  ** longer needs email-addresses as part of the certificates.
+  ** It is not set by default.
+  */
   { "smime_self_encrypt_as",	DT_SYN,  R_NONE, {.p="smime_default_key"}, {.p=0} },
   { "smime_default_key",		DT_STR,	 R_NONE, {.p=&SmimeDefaultKey}, {.p=0} },
   /*


[FILE:926:patches/patch-mutt.h]
--- mutt.h.orig	2021-06-12 18:01:35 UTC
+++ mutt.h
@@ -168,6 +168,16 @@ typedef enum
   MUTT_WRITE_HEADER_MIME
 } mutt_write_header_mode;
 
+/* flags for SmartDate */
+typedef enum {
+    FUTURE      = 1,
+    SMARTTIME   = 2,
+    YESTERDAY   = 3,
+    WEEKDAY     = 4,
+    STANDARD    = 5,
+    ANCIENT     = 6
+} smartdate_type;
+
 /* types for mutt_add_hook() */
 #define MUTT_FOLDERHOOK  1
 #define MUTT_MBOXHOOK    (1<<1)
@@ -236,6 +246,7 @@ enum
   MUTT_EXPIRED,
   MUTT_SUPERSEDED,
   MUTT_TRASH,
+  MUTT_THREADCOMPLETE,
 
   /* actions for mutt_pattern_comp/mutt_pattern_exec */
   MUTT_AND,
@@ -423,6 +434,7 @@ enum
   OPTFCCCLEAR,
   OPTFLAGSAFE,
   OPTFOLLOWUPTO,
+  OPTFORCEBASE64,
   OPTFORCENAME,
   OPTFORWDECODE,
   OPTFORWQUOTE,
@@ -596,6 +608,7 @@ enum
   OPTSMIMEISDEFAULT,
   OPTSMIMESELFENCRYPT,
   OPTASKCERTLABEL,
+  OPTSMIMENOSENDER,
   OPTSDEFAULTDECRYPTKEY,
   OPTPGPIGNORESUB,
   OPTPGPCHECKEXIT,


[FILE:721:patches/patch-sendlib.c]
--- sendlib.c.orig	2021-07-12 17:43:55 UTC
+++ sendlib.c
@@ -1214,7 +1214,9 @@ static void mutt_set_encoding (BODY *b,
   if (b->type == TYPETEXT)
   {
     char *chsname = mutt_get_body_charset (send_charset, sizeof (send_charset), b);
-    if ((info->lobin && ascii_strncasecmp (chsname, "iso-2022", 8)) || info->linemax > 990 || (info->from && option (OPTENCODEFROM)))
+    if (option (OPTFORCEBASE64))
+      b->encoding = ENCBASE64;
+    else if ((info->lobin && ascii_strncasecmp (chsname, "iso-2022", 8)) || info->linemax > 990 || (info->from && option (OPTENCODEFROM)))
       b->encoding = ENCQUOTEDPRINTABLE;
     else if (info->hibin)
       b->encoding = option (OPTALLOW8BIT) ? ENC8BIT : ENCQUOTEDPRINTABLE;

