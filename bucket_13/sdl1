# Buildsheet autogenerated by ravenadm tool -- Do not edit.

NAMEBASE=		sdl1
VERSION=		1.2.15
REVISION=		2
KEYWORDS=		devel
VARIANTS=		std
SDESC[std]=		Cross-platform multimedia development API
HOMEPAGE=		http://www.libsdl.org/
CONTACT=		nobody

DOWNLOAD_GROUPS=	main
SITES[main]=		http://www.libsdl.org/release/
			SF/libsdl/SDL/1.2.15
DISTFILE[1]=		SDL-1.2.15.tar.gz:main
DF_INDEX=		1
SPKGS[std]=		set
			primary
			docs
			examples
			man
			dev

OPTIONS_AVAILABLE=	AALIB OSS SNDIO PULSEAUDIO OPENGL X11
OPTIONS_STANDARD=	AALIB OSS SNDIO PULSEAUDIO OPENGL X11
OPTGROUP_UNLIMITED=	AUDIO
OPTDESCR[AUDIO]=	Audio Support
OPTGROUP[AUDIO]=	AALIB OSS SNDIO PULSEAUDIO
OPT_ON[freebsd]=	OSS
OPT_ON[all]=		AALIB OPENGL X11
OPT_ON[dragonfly]=	OSS

BUILD_DEPENDS=		nasm:primary:std

USES=			cpe gmake libtool pkgconfig iconv fbsd10fix

DISTNAME=		SDL-1.2.15

LICENSE=		LGPL21+:primary
LICENSE_TERMS=		primary:{{WRKDIR}}/TERMS
LICENSE_FILE=		LGPL21+:{{WRKSRC}}/COPYING
LICENSE_AWK=		TERMS:"SDL_config"
LICENSE_SOURCE=		TERMS:{{WRKSRC}}/src/SDL.c
LICENSE_SCHEME=		solo

CPE_PRODUCT=		simple_directmedia_layer
CPE_VENDOR=		libsdl
FPC_EQUIVALENT=		devel/sdl12

MUST_CONFIGURE=		gnu
CONFIGURE_ARGS=		--disable-alsa
			--disable-alsatest
			--disable-arts
			--disable-video-directfb
			--disable-video-ggi
CONFIGURE_ENV=		ac_cv_header_libusbhid_h=no

[OPENGL].BUILDRUN_DEPENDS_ON=		libglvnd:primary:std
[OPENGL].BUILD_DEPENDS_ON=		libglvnd:dev:std
[OPENGL].CONFIGURE_ENABLE_BOTH=		video-opengl

[SNDIO].BUILDRUN_DEPENDS_ON=		sndio:primary:std
[SNDIO].BUILD_DEPENDS_ON=		sndio:dev:std
[SNDIO].CONFIGURE_ENABLE_BOTH=		sndio

[AALIB].BUILDRUN_DEPENDS_ON=		aalib:primary:std
[AALIB].BUILD_DEPENDS_ON=		aalib:dev:std
[AALIB].CONFIGURE_ENABLE_BOTH=		video-aalib

[PULSEAUDIO].BROKEN_ON=			not yet implemented

[OSS].CONFIGURE_ENABLE_BOTH=		oss

[X11].CONFIGURE_ENABLE_BOTH=		video-x11
[X11].XORG_COMPONENTS_ON=		x11
					xrender
					xrandr
					xext

post-patch:
	${REINPLACE_CMD} -e '/EXTRA_LDFLAGS/s/-liconv/${ICONV_LIB}/' \
		${WRKSRC}/configure

post-patch-SNDIO-ON:
	@${MKDIR} ${WRKSRC}/src/audio/sndio
	${CP} ${FILESDIR}/SDL_sndioaudio.* ${WRKSRC}/src/audio/sndio

post-install:
	@${MKDIR} ${STAGEDIR}${STD_DOCDIR} ${STAGEDIR}${STD_EXAMPLESDIR}
.for doc in BUGS CREDITS README README-SDL.txt WhatsNew docs.html
	${INSTALL_DATA} ${WRKSRC}/${doc} ${STAGEDIR}${STD_DOCDIR}/
.endfor
	(cd ${WRKSRC} && ${COPYTREE_SHARE} docs \
		${STAGEDIR}${STD_DOCDIR}/ "! -regex .*/man3.*")
.for exam in test/*.c test/*.bmp test/*.dat test/*.xbm test/*.wav
	${INSTALL_DATA} ${WRKSRC}/${exam} ${STAGEDIR}${STD_EXAMPLESDIR}/
.endfor
	${STRIP_CMD} ${STAGEDIR}${PREFIX}/lib/libSDL-1.2.so.0

[FILE:385:descriptions/desc.primary]
The SDL library (series 1) is designed to make it easy to write games that
run on UNIX, Win32 and BeOS using the various native high-performance media
interfaces, (for video, audio, etc) and presenting a single source-code
level API to your application.  This is a fairly low level API, but using
this, completely portable applications can be written with a great deal of
flexibility.


[FILE:96:distinfo]
d6d316a793e5e348155f0dd93b979798933fb98aa1edebcc108829d6474aad00      3920622 SDL-1.2.15.tar.gz


[FILE:59:manifests/plist.primary]
bin/sdl-config
lib/
 libSDL-1.2.so.0
 libSDL-1.2.so.0.11.4


[FILE:3805:manifests/plist.man]
share/man/man3/
 SDLKey.3.gz
 SDL_ActiveEvent.3.gz
 SDL_AddTimer.3.gz
 SDL_AudioCVT.3.gz
 SDL_AudioSpec.3.gz
 SDL_BlitSurface.3.gz
 SDL_BuildAudioCVT.3.gz
 SDL_CD.3.gz
 SDL_CDClose.3.gz
 SDL_CDEject.3.gz
 SDL_CDName.3.gz
 SDL_CDNumDrives.3.gz
 SDL_CDOpen.3.gz
 SDL_CDPause.3.gz
 SDL_CDPlay.3.gz
 SDL_CDPlayTracks.3.gz
 SDL_CDResume.3.gz
 SDL_CDStatus.3.gz
 SDL_CDStop.3.gz
 SDL_CDtrack.3.gz
 SDL_CloseAudio.3.gz
 SDL_Color.3.gz
 SDL_CondBroadcast.3.gz
 SDL_CondSignal.3.gz
 SDL_CondWait.3.gz
 SDL_CondWaitTimeout.3.gz
 SDL_ConvertAudio.3.gz
 SDL_ConvertSurface.3.gz
 SDL_CreateCond.3.gz
 SDL_CreateCursor.3.gz
 SDL_CreateMutex.3.gz
 SDL_CreateRGBSurface.3.gz
 SDL_CreateRGBSurfaceFrom.3.gz
 SDL_CreateSemaphore.3.gz
 SDL_CreateThread.3.gz
 SDL_CreateYUVOverlay.3.gz
 SDL_Delay.3.gz
 SDL_DestroyCond.3.gz
 SDL_DestroyMutex.3.gz
 SDL_DestroySemaphore.3.gz
 SDL_DisplayFormat.3.gz
 SDL_DisplayFormatAlpha.3.gz
 SDL_DisplayYUVOverlay.3.gz
 SDL_EnableKeyRepeat.3.gz
 SDL_EnableUNICODE.3.gz
 SDL_Event.3.gz
 SDL_EventState.3.gz
 SDL_ExposeEvent.3.gz
 SDL_FillRect.3.gz
 SDL_Flip.3.gz
 SDL_FreeCursor.3.gz
 SDL_FreeSurface.3.gz
 SDL_FreeWAV.3.gz
 SDL_FreeYUVOverlay.3.gz
 SDL_GL_GetAttribute.3.gz
 SDL_GL_GetProcAddress.3.gz
 SDL_GL_LoadLibrary.3.gz
 SDL_GL_SetAttribute.3.gz
 SDL_GL_SwapBuffers.3.gz
 SDL_GLattr.3.gz
 SDL_GetAppState.3.gz
 SDL_GetAudioStatus.3.gz
 SDL_GetClipRect.3.gz
 SDL_GetCursor.3.gz
 SDL_GetError.3.gz
 SDL_GetEventFilter.3.gz
 SDL_GetGamma.3.gz
 SDL_GetGammaRamp.3.gz
 SDL_GetKeyName.3.gz
 SDL_GetKeyState.3.gz
 SDL_GetModState.3.gz
 SDL_GetMouseState.3.gz
 SDL_GetRGB.3.gz
 SDL_GetRGBA.3.gz
 SDL_GetRelativeMouseState.3.gz
 SDL_GetThreadID.3.gz
 SDL_GetTicks.3.gz
 SDL_GetVideoInfo.3.gz
 SDL_GetVideoSurface.3.gz
 SDL_Init.3.gz
 SDL_InitSubSystem.3.gz
 SDL_JoyAxisEvent.3.gz
 SDL_JoyBallEvent.3.gz
 SDL_JoyButtonEvent.3.gz
 SDL_JoyHatEvent.3.gz
 SDL_JoystickClose.3.gz
 SDL_JoystickEventState.3.gz
 SDL_JoystickGetAxis.3.gz
 SDL_JoystickGetBall.3.gz
 SDL_JoystickGetButton.3.gz
 SDL_JoystickGetHat.3.gz
 SDL_JoystickIndex.3.gz
 SDL_JoystickName.3.gz
 SDL_JoystickNumAxes.3.gz
 SDL_JoystickNumBalls.3.gz
 SDL_JoystickNumButtons.3.gz
 SDL_JoystickNumHats.3.gz
 SDL_JoystickOpen.3.gz
 SDL_JoystickOpened.3.gz
 SDL_JoystickUpdate.3.gz
 SDL_KeyboardEvent.3.gz
 SDL_KillThread.3.gz
 SDL_ListModes.3.gz
 SDL_LoadBMP.3.gz
 SDL_LoadWAV.3.gz
 SDL_LockAudio.3.gz
 SDL_LockSurface.3.gz
 SDL_LockYUVOverlay.3.gz
 SDL_MapRGB.3.gz
 SDL_MapRGBA.3.gz
 SDL_MixAudio.3.gz
 SDL_MouseButtonEvent.3.gz
 SDL_MouseMotionEvent.3.gz
 SDL_NumJoysticks.3.gz
 SDL_OpenAudio.3.gz
 SDL_Overlay.3.gz
 SDL_Palette.3.gz
 SDL_PauseAudio.3.gz
 SDL_PeepEvents.3.gz
 SDL_PixelFormat.3.gz
 SDL_PollEvent.3.gz
 SDL_PumpEvents.3.gz
 SDL_PushEvent.3.gz
 SDL_Quit.3.gz
 SDL_QuitEvent.3.gz
 SDL_QuitSubSystem.3.gz
 SDL_RWFromFile.3.gz
 SDL_Rect.3.gz
 SDL_RemoveTimer.3.gz
 SDL_ResizeEvent.3.gz
 SDL_SaveBMP.3.gz
 SDL_SemPost.3.gz
 SDL_SemTryWait.3.gz
 SDL_SemValue.3.gz
 SDL_SemWait.3.gz
 SDL_SemWaitTimeout.3.gz
 SDL_SetAlpha.3.gz
 SDL_SetClipRect.3.gz
 SDL_SetColorKey.3.gz
 SDL_SetColors.3.gz
 SDL_SetCursor.3.gz
 SDL_SetEventFilter.3.gz
 SDL_SetGamma.3.gz
 SDL_SetGammaRamp.3.gz
 SDL_SetModState.3.gz
 SDL_SetPalette.3.gz
 SDL_SetTimer.3.gz
 SDL_SetVideoMode.3.gz
 SDL_ShowCursor.3.gz
 SDL_Surface.3.gz
 SDL_SysWMEvent.3.gz
 SDL_ThreadID.3.gz
 SDL_UnlockAudio.3.gz
 SDL_UnlockSurface.3.gz
 SDL_UnlockYUVOverlay.3.gz
 SDL_UpdateRect.3.gz
 SDL_UpdateRects.3.gz
 SDL_UserEvent.3.gz
 SDL_VideoDriverName.3.gz
 SDL_VideoInfo.3.gz
 SDL_VideoModeOK.3.gz
 SDL_WM_GetCaption.3.gz
 SDL_WM_GrabInput.3.gz
 SDL_WM_IconifyWindow.3.gz
 SDL_WM_SetCaption.3.gz
 SDL_WM_SetIcon.3.gz
 SDL_WM_ToggleFullScreen.3.gz
 SDL_WaitEvent.3.gz
 SDL_WaitThread.3.gz
 SDL_WarpMouse.3.gz
 SDL_WasInit.3.gz
 SDL_keysym.3.gz
 SDL_mutexP.3.gz
 SDL_mutexV.3.gz


[FILE:531:manifests/plist.dev]
include/SDL/
 SDL.h
 SDL_active.h
 SDL_audio.h
 SDL_byteorder.h
 SDL_cdrom.h
 SDL_config.h
 SDL_cpuinfo.h
 SDL_endian.h
 SDL_error.h
 SDL_events.h
 SDL_getenv.h
 SDL_joystick.h
 SDL_keyboard.h
 SDL_keysym.h
 SDL_loadso.h
 SDL_main.h
 SDL_mouse.h
 SDL_mutex.h
 SDL_name.h
 SDL_opengl.h
 SDL_platform.h
 SDL_quit.h
 SDL_rwops.h
 SDL_stdinc.h
 SDL_syswm.h
 SDL_thread.h
 SDL_timer.h
 SDL_types.h
 SDL_version.h
 SDL_video.h
 begin_code.h
 close_code.h
lib/
 libSDL.a
 libSDL.so
 libSDLmain.a
lib/pkgconfig/sdl.pc
share/aclocal/sdl.m4


[FILE:541:patches/patch-Makefile.in]
--- Makefile.in.orig	2012-01-19 06:30:05 UTC
+++ Makefile.in
@@ -49,7 +49,7 @@ LT_AGE      = @LT_AGE@
 LT_CURRENT  = @LT_CURRENT@
 LT_RELEASE  = @LT_RELEASE@
 LT_REVISION = @LT_REVISION@
-LT_LDFLAGS  = -no-undefined -rpath $(DESTDIR)$(libdir) -release $(LT_RELEASE) -version-info $(LT_CURRENT):$(LT_REVISION):$(LT_AGE)
+LT_LDFLAGS  = -no-undefined -rpath $(libdir) -release $(LT_RELEASE) -version-info $(LT_CURRENT):$(LT_REVISION):$(LT_AGE)
 
 all: $(srcdir)/configure Makefile $(objects) $(objects)/$(TARGET) $(objects)/$(SDLMAIN_TARGET)
 


[FILE:4283:patches/patch-configure]
--- configure.orig	2012-01-19 06:30:12 UTC
+++ configure
@@ -2039,12 +2039,6 @@ ac_compiler_gnu=$ac_cv_c_compiler_gnu
 
 ac_config_headers="$ac_config_headers include/SDL_config.h"
 
-
-cat >>confdefs.h <<\_ACEOF
-#define _GNU_SOURCE 1
-_ACEOF
-
-
 ac_aux_dir=
 for ac_dir in $srcdir/build-scripts; do
   if test -f "$ac_dir/install-sh"; then
@@ -4209,7 +4203,7 @@ darwin* | rhapsody*)
   lt_cv_deplibs_check_method=pass_all
   ;;
 
-freebsd* | dragonfly*)
+freebsd* | dragonfly* | midnight*)
   if echo __ELF__ | $CC -E - | $GREP __ELF__ > /dev/null; then
     case $host_cpu in
     i*86 )
@@ -8411,7 +8405,7 @@ if test -z "$aix_libpath"; then aix_libp
       ;;
 
     # FreeBSD 3 and greater uses gcc -shared to do shared libraries.
-    freebsd* | dragonfly*)
+    freebsd* | dragonfly* | midnight*)
       archive_cmds='$CC -shared -o $lib $libobjs $deplibs $compiler_flags'
       hardcode_libdir_flag_spec='-R$libdir'
       hardcode_direct=yes
@@ -9290,7 +9284,7 @@ freebsd1*)
   dynamic_linker=no
   ;;
 
-freebsd* | dragonfly*)
+freebsd* | dragonfly* | midnight*)
   # DragonFly does not have aout.  When/if they implement a new
   # versioning mechanism, adjust this.
   if test -x /usr/bin/objformat; then
@@ -13308,7 +13302,7 @@ if test -z "$aix_libpath"; then aix_libp
         archive_cmds_need_lc_CXX=no
         ;;
 
-      freebsd* | dragonfly*)
+      freebsd* | dragonfly* | midnight*)
         # FreeBSD 3 and later use GNU C++ and GNU ld with standard ELF
         # conventions
         ld_shlibs_CXX=yes
@@ -14258,7 +14252,7 @@ echo $ECHO_N "checking for $compiler opt
 	    ;;
 	esac
 	;;
-      freebsd* | dragonfly*)
+      freebsd* | dragonfly* | midnight*)
 	# FreeBSD uses GNU C++
 	;;
       hpux9* | hpux10* | hpux11*)
@@ -15062,7 +15056,7 @@ freebsd1*)
   dynamic_linker=no
   ;;
 
-freebsd* | dragonfly*)
+freebsd* | dragonfly* | midnight*)
   # DragonFly does not have aout.  When/if they implement a new
   # versioning mechanism, adjust this.
   if test -x /usr/bin/objformat; then
@@ -15826,7 +15820,7 @@ case "$host" in
         BASE_LDFLAGS="-mno-cygwin"
         ;;
     *)
-        BASE_CFLAGS="-D_GNU_SOURCE=1"
+        BASE_CFLAGS=""
         BASE_LDFLAGS=""
         ;;
 esac
@@ -20999,6 +20993,16 @@ _ACEOF
         fi
     fi
 }
+ 
+CheckSndio()
+{
+if test "x${enable_sndio}" = "xyes"; then :
+  SOURCES="$SOURCES $srcdir/src/audio/sndio/SDL_sndioaudio.c"
+  EXTRA_CFLAGS="$EXTRA_CFLAGS -DSDL_AUDIO_DRIVER_SNDIO=1"
+  EXTRA_LDFLAGS="$EXTRA_LDFLAGS -lsndio"
+  have_audio=yes
+fi
+}
 
 CheckPulseAudio()
 {
@@ -26934,7 +26938,7 @@ fi
 # causes Carbon.p complaints?
 #            pthread_cflags="-D_REENTRANT -D_THREAD_SAFE"
             ;;
-        *-*-freebsd*|*-*-dragonfly*)
+        *-*-freebsd*|*-*-dragonfly*|*-*-midnight*)
             pthread_cflags="-D_REENTRANT -D_THREAD_SAFE"
             pthread_lib="-pthread"
             ;;
@@ -29518,7 +29522,7 @@ _ACEOF
             have_timers=yes
         fi
         ;;
-    *-*-linux*|*-*-uclinux*|*-*-gnu*|*-*-k*bsd*-gnu|*-*-bsdi*|*-*-freebsd*|*-*-dragonfly*|*-*-netbsd*|*-*-openbsd*|*-*-sysv5*|*-*-solaris*|*-*-hpux*|*-*-irix*|*-*-aix*|*-*-osf*)
+    *-*-linux*|*-*-uclinux*|*-*-gnu*|*-*-k*bsd*-gnu|*-*-bsdi*|*-*-freebsd*|*-*-dragonfly*|*-*-netbsd*|*-*-openbsd*|*-*-sysv5*|*-*-solaris*|*-*-hpux*|*-*-irix*|*-*-aix*|*-*-osf*|*-*-midnight*)
         case "$host" in
             *-*-linux*)         ARCH=linux ;;
             *-*-uclinux*)       ARCH=linux ;;
@@ -29529,6 +29533,7 @@ _ACEOF
             *-*-bsdi*)          ARCH=bsdi ;;
             *-*-freebsd*)       ARCH=freebsd ;;
             *-*-dragonfly*)     ARCH=freebsd ;;
+            *-*-midnightbsd*)   ARCH=freebsd ;;
             *-*-netbsd*)        ARCH=netbsd ;;
             *-*-openbsd*)       ARCH=openbsd ;;
             *-*-sysv5*)         ARCH=sysv5 ;;
@@ -29551,6 +29556,7 @@ _ACEOF
         CheckALSA
         CheckARTSC
         CheckESD
+        CheckSndio
         CheckPulseAudio
         CheckNAS
         CheckX11
@@ -29628,7 +29634,7 @@ _ACEOF
                 SOURCES="$SOURCES $srcdir/src/cdrom/linux/*.c"
                 have_cdrom=yes
             ;;
-            *freebsd*)
+            *freebsd*|*midnight*)
                 cat >>confdefs.h <<\_ACEOF
 #define SDL_CDROM_FREEBSD 1
 _ACEOF


[FILE:474:patches/patch-sdl-config.in]
#
# Temporary hack to provide iconv include directory is well
# (sdl explicitly includes iconv.h)
#
--- sdl-config.in.orig	2012-01-19 06:30:06 UTC
+++ sdl-config.in
@@ -42,7 +42,7 @@ while test $# -gt 0; do
       echo @SDL_VERSION@
       ;;
     --cflags)
-      echo -I@includedir@/SDL @SDL_CFLAGS@
+      echo -I@includedir@/SDL -I@includedir@ @SDL_CFLAGS@
       ;;
 @ENABLE_SHARED_TRUE@    --libs)
 @ENABLE_SHARED_TRUE@      echo -L@libdir@ @SDL_RLD_FLAGS@ @SDL_LIBS@


[FILE:276:patches/patch-sdl.pc.in]
--- sdl.pc.in.orig	2012-01-19 06:30:06 UTC
+++ sdl.pc.in
@@ -12,4 +12,4 @@ Requires:
 Conflicts:
 Libs: -L${libdir} @SDL_RLD_FLAGS@ @SDL_LIBS@
 Libs.private: @SDL_STATIC_LIBS@
-Cflags: -I${includedir}/SDL @SDL_CFLAGS@
+Cflags: -I${includedir}/SDL -I${includedir} @SDL_CFLAGS@


[FILE:478:patches/patch-src_audio_SDL__audio.c]
$OpenBSD: patch-src_audio_SDL_audio_c,v 1.17 2012/03/02 09:10:38 dcoppa Exp $
--- src/audio/SDL_audio.c.orig	2012-01-19 06:30:06 UTC
+++ src/audio/SDL_audio.c
@@ -36,12 +36,16 @@
 
 /* Available audio drivers */
 static AudioBootStrap *bootstrap[] = {
+
 #if SDL_AUDIO_DRIVER_PULSE
 	&PULSE_bootstrap,
 #endif
 #if SDL_AUDIO_DRIVER_ALSA
 	&ALSA_bootstrap,
 #endif
+#if SDL_AUDIO_DRIVER_SNDIO
+	&SNDIO_bootstrap,
+#endif
 #if SDL_AUDIO_DRIVER_BSD
 	&BSD_AUDIO_bootstrap,
 #endif


[FILE:449:patches/patch-src_audio_SDL__sysaudio.h]
$OpenBSD: patch-src_audio_SDL_sysaudio_h,v 1.6 2012/03/02 09:10:38 dcoppa Exp $
--- src/audio/SDL_sysaudio.h.orig	2012-01-19 06:30:06 UTC
+++ src/audio/SDL_sysaudio.h
@@ -105,6 +105,9 @@ typedef struct AudioBootStrap {
 #if SDL_AUDIO_DRIVER_BSD
 extern AudioBootStrap BSD_AUDIO_bootstrap;
 #endif
+#if SDL_AUDIO_DRIVER_SNDIO
+extern AudioBootStrap SNDIO_bootstrap;
+#endif
 #if SDL_AUDIO_DRIVER_PULSE
 extern AudioBootStrap PULSE_bootstrap;
 #endif


[FILE:469:patches/patch-src_cdrom_freebsd_SDL_syscdrom.c]
--- src/cdrom/freebsd/SDL_syscdrom.c.orig	2012-01-19 06:30:06 UTC
+++ src/cdrom/freebsd/SDL_syscdrom.c
@@ -188,7 +188,7 @@ int  SDL_SYS_CDInit(void)
 			char *insert;
 			exists = 1;
 			for ( j=checklist[i][1]; exists; ++j ) {
-				SDL_snprintf(drive, SDL_arraysize(drive), "/dev/%sc", &checklist[i][3]);
+				SDL_snprintf(drive, SDL_arraysize(drive), "/dev/%s", &checklist[i][3]);
 				insert = SDL_strchr(drive, '?');
 				if ( insert != NULL ) {
 					*insert = j;


[FILE:7860:patches/patch-src_joystick_bsd_SDL_sysjoystick.c]
--- src/joystick/bsd/SDL_sysjoystick.c.orig	2012-01-19 06:30:06 UTC
+++ src/joystick/bsd/SDL_sysjoystick.c
@@ -82,7 +82,9 @@
 #define MAX_JOYS	(MAX_UHID_JOYS + MAX_JOY_JOYS)
 
 struct report {
-#if defined(__FREEBSD__) && (__FreeBSD_kernel_version > 800063)
+#if defined(__FREEBSD__) && (__FreeBSD_kernel_version > 900000)
+	void *buf;			/* Buffer */
+#elif defined(__FREEBSD__) && (__FreeBSD_kernel_version > 800063)
 	struct	usb_gen_descriptor *buf;	/* Buffer */
 #else
 	struct	usb_ctl_report *buf;	/* Buffer */
@@ -148,8 +150,10 @@ static char *joydevnames[MAX_JOYS];
 static int	report_alloc(struct report *, struct report_desc *, int);
 static void	report_free(struct report *);
 
-#if defined(USBHID_UCR_DATA) || defined(__FreeBSD_kernel__)
+#if defined(USBHID_UCR_DATA) || (defined(__FreeBSD_kernel__) && __FreeBSD_kernel_version <= 800063)
 #define REP_BUF_DATA(rep) ((rep)->buf->ucr_data)
+#elif (defined(__FREEBSD__) && (__FreeBSD_kernel_version > 900000))
+#define REP_BUF_DATA(rep) ((rep)->buf)
 #elif (defined(__FREEBSD__) && (__FreeBSD_kernel_version > 800063))
 #define REP_BUF_DATA(rep) ((rep)->buf->ugd_data)
 #else
@@ -411,47 +415,47 @@ SDL_SYS_JoystickUpdate(SDL_Joystick *joy
 	struct joystick gameport;
  
 	if (joy->hwdata->type == BSDJOY_JOY) {
-		if (read(joy->hwdata->fd, &gameport, sizeof gameport) != sizeof gameport)
-			return;
-		if (abs(joy->hwdata->x - gameport.x) > 8) {
-			joy->hwdata->x = gameport.x;
-			if (joy->hwdata->x < joy->hwdata->xmin) {
-				joy->hwdata->xmin = joy->hwdata->x;
-			}
-			if (joy->hwdata->x > joy->hwdata->xmax) {
-				joy->hwdata->xmax = joy->hwdata->x;
-			}
-			if (joy->hwdata->xmin == joy->hwdata->xmax) {
-				joy->hwdata->xmin--;
-				joy->hwdata->xmax++;
-			}
-			v = (Sint32)joy->hwdata->x;
-			v -= (joy->hwdata->xmax + joy->hwdata->xmin + 1)/2;
-			v *= 32768/((joy->hwdata->xmax - joy->hwdata->xmin + 1)/2);
-			SDL_PrivateJoystickAxis(joy, 0, v);
-		}
-		if (abs(joy->hwdata->y - gameport.y) > 8) {
-			joy->hwdata->y = gameport.y;
-			if (joy->hwdata->y < joy->hwdata->ymin) {
-				joy->hwdata->ymin = joy->hwdata->y;
+		while (read(joy->hwdata->fd, &gameport, sizeof gameport) == sizeof gameport) {
+			if (abs(joy->hwdata->x - gameport.x) > 8) {
+				joy->hwdata->x = gameport.x;
+				if (joy->hwdata->x < joy->hwdata->xmin) {
+					joy->hwdata->xmin = joy->hwdata->x;
+				}
+				if (joy->hwdata->x > joy->hwdata->xmax) {
+					joy->hwdata->xmax = joy->hwdata->x;
+				}
+				if (joy->hwdata->xmin == joy->hwdata->xmax) {
+					joy->hwdata->xmin--;
+					joy->hwdata->xmax++;
+				}
+				v = (Sint32)joy->hwdata->x;
+				v -= (joy->hwdata->xmax + joy->hwdata->xmin + 1)/2;
+				v *= 32768/((joy->hwdata->xmax - joy->hwdata->xmin + 1)/2);
+				SDL_PrivateJoystickAxis(joy, 0, v);
+			}
+			if (abs(joy->hwdata->y - gameport.y) > 8) {
+				joy->hwdata->y = gameport.y;
+				if (joy->hwdata->y < joy->hwdata->ymin) {
+					joy->hwdata->ymin = joy->hwdata->y;
+				}
+				if (joy->hwdata->y > joy->hwdata->ymax) {
+					joy->hwdata->ymax = joy->hwdata->y;
+				}
+				if (joy->hwdata->ymin == joy->hwdata->ymax) {
+					joy->hwdata->ymin--;
+					joy->hwdata->ymax++;
+				}
+				v = (Sint32)joy->hwdata->y;
+				v -= (joy->hwdata->ymax + joy->hwdata->ymin + 1)/2;
+				v *= 32768/((joy->hwdata->ymax - joy->hwdata->ymin + 1)/2);
+				SDL_PrivateJoystickAxis(joy, 1, v);
 			}
-			if (joy->hwdata->y > joy->hwdata->ymax) {
-				joy->hwdata->ymax = joy->hwdata->y;
+			if (gameport.b1 != joy->buttons[0]) {
+				SDL_PrivateJoystickButton(joy, 0, gameport.b1);
 			}
-			if (joy->hwdata->ymin == joy->hwdata->ymax) {
-				joy->hwdata->ymin--;
-				joy->hwdata->ymax++;
+			if (gameport.b2 != joy->buttons[1]) {
+				SDL_PrivateJoystickButton(joy, 1, gameport.b2);
 			}
-			v = (Sint32)joy->hwdata->y;
-			v -= (joy->hwdata->ymax + joy->hwdata->ymin + 1)/2;
-			v *= 32768/((joy->hwdata->ymax - joy->hwdata->ymin + 1)/2);
-			SDL_PrivateJoystickAxis(joy, 1, v);
-		}
-		if (gameport.b1 != joy->buttons[0]) {
-			SDL_PrivateJoystickButton(joy, 0, gameport.b1);
-		}
-		if (gameport.b2 != joy->buttons[1]) {
-			SDL_PrivateJoystickButton(joy, 1, gameport.b2);
 		}
 		return;
 	}
@@ -459,65 +463,61 @@ SDL_SYS_JoystickUpdate(SDL_Joystick *joy
 	
 	rep = &joy->hwdata->inreport;
 
-	if (read(joy->hwdata->fd, REP_BUF_DATA(rep), rep->size) != rep->size) {
-		return;
-	}
+	while (read(joy->hwdata->fd, REP_BUF_DATA(rep), rep->size) == rep->size) {
 #if defined(USBHID_NEW) || (defined(__FREEBSD__) && __FreeBSD_kernel_version >= 500111) || defined(__FreeBSD_kernel__)
-	hdata = hid_start_parse(joy->hwdata->repdesc, 1 << hid_input, rep->rid);
+		hdata = hid_start_parse(joy->hwdata->repdesc, 1 << hid_input, rep->rid);
 #else
-	hdata = hid_start_parse(joy->hwdata->repdesc, 1 << hid_input);
+		hdata = hid_start_parse(joy->hwdata->repdesc, 1 << hid_input);
 #endif
-	if (hdata == NULL) {
-		fprintf(stderr, "%s: Cannot start HID parser\n",
-		    joy->hwdata->path);
-		return;
-	}
+		if (hdata == NULL) {
+			/*fprintf(stderr, "%s: Cannot start HID parser\n", joy->hwdata->path);*/
+			continue;
+		}
 
-	for (nbutton = 0; hid_get_item(hdata, &hitem) > 0;) {
-		switch (hitem.kind) {
-		case hid_input:
-			switch (HID_PAGE(hitem.usage)) {
-			case HUP_GENERIC_DESKTOP: {
-			    unsigned usage = HID_USAGE(hitem.usage);
-			    int joyaxe = usage_to_joyaxe(usage);
-			    if (joyaxe >= 0) {
-				naxe = joy->hwdata->axis_map[joyaxe];
-				/* scaleaxe */
-				v = (Sint32)hid_get_data(REP_BUF_DATA(rep),
-							 &hitem);
-				v -= (hitem.logical_maximum + hitem.logical_minimum + 1)/2;
-				v *= 32768/((hitem.logical_maximum - hitem.logical_minimum + 1)/2);
-				if (v != joy->axes[naxe]) {
-				    SDL_PrivateJoystickAxis(joy, naxe, v);
+		for (nbutton = 0; hid_get_item(hdata, &hitem) > 0;) {
+			switch (hitem.kind) {
+			case hid_input:
+				switch (HID_PAGE(hitem.usage)) {
+				case HUP_GENERIC_DESKTOP: {
+					unsigned usage = HID_USAGE(hitem.usage);
+					int joyaxe = usage_to_joyaxe(usage);
+					if (joyaxe >= 0) {
+					naxe = joy->hwdata->axis_map[joyaxe];
+					/* scaleaxe */
+					v = (Sint32)hid_get_data(REP_BUF_DATA(rep),
+								 &hitem);
+					v -= (hitem.logical_maximum + hitem.logical_minimum + 1)/2;
+					v *= 32768/((hitem.logical_maximum - hitem.logical_minimum + 1)/2);
+					if (v != joy->axes[naxe]) {
+						SDL_PrivateJoystickAxis(joy, naxe, v);
+					}
+					} else if (usage == HUG_HAT_SWITCH) {
+					v = (Sint32)hid_get_data(REP_BUF_DATA(rep),
+								 &hitem);
+					SDL_PrivateJoystickHat(joy, 0,
+						hatval_to_sdl(v)-hitem.logical_minimum);
+					}
+					break;
 				}
-			    } else if (usage == HUG_HAT_SWITCH) {
-				v = (Sint32)hid_get_data(REP_BUF_DATA(rep),
-							 &hitem);
-				SDL_PrivateJoystickHat(joy, 0,
-					hatval_to_sdl(v)-hitem.logical_minimum);
-			    }
-			    break;
-			}
-			case HUP_BUTTON:
-				v = (Sint32)hid_get_data(REP_BUF_DATA(rep),
-				    &hitem);
-				if (joy->buttons[nbutton] != v) {
-					SDL_PrivateJoystickButton(joy,
-					    nbutton, v);
+				case HUP_BUTTON:
+					v = (Sint32)hid_get_data(REP_BUF_DATA(rep),
+						&hitem);
+					if (joy->buttons[nbutton] != v) {
+						SDL_PrivateJoystickButton(joy,
+							nbutton, v);
+					}
+					nbutton++;
+					break;
+				default:
+					continue;
 				}
-				nbutton++;
 				break;
 			default:
-				continue;
+				break;
 			}
-			break;
-		default:
-			break;
 		}
+		hid_end_parse(hdata);
 	}
-	hid_end_parse(hdata);
-
-	return;
 }
 
 /* Function to close a joystick after use */
@@ -582,8 +582,12 @@ report_alloc(struct report *r, struct re
 	r->size = len;
 
 	if (r->size > 0) {
+#if defined(__FREEBSD__) && (__FreeBSD_kernel_version > 900000)
+		r->buf = SDL_malloc(r->size);
+#else
 		r->buf = SDL_malloc(sizeof(*r->buf) - sizeof(REP_BUF_DATA(r)) +
 		    r->size);
+#endif
 		if (r->buf == NULL) {
 			SDL_OutOfMemory();
 			return (-1);


[FILE:498:patches/patch-src_video_x11_SDL_x11sym.h]
--- src/video/x11/SDL_x11sym.h.orig	2012-01-19 06:30:06 UTC
+++ src/video/x11/SDL_x11sym.h
@@ -165,7 +165,7 @@ SDL_X11_SYM(Bool,XShmQueryExtension,(Dis
  */
 #ifdef LONG64
 SDL_X11_MODULE(IO_32BIT)
-SDL_X11_SYM(int,_XData32,(Display *dpy,register long *data,unsigned len),(dpy,data,len),return)
+SDL_X11_SYM(int,_XData32,(Display *dpy,register _Xconst long *data,unsigned len),(dpy,data,len),return)
 SDL_X11_SYM(void,_XRead32,(Display *dpy,register long *data,long len),(dpy,data,len),)
 #endif
 


[FILE:5310:files/SDL_sndioaudio.c]
/*
 * Copyright (c) 2008 Jacob Meuser <jakemsr@sdf.lonestar.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include "SDL_config.h"

/* Allow access to a raw mixing buffer */

#ifdef HAVE_SIGNAL_H
#include <signal.h>
#endif
#include <unistd.h>

#include "SDL_timer.h"
#include "SDL_audio.h"
#include "../SDL_audiomem.h"
#include "../SDL_audio_c.h"
#include "../SDL_audiodev_c.h"
#include "SDL_sndioaudio.h"

/* The tag name used by sndio audio */
#define SNDIO_DRIVER_NAME         "sndio"

/* Audio driver functions */
static int SNDIO_OpenAudio(_THIS, SDL_AudioSpec *spec);
static void SNDIO_WaitAudio(_THIS);
static void SNDIO_PlayAudio(_THIS);
static Uint8 *SNDIO_GetAudioBuf(_THIS);
static void SNDIO_CloseAudio(_THIS);

/* Audio driver bootstrap functions */

static int Audio_Available(void)
{
	struct sio_hdl *this_hdl;
	int available = 0;

	if ( (this_hdl = sio_open(SIO_DEVANY, SIO_PLAY, 0)) != NULL ) {
		sio_close(this_hdl);
		available = 1;
	}

	return available;
}

static void Audio_DeleteDevice(SDL_AudioDevice *device)
{
	SDL_free(device->hidden);
	SDL_free(device);
}

static SDL_AudioDevice *Audio_CreateDevice(int devindex)
{
	SDL_AudioDevice *this;

	/* Initialize all variables that we clean on shutdown */
	this = (SDL_AudioDevice *)SDL_malloc(sizeof(SDL_AudioDevice));
	if ( this ) {
		SDL_memset(this, 0, (sizeof *this));
		this->hidden = (struct SDL_PrivateAudioData *)
				SDL_malloc((sizeof *this->hidden));
	}
	if ( (this == NULL) || (this->hidden == NULL) ) {
		SDL_OutOfMemory();
		if ( this ) {
			SDL_free(this);
		}
		return(0);
	}
	SDL_memset(this->hidden, 0, (sizeof *this->hidden));

	/* Set the function pointers */
	this->OpenAudio = SNDIO_OpenAudio;
	this->WaitAudio = SNDIO_WaitAudio;
	this->PlayAudio = SNDIO_PlayAudio;
	this->GetAudioBuf = SNDIO_GetAudioBuf;
	this->CloseAudio = SNDIO_CloseAudio;

	this->free = Audio_DeleteDevice;

	hdl = NULL;

	return this;
}

AudioBootStrap SNDIO_bootstrap = {
	SNDIO_DRIVER_NAME, "sndio",
	Audio_Available, Audio_CreateDevice
};



/* This function waits until it is possible to write a full sound buffer */
static void SNDIO_WaitAudio(_THIS)
{
	/* nothing, we're using the blocking api */
}

static void SNDIO_PlayAudio(_THIS)
{
	int written;

	/* Write the audio data */
	written = sio_write(hdl, mixbuf, mixlen);
	
	/* If we couldn't write, assume fatal error for now */
	if ( written == 0 ) {
		this->enabled = 0;
	}
#ifdef DEBUG_AUDIO
	fprintf(stderr, "Wrote %d bytes of audio data\n", written);
#endif
}

static Uint8 *SNDIO_GetAudioBuf(_THIS)
{
	return(mixbuf);
}

static void SNDIO_CloseAudio(_THIS)
{
	if ( mixbuf != NULL ) {
		SDL_FreeAudioMem(mixbuf);
		mixbuf = NULL;
	}
	if ( hdl != NULL ) {
		sio_close(hdl);
		hdl = NULL;
	}
}

static int SNDIO_OpenAudio(_THIS, SDL_AudioSpec *spec)
{
	struct sio_par par;

	mixbuf = NULL;

	if ((hdl = sio_open(NULL, SIO_PLAY, 0)) == NULL) {
		SDL_SetError("sio_open() failed");
		return(-1);
	}

	sio_initpar(&par);

	switch (spec->format) {
	case AUDIO_S16LSB:
		par.bits = 16;
		par.sig = 1;
		par.le = 1;
		break;
	case AUDIO_S16MSB:
		par.bits = 16;
		par.sig = 1;
		par.le = 0;
		break;
	case AUDIO_S8:
		par.bits = 8;
		par.sig = 1;
		break;
	case AUDIO_U16LSB:
		par.bits = 16;
		par.sig = 0;
		par.le = 1;
		break;
	case AUDIO_U16MSB:
		par.bits = 16;
		par.sig = 0;
		par.le = 0;
		break;
	case AUDIO_U8:
		par.bits = 8;
		par.sig = 0;
		break;
	default:
		SDL_SetError("SNDIO unknown format");
		return(-1);
	}

	par.rate = spec->freq;
	par.pchan = spec->channels;
	par.round = spec->samples;
	par.appbufsz = par.round * 2;

	if (sio_setpar(hdl, &par) == 0) {
		SDL_SetError("sio_setpar() failed");
		return(-1);
	}

	if (sio_getpar(hdl, &par) == 0) {
		SDL_SetError("sio_getpar() failed");
		return(-1);
	}

	if (par.bits == 16) {
		if (par.sig && par.le) {
			spec->format = AUDIO_S16LSB;
		} else if (par.sig && !par.le) {
			spec->format = AUDIO_S16MSB;
		} else if (!par.sig && par.le) {
			spec->format = AUDIO_U16LSB;
		} else 
			spec->format = AUDIO_U16MSB;
	} else if (par.bits == 8) {
		spec->format = par.sig ? AUDIO_S8 : AUDIO_U8;
	} else {
		SDL_SetError("SNDIO couldn't configure a suitable format");
		return(-1);
	}

	spec->freq = par.rate;
	spec->channels = par.pchan;
	spec->samples = par.round;

	SDL_CalculateAudioSpec(spec);

	/* Allocate mixing buffer */
	mixlen = spec->size;
	mixbuf = (Uint8 *)SDL_AllocAudioMem(mixlen);
	if ( mixbuf == NULL ) {
		return(-1);
	}
	SDL_memset(mixbuf, spec->silence, spec->size);

	if ( sio_start(hdl) == 0 ) {
		SDL_SetError("sio_start() failed");
		return(-1);
	}

	/* We're ready to rock and roll. :-) */
	return(0);
}


[FILE:1512:files/SDL_sndioaudio.h]
/*
 * Copyright (c) 2008 Jacob Meuser <jakemsr@sdf.lonestar.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include "SDL_config.h"

#ifndef _SDL_sndioaudio_h
#define _SDL_sndioaudio_h

#include <sndio.h>

#include "../SDL_sysaudio.h"

/* Hidden "this" pointer for the video functions */
#define _THIS	SDL_AudioDevice *this

struct SDL_PrivateAudioData {
	/* The stream descriptor for the audio device */
	struct sio_hdl *hdl;

	/* The parent process id, to detect when application quits */
	pid_t parent;

	/* Raw mixing buffer */
	Uint8 *mixbuf;
	int    mixlen;

};

/* Old variable names */
#define stream			(this->hidden->stream)
#define parent			(this->hidden->parent)
#define mixbuf			(this->hidden->mixbuf)
#define mixlen			(this->hidden->mixlen)
#define hdl			(this->hidden->hdl)

#endif /* _SDL_sndioaudio_h */


