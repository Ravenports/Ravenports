# Buildsheet autogenerated by ravenadm tool -- Do not edit.

NAMEBASE=		python-croniter
VERSION=		1.4.1
KEYWORDS=		python
VARIANTS=		py310 v11
SDESC[py310]=		Iteration for datetime object like cron (3.10)
SDESC[v11]=		Iteration for datetime object like cron (3.11)
HOMEPAGE=		https://github.com/kiorky/croniter
CONTACT=		Python_Automaton[python@ironwolf.systems]

DOWNLOAD_GROUPS=	main
SITES[main]=		PYPIWHL/f2/91/e5ae454da8200c6eb6cf94ca05d799b51e2cb2cc458a7737aebc0c5a21bb
DISTFILE[1]=		croniter-1.4.1-py2.py3-none-any.whl:main
DF_INDEX=		1
SPKGS[py310]=		single
SPKGS[v11]=		single

OPTIONS_AVAILABLE=	PY310 PY311
OPTIONS_STANDARD=	none
VOPTS[py310]=		PY310=ON PY311=OFF
VOPTS[v11]=		PY310=OFF PY311=ON

DISTNAME=		croniter-1.4.1.dist-info

GENERATED=		yes

[PY310].RUN_DEPENDS_ON=			python-python-dateutil:single:py310
[PY310].USES_ON=			python:py310,wheel

[PY311].RUN_DEPENDS_ON=			python-python-dateutil:single:v11
[PY311].USES_ON=			python:v11,wheel

[FILE:3733:descriptions/desc.single]
Introduction
============

Usage
============

A simple example::

    >>> from croniter import croniter
    >>> from datetime import datetime
    >>> base = datetime(2010, 1, 25, 4, 46)
    >>> iter = croniter('*/5 * * * *', base)  # every 5 minutes
    >>> print(iter.get_next(datetime))   # 2010-01-25 04:50:00
    >>> print(iter.get_next(datetime))   # 2010-01-25 04:55:00
    >>> print(iter.get_next(datetime))   # 2010-01-25 05:00:00
    >>>
    >>> iter = croniter('2 4 * * mon,fri', base)  # 04:02 on every Monday
and Friday
    >>> print(iter.get_next(datetime))   # 2010-01-26 04:02:00
    >>> print(iter.get_next(datetime))   # 2010-01-30 04:02:00
    >>> print(iter.get_next(datetime))   # 2010-02-02 04:02:00
    >>>
    >>> iter = croniter('2 4 1 * wed', base)  # 04:02 on every Wednesday OR
on 1st day of month
    >>> print(iter.get_next(datetime))   # 2010-01-27 04:02:00
    >>> print(iter.get_next(datetime))   # 2010-02-01 04:02:00
    >>> print(iter.get_next(datetime))   # 2010-02-03 04:02:00
    >>>
    >>> iter = croniter('2 4 1 * wed', base, day_or=False)  # 04:02 on
every 1st day of the month if it is a Wednesday
    >>> print(iter.get_next(datetime))   # 2010-09-01 04:02:00
    >>> print(iter.get_next(datetime))   # 2010-12-01 04:02:00
    >>> print(iter.get_next(datetime))   # 2011-06-01 04:02:00
    >>>
    >>> iter = croniter('0 0 * * sat#1,sun#2', base)  # 1st Saturday, and
2nd Sunday of the month
    >>> print(iter.get_next(datetime))   # 2010-02-06 00:00:00
    >>>
    >>> iter = croniter('0 0 * * 5#3,L5', base)  # 3rd and last Friday of
the month
    >>> print(iter.get_next(datetime))   # 2010-01-29 00:00:00
    >>> print(iter.get_next(datetime))   # 2010-02-19 00:00:00

All you need to know is how to use the constructor and the get_next
method, the signature of these methods are listed below::

    >>> def __init__(self, cron_format, start_time=time.time(),
day_or=True)

croniter iterates along with cron_format from start_time.
cron_format is **min hour day month day_of_week**, you can refer to
http://en.wikipedia.org/wiki/Cron for more details. The day_or
switch is used to control how croniter handles **day** and **day_of_week**
entries. Default option is the cron behaviour, which connects those
values using **OR**. If the switch is set to False, the values are
connected
using **AND**. This behaves like fcron and enables you to e.g. define a job
that
executes each 2nd Friday of a month by setting the days of month and the
weekday.
::

    >>> def get_next(self, ret_type=float)

get_next calculates the next value according to the cron expression and
returns an object of type ret_type. ret_type should be a float or a
datetime object.

Supported added for get_prev method. (>= 0.2.0)::

    >>> base = datetime(2010, 8, 25)
    >>> itr = croniter('0 0 1 * *', base)
    >>> print(itr.get_prev(datetime))  # 2010-08-01 00:00:00
    >>> print(itr.get_prev(datetime))  # 2010-07-01 00:00:00
    >>> print(itr.get_prev(datetime))  # 2010-06-01 00:00:00

You can validate your crons using is_valid class method. (>= 0.3.18)::

    >>> croniter.is_valid('0 0 1 * *')  # True
    >>> croniter.is_valid('0 wrong_value 1 * *')  # False

About DST
=========
Be sure to init your croniter instance with a TZ aware datetime for this to
work!

Example using pytz::

    >>> import pytz
    >>> tz = pytz.timezone("Europe/Paris")
    >>> local_date = tz.localize(datetime(2017, 3, 26))
    >>> val = croniter('0 0 * * *', local_date).get_next(datetime)

Example using python_dateutil::

    >>> import dateutil.tz
    >>> tz = dateutil.tz.gettz('Asia/Tokyo')
    >>> local_date = datetime(2017, 3, 26, tzinfo=tz)
    >>> val = croniter('0 0 * * *', local_date).get_next(datetime)



[FILE:114:distinfo]
9595da48af37ea06ec3a9f899738f1b2c1c13da3c38cea606ef7cd03ea421128        19579 croniter-1.4.1-py2.py3-none-any.whl

