# Buildsheet autogenerated by ravenadm tool -- Do not edit.

NAMEBASE=		libexecinfo
VERSION=		1.1
REVISION=		1
EPOCH=			1
KEYWORDS=		devel
VARIANTS=		standard
SDESC[standard]=	Backtrace Information Library
HOMEPAGE=		https://www.freshports.org/devel/libexecinfo
CONTACT=		nobody

DOWNLOAD_GROUPS=	main
SITES[main]=		FREELOCAL/itetcu
DISTFILE[1]=		libexecinfo-1.1.tar.bz2:main
DF_INDEX=		1
SPKGS[standard]=	single

OPTIONS_AVAILABLE=	none
OPTIONS_STANDARD=	none

LICENSE=		BSD2CLAUSE:single
LICENSE_FILE=		BSD2CLAUSE:{{WRKDIR}}/LICENSE
LICENSE_AWK=		BSD2CLAUSE:"^$$"
LICENSE_SOURCE=		BSD2CLAUSE:{{WRKSRC}}/execinfo.h
LICENSE_SCHEME=		solo

SINGLE_JOB=		yes

post-install:
	${INSTALL_MAN} ${FILESDIR}/backtrace.3 \
		${STAGEDIR}${MANPREFIX}/man/man3/
	# install our PIC library
	${INSTALL_DATA} ${WRKSRC}/libexecinfo_pic.a ${STAGEDIR}${PREFIX}/lib/

post-build:
	# assemble PIC library
	(cd ${WRKSRC} \
	 && ${AR} -cq libexecinfo_pic.a *.So \
	 && ranlib libexecinfo_pic.a)

[FILE:762:descriptions/desc.single]
Backtrace Information Library (libexecinfo, -lexecinfo)

This is a quick-n-dirty BSD licensed clone of backtrace facility found
in the GNU libc, mainly intended for porting Linuxish code to BSD
platforms, however it can be used at any platform which has a gcc
compiler.

Supports the backtrace function to fill in the backtrace of the currently
executing thread.

  The backtrace() function places into the array pointed by addrlist the
  array of the values of the program counter for each frame called up to
  len frames.  The number of frames found (which can be fewer than len) is
  returned.

  The backtrace_symbols_fmt() function takes an array of previously filled
  addresses from backtrace() in addrlist of len elements, and uses fmt to
  format them.


[FILE:102:distinfo]
c9a21913e7fdac8ef6b33250b167aa1fc0a7b8a175145e26913a4c19d8a59b1f         4841 libexecinfo-1.1.tar.bz2


[FILE:122:manifests/plist.single]
include/execinfo.h
lib/
 libexecinfo.a
 libexecinfo.so
 libexecinfo.so.2
 libexecinfo_pic.a
share/man/man3/backtrace.3.gz


[FILE:1409:patches/patch-Makefile]
--- Makefile.orig	2004-07-19 05:19:55 UTC
+++ Makefile
@@ -24,23 +24,28 @@
 #
 # $Id: Makefile,v 1.3 2004/07/19 05:19:55 sobomax Exp $
 
-LIB=	execinfo
-
+EXECINFO_CFLAGS=	${CFLAGS} -fno-strict-aliasing -std=gnu99 -fno-omit-frame-pointer
+SHARED_FLAGS=	-fpic -DPIC
+LIBNAME=	libexecinfo
+STATIC_LIB=	${LIBNAME}.a
+SHARED_LIB=	${LIBNAME}.so.2
 SRCS=	stacktraverse.c stacktraverse.h execinfo.c execinfo.h
 
-INCS=	execinfo.h
-
-SHLIB_MAJOR=	1
-SHLIB_MINOR=	0
-
-NOPROFILE=	yes
-
-DPADD=		${LIBM}
-LDADD=		-lm
-
-#WARNS?=	4
+all: ${STATIC_LIB} ${SHARED_LIB}
 
-#stacktraverse.c: gen.py
-#	./gen.py > stacktraverse.c
+${STATIC_LIB}: ${SRCS}
+	${CC} ${EXECINFO_CFLAGS} ${LDFLAGS} -c stacktraverse.c
+	${CC} ${EXECINFO_CFLAGS} ${LDFLAGS} -c execinfo.c
+	${AR} rcs ${STATIC_LIB} stacktraverse.o execinfo.o
+
+${SHARED_LIB}: ${SRCS}
+	${CC} ${SHARED_FLAGS} ${EXECINFO_CFLAGS} ${LDFLAGS} -c stacktraverse.c -o stacktraverse.So
+	${CC} ${SHARED_FLAGS} ${EXECINFO_CFLAGS} ${LDFLAGS} -c execinfo.c -o execinfo.So
+	${CC} -shared -Wl,-soname,${SHARED_LIB} -o ${SHARED_LIB} stacktraverse.So execinfo.So
+
+install: ${STATIC_LIB} ${SHARED_LIB} execinfo.h
+	${BSD_INSTALL_DATA} execinfo.h ${DESTDIR}${PREFIX}/include/
+	${BSD_INSTALL_DATA} ${STATIC_LIB} ${DESTDIR}${PREFIX}/lib/
+	${BSD_INSTALL_LIB} ${SHARED_LIB} ${DESTDIR}${PREFIX}/lib/
+	ln -s ${SHARED_LIB} ${DESTDIR}${PREFIX}/lib/${LIBNAME}.so 
 
-.include <bsd.lib.mk>


[FILE:2230:patches/patch-execinfo.c]
--- execinfo.c.orig	2004-07-19 05:21:09 UTC
+++ execinfo.c
@@ -69,7 +69,8 @@ backtrace(void **buffer, int size)
 char **
 backtrace_symbols(void *const *buffer, int size)
 {
-    int i, clen, alen, offset;
+    size_t clen, alen;
+    int i, offset;
     char **rval;
     char *cp;
     Dl_info info;
@@ -78,7 +79,6 @@ backtrace_symbols(void *const *buffer, i
     rval = malloc(clen);
     if (rval == NULL)
         return NULL;
-    (char **)cp = &(rval[size]);
     for (i = 0; i < size; i++) {
         if (dladdr(buffer[i], &info) != 0) {
             if (info.dli_sname == NULL)
@@ -92,14 +92,14 @@ backtrace_symbols(void *const *buffer, i
                    2 +                      /* " <" */
                    strlen(info.dli_sname) + /* "function" */
                    1 +                      /* "+" */
-                   D10(offset) +            /* "offset */
+                   10 +                     /* "offset */
                    5 +                      /* "> at " */
                    strlen(info.dli_fname) + /* "filename" */
                    1;                       /* "\0" */
             rval = realloc_safe(rval, clen + alen);
             if (rval == NULL)
                 return NULL;
-            snprintf(cp, alen, "%p <%s+%d> at %s",
+            snprintf((char *) rval + clen, alen, "%p <%s+%d> at %s",
               buffer[i], info.dli_sname, offset, info.dli_fname);
         } else {
             alen = 2 +                      /* "0x" */
@@ -108,12 +108,15 @@ backtrace_symbols(void *const *buffer, i
             rval = realloc_safe(rval, clen + alen);
             if (rval == NULL)
                 return NULL;
-            snprintf(cp, alen, "%p", buffer[i]);
+            snprintf((char *) rval + clen, alen, "%p", buffer[i]);
         }
-        rval[i] = cp;
-        cp += alen;
+        rval[i] = (char *) clen;
+        clen += alen;
     }
 
+    for (i = 0; i < size; i++)
+        rval[i] += (long) rval;
+
     return rval;
 }
 
@@ -155,6 +158,6 @@ backtrace_symbols_fd(void *const *buffer
                 return;
             snprintf(buf, len, "%p\n", buffer[i]);
         }
-        write(fd, buf, len - 1);
+        write(fd, buf, strlen(buf));
     }
 }


[FILE:3072:files/backtrace.3]
.Dd November 3, 2015
.Dt BACKTRACE 3
.Os
.Sh NAME
.Nm backtrace
.Nd fill in the backtrace of the currently executing thread
.Sh LIBRARY
.Lb libexecinfo
.Sh SYNOPSIS
.In execinfo.h
.Ft size_t
.Fn backtrace "void **addrlist" "size_t len"
.Ft "char **"
.Fn backtrace_symbols "void * const *addrlist" "size_t len"
.Ft int
.Fn backtrace_symbols_fd "void * const *addrlist" "size_t len" "int fd"
.Ft "char **"
.Fn backtrace_symbols_fmt "void * const *addrlist" "size_t len" "const char *fmt"
.Ft int
.Fn backtrace_symbols_fd_fmt "void * const *addrlist" "size_t len" "int fd" "const char *fmt"
.Sh DESCRIPTION
The
.Fn backtrace
function places into the array pointed by
.Fa addrlist
the array of the values of the program counter for each frame called up to
.Fa len
frames.
The number of frames found (which can be fewer than
.Fa len )
is returned.
.Pp
The
.Fn backtrace_symbols_fmt
function takes an array of previously filled addresses from
.Fn backtrace
in
.Fa addrlist
of
.Fa len
elements, and uses
.Fa fmt
to format them.
The formatting characters available are:
.Bl -tag -width a -offset indent
.It Dv a
The numeric address of each element as would be printed using %p.
.It Dv n
The name of the nearest function symbol (smaller than the address element)
as determined by
.Xr dladdr 3
if the symbol was dynamic, or looked up in the executable if static and
the /proc filesystem is available to determine the executable path.
.It Dv d
The difference of the symbol address and the address element printed
using 0x%tx.
.It Dv D
The difference of the symbol address and the address element printed using
+0x%tx if non-zero, or nothing if zero.
.It Dv f
The filename of the symbol as determined by
.Xr dladdr 3 .
.El
.Pp
The array of formatted strings is returned as a contiguous memory address which
can be freed by a single
.Xr free 3 .
.Pp
The
.Fn backtrace_symbols
function is equivalent of calling
.Fn backtrace_symbols_fmt
with a format argument of
.Dv "%a <%n%D> at %f"
.Pp
The
.Fn backtrace_symbols_fd
and
.Fn backtrace_symbols_fd_fmt
are similar to the non _fd named functions, only instead of returning
an array or strings, they print a new-line separated array of strings in
fd, and return
.Dv 0
on success and
.Dv \-1
on failure.
.Sh RETURN VALUES
The
.Fn backtrace
function returns the number of elements that were filled in the backtrace.
The
.Fn backtrace_symbols
and
.Fn backtrace_symbols_fmt
return a string array on success, and
.Dv NULL
on failure, setting
.Va errno .
Diagnostic output may also be produced by the ELF symbol lookup functions.
.Sh SEE ALSO
.Xr dladdr 3
.\".Xr elf 3
.Sh HISTORY
The
.Fn backtrace
library of functions first appeared in
.Nx 7.0
and
.Fx 10.0 .
.Sh BUGS
.Bl -enum
.It
Errors should not be printed but communicated to the caller differently.
.\".It
.\"Because these functions use
.\".Xr elf 3
.\"this is a separate library instead of being part of libc/libutil
.\"so that no library dependencies are introduced.
.It
The Linux versions of the functions (there are no _fmt variants) use
.Ft int
instead of
.Ft size_t
arguments.
.El


[FILE:447:linux/patch-define-gnu-source]
--- execinfo.c.orig
+++ execinfo.c
@@ -26,6 +26,7 @@
  * $Id: execinfo.c,v 1.3 2004/07/19 05:21:09 sobomax Exp $
  */
 
+#define _GNU_SOURCE
 #include <sys/types.h>
 #include <sys/uio.h>
 #include <dlfcn.h>
--- stacktraverse.c.orig
+++ stacktraverse.c
@@ -1,3 +1,4 @@
+#define _GNU_SOURCE
 #include <stddef.h>
 
 #include "stacktraverse.h"
--- test.c.orig
+++ test.c
@@ -1,3 +1,4 @@
+#define _GNU_SOURCE
 #include <stdio.h>
 #include <stdlib.h>
 

