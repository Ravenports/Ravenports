# Buildsheet autogenerated by ravenadm tool -- Do not edit.

NAMEBASE=		libexecinfo
VERSION=		100
REVISION=		3
KEYWORDS=		devel
VARIANTS=		standard
SDESC[standard]=	Backtrace Information Library
HOMEPAGE=		none
CONTACT=		nobody

DOWNLOAD_GROUPS=	main
SITES[main]=		SF/elftoolchain/Sources/elftoolchain-0.7.1
DISTFILE[1]=		elftoolchain-0.7.1.tgz:main
DF_INDEX=		1
SPKGS[standard]=	single

OPTIONS_AVAILABLE=	none
OPTIONS_STANDARD=	none

B_DEPS[sunos]=		libbsd4sol:single:standard

USES=			cclibs:single

DISTNAME=		libexecinfo

MAKE_ENV=		TOOLCHAINDIR={{WRKDIR}}/elftoolchain-0.7.1

post-extract:
	@${MKDIR} ${WRKSRC}
	${CP} ${FILESDIR}/* ${WRKSRC}

[FILE:553:descriptions/desc.single]
Backtrace Information Library (libexecinfo, -lexecinfo)

Supports the backtrace function to fill in the backtrace of the currently
executing thread.

  The backtrace() function places into the array pointed by addrlist the
  array of the values of the program counter for each frame called up to
  len frames.  The number of frames found (which can be fewer than len) is
  returned.

  The backtrace_symbols_fmt() function takes an array of previously filled
  addresses from backtrace() in addrlist of len elements, and uses fmt to
  format them.
     

[FILE:101:distinfo]
92bfe36f886024bbc433846483b026c7ce44d553b9b941a0fd13e451911ae297      6717652 elftoolchain-0.7.1.tgz


[FILE:103:manifests/plist.single]
include/execinfo.h
lib/
 libexecinfo.a
 libexecinfo.so
 libexecinfo.so.2
share/man/man3/backtrace.3.gz


[FILE:1091:patches/patch-elftoolchain-0.7.1_common___elftc.h]
--- ../elftoolchain-0.7.1/common/_elftc.h.orig	2015-08-31 19:53:08 UTC
+++ ../elftoolchain-0.7.1/common/_elftc.h
@@ -294,6 +294,10 @@ struct name {							\
 #define	ELFTC_VCSID(ID)		__FBSDID(ID)
 #endif
 
+#if defined(__sun__)
+#define	ELFTC_VCSID(ID)		/**/
+#endif
+
 #if defined(__APPLE__) || defined(__GLIBC__) || defined(__GNU__) || \
     defined(__linux__)
 #if defined(__GNUC__)
@@ -332,7 +336,7 @@ struct name {							\
 #ifndef	ELFTC_GETPROGNAME
 
 #if defined(__APPLE__) || defined(__DragonFly__) || defined(__FreeBSD__) || \
-    defined(__minix) || defined(__NetBSD__)
+    defined(__minix) || defined(__NetBSD__) || defined(__sun__)
 
 #include <stdlib.h>
 
@@ -400,6 +404,15 @@ extern const char *__progname;
 
 #endif
 
+#if defined(__sun__)
+#define ELFTC_BYTE_ORDER			1234
+#define ELFTC_BYTE_ORDER_LITTLE_ENDIAN		1234
+#define ELFTC_BYTE_ORDER_BIG_ENDIAN		4321
+#define ELFTC_HAVE_MMAP				1
+#define roundup(x, y)		((((x)+((y)-1))/(y))*(y))
+#define roundup2(x, y)		(((x)+((y)-1))&(~((y)-1)))
+#endif
+ 
 #if defined(__GLIBC__) || defined(__linux__)
 
 #include <endian.h>


[FILE:345:patches/patch-elftoolchain-0.7.1_libelf___libelf__config.h]
--- ../elftoolchain-0.7.1/libelf/_libelf_config.h.orig	2015-02-24 19:17:47 UTC
+++ ../elftoolchain-0.7.1/libelf/_libelf_config.h
@@ -40,6 +40,12 @@
 
 #endif	/* __DragonFly__ */
 
+#if defined(__sun__)
+# define LIBELF_ARCH		EM_X86_64
+# define LIBELF_BYTEORDER	ELFDATA2LSB
+# define LIBELF_CLASS		ELFCLASS64
+#endif
+
 #ifdef __FreeBSD__
 
 /*


[FILE:1648:files/LICENSE]
/*	$NetBSD: execinfo.h,v 1.2 2012/06/09 21:22:17 christos Exp $	*/
/*	$FreeBSD: head/contrib/libexecinfo/execinfo.h 255177 2013-09-03 13:38:41Z emaste $ */

/*-
 * Copyright (c) 2012 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Christos Zoulas.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */


[FILE:3205:files/Makefile]
# libexecinfo has libelf inbuilt from elftoolchain project

.SUFFIXES:	.o .c
.SUFFIXES:	.So .c
.SUFFIXES:	.m4 .c

.c.o:
	${CC} ${_${.IMPSRC:T}_FLAGS} ${PICFLAG} -DPIC ${CFLAGS} -c ${.IMPSRC}

.c.So:
	${CC} ${_${.IMPSRC:T}_FLAGS} ${PICFLAG} -DPIC ${CFLAGS} -c ${.IMPSRC} -o ${.TARGET}

.m4.c:
	m4 -D SRCDIR=${SRCDIR} ${M4FLAGS} ${.IMPSRC} > ${.TARGET}

LIB=		execinfo
LIBMAJOR=	2
LIB_STATIC=	lib${LIB}.a
LIB_SHARED=	lib${LIB}.so.${LIBMAJOR}
LIB_LINK=	lib${LIB}.so
PICFLAG=	-fpic
SRCDIR=		${TOOLCHAINDIR}/libelf
COMMON=		${TOOLCHAINDIR}/common
CFLAGS+=	-I. -I${SRCDIR} -I${COMMON}

.PATH:		${SRCDIR}

all: ${LIB_STATIC} ${LIB_SHARED}

.if ${OPSYS} == Linux || ${OPSYS} == SunOS
TSORT=		tsort 2>/dev/null
.else
TSORT=		tsort -q
.endif

# verbatim from Elftoolchain sourcefile
SRCS=	elf.c							\
	elf_begin.c						\
	elf_cntl.c						\
	elf_end.c elf_errmsg.c elf_errno.c			\
	elf_data.c						\
	elf_fill.c						\
	elf_flag.c						\
	elf_getarhdr.c						\
	elf_getarsym.c						\
	elf_getbase.c						\
	elf_getident.c						\
	elf_hash.c						\
	elf_kind.c						\
	elf_memory.c						\
	elf_next.c						\
	elf_open.c						\
	elf_rand.c						\
	elf_rawfile.c						\
	elf_phnum.c						\
	elf_shnum.c						\
	elf_shstrndx.c						\
	elf_scn.c						\
	elf_strptr.c						\
	elf_update.c						\
	elf_version.c						\
	gelf_cap.c						\
	gelf_checksum.c						\
	gelf_dyn.c						\
	gelf_ehdr.c						\
	gelf_getclass.c						\
	gelf_fsize.c						\
	gelf_move.c						\
	gelf_phdr.c						\
	gelf_rel.c						\
	gelf_rela.c						\
	gelf_shdr.c						\
	gelf_sym.c						\
	gelf_syminfo.c						\
	gelf_symshndx.c						\
	gelf_xlate.c						\
	libelf_align.c						\
	libelf_allocate.c					\
	libelf_ar.c						\
	libelf_ar_util.c					\
	libelf_checksum.c					\
	libelf_data.c						\
	libelf_ehdr.c						\
	libelf_extended.c					\
	libelf_memory.c						\
	libelf_open.c						\
	libelf_phdr.c						\
	libelf_shdr.c						\
	libelf_xlate.c						\
	${GENSRCS}

GENSRCS=	libelf_fsize.c libelf_msize.c libelf_convert.c

libelf_convert.c:	elf_types.m4 libelf_convert.m4
libelf_fsize.c:		elf_types.m4 libelf_fsize.m4
libelf_msize.c:		elf_types.m4 libelf_msize.m4

.if ${OPSYS} == Linux
${SRCS}: native-elf-format.h
.endif

.if "${OPSYS}" == "SunOS"
CFLAGS+=	-I${PREFIX}/include/bsd
SRCS+=		progname.c
.endif

# libexec sources
PREFIX?=	/usr/local
SRCS+=		backtrace.c symtab.c unwind.c
OBJS=		${SRCS:.c=.o}
SOBJS=		${SRCS:.c=.So}

${LIB_STATIC}: ${OBJS}
	@${ECHO} building static ${LIB} library
	${AR} cq ${.TARGET} `lorder ${OBJS} | ${TSORT}`
	ranlib ${.TARGET}

${LIB_SHARED}: ${SOBJS}
	@${ECHO} building shared ${LIB} library
	${CC_LINK} ${LDFLAGS} -shared \
	    -o ${.TARGET} -Wl,-soname,${.TARGET} \
	    `lorder ${SOBJS} | ${TSORT}`

native-elf-format.h: ${COMMON}/native-elf-format
	/bin/sh ${.ALLSRC} > ${.TARGET}

install:
	mkdir -p ${DESTDIR}${PREFIX}/lib ${DESTDIR}${PREFIX}/share/man/man3
	mkdir -p ${DESTDIR}${PREFIX}/include
	${BSD_INSTALL_LIB} ${LIB_SHARED} ${DESTDIR}${PREFIX}/lib
	${BSD_INSTALL_DATA} ${LIB_STATIC} ${DESTDIR}${PREFIX}/lib
	ln -s ${LIB_SHARED} ${DESTDIR}${PREFIX}/lib/${LIB_LINK}
	${BSD_INSTALL_MAN} backtrace.3 ${DESTDIR}${PREFIX}/share/man/man3/
	${BSD_INSTALL_DATA} execinfo.h ${DESTDIR}${PREFIX}/include/


[FILE:3072:files/backtrace.3]
.Dd November 3, 2015
.Dt BACKTRACE 3
.Os
.Sh NAME
.Nm backtrace
.Nd fill in the backtrace of the currently executing thread
.Sh LIBRARY
.Lb libexecinfo
.Sh SYNOPSIS
.In execinfo.h
.Ft size_t
.Fn backtrace "void **addrlist" "size_t len"
.Ft "char **"
.Fn backtrace_symbols "void * const *addrlist" "size_t len"
.Ft int
.Fn backtrace_symbols_fd "void * const *addrlist" "size_t len" "int fd"
.Ft "char **"
.Fn backtrace_symbols_fmt "void * const *addrlist" "size_t len" "const char *fmt"
.Ft int
.Fn backtrace_symbols_fd_fmt "void * const *addrlist" "size_t len" "int fd" "const char *fmt"
.Sh DESCRIPTION
The
.Fn backtrace
function places into the array pointed by
.Fa addrlist
the array of the values of the program counter for each frame called up to
.Fa len
frames.
The number of frames found (which can be fewer than
.Fa len )
is returned.
.Pp
The
.Fn backtrace_symbols_fmt
function takes an array of previously filled addresses from
.Fn backtrace
in
.Fa addrlist
of
.Fa len
elements, and uses
.Fa fmt
to format them.
The formatting characters available are:
.Bl -tag -width a -offset indent
.It Dv a
The numeric address of each element as would be printed using %p.
.It Dv n
The name of the nearest function symbol (smaller than the address element)
as determined by
.Xr dladdr 3
if the symbol was dynamic, or looked up in the executable if static and
the /proc filesystem is available to determine the executable path.
.It Dv d
The difference of the symbol address and the address element printed
using 0x%tx.
.It Dv D
The difference of the symbol address and the address element printed using
+0x%tx if non-zero, or nothing if zero.
.It Dv f
The filename of the symbol as determined by
.Xr dladdr 3 .
.El
.Pp
The array of formatted strings is returned as a contiguous memory address which
can be freed by a single
.Xr free 3 .
.Pp
The
.Fn backtrace_symbols
function is equivalent of calling
.Fn backtrace_symbols_fmt
with a format argument of
.Dv "%a <%n%D> at %f"
.Pp
The
.Fn backtrace_symbols_fd
and
.Fn backtrace_symbols_fd_fmt
are similar to the non _fd named functions, only instead of returning
an array or strings, they print a new-line separated array of strings in
fd, and return
.Dv 0
on success and
.Dv \-1
on failure.
.Sh RETURN VALUES
The
.Fn backtrace
function returns the number of elements that were filled in the backtrace.
The
.Fn backtrace_symbols
and
.Fn backtrace_symbols_fmt
return a string array on success, and
.Dv NULL
on failure, setting
.Va errno .
Diagnostic output may also be produced by the ELF symbol lookup functions.
.Sh SEE ALSO
.Xr dladdr 3
.\".Xr elf 3
.Sh HISTORY
The
.Fn backtrace
library of functions first appeared in
.Nx 7.0
and
.Fx 10.0 .
.Sh BUGS
.Bl -enum
.It
Errors should not be printed but communicated to the caller differently.
.\".It
.\"Because these functions use
.\".Xr elf 3
.\"this is a separate library instead of being part of libc/libutil
.\"so that no library dependencies are introduced.
.It
The Linux versions of the functions (there are no _fmt variants) use
.Ft int
instead of
.Ft size_t
arguments.
.El


[FILE:4638:files/backtrace.c]
#include <sys/cdefs.h>
#include <sys/param.h>
#include <assert.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <stdarg.h>
#include <stdint.h>
#include <stddef.h>
#include <unistd.h>
#include <fcntl.h>
#include <elf.h>

#include "execinfo.h"
#include "symtab.h"

#ifdef __linux__
#define SELF	"/proc/self/exe"
#elif defined __sun__
#define SELF	"/proc/self/path/a.out"
#else
#include <sys/sysctl.h>
#define SELF	"/proc/curproc/file"
#endif

#ifndef __printflike
#define	__printflike(fmtarg, firstvararg) \
            __attribute__((__nonnull__(fmtarg), \
			  __format__ (__printf__, fmtarg, firstvararg)))
#endif

#ifndef MAX
#define MAX(a, b)	((a) >= (b) ? (a) : (b))
#endif

static int
open_self(int flags)
{
	const char *pathname = SELF;
#ifdef KERN_PROC_PATHNAME
	static const int name[] = {
		CTL_KERN, KERN_PROC, KERN_PROC_PATHNAME, -1,
	};
	char path[MAXPATHLEN];
	size_t len;

	len = sizeof(path);
	if (sysctl(name, 4, path, &len, NULL, 0) != -1)
		pathname = path;
#endif
	return open(pathname, flags);
}


static int __printflike(4, 5)
rasprintf(char **buf, size_t *bufsiz, size_t offs, const char *fmt, ...)
{
	for (;;) {
		size_t nbufsiz;
		char *nbuf;

		if (*buf && offs < *bufsiz) {
			va_list ap;
			int len;

			va_start(ap, fmt);
			len = vsnprintf(*buf + offs, *bufsiz - offs, fmt, ap);
			va_end(ap);

			if (len < 0 || (size_t)len + 1 < *bufsiz - offs)
				return len;
			nbufsiz = MAX(*bufsiz + 512, (size_t)len + 1);
		} else
			nbufsiz = MAX(offs, *bufsiz) + 512;

		nbuf = realloc(*buf, nbufsiz);
		if (nbuf == NULL)
			return -1;
		*buf = nbuf;
		*bufsiz = nbufsiz;
	}
}

/*
 * format specifiers:
 *	%a	= address
 *	%n	= symbol_name
 *	%d	= symbol_address - address
 *	%D	= if symbol_address == address "" else +%d
 *	%f	= filename
 */
static ssize_t
format_string(char **buf, size_t *bufsiz, size_t offs, const char *fmt,
    Dl_info *dli, const void *addr)
{
	ptrdiff_t diff = (const char *)addr - (const char *)dli->dli_saddr;
	size_t o = offs;
	int len;

	for (; *fmt; fmt++) {
		if (*fmt != '%')
			goto printone;
		switch (*++fmt) {
		case 'a':
			len = rasprintf(buf, bufsiz, o, "%p", addr);
			break;
		case 'n':
			len = rasprintf(buf, bufsiz, o, "%s", dli->dli_sname);
			break;
		case 'D':
			if (diff)
				len = rasprintf(buf, bufsiz, o, "+0x%tx", diff);
			else
				len = 0;
			break;
		case 'd':
			len = rasprintf(buf, bufsiz, o, "0x%tx", diff);
			break;
		case 'f':
			len = rasprintf(buf, bufsiz, o, "%s", dli->dli_fname);
			break;
		default:
		printone:
			len = rasprintf(buf, bufsiz, o, "%c", *fmt);
			break;
		}
		if (len == -1)
			return -1;
		o += len;
	}
	return o - offs;
}

static ssize_t
format_address(symtab_t *st, char **buf, size_t *bufsiz, size_t offs,
    const char *fmt, const void *addr)
{
	Dl_info dli;

	memset(&dli, 0, sizeof(dli));
	(void)dladdr(addr, &dli);
	if (st)
		symtab_find(st, addr, &dli);

	if (dli.dli_sname == NULL)
		dli.dli_sname = "???";
	if (dli.dli_fname == NULL)
		dli.dli_fname = "???";
	if (dli.dli_saddr == NULL)
		dli.dli_saddr = (void *)(intptr_t)addr;

	return format_string(buf, bufsiz, offs, fmt, &dli, addr);
}

char **
backtrace_symbols_fmt(void *const *trace, size_t len, const char *fmt)
{

	static const size_t slen = sizeof(char *) + 64;	/* estimate */
	char *ptr;
	symtab_t *st;
	int fd;

	if ((fd = open_self(O_RDONLY)) != -1)
		st = symtab_create(fd, -1, STT_FUNC);
	else
		st = NULL;

	if ((ptr = calloc(len, slen)) == NULL)
		goto out;

	size_t psize = len * slen;
	size_t offs = len * sizeof(char *);

	/* We store only offsets in the first pass because of realloc */
	for (size_t i = 0; i < len; i++) {
		ssize_t x;
		((char **)(void *)ptr)[i] = (void *)offs;
		x = format_address(st, &ptr, &psize, offs, fmt, trace[i]);
		if (x == -1) {
			free(ptr);
			ptr = NULL;
			goto out;
		}
		offs += x;
		ptr[offs++] = '\0';
		assert(offs < psize);
	}

	/* Change offsets to pointers */
	for (size_t j = 0; j < len; j++)
		((char **)(void *)ptr)[j] += (intptr_t)ptr;

out:
	symtab_destroy(st);
	if (fd != -1)
		(void)close(fd);

	return (void *)ptr;
}

int
backtrace_symbols_fd_fmt(void *const *trace, size_t len, int fd,
    const char *fmt)
{
	char **s = backtrace_symbols_fmt(trace, len, fmt);
	if (s == NULL)
		return -1;
	for (size_t i = 0; i < len; i++)
		if (dprintf(fd, "%s\n", s[i]) < 0)
			break;
	free(s);
	return 0;
}

static const char fmt[] = "%a <%n%D> at %f";

char **
backtrace_symbols(void *const *trace, size_t len)
{
	return backtrace_symbols_fmt(trace, len, fmt);
}

int
backtrace_symbols_fd(void *const *trace, size_t len, int fd)
{
	return backtrace_symbols_fd_fmt(trace, len, fd, fmt);
}


[FILE:394:files/execinfo.h]
#ifndef _EXECINFO_H_
#define _EXECINFO_H_

#include <stddef.h>

__BEGIN_DECLS
size_t backtrace(void **, size_t);
char **backtrace_symbols(void *const *, size_t);
int backtrace_symbols_fd(void *const *, size_t, int);
char **backtrace_symbols_fmt(void *const *, size_t, const char *);
int backtrace_symbols_fd_fmt(void *const *, size_t, int, const char *);
__END_DECLS

#endif /* _EXECINFO_H_ */


[FILE:523:files/progname.c]
#include <libgen.h>
#include <string.h>
#include <stdlib.h>

const char *getprogname () {
    static const char *progname;

    if (progname == NULL) {
        const char *e = getexecname();
        if (e != NULL) {
            /* Have to make a copy since getexecname can return a readonly
               string, but basename expects to be able to modify its arg. */
            char *n = strdup(e);
            if (n != NULL) {
                progname = basename(n);
            }
        }
    }
    return progname;
}


[FILE:3049:files/symtab.c]
#include <sys/cdefs.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <stdint.h>
#include <err.h>

#include <libelf.h>
#include <gelf.h>
#ifndef ELF_ST_BIND
#define ELF_ST_BIND(x)          ((x) >> 4)
#endif
#ifndef ELF_ST_TYPE
#define ELF_ST_TYPE(x)          (((unsigned int)x) & 0xf)
#endif


#include "symtab.h"

struct symbol {
	char *st_name;
	uintptr_t st_value;
	uintptr_t st_info;
};

struct symtab {
	size_t nsymbols;
	struct symbol *symbols;
};

static int
address_compare(const void *a, const void *b)
{
	const struct symbol *sa = a;
	const struct symbol *sb = b;
	return (int)(intmax_t)(sa->st_value - sb->st_value);
}

void
symtab_destroy(symtab_t *s)
{
	if (s == NULL)
		return;
	for (size_t i = 0; i < s->nsymbols; i++)
		free(s->symbols[i].st_name);
	free(s->symbols);
	free(s);
}

symtab_t *
symtab_create(int fd, int bind, int type)
{
	Elf *elf;
	symtab_t *st;
	Elf_Scn *scn = NULL;

	if (elf_version(EV_CURRENT) == EV_NONE) {
		warnx("Elf Library is out of date.");
		return NULL;
	}

	elf = elf_begin(fd, ELF_C_READ, NULL);
	if (elf == NULL) {
		warnx("Error opening elf file: %s", elf_errmsg(elf_errno()));
		return NULL;
	}
	st = calloc(1, sizeof(*st));
	if (st == NULL) {
		warnx("Error allocating symbol table");
		elf_end(elf);
		return NULL;
	}

	while ((scn = elf_nextscn(elf, scn)) != NULL) {
		GElf_Shdr shdr;
		Elf_Data *edata;
		size_t ns;
		struct symbol *s;

		gelf_getshdr(scn, &shdr);
		if(shdr.sh_type != SHT_SYMTAB)
			continue;

		edata = elf_getdata(scn, NULL);
		ns = shdr.sh_size / shdr.sh_entsize;
		s = calloc(ns, sizeof(*s));
		if (s == NULL) {
			warn("Cannot allocate %zu symbols", ns);
			goto out;
		}
		st->symbols = s;

		for (size_t i = 0; i < ns; i++) {
			GElf_Sym sym;
                        gelf_getsym(edata, (int)i, &sym);

			if (bind != -1 &&
			    (unsigned)bind != ELF_ST_BIND(sym.st_info))
				continue;

			if (type != -1 &&
			    (unsigned)type != ELF_ST_TYPE(sym.st_info))
				continue;

			s->st_value = sym.st_value;
			s->st_info = sym.st_info;
			s->st_name = strdup(
			    elf_strptr(elf, shdr.sh_link, sym.st_name));
			if (s->st_name == NULL)
				goto out;
			s++;
                }
		st->nsymbols = s - st->symbols;
		if (st->nsymbols == 0) {
			warnx("No symbols found");
			goto out;
		}
		qsort(st->symbols, st->nsymbols, sizeof(*st->symbols),
		    address_compare);
		elf_end(elf);
		return st;
	}
out:
	symtab_destroy(st);
	elf_end(elf);
	return NULL;
}

	
int
symtab_find(const symtab_t *st, const void *p, Dl_info *dli)
{
	struct symbol *s = st->symbols;
	size_t ns = st->nsymbols;
	size_t hi = ns;
	size_t lo = 0;
	size_t mid = ns / 2;
	uintptr_t dd, sd, me = (uintptr_t)p;

	for (;;) {
		if (s[mid].st_value < me)
			lo = mid;
		else if (s[mid].st_value > me)
			hi = mid;
		else
			break;
		if (hi - lo == 1) {
			mid = lo;
			break;
		}
		mid = (hi + lo) / 2;
	}
	dd = me - (uintptr_t)dli->dli_saddr;
	sd = me - s[mid].st_value;
	if (dd > sd) {
		dli->dli_saddr = (void *)s[mid].st_value;
		dli->dli_sname = s[mid].st_name;
	}
	return 1;
}


[FILE:320:files/symtab.h]
#ifndef _SYMTAB_H_
#define _SYMTAB_H_

#ifdef __linux__
#define	__USE_GNU
#endif

#include <dlfcn.h>

__BEGIN_DECLS
typedef struct symtab symtab_t;

void symtab_destroy(symtab_t *);
symtab_t * symtab_create(int, int, int);
int symtab_find(const symtab_t *, const void *, Dl_info *);
__END_DECLS

#endif /* _SYMTAB_H_ */


[FILE:714:files/unwind.c]
#include <sys/cdefs.h>
#include <sys/types.h>
#include <stdio.h>

#include "unwind.h"
#include "execinfo.h"

struct tracer_context {
	void **arr;
	size_t len;
	size_t n;
};

static _Unwind_Reason_Code
tracer(struct _Unwind_Context *ctx, void *arg)
{
	struct tracer_context *t = arg;
	if (t->n == (size_t)~0) {
		/* Skip backtrace frame */
		t->n = 0;
		return 0;
	}
	if (t->n < t->len)
		t->arr[t->n++] = _Unwind_GetIP(ctx);
	return 0;
}

size_t
backtrace(void **arr, size_t len)
{
	struct tracer_context ctx;

	ctx.arr = arr;
	ctx.len = len;
	ctx.n = (size_t)~0;

	_Unwind_Backtrace(tracer, &ctx);
	if (ctx.n != (size_t)~0 && ctx.n > 0)
		ctx.arr[--ctx.n] = NULL;	/* Skip frame below __start */

	return ctx.n;
}


[FILE:1566:files/unwind.h]
#ifndef _UNWIND_H_
#define _UNWIND_H_

__BEGIN_DECLS
struct _Unwind_Context;
struct _Unwind_Exception;
typedef int _Unwind_Reason_Code;
typedef void *_Unwind_Ptr;
typedef long _Unwind_Word;

typedef _Unwind_Reason_Code
    (*_Unwind_Trace_Fn)(struct _Unwind_Context *, void *);
#ifdef notyet
typedef _Unwind_Reason_Code
    (*_Unwind_Stop_Fn)(struct _Unwind_Context *, void *);
#endif

_Unwind_Reason_Code	 _Unwind_Backtrace(_Unwind_Trace_Fn, void *);
void 			 _Unwind_DeleteException(struct _Unwind_Exception *);
void 	       		*_Unwind_FindEnclosingFunction(void *);
#ifdef notyet
_Unwind_Reason_Code 	 _Unwind_ForcedUnwind(struct _Unwind_Exception *,
    _Unwind_Stop_fn, void *);
#endif
_Unwind_Word		 _Unwind_GetCFA(struct _Unwind_Context *);
_Unwind_Ptr		 _Unwind_GetDataRelBase(struct _Unwind_Context *);
_Unwind_Word 		 _Unwind_GetGR(struct _Unwind_Context *, int);
_Unwind_Ptr		 _Unwind_GetIP(struct _Unwind_Context *);
_Unwind_Ptr		 _Unwind_GetIPInfo(struct _Unwind_Context *, int *);
void 			*_Unwind_GetLanguageSpecificData(
    struct _Unwind_Context *);
_Unwind_Ptr		 _Unwind_GetRegionStart(struct _Unwind_Context *);
_Unwind_Ptr		 _Unwind_GetTextRelBase(struct _Unwind_Context *);
_Unwind_Reason_Code	 _Unwind_RaiseException(struct _Unwind_Exception *);
void			 _Unwind_Resume(struct _Unwind_Exception *);
_Unwind_Reason_Code	 _Unwind_Resume_or_Rethrow(struct _Unwind_Exception *);
void			 _Unwind_SetGR(struct _Unwind_Context *, int,
    _Unwind_Ptr);
void			 _Unwind_SetIP(struct _Unwind_Context *, _Unwind_Ptr);
__END_DECLS
#endif /* _UNWIND_H_ */

