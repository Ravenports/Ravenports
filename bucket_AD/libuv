# Buildsheet autogenerated by ravenadm tool -- Do not edit.

NAMEBASE=		libuv
VERSION=		1.45.0
KEYWORDS=		devel
VARIANTS=		standard
SDESC[standard]=	Multi-platform support for asynchronous I/O
HOMEPAGE=		https://github.com/libuv/libuv
CONTACT=		nobody

DOWNLOAD_GROUPS=	main
SITES[main]=		GITHUB/libuv:libuv:v1.45.0
DISTFILE[1]=		generated:main
DF_INDEX=		1
SPKGS[standard]=	complete
			primary
			dev

OPTIONS_AVAILABLE=	none
OPTIONS_STANDARD=	none

USES=			autoreconf libtool pkgconfig solaris-funcs cpe gmake

LICENSE=		MIT:primary
LICENSE_FILE=		MIT:{{WRKSRC}}/LICENSE
LICENSE_SCHEME=		solo

CPE_VENDOR=		libuv_project
FPC_EQUIVALENT=		devel/libuv
SOL_FUNCTIONS=		mkdtemp:src/unix/fs.c
			strnlen:src/unix/getaddrinfo.c

MUST_CONFIGURE=		gnu

INSTALL_TARGET=		install-strip
SOVERSION=		1.0.0

VAR_OPSYS[sunos]=	CFLAGS=-DSUNOS_NO_IFADDRS

pre-configure:
	${ECHO_CMD} "m4_define([UV_EXTRA_AUTOMAKE_FLAGS], [ serial-tests])" \
		> ${WRKSRC}/m4/libuv-extra-automake-flags.m4

[FILE:463:descriptions/desc.primary]
libuv is a multi-platform support library with a focus on asynchronous I/O.

Feature highlights:
 + Full-featured event loop backed by epoll, kqueue, IOCP, event ports.
 + Asynchronous TCP and UDP sockets
 + Asynchronous DNS resolution
 + Asynchronous file and file system operations
 + File system events
 + ANSI escape code controlled TTY
 + Child processes
 + Thread pool
 + Signal handling
 + High resolution clock
 + Threading and synchronization primitives


[FILE:104:distinfo]
458e34d5ef7f3c0394a2bfd8c39d757cb1553baa5959b9b4b45df63aa027a228      1307245 libuv-libuv-1.45.0.tar.gz


[FILE:51:manifests/plist.primary]
lib/
 libuv.so.%%SOMAJOR%%
 libuv.so.%%SOVERSION%%


[FILE:352:manifests/plist.dev]
%%ONLY-DARWIN%%include/uv/darwin.h
%%ONLY-DRAGONFLY%%include/uv/bsd.h
%%ONLY-FREEBSD%%include/uv/bsd.h
%%ONLY-LINUX%%include/uv/linux.h
%%ONLY-MIDNIGHTBSD%%include/uv/bsd.h
%%ONLY-NETBSD%%include/uv/bsd.h
%%ONLY-SUNOS%%include/uv/sunos.h
include/uv.h
include/uv/
 errno.h
 threadpool.h
 unix.h
 version.h
lib/
 libuv.a
 libuv.so
lib/pkgconfig/libuv.pc


[FILE:620:patches/patch-Makefile.am]
--- Makefile.am.orig	2023-05-19 11:21:01 UTC
+++ Makefile.am
@@ -449,6 +449,17 @@ libuv_la_SOURCES += src/unix/bsd-ifaddrs
 test_run_tests_LDFLAGS += -lutil
 endif
 
+if MIDNIGHT 
+uvinclude_HEADERS += include/uv/bsd.h
+libuv_la_SOURCES += src/unix/bsd-ifaddrs.c \
+                    src/unix/bsd-proctitle.c \
+                    src/unix/freebsd.c \
+                    src/unix/kqueue.c \
+                    src/unix/posix-hrtime.c \
+                    src/unix/random-getrandom.c
+test_run_tests_LDFLAGS += -lutil
+endif
+
 if HAIKU
 uvinclude_HEADERS += include/uv/posix.h
 libuv_la_CFLAGS += -D_BSD_SOURCE


[FILE:1102:patches/patch-configure.ac]
Dragonfly is getting counted as FreeBSD too so we're linking statically twice.
Just disable dragonfly and use the freebsd config for now.
--- configure.ac.orig	2023-05-19 11:21:01 UTC
+++ configure.ac
@@ -60,8 +60,9 @@ AM_CONDITIONAL([AIX],      [AS_CASE([$ho
 AM_CONDITIONAL([ANDROID],  [AS_CASE([$host_os],[linux-android*],[true], [false])])
 AM_CONDITIONAL([CYGWIN],   [AS_CASE([$host_os],[cygwin*],       [true], [false])])
 AM_CONDITIONAL([DARWIN],   [AS_CASE([$host_os],[darwin*],       [true], [false])])
-AM_CONDITIONAL([DRAGONFLY],[AS_CASE([$host_os],[dragonfly*],    [true], [false])])
+AM_CONDITIONAL([DRAGONFLY],[AS_CASE([$host_os],[xxdragonfly*],    [true], [false])])
 AM_CONDITIONAL([FREEBSD],  [AS_CASE([$host_os],[freebsd*],      [true], [false])])
+AM_CONDITIONAL([MIDNIGHT], [AS_CASE([$host_os],[midnightbsd*],  [true], [false])])
 AM_CONDITIONAL([HAIKU],    [AS_CASE([$host_os],[haiku],         [true], [false])])
 AM_CONDITIONAL([HURD],     [AS_CASE([$host_os],[gnu*],          [true], [false])])
 AM_CONDITIONAL([LINUX],    [AS_CASE([$host_os],[linux*],        [true], [false])])


[FILE:1558:patches/patch-src_unix_fs.c]
--- src/unix/fs.c.orig	2023-05-19 11:21:01 UTC
+++ src/unix/fs.c
@@ -1119,13 +1119,13 @@ static ssize_t uv__fs_sendfile(uv_fs_t*
 static ssize_t uv__fs_utime(uv_fs_t* req) {
 #if defined(__linux__)                                                         \
     || defined(_AIX71)                                                         \
-    || defined(__sun)                                                          \
     || defined(__HAIKU__)
   struct timespec ts[2];
   ts[0] = uv__fs_to_timespec(req->atime);
   ts[1] = uv__fs_to_timespec(req->mtime);
   return utimensat(AT_FDCWD, req->path, ts, 0);
 #elif defined(__APPLE__)                                                      \
+    || defined(__sun)                                                         \
     || defined(__DragonFly__)                                                 \
     || defined(__FreeBSD__)                                                   \
     || defined(__NetBSD__)                                                    \
@@ -1158,7 +1158,6 @@ static ssize_t uv__fs_utime(uv_fs_t* req
 static ssize_t uv__fs_lutime(uv_fs_t* req) {
 #if defined(__linux__)            ||                                           \
     defined(_AIX71)               ||                                           \
-    defined(__sun)                ||                                           \
     defined(__HAIKU__)            ||                                           \
     defined(__GNU__)              ||                                           \
     defined(__OpenBSD__)

