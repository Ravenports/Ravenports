# Buildsheet autogenerated by ravenadm tool -- Do not edit.

NAMEBASE=		libuv
VERSION=		1.20.3
KEYWORDS=		devel
VARIANTS=		standard
SDESC[standard]=	Multi-platform support for asynchronous I/O
HOMEPAGE=		https://github.com/libuv/libuv
CONTACT=		nobody

DOWNLOAD_GROUPS=	main
SITES[main]=		GITHUB/libuv:libuv:v1.20.3
DISTFILE[1]=		generated:main
DF_INDEX=		1
SPKGS[standard]=	single

OPTIONS_AVAILABLE=	none
OPTIONS_STANDARD=	none

USES=			autoreconf libtool pkgconfig

LICENSE=		MIT:single
LICENSE_FILE=		MIT:{{WRKSRC}}/LICENSE
LICENSE_SCHEME=		solo

FPC_EQUIVALENT=		devel/libuv

MUST_CONFIGURE=		gnu

INSTALL_TARGET=		install-strip

VAR_OPSYS[sunos]=	CFLAGS=-DSUNOS_NO_IFADDRS

pre-configure:
	${ECHO_CMD} "m4_define([UV_EXTRA_AUTOMAKE_FLAGS], [ serial-tests])" \
		> ${WRKSRC}/m4/libuv-extra-automake-flags.m4

[FILE:463:descriptions/desc.single]
libuv is a multi-platform support library with a focus on asynchronous I/O.

Feature highlights:
 + Full-featured event loop backed by epoll, kqueue, IOCP, event ports.
 + Asynchronous TCP and UDP sockets
 + Asynchronous DNS resolution
 + Asynchronous file and file system operations
 + File system events
 + ANSI escape code controlled TTY
 + Child processes
 + Thread pool
 + Signal handling
 + High resolution clock
 + Threading and synchronization primitives


[FILE:104:distinfo]
43a388687194a15d5f3cc1980d53c405020a3586254c620e5f3c4d241bb9da05      1181741 libuv-libuv-1.20.3.tar.gz


[FILE:278:manifests/plist.single]
%%ONLY-DRAGONFLY%%include/uv-bsd.h
%%ONLY-FREEBSD%%include/uv-bsd.h
%%ONLY-LINUX%%include/uv-linux.h
%%ONLY-SUNOS%%include/uv-sunos.h
include/
 uv-errno.h
 uv-threadpool.h
 uv-unix.h
 uv-version.h
 uv.h
lib/
 libuv.a
 libuv.so
 libuv.so.1
 libuv.so.1.0.0
lib/pkgconfig/libuv.pc


[FILE:352:patches/patch-src_unix_fs.c]
--- src/unix/fs.c.orig	2018-04-18 13:18:43 UTC
+++ src/unix/fs.c
@@ -258,7 +258,15 @@ skip:
 
 
 static ssize_t uv__fs_mkdtemp(uv_fs_t* req) {
+#ifdef __sun__
+  char *tmplt;
+  tmplt = mktemp((char*) req->path);
+  if (tmplt == NULL)
+	return (-1);
+  return (mkdir (tmplt, 0700));
+#else
   return mkdtemp((char*) req->path) ? 0 : -1;
+#endif
 }
 
 


[FILE:405:patches/patch-src_unix_getaddrinfo.c]
--- src/unix/getaddrinfo.c.orig	2018-04-18 13:18:43 UTC
+++ src/unix/getaddrinfo.c
@@ -37,6 +37,17 @@
 /* EAI_* constants. */
 #include <netdb.h>
 
+#ifdef __sun__
+static size_t
+strnlen(const char *s, size_t maxlen)
+{
+	size_t len;
+	for (len = 0; len < maxlen; len++, s++) {
+		if (!*s) break;
+	}
+	return (len);
+}
+#endif
 
 int uv__getaddrinfo_translate_error(int sys_err) {
   switch (sys_err) {


[FILE:713:dragonfly/patch-src_unix_freebsd.c]
--- src/unix/freebsd.c.orig	2018-04-18 13:18:43 UTC
+++ src/unix/freebsd.c
@@ -67,7 +67,8 @@ void uv__platform_loop_delete(uv_loop_t*
 
 
 #ifdef __DragonFly__
-int uv_exepath(char* buffer, size_t* size) {
+/* deprecated long ago, use KERN_PROC_PATHNAME sysctl */
+int uv_exepath_procfs(char* buffer, size_t* size) {
   char abspath[PATH_MAX * 2 + 1];
   ssize_t abspath_size;
 
@@ -89,7 +90,8 @@ int uv_exepath(char* buffer, size_t* siz
 
   return 0;
 }
-#else
+#endif
+
 int uv_exepath(char* buffer, size_t* size) {
   char abspath[PATH_MAX * 2 + 1];
   int mib[4];
@@ -119,7 +121,6 @@ int uv_exepath(char* buffer, size_t* siz
 
   return 0;
 }
-#endif
 
 uint64_t uv_get_free_memory(void) {
   int freecount;

