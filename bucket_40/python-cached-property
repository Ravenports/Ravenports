# Buildsheet autogenerated by ravenadm tool -- Do not edit.

NAMEBASE=		python-cached-property
VERSION=		1.5.1
KEYWORDS=		python
VARIANTS=		py38 py37
SDESC[py37]=		Decorator for caching properties in classe (PY 37)
SDESC[py38]=		Decorator for caching properties in classe (PY 38)
HOMEPAGE=		https://github.com/pydanny/cached-property
CONTACT=		Python_Automaton[python@ironwolf.systems]

DOWNLOAD_GROUPS=	main
SITES[main]=		PYPI/c/cached-property
DISTFILE[1]=		cached-property-1.5.1.tar.gz:main
DF_INDEX=		1
SPKGS[py37]=		single
SPKGS[py38]=		single

OPTIONS_AVAILABLE=	PY38 PY37
OPTIONS_STANDARD=	none
VOPTS[py37]=		PY38=OFF PY37=ON
VOPTS[py38]=		PY38=ON PY37=OFF

DISTNAME=		cached-property-1.5.1

GENERATED=		yes

[PY37].USES_ON=				python:py37

[PY38].USES_ON=				python:py38

[FILE:2581:descriptions/desc.single]
===============================
cached-property
===============================

.. image:: https://img.shields.io/pypi/v/cached-property.svg
    :target: https://pypi.python.org/pypi/cached-property

.. image:: https://img.shields.io/travis/pydanny/cached-property/master.svg
    :target: https://travis-ci.org/pydanny/cached-property

.. image:: https://img.shields.io/badge/code%20style-black-000000.svg
    :target: https://github.com/ambv/black
    :alt: Code style: black


A decorator for caching properties in classes.

Why?
-----

* Makes caching of time or computational expensive properties quick and
easy.
* Because I got tired of copy/pasting this code from non-web project to
non-web project.
* I needed something really simple that worked in Python 2 and 3.

How to use it
--------------

Let's define a class with an expensive property. Every time you stay there
the
price goes up by $50!

.. code-block:: python

    class Monopoly(object):

        def __init__(self):
            self.boardwalk_price = 500

        @property
        def boardwalk(self):
            # In reality, this might represent a database call or time
            # intensive task like calling a third-party API.
            self.boardwalk_price += 50
            return self.boardwalk_price

Now run it:

.. code-block:: python

    >>> monopoly = Monopoly()
    >>> monopoly.boardwalk
    550
    >>> monopoly.boardwalk
    600

Let's convert the boardwalk property into a ``cached_property``.

.. code-block:: python

    from cached_property import cached_property

    class Monopoly(object):

        def __init__(self):
            self.boardwalk_price = 500

        @cached_property
        def boardwalk(self):
            # Again, this is a silly example. Don't worry about it, this is
            #   just an example for clarity.
            self.boardwalk_price += 50
            return self.boardwalk_price

Now when we run it the price stays at $550.

.. code-block:: python

    >>> monopoly = Monopoly()
    >>> monopoly.boardwalk
    550
    >>> monopoly.boardwalk
    550
    >>> monopoly.boardwalk
    550

Why doesn't the value of ``monopoly.boardwalk`` change? Because it's a
**cached property**!

Invalidating the Cache
----------------------

Results of cached functions can be invalidated by outside forces. Let's
demonstrate how to force the cache to invalidate:

.. code-block:: python

    >>> monopoly = Monopoly()
    >>> monopoly.boardwalk
    550
    >>> monopoly.boardwalk
    550
    >>> # invalidate the cache
    >>> del monopoly.__dict__['boardwalk']


[FILE:107:distinfo]
9217a59f14a5682da7c4b8829deadbfc194ac22e9908ccf7c8820234e80a1504        12791 cached-property-1.5.1.tar.gz

