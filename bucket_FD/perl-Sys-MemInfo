# Buildsheet autogenerated by ravenadm tool -- Do not edit.

NAMEBASE=		perl-Sys-MemInfo
VERSION=		0.99
KEYWORDS=		perl
VARIANTS=		530 528
SDESC[530]=		No description provided. (v530)
SDESC[528]=		No description provided. (v528)
HOMEPAGE=		none
CONTACT=		Perl_Automaton[perl@ironwolf.systems]

DOWNLOAD_GROUPS=	main
SITES[main]=		CPAN/ID:S/SC/SCRESTO
DISTFILE[1]=		Sys-MemInfo-0.99.tar.gz:main
DF_INDEX=		1
SPKGS[530]=		single
SPKGS[528]=		single

OPTIONS_AVAILABLE=	PERL_530 PERL_528
OPTIONS_STANDARD=	none
VOPTS[530]=		PERL_530=ON PERL_528=OFF
VOPTS[528]=		PERL_530=OFF PERL_528=ON

DISTNAME=		Sys-MemInfo-0.99

GENERATED=		yes

SINGLE_JOB=		yes

[PERL_528].USES_ON=			perl:528,configure

[PERL_530].USES_ON=			perl:530,configure

[FILE:25:descriptions/desc.single]
No description provided.


[FILE:102:distinfo]
0786319d3a3a8bae5d727939244bf17e140b714f52734d5e9f627203e4cf3e3b        13276 Sys-MemInfo-0.99.tar.gz


[FILE:379:patches/patch-Makefile.PL]
--- Makefile.PL.orig	2006-11-10 00:19:12.000000000 +0200
+++ Makefile.PL
@@ -36,6 +36,9 @@ for ($^O) {
     } else {
       print "Sys::MemInfo for FreeBSD 4 and lower\n";
     }
+  } elsif (/dragonfly/) {
+    copy ('arch/dragonfly.xs', 'MemInfo.xs');
+    print "Sys::MemInfo for DragonFly\n";
   } elsif (/bsd/) {
     copy ('arch/bsd.xs', 'MemInfo.xs');
     if (/netbsd/) {


[FILE:2422:patches/patch-arch_dragonfly.xs]
--- /dev/null	2015-12-12 12:33:16.341252360 +0200
+++ arch/dragonfly.xs
@@ -0,0 +1,110 @@
+#include "EXTERN.h"
+#include "perl.h"
+#include "XSUB.h"
+
+MODULE = Sys::MemInfo PACKAGE = Sys::MemInfo
+
+#include "arch/functions.h"
+#include <stdio.h>
+#include <unistd.h>
+#include <sys/param.h>
+#include <sys/sysctl.h>
+#include <vm/vm_param.h>
+
+void
+availkeys()
+	PREINIT:
+	PPCODE:
+                XPUSHs(sv_2mortal(newSVpv(_totalmem, strlen(_totalmem))));
+                XPUSHs(sv_2mortal(newSVpv(_freemem, strlen(_freemem))));
+                XPUSHs(sv_2mortal(newSVpv(_totalswap, strlen(_totalswap))));
+                XPUSHs(sv_2mortal(newSVpv(_freeswap, strlen(_freeswap))));
+
+double
+totalmem()
+	PROTOTYPE: DISABLE
+	CODE:
+		unsigned long long ret = 0;
+		size_t len = sizeof (ret);
+		static int mib[2] = { CTL_HW, HW_PHYSMEM };
+
+		if (sysctl (mib, 2, &ret, &len, NULL, 0) != -1) {
+      			RETVAL = (double) (ret);
+    		} else {
+			RETVAL = 0;
+		}
+	OUTPUT:
+		RETVAL
+		
+
+double
+freemem()
+	PROTOTYPE: DISABLE
+	CODE:
+		double ret= 0;
+		u_int fmem = 0;
+		size_t len = sizeof (fmem);
+		static int pagesize = 0;
+
+		if (!pagesize) pagesize = getpagesize();
+
+		if (sysctlbyname("vm.stats.vm.v_free_count", &fmem, &len, NULL, 0) != -1) {
+			ret = (double) (fmem);
+			ret *= pagesize;
+		}
+
+		RETVAL = ret;
+	OUTPUT:
+		RETVAL
+
+double
+totalswap()
+	PROTOTYPE: DISABLE
+	CODE:
+		double ret= 0;
+		int free_swap = 0;
+		int sused_anon = 0;
+		int sused_cache = 0;
+		size_t len = sizeof (free_swap);
+		static int pagesize = 0;
+
+		if (!pagesize) pagesize = getpagesize();
+
+		if (sysctlbyname("vm.swap_size", &free_swap, &len, NULL, 0) != -1) {
+			ret = (double) (free_swap);
+		}
+		if (sysctlbyname("vm.swap_anon_use", &sused_anon, &len, NULL, 0) != -1) {
+			ret += (double) (sused_anon);
+		}
+		if (sysctlbyname("vm.swap_cache_use", &sused_cache, &len, NULL, 0) != -1) {
+			ret += (double) (sused_cache);
+		}
+
+		ret *= pagesize;
+
+		RETVAL = ret;
+	OUTPUT:
+		RETVAL
+
+double
+freeswap()
+	PROTOTYPE: DISABLE
+	CODE:
+		double ret= 0;
+		int free_swap = 0;
+		size_t len = sizeof (free_swap);
+		static int pagesize = 0;
+
+		if (!pagesize) pagesize = getpagesize();
+
+		if (sysctlbyname("vm.swap_size", &free_swap, &len, NULL, 0) != -1) {
+			ret = (double) (free_swap);
+		}
+
+		ret *= pagesize;
+
+		RETVAL = ret;
+	OUTPUT:
+		RETVAL
+
+# vim:et:ts=2:sts=2:sw=2

