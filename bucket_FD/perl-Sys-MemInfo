# Buildsheet autogenerated by ravenadm tool -- Do not edit.

NAMEBASE=		perl-Sys-MemInfo
VERSION=		0.99
KEYWORDS=		perl
VARIANTS=		534 536
SDESC[534]=		Returns free and used physical memory (5.34)
SDESC[536]=		Returns free and used physical memory (5.36)
HOMEPAGE=		none
CONTACT=		Perl_Automaton[perl@ironwolf.systems]

DOWNLOAD_GROUPS=	main
SITES[main]=		CPAN/ID:S/SC/SCRESTO
DISTFILE[1]=		Sys-MemInfo-0.99.tar.gz:main
DF_INDEX=		1
SPKGS[534]=		single
SPKGS[536]=		single

OPTIONS_AVAILABLE=	PERL_534 PERL_536
OPTIONS_STANDARD=	none
VOPTS[534]=		PERL_534=ON PERL_536=OFF
VOPTS[536]=		PERL_534=OFF PERL_536=ON

DISTNAME=		Sys-MemInfo-0.99

GENERATED=		yes

SINGLE_JOB=		yes

[PERL_534].USES_ON=			perl:534,configure

[PERL_536].USES_ON=			perl:536,configure

[FILE:351:descriptions/desc.single]
This module return the total amount of free and used physical memory
in bytes in totalmem and freemem variables.

This module has been tested on Linux 3.13.0, UnixWare 7.1.2, AIX5,
OpenBSD 3.8, NetBSD 2.0.2, FreBSD 5.4, HPUX11, Solaris 9, Tru64 5.1,
Irix 6.5, MacOS X 10.2 and Windows XP.

It should work on FreeBSD 4 and Windows 9X/ME/NT/200X/Vista.


[FILE:102:distinfo]
0786319d3a3a8bae5d727939244bf17e140b714f52734d5e9f627203e4cf3e3b        13276 Sys-MemInfo-0.99.tar.gz


[FILE:379:patches/patch-Makefile.PL]
--- Makefile.PL.orig	2006-11-10 00:19:12.000000000 +0200
+++ Makefile.PL
@@ -36,6 +36,9 @@ for ($^O) {
     } else {
       print "Sys::MemInfo for FreeBSD 4 and lower\n";
     }
+  } elsif (/dragonfly/) {
+    copy ('arch/dragonfly.xs', 'MemInfo.xs');
+    print "Sys::MemInfo for DragonFly\n";
   } elsif (/bsd/) {
     copy ('arch/bsd.xs', 'MemInfo.xs');
     if (/netbsd/) {


[FILE:372:patches/patch-arch_bsd.xs]
$NetBSD: patch-arch_bsd.xs,v 1.1 2021/12/18 15:07:01 prlw1 Exp $

UVM appeared since NetBSD 2.0.2.

--- arch/bsd.xs.orig	2006-09-16 14:32:56.000000000 +0000
+++ arch/bsd.xs
@@ -8,6 +8,9 @@ MODULE = Sys::MemInfo PACKAGE = Sys::Mem
 #include <stdio.h>
 #include <sys/param.h>
 #include <sys/sysctl.h>
+#ifdef NETBSD
+#include <uvm/uvm_extern.h>
+#endif
 
 void
 availkeys()


[FILE:2422:patches/patch-arch_dragonfly.xs]
--- /dev/null	2015-12-12 12:33:16.341252360 +0200
+++ arch/dragonfly.xs
@@ -0,0 +1,110 @@
+#include "EXTERN.h"
+#include "perl.h"
+#include "XSUB.h"
+
+MODULE = Sys::MemInfo PACKAGE = Sys::MemInfo
+
+#include "arch/functions.h"
+#include <stdio.h>
+#include <unistd.h>
+#include <sys/param.h>
+#include <sys/sysctl.h>
+#include <vm/vm_param.h>
+
+void
+availkeys()
+	PREINIT:
+	PPCODE:
+                XPUSHs(sv_2mortal(newSVpv(_totalmem, strlen(_totalmem))));
+                XPUSHs(sv_2mortal(newSVpv(_freemem, strlen(_freemem))));
+                XPUSHs(sv_2mortal(newSVpv(_totalswap, strlen(_totalswap))));
+                XPUSHs(sv_2mortal(newSVpv(_freeswap, strlen(_freeswap))));
+
+double
+totalmem()
+	PROTOTYPE: DISABLE
+	CODE:
+		unsigned long long ret = 0;
+		size_t len = sizeof (ret);
+		static int mib[2] = { CTL_HW, HW_PHYSMEM };
+
+		if (sysctl (mib, 2, &ret, &len, NULL, 0) != -1) {
+      			RETVAL = (double) (ret);
+    		} else {
+			RETVAL = 0;
+		}
+	OUTPUT:
+		RETVAL
+		
+
+double
+freemem()
+	PROTOTYPE: DISABLE
+	CODE:
+		double ret= 0;
+		u_int fmem = 0;
+		size_t len = sizeof (fmem);
+		static int pagesize = 0;
+
+		if (!pagesize) pagesize = getpagesize();
+
+		if (sysctlbyname("vm.stats.vm.v_free_count", &fmem, &len, NULL, 0) != -1) {
+			ret = (double) (fmem);
+			ret *= pagesize;
+		}
+
+		RETVAL = ret;
+	OUTPUT:
+		RETVAL
+
+double
+totalswap()
+	PROTOTYPE: DISABLE
+	CODE:
+		double ret= 0;
+		int free_swap = 0;
+		int sused_anon = 0;
+		int sused_cache = 0;
+		size_t len = sizeof (free_swap);
+		static int pagesize = 0;
+
+		if (!pagesize) pagesize = getpagesize();
+
+		if (sysctlbyname("vm.swap_size", &free_swap, &len, NULL, 0) != -1) {
+			ret = (double) (free_swap);
+		}
+		if (sysctlbyname("vm.swap_anon_use", &sused_anon, &len, NULL, 0) != -1) {
+			ret += (double) (sused_anon);
+		}
+		if (sysctlbyname("vm.swap_cache_use", &sused_cache, &len, NULL, 0) != -1) {
+			ret += (double) (sused_cache);
+		}
+
+		ret *= pagesize;
+
+		RETVAL = ret;
+	OUTPUT:
+		RETVAL
+
+double
+freeswap()
+	PROTOTYPE: DISABLE
+	CODE:
+		double ret= 0;
+		int free_swap = 0;
+		size_t len = sizeof (free_swap);
+		static int pagesize = 0;
+
+		if (!pagesize) pagesize = getpagesize();
+
+		if (sysctlbyname("vm.swap_size", &free_swap, &len, NULL, 0) != -1) {
+			ret = (double) (free_swap);
+		}
+
+		ret *= pagesize;
+
+		RETVAL = ret;
+	OUTPUT:
+		RETVAL
+
+# vim:et:ts=2:sts=2:sw=2

