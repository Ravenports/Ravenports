# Buildsheet autogenerated by ravenadm tool -- Do not edit.

NAMEBASE=		python-jmespath
VERSION=		0.10.0
KEYWORDS=		python
VARIANTS=		py38 py37
SDESC[py37]=		JSON Matching Expressions (PY37)
SDESC[py38]=		JSON Matching Expressions (PY38)
HOMEPAGE=		https://github.com/jmespath/jmespath.py
CONTACT=		Python_Automaton[python@ironwolf.systems]

DOWNLOAD_GROUPS=	main
SITES[main]=		PYPIWHL/07/cb/5f001272b6faeb23c1c9e0acc04d48eaaf5c862c17709d20e3469c6e0139
DISTFILE[1]=		jmespath-0.10.0-py2.py3-none-any.whl:main
DF_INDEX=		1
SPKGS[py37]=		single
SPKGS[py38]=		single

OPTIONS_AVAILABLE=	PY38 PY37
OPTIONS_STANDARD=	none
VOPTS[py37]=		PY38=OFF PY37=ON
VOPTS[py38]=		PY38=ON PY37=OFF

DISTNAME=		jmespath-0.10.0.dist-info

GENERATED=		yes

[PY37].BUILD_DEPENDS_ON=		python-pip:single:py37
[PY37].USES_ON=				python:py37,wheel

[PY38].BUILD_DEPENDS_ON=		python-pip:single:py38
[PY38].USES_ON=				python:py38,wheel

[FILE:2647:descriptions/desc.single]
JMESPath
========

JMESPath (pronounced "james path") allows you to declaratively specify how
to
extract elements from a JSON document.

For example, given this document::

    {"foo": {"bar": "baz"}}

The jmespath expression ``foo.bar`` will return "baz".

JMESPath also supports:

Referencing elements in a list.  Given the data::

    {"foo": {"bar": ["one", "two"]}}

The expression: ``foo.bar[0]`` will return "one".
You can also reference all the items in a list using the ``*``
syntax::

   {"foo": {"bar": [{"name": "one"}, {"name": "two"}]}}

The expression: ``foo.bar[*].name`` will return ["one", "two"].
Negative indexing is also supported (-1 refers to the last element
in the list).  Given the data above, the expression
``foo.bar[-1].name`` will return "two".

The ``*`` can also be used for hash types::

   {"foo": {"bar": {"name": "one"}, "baz": {"name": "two"}}}

The expression: ``foo.*.name`` will return ["one", "two"].

Installation
============

You can install JMESPath from pypi with:

.. code:: bash

    pip install jmespath

API
===

The ``jmespath.py`` library has two functions
that operate on python data structures.  You can use search
and give it the jmespath expression and the data:

.. code:: python

    >>> import jmespath
    >>> path = jmespath.search('foo.bar', {'foo': {'bar': 'baz'}})
    'baz'

Similar to the re module, you can use the compile function
to compile the JMESPath expression and use this parsed expression
to perform repeated searches:

.. code:: python

    >>> import jmespath
    >>> expression = jmespath.compile('foo.bar')
    >>> expression.search({'foo': {'bar': 'baz'}})
    'baz'
    >>> expression.search({'foo': {'bar': 'other'}})
    'other'

This is useful if you're going to use the same jmespath expression to
search multiple documents.  This avoids having to reparse the
JMESPath expression each time you search a new document.

Options
-------

You can provide an instance of ``jmespath.Options`` to control how
a JMESPath expression is evaluated.  The most common scenario for
using an Options instance is if you want to have ordered output
of your dict keys.  To do this you can use either of these options:

.. code:: python

    >>> import jmespath
    >>> jmespath.search('{a: a, b: b}',
    ...                 mydata,
    ...                 jmespath.Options(dict_cls=collections.OrderedDict))

    >>> import jmespath
    >>> parsed = jmespath.compile('{a: a, b: b}')
    >>> parsed.search(mydata,
    ...               jmespath.Options(dict_cls=collections.OrderedDict))

Custom Functions
~~~~~~~~~~~~~~~~

The JMESPath language has numerous
`built-in functions


[FILE:115:distinfo]
cdf6525904cc597730141d61b36f2e4b8ecc257c420fa2f4549bac2c2d0cb72f        24489 jmespath-0.10.0-py2.py3-none-any.whl

