# Buildsheet autogenerated by ravenadm tool -- Do not edit.

NAMEBASE=		python-jmespath
VERSION=		0.9.3
KEYWORDS=		python
VARIANTS=		py27 py35 py36
SDESC[py35]=		JSON Matching Expressions (PY 35)
SDESC[py36]=		JSON Matching Expressions (PY 36)
SDESC[py27]=		JSON Matching Expressions (PY 27)
HOMEPAGE=		https://github.com/jmespath/jmespath.py
CONTACT=		Python_Automaton[python@ironwolf.systems]

DOWNLOAD_GROUPS=	main
SITES[main]=		PYPI/j/jmespath
DISTFILE[1]=		jmespath-0.9.3.tar.gz:main
DF_INDEX=		1
SPKGS[py35]=		single
SPKGS[py36]=		single
SPKGS[py27]=		single

OPTIONS_AVAILABLE=	PY27 PY35 PY36
OPTIONS_STANDARD=	none
VOPTS[py35]=		PY27=OFF PY35=ON PY36=OFF
VOPTS[py36]=		PY27=OFF PY35=OFF PY36=ON
VOPTS[py27]=		PY27=ON PY35=OFF PY36=OFF

DISTNAME=		jmespath-0.9.3

LICENSE=		MIT:single
LICENSE_FILE=		MIT:{{WRKSRC}}/LICENSE.txt
LICENSE_SCHEME=		solo

GENERATED=		yes

[PY35].USES_ON=				python:py35

[PY36].USES_ON=				python:py36

[PY27].USES_ON=				python:py27

[FILE:2895:descriptions/desc.single]
JMESPath
========


.. image:: https://badges.gitter.im/Join Chat.svg
   :target: https://gitter.im/jmespath/chat


.. image::
https://secure.travis-ci.org/jmespath/jmespath.py.png?branch=develop
   :target: http://travis-ci.org/jmespath/jmespath.py


.. image::
https://codecov.io/github/jmespath/jmespath.py/coverage.svg?branch=develop
    :target: https://codecov.io/github/jmespath/jmespath.py?branch=develop


JMESPath (pronounced "james path") allows you to declaratively specify how
to
extract elements from a JSON document.

For example, given this document::

    {"foo": {"bar": "baz"}}

The jmespath expression ``foo.bar`` will return "baz".

JMESPath also supports:

Referencing elements in a list.  Given the data::

    {"foo": {"bar": ["one", "two"]}}

The expression: ``foo.bar[0]`` will return "one".
You can also reference all the items in a list using the ``*``
syntax::

   {"foo": {"bar": [{"name": "one"}, {"name": "two"}]}}

The expression: ``foo.bar[*].name`` will return ["one", "two"].
Negative indexing is also supported (-1 refers to the last element
in the list).  Given the data above, the expression
``foo.bar[-1].name`` will return "two".

The ``*`` can also be used for hash types::

   {"foo": {"bar": {"name": "one"}, "baz": {"name": "two"}}}

The expression: ``foo.*.name`` will return ["one", "two"].


API
===

The ``jmespath.py`` library has two functions
that operate on python data structures.  You can use ``search``
and give it the jmespath expression and the data:

.. code:: python

    >>> import jmespath
    >>> path = jmespath.search('foo.bar', {'foo': {'bar': 'baz'}})
    'baz'

Similar to the ``re`` module, you can use the ``compile`` function
to compile the JMESPath expression and use this parsed expression
to perform repeated searches:

.. code:: python

    >>> import jmespath
    >>> expression = jmespath.compile('foo.bar')
    >>> expression.search({'foo': {'bar': 'baz'}})
    'baz'
    >>> expression.search({'foo': {'bar': 'other'}})
    'other'

This is useful if you're going to use the same jmespath expression to
search multiple documents.  This avoids having to reparse the
JMESPath expression each time you search a new document.

Options
-------

You can provide an instance of ``jmespath.Options`` to control how
a JMESPath expression is evaluated.  The most common scenario for
using an ``Options`` instance is if you want to have ordered output
of your dict keys.  To do this you can use either of these options:

.. code:: python

    >>> import jmespath
    >>> jmespath.search('{a: a, b: b},
    ...                 mydata,
    ...                 jmespath.Options(dict_cls=collections.OrderedDict))


    >>> import jmespath
    >>> parsed = jmespath.compile('{a: a, b: b}')
    >>> parsed.search('{a: a, b: b},
    ...               mydata,
    ...               jmespath.Options(dict_cls=collections.OrderedDict))


[FILE:100:distinfo]
6a81d4c9aa62caf061cb517b4d9ad1dd300374cd4706997aff9cd6aedd61fc64        22967 jmespath-0.9.3.tar.gz

