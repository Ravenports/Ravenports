# Buildsheet autogenerated by ravenadm tool -- Do not edit.

NAMEBASE=		libdiscid
VERSION=		0.6.2
KEYWORDS=		audio
VARIANTS=		standard
SDESC[standard]=	Library for creating MusicBrainz DiscIDs
HOMEPAGE=		https://musicbrainz.org/doc/libdiscid
CONTACT=		Michael_Reim[kraileth@elderlinux.org]

DOWNLOAD_GROUPS=	main
SITES[main]=		http://ftp.musicbrainz.org/pub/musicbrainz/libdiscid/
DISTFILE[1]=		libdiscid-0.6.2.tar.gz:main
DF_INDEX=		1
SPKGS[standard]=	single

OPTIONS_AVAILABLE=	none
OPTIONS_STANDARD=	none

USES=			cmake

LICENSE=		LGPL21+:single
LICENSE_TERMS=		single:{{WRKDIR}}/TERMS
LICENSE_FILE=		LGPL21+:{{WRKSRC}}/COPYING
LICENSE_AWK=		TERMS:"ifndef MUSICBRAINZ_DISC_ID_H"
LICENSE_SOURCE=		TERMS:{{WRKSRC}}/include/discid/discid.h
LICENSE_SCHEME=		solo

FPC_EQUIVALENT=		audio/libdiscid

SOVERSION=		0.6.2

post-install:
	${STRIP_CMD} ${STAGEDIR}${PREFIX}/lib/libdiscid.so.${SOVERSION}

[FILE:278:descriptions/desc.single]
Libdiscid is a C library for creating MusicBrainz DiscIDs from audio CDs. 
It reads a CD's table of contents (TOC) and generates an identifier which 
can be used to lookup the CD at MusicBrainz. Additionally, it provides a 
submission URL for adding the DiscID to the database.


[FILE:101:distinfo]
f9e443ac4c0dd4819c2841fcc82169a46fb9a626352cdb9c7f65dd3624cd31b9       401455 libdiscid-0.6.2.tar.gz


[FILE:124:manifests/plist.single]
include/discid/discid.h
lib/
 libdiscid.so
 libdiscid.so.%%SOMAJOR%%
 libdiscid.so.%%SOVERSION%%
lib/pkgconfig/libdiscid.pc


[FILE:424:patches/patch-CMakeLists.txt]
--- CMakeLists.txt.orig	2017-01-29 12:43:54 UTC
+++ CMakeLists.txt
@@ -54,6 +54,8 @@ IF(CMAKE_SYSTEM_NAME MATCHES "Linux")
     SET(libdiscid_OS "linux")
 ELSEIF(CMAKE_SYSTEM_NAME MATCHES "Darwin")
     SET(libdiscid_OS "darwin")
+ELSEIF(CMAKE_SYSTEM_NAME MATCHES "DragonFly")
+    SET(libdiscid_OS "bsd")
 ELSEIF(CMAKE_SYSTEM_NAME MATCHES "FreeBSD")
     SET(libdiscid_OS "bsd")
 ELSEIF(CMAKE_SYSTEM_NAME MATCHES "NetBSD")


[FILE:1791:patches/patch-src_disc__bsd.c]
--- src/disc_bsd.c.orig	2017-01-29 12:43:54 UTC
+++ src/disc_bsd.c
@@ -32,7 +32,7 @@
 #include <sys/types.h>
 #include <unistd.h>
 
-#if defined(__FreeBSD__)
+#if defined(__FreeBSD__) || defined __DragonFly__
 #include <netinet/in.h> /* for ntohl() */
 #else
 #include <util.h> /* for getrawpartition() */
@@ -44,7 +44,7 @@
 #define MAX_DEV_LEN 15
 
 static int get_device(int n, char* device_name, size_t device_name_length) {
-#if !defined(__FreeBSD__) /* /dev/rcdNX, where X is the letter for the raw partition */
+#if !defined(__FreeBSD__) && !defined __DragonFly__ /* /dev/rcdNX, where X is the letter for the raw partition */
 	snprintf(device_name, device_name_length, "/dev/rcd%d%c", n - 1, 'a' + getrawpartition());
 #else /* on FreeBSD it's just /dev/cdN */
 	snprintf(device_name, device_name_length, "/dev/cd%d", n - 1);
@@ -82,7 +82,7 @@ int mb_disc_unix_read_toc_header(int fd,
 
 	for (i = toc->first_track_num; i <= toc->last_track_num; ++i) {
 		assert(te[i - toc->first_track_num].track == i);
-#if defined(__FreeBSD__) /* LBA address is in network byte order */
+#if defined(__FreeBSD__) || defined __DragonFly__ /* LBA address is in network byte order */
 		toc->tracks[i].address = ntohl(te[i - toc->first_track_num].addr.lba);
 #else
 		toc->tracks[i].address = te[i - toc->first_track_num].addr.lba;
@@ -91,7 +91,7 @@ int mb_disc_unix_read_toc_header(int fd,
 	}
 	/* leadout - track number 170 (0xAA) */
 	assert(te[i - toc->first_track_num].track == 0xAA);
-#if defined(__FreeBSD__) /* LBA address is in network byte order */
+#if defined(__FreeBSD__) || defined __DragonFly__ /* LBA address is in network byte order */
 	toc->tracks[0].address = ntohl(te[i - toc->first_track_num].addr.lba);
 #else
 	toc->tracks[0].address = te[i - toc->first_track_num].addr.lba;

