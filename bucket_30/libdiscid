# Buildsheet autogenerated by ravenadm tool -- Do not edit.

NAMEBASE=		libdiscid
VERSION=		0.6.5
KEYWORDS=		audio
VARIANTS=		std
SDESC[std]=		Library for creating MusicBrainz DiscIDs
HOMEPAGE=		https://github.com/metabrainz/libdiscid
CONTACT=		Michael_Reim[kraileth@elderlinux.org]

DOWNLOAD_GROUPS=	main
SITES[main]=		http://ftp.musicbrainz.org/pub/musicbrainz/libdiscid/
DISTFILE[1]=		libdiscid-0.6.5.tar.gz:main
DF_INDEX=		1
SPKGS[std]=		set
			primary
			dev

OPTIONS_AVAILABLE=	none
OPTIONS_STANDARD=	none

USES=			cmake

LICENSE=		LGPL21+:primary
LICENSE_TERMS=		primary:{{WRKDIR}}/TERMS
LICENSE_FILE=		LGPL21+:{{WRKSRC}}/COPYING
LICENSE_AWK=		TERMS:"ifndef MUSICBRAINZ_DISC_ID_H"
LICENSE_SOURCE=		TERMS:{{WRKSRC}}/include/discid/discid.h
LICENSE_SCHEME=		solo

FPC_EQUIVALENT=		audio/libdiscid

SOVERSION=		0.6.5

CMAKE_ARGS=		-DCMAKE_POLICY_VERSION_MINIMUM=3.5

post-install:
	${STRIP_CMD} ${STAGEDIR}${PREFIX}/lib/libdiscid.so.${SOVERSION}

[FILE:278:descriptions/desc.primary]
Libdiscid is a C library for creating MusicBrainz DiscIDs from audio CDs. 
It reads a CD's table of contents (TOC) and generates an identifier which 
can be used to lookup the CD at MusicBrainz. Additionally, it provides a 
submission URL for adding the DiscID to the database.


[FILE:101:distinfo]
72dbb493e07336418fe2056f0ebc7ce544eedb500bb896cc1cc04bd078c2d530       396307 libdiscid-0.6.5.tar.gz


[FILE:59:manifests/plist.primary]
lib/
 libdiscid.so.%%SOMAJOR%%
 libdiscid.so.%%SOVERSION%%


[FILE:68:manifests/plist.dev]
include/discid/discid.h
lib/libdiscid.so
lib/pkgconfig/libdiscid.pc


[FILE:424:patches/patch-CMakeLists.txt]
--- CMakeLists.txt.orig	2025-05-21 10:20:16 UTC
+++ CMakeLists.txt
@@ -51,6 +51,8 @@ IF(CMAKE_SYSTEM_NAME MATCHES "Linux")
     SET(libdiscid_OS "linux")
 ELSEIF(CMAKE_SYSTEM_NAME MATCHES "Darwin")
     SET(libdiscid_OS "darwin")
+ELSEIF(CMAKE_SYSTEM_NAME MATCHES "DragonFly")
+    SET(libdiscid_OS "bsd")
 ELSEIF(CMAKE_SYSTEM_NAME MATCHES "FreeBSD")
     SET(libdiscid_OS "bsd")
 ELSEIF(CMAKE_SYSTEM_NAME MATCHES "NetBSD")


[FILE:1824:patches/patch-src_disc__bsd.c]
--- src/disc_bsd.c.orig	2025-05-21 10:20:16 UTC
+++ src/disc_bsd.c
@@ -32,7 +32,7 @@
 #include <sys/types.h>
 #include <unistd.h>
 
-#if defined(__FreeBSD__) || defined(__FreeBSD_kernel__)
+#if defined(__FreeBSD__) || defined(__FreeBSD_kernel__) || defined(__DragonFly__)
 #include <netinet/in.h> /* for ntohl() */
 #else
 #include <util.h> /* for getrawpartition() */
@@ -44,7 +44,7 @@
 #define MAX_DEV_LEN 15
 
 static int get_device(int n, char* device_name, size_t device_name_length) {
-#if defined(__FreeBSD__) || defined(__FreeBSD_kernel__)
+#if defined(__FreeBSD__) || defined(__FreeBSD_kernel__) || defined(__DragonFly__)
 	/* on FreeBSD it's just /dev/cdN */
 	snprintf(device_name, device_name_length, "/dev/cd%d", n - 1);
 #else
@@ -84,7 +84,7 @@ int mb_disc_unix_read_toc_header(int fd,
 
 	for (i = toc->first_track_num; i <= toc->last_track_num; ++i) {
 		assert(te[i - toc->first_track_num].track == i);
-#if defined(__FreeBSD__) || defined(__FreeBSD_kernel__) /* LBA address is in network byte order */
+#if defined(__FreeBSD__) || defined(__FreeBSD_kernel__) || defined(__DragonFly__)/* LBA address is in network byte order */
 		toc->tracks[i].address = ntohl(te[i - toc->first_track_num].addr.lba);
 #else
 		toc->tracks[i].address = te[i - toc->first_track_num].addr.lba;
@@ -93,7 +93,7 @@ int mb_disc_unix_read_toc_header(int fd,
 	}
 	/* leadout - track number 170 (0xAA) */
 	assert(te[i - toc->first_track_num].track == 0xAA);
-#if defined(__FreeBSD__) || defined(__FreeBSD_kernel__) /* LBA address is in network byte order */
+#if defined(__FreeBSD__) || defined(__FreeBSD_kernel__) || defined(__DragonFly__) /* LBA address is in network byte order */
 	toc->tracks[0].address = ntohl(te[i - toc->first_track_num].addr.lba);
 #else
 	toc->tracks[0].address = te[i - toc->first_track_num].addr.lba;

