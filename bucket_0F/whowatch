# Buildsheet autogenerated by ravenadm tool -- Do not edit.

NAMEBASE=		whowatch
VERSION=		1.8.5
KEYWORDS=		sysutils
VARIANTS=		standard
SDESC[standard]=	Display information logged on users
HOMEPAGE=		http://wizard.ae.krakow.pl/~mike/
CONTACT=		nobody

DOWNLOAD_GROUPS=	main
SITES[main]=		http://wizard.ae.krakow.pl/~mike/download/
DISTFILE[1]=		whowatch-1.8.5.tar.gz:main
DF_INDEX=		1
SPKGS[standard]=	single

OPTIONS_AVAILABLE=	none
OPTIONS_STANDARD=	none

NOT_FOR_OPSYS=		sunos

USES=			ncurses

LICENSE=		GPLv2:single
LICENSE_SCHEME=		solo
LICENSE_FILE=		GPLv2:{{WRKSRC}}/COPYING

FPC_EQUIVALENT=		sysutils/whowatch

MUST_CONFIGURE=		gnu

CPPFLAGS=		-I{{NCURSESINC}}

post-patch:
	${REINPLACE_CMD} -e "s|utmp|utmpx|g" ${WRKSRC}/configure

post-extract:
	${RM} ${WRKSRC}/src/procinfo.[ch]*
	${RM} ${WRKSRC}/src/proc_plugin.c*

[FILE:397:descriptions/desc.single]
Whowatch is an interactive who-like program that displays information
about the users currently logged on to the machine. In addition to
standard information (login name, tty, host, user's process), the type of
the connection (telnet or ssh) is shown. You can toggle display between
the users' commands or idle times. You can watch the process tree,
navigate in it, and send INT and KILL signals.


[FILE:100:distinfo]
5e77107c2bd31eee5609d80caf3f07fb4b913b4b2e71c1d0e73204937ffc9c8a       133845 whowatch-1.8.5.tar.gz


[FILE:42:manifests/plist.single]
bin/whowatch
share/man/man1/whowatch.1.gz


[FILE:527:patches/patch-configure]
--- configure.orig	2013-10-07 12:11:45 UTC
+++ configure
@@ -4897,6 +4897,7 @@ else
 /* end confdefs.h.  */
 #include <sys/types.h>
 #include <sys/time.h>
+#include <stdlib.h>
 #include <unistd.h>
 
 int main()
@@ -4948,7 +4949,7 @@ if ac_fn_c_try_compile "$LINENO"; then :
   { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
 $as_echo "yes" >&6; };
 $as_echo "#define HAVE_PROCESS_SYSCTL 1" >>confdefs.h
-
+HAVE_PROCESS_SYSCTL=1
 else
   { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
 $as_echo "no" >&6; }


[FILE:4221:patches/patch-src_dialects_bsd_proc__plugin.c]
--- src/dialects/bsd/proc_plugin.c.orig	2013-10-07 12:11:29 UTC
+++ src/dialects/bsd/proc_plugin.c
@@ -18,9 +18,15 @@ extern int can_use_kvm;
 #define elemof(x)	(sizeof (x) / sizeof*(x))
 #define endof(x)	((x) + elemof(x))
 
-static inline void no_info(void)
+#define CR	1
+#define NO_CR	0
+
+static inline void no_info(int newline)
 {
-	println("Information unavailable.");
+	if (newline)
+		println("Information unavailable.\n");
+	else
+		println("Information unavailable.");
 }
 
 static inline char *_read_link(const char *path)
@@ -39,7 +45,7 @@ static void read_link(int pid, char *nam
 	snprintf(pbuf, sizeof pbuf, "/proc/%d/%s", pid, name); 
 	v = _read_link(pbuf);
 	if(!v) {
-		no_info();
+		no_info(CR);
 		return;
 	}
 	println(v);
@@ -241,7 +247,7 @@ void open_fds(int pid, char *name)
 	snprintf(buf, sizeof buf, "/proc/%d/fd", pid);
 	d = opendir(buf);
 	if(!d) {
-		no_info();
+		no_info(CR);
 		return;
 	}
 	if(!count || ticks - count >= 2) {
@@ -256,7 +262,7 @@ void open_fds(int pid, char *name)
 		print("%s - ", dn->d_name);
 		snprintf(buf, sizeof buf, "/proc/%d/fd/%s", pid, dn->d_name);
 		s = _read_link(buf);
-		if(!s) no_info();
+		if(!s) no_info(CR);
 		else {
 			if(!strncmp("socket:[", s, 8) && show_net_conn(s+8));
 			else print("%s", s);
@@ -306,7 +312,7 @@ static void read_proc_file(char *name, c
 	if(end) elen = strlen(end);
 	f = fopen(name, "r");
 	if(!f) {
-		no_info();
+		no_info(NO_CR);
 		return;
 	}
 	if(!start) ok = 1;
@@ -319,7 +325,7 @@ static void read_proc_file(char *name, c
 		newln();
 	}
 END:	
-	if(!ok) no_info();
+	if(!ok) no_info(CR);
 	fclose(f);
 }	
 
@@ -381,7 +387,7 @@ FOUND:
 	boot_time = (time_t) c;
 }		
 
-#include <asm/param.h>	// for HZ
+#define HZ	60
 
 static void proc_starttime(int pid, char *name)
 {
@@ -389,7 +395,7 @@ static void proc_starttime(int pid, char
 	char *s;
 	i = p_start_time(pid);
 	if(i == -1 || !boot_time) {
-		no_info();
+		no_info(CR);
 		return;
 	}
 	sec = boot_time + i/HZ;
@@ -414,7 +420,7 @@ struct proc_detail_t proc_details_t[] =
 };
 
 
-void builtin_proc_draw(void *p)
+void eproc(void *p)
 {
         int i;
 	int pid = *(int*)p;
@@ -431,7 +437,7 @@ void builtin_proc_draw(void *p)
 static inline void print_boot_time(void)
 {
 	if(boot_time) print("%s",ctime(&boot_time));
-	else no_info();
+	else no_info(CR);
 }
 
 struct cpu_info_t {
@@ -488,7 +494,10 @@ static void get_cpu_info()
 {
 	char buf[64];
 	unsigned long z;
-	if(fill_cpu_info() == -1) no_info();
+	if(fill_cpu_info() == -1) {
+		no_info(CR);
+		return;
+	}
 	z = eff_info.u_mode + eff_info.nice + eff_info.s_mode + eff_info.idle;
 	snprintf(buf, sizeof buf, "%.1f%% user %.1f%% sys %.1f%% nice %.1f%% idle\n",
 		prcnt(eff_info.u_mode, z),
@@ -499,37 +508,37 @@ static void get_cpu_info()
 	print("%s", buf);
 }
 
-void builtin_sys_draw(void *unused)
+void esys(void *unused)
 {
 	int c;
-	print("BOOT TIME: ");
+	println("     BOOT TIME: ");
 	print_boot_time();
-	print("CPU: ");
+	println("           CPU: ");
 	get_cpu_info();
-	println("MEMORY:");
+	println("        MEMORY: ");
 	read_proc_file("/proc/meminfo", "MemTotal:", 0);
-	title("USED FILES: ");
+	println("\n    USED FILES: ");
 	c = read_file_pos("/proc/sys/fs/file-nr", 2);
-	if(c == -1) no_info();
+	if(c == -1) no_info(CR);
 	else println("%d", c);
-	print("USED INODES: ");
+	println("   USED INODES: ");
 	c = read_file_pos("/proc/sys/fs/inode-nr", 2);
-	if(c == -1) no_info();
+	if(c == -1) no_info(CR);
 	else println("%d", c);
 	
-	print("MAX FILES: ");
+	println("     MAX FILES: ");
 	read_proc_file("/proc/sys/fs/file-max", 0, 0);
-	print("MAX INODES: ");
+	println("\n    MAX INODES: ");
 	read_proc_file("/proc/sys/fs/inode-max", 0, 0);
-	println("\nSTAT:");
+	println("\n          STAT: ");
 	read_proc_file("/proc/stat", "cpu", "intr");
-	println("\nLOADED MODULES:");
+	println("\nLOADED MODULES: ");
 	read_proc_file("/proc/modules", 0, 0);
-	println("\nFILESYSTEMS:");
+	println("\n   FILESYSTEMS: ");
 	read_proc_file("/proc/filesystems", 0, 0);
-	println("\nPARTITIONS:");
+	println("\n    PARTITIONS: ");
 	read_proc_file("/proc/partitions", 0, 0);
-	println("\nDEVICES:");
+	println("\n       DEVICES: ");
 	read_proc_file("/proc/devices", 0, 0);
-}	
+}
 


[FILE:4702:patches/patch-src_dialects_bsd_procinfo.c]
--- src/dialects/bsd/procinfo.c.orig	2013-10-07 12:11:29 UTC
+++ src/dialects/bsd/procinfo.c
@@ -63,7 +63,7 @@ void get_info(int pid, struct procinfo *
 int fill_kinfo(struct kinfo_proc *info, int pid)
 {
 	int mib[] = { CTL_KERN, KERN_PROC, KERN_PROC_PID, pid };
-	int len = sizeof *info;
+	size_t len = sizeof *info;
 	if(sysctl(mib, 4, info, &len, 0, 0) == -1) 
 		return -1;
 	return len?0:-1;
@@ -81,12 +81,28 @@ void get_info(int pid, struct procinfo *
 	
 	if(fill_kinfo(&info, pid) == -1) return;
 	
+# if defined __FreeBSD__
+    	p->ppid  = info.ki_ppid;
+    	p->tpgid = info.ki_tpgid;
+    	p->euid  = info.ki_uid;
+    	p->stat  = info.ki_stat;
+    	strncpy(p->exec_file, info.ki_comm, EXEC_FILE);
+    	p->cterm = info.ki_tdev;
+# elif defined __DragonFly__
+    	p->ppid  = info.kp_ppid;
+    	p->tpgid = info.kp_tpgid;
+    	p->euid  = info.kp_uid;
+    	p->stat  = info.kp_stat;
+    	strncpy(p->exec_file, info.kp_comm, EXEC_FILE);
+    	p->cterm = info.kp_tdev;
+# else	
     	p->ppid = info.kp_eproc.e_ppid;
     	p->tpgid = info.kp_eproc.e_tpgid;
     	p->euid = info.kp_eproc.e_pcred.p_svuid;
     	p->stat = info.kp_proc.p_stat;
     	strncpy(p->exec_file, info.kp_proc.p_comm, EXEC_FILE);
     	p->cterm = info.kp_eproc.e_tdev;
+# endif
 	p->exec_file[EXEC_FILE] = '\0';
 }
 #endif
@@ -101,6 +117,16 @@ int get_ppid(int pid)
 	return p.ppid;
 }
 
+/*
+ * Get UID
+ */
+int proc_pid_uid(u32 pid)
+{
+	static struct procinfo p;
+	get_info((int)pid, &p);
+	return p.euid;
+}
+
 #ifdef HAVE_PROCESS_SYSCTL
 /*
  * Get terminal
@@ -122,7 +148,8 @@ int get_term(char *tty)
 int get_login_pid(char *tty)
 {
 	int mib[4] = {CTL_KERN, KERN_PROC, KERN_PROC_TTY, 0};
-	int len, t, el, i, pid, cndt = -1, l;
+	int t, el, i, pid, cndt = -1, l;
+	size_t len;
 	struct kinfo_proc *info;
 	struct procinfo p;
 	
@@ -140,6 +167,29 @@ int get_login_pid(char *tty)
 	if(sysctl(mib, 4, info, &len, 0, 0) == -1)
 		return -1;
 	for(i = 0; i < el; i++) {
+# if defined __FreeBSD__
+		if(!(pid = info[i].ki_pid)) continue;
+		get_info(get_ppid(pid), &p);
+		if(p.cterm == -1 || p.cterm != t) {
+			cndt = pid;
+			l = strlen(info[i].ki_comm);
+			if(l > 1 && !strncmp("sh",info[i].ki_comm+l-2,2)) {
+				free(info);
+				return pid;
+			}
+		}
+# elif defined __DragonFly__
+		if(!(pid = info[i].kp_pid)) continue;
+		get_info(get_ppid(pid), &p);
+		if(p.cterm == -1 || p.cterm != t) {
+			cndt = pid;
+			l = strlen(info[i].kp_comm);
+			if(l > 1 && !strncmp("sh",info[i].kp_comm+l-2,2)) {
+				free(info);
+				return pid;
+			}
+		}
+# else
 		if(!(pid = info[i].kp_proc.p_pid)) continue;
 		get_info(get_ppid(pid), &p);
 		if(p.cterm == -1 || p.cterm != t) {
@@ -156,6 +206,7 @@ int get_login_pid(char *tty)
 				return pid;
 			}
 		}
+# endif
 	}
 	free(info);
 	return cndt;
@@ -167,7 +218,8 @@ int get_login_pid(char *tty)
 int get_all_info(struct kinfo_proc **info)
 {
 	int mib[3] = { CTL_KERN, KERN_PROC, KERN_PROC_ALL };
-	int len, el;
+	int el;
+	size_t len;
 
 	if(sysctl(mib, 3, 0, &len, 0, 0) == -1)
 		return 0;
@@ -237,7 +289,13 @@ char *get_cmdline(int pid)
 	bzero(buf, sizeof buf);
 	if(fill_kinfo(&info, pid) == -1)
 		return "-";
+# if defined __FreeBSD__
+	memcpy(buf, info.ki_comm, sizeof buf - 1);
+# elif defined __DragonFly__
+	memcpy(buf, info.kp_comm, sizeof buf - 1);
+# else
 	memcpy(buf, info.kp_proc.p_comm, sizeof buf - 1);
+# endif
 	if(!full_cmd) return buf;
 #ifdef HAVE_LIBKVM
 	if(!can_use_kvm) return buf;
@@ -279,48 +337,9 @@ char *get_name(int pid)
 	return p.exec_file;
 }
 
-
-/*
- * Get state and owner (effective uid) of a process
- */
-#ifdef HAVE_PROCESS_SYSCTL
-void get_state(struct process *p)
-{
-	struct procinfo pi;
-	/* state SSLEEP won't be marked in proc tree */
-	char s[] = "FR DZ";
-	get_info(p->proc->pid, &pi);
-	p->uid = pi.euid;
-	if(pi.stat == ' ') {
-		p->state = '?';
-		return;
-	}
-	p->state = s[pi.stat-1];
-}
-#else
-void get_state(struct process *p)
+int proc_getloadavg(double d[], int l)
 {
-	char buf[256];
-	struct stat s;
-	char state;
-        FILE *f;
-        snprintf(buf, sizeof buf - 6, "/proc/%d", p->proc->pid);
-	p->uid = -1;
-	if (stat(buf, &s) >= 0) p->uid = s.st_uid;  
-	strcat(buf,"/stat");
-        if (!(f = fopen(buf,"rt"))){
-               	p->state = '?';
-		return;
-	}
-        fscanf(f,"%*d %*s %c",&state);
-	fclose(f);
-	p->state = state=='S'?' ':state;
-}
-#endif
-
 #ifndef HAVE_GETLOADAVG
-int getloadavg(double d[], int l)
-{
 	FILE *f;
 	if(!(f = fopen("/proc/loadavg", "r")))
 		return -1;
@@ -330,8 +349,11 @@ int getloadavg(double d[], int l)
 	}
 	fclose(f);
 	return 0;
-}
+#else
+	return getloadavg(d, l);
 #endif
+}
+
 /* 
  * It really shouldn't be in this file.
  * Count idle time.


[FILE:306:patches/patch-src_dialects_bsd_procinfo.h]
--- src/dialects/bsd/procinfo.h.orig	2013-10-07 12:11:29 UTC
+++ src/dialects/bsd/procinfo.h
@@ -1,7 +1,11 @@
 #ifdef HAVE_PROCESS_SYSCTL
 #include <sys/param.h>
 #include <sys/sysctl.h>
+# ifdef __DragonFly__
+#include <sys/user.h>
+# else
 #include <sys/proc.h>
+# endif
 #include <sys/stat.h>
 #endif
 


[FILE:606:patches/patch-src_proctree.c]
--- src/proctree.c.orig	2013-10-07 12:11:29 UTC
+++ src/proctree.c
@@ -172,8 +172,17 @@ int update_tree(void del(void*))
 #ifdef HAVE_PROCESS_SYSCTL
 	el = get_all_info(&pi);
 	for(i = 0; i < el; i++) {
+# if defined __FreeBSD__
+		p = validate_proc(pi[i].ki_pid, ' ');
+		q = validate_proc(pi[i].ki_ppid, ' ');
+# elif defined __DragonFly__
+		if (pi[i].kp_pid < 1) continue;
+		p = validate_proc(pi[i].kp_pid, ' ');
+		q = validate_proc(pi[i].kp_ppid, ' ');
+# else
 		p = validate_proc(pi[i].kp_proc.p_pid, ' ');
 		q = validate_proc(pi[i].kp_eproc.e_ppid, ' ');
+# endif
 #else
 
 	d=opendir(PROCDIR);


[FILE:2771:patches/patch-src_ulist.c]
--- src/ulist.c.orig	2013-10-07 12:11:29 UTC
+++ src/ulist.c
@@ -48,21 +48,17 @@ void update_line(int line)
 /* 
  * Create new user structure and fill it
  */
-struct user_t *alloc_user(struct utmp *entry)
+struct user_t *alloc_user(struct utmpx *entry)
 {
 	struct user_t *u;
 	int ppid;
 	
 	u = calloc(1, sizeof *u);
 	if(!u) errx(1, "Cannot allocate memory.");
-	strncpy(u->name, entry->ut_user, UT_NAMESIZE);
-	strncpy(u->tty, entry->ut_line, UT_LINESIZE);
-	strncpy(u->host, entry->ut_host, UT_HOSTSIZE);
-#ifdef HAVE_UTPID		
+	strncpy(u->name, entry->ut_user, sizeof(entry->ut_user));
+	strncpy(u->tty, entry->ut_line, sizeof(entry->ut_line));
+	strncpy(u->host, entry->ut_host, sizeof(entry->ut_host));
 	u->pid = entry->ut_pid;
-#else
-	u->pid = get_login_pid(u->tty);
-#endif
  	if((ppid = get_ppid(u->pid)) == -1)
 		strncpy(u->parent, "can't access", sizeof u->parent);
 	else 	strncpy(u->parent, get_name(ppid), sizeof u->parent - 1);
@@ -70,7 +66,7 @@ struct user_t *alloc_user(struct utmp *e
 	return u;
 }
 
-static struct user_t* new_user(struct utmp *ut)
+static struct user_t* new_user(struct utmpx *ut)
 {
 	struct user_t *u;
 	u = alloc_user(ut);
@@ -108,21 +104,13 @@ void uredraw(struct wdgt *w)
  */
 void read_utmp(void)		
 {
-	int fd, i;
-	static struct utmp entry;
+	static struct utmpx *entry;
 	struct user_t *u;
-	
-	if ((fd = open(UTMP_FILE ,O_RDONLY)) == -1) err_exit(1, "Cannot open utmp");
-	while((i = read(fd, &entry,sizeof entry)) > 0) {
-		if(i != sizeof entry) errx(1, "Error reading " UTMP_FILE );
-#ifdef HAVE_USER_PROCESS
-		if(entry.ut_type != USER_PROCESS) continue;
-#else
-		if(!entry.ut_name[0]) continue;
-#endif
-		u = new_user(&entry);
+
+	while ((entry = getutxent()) != NULL) {
+		if(entry->ut_type != USER_PROCESS) continue;
+		u = new_user(entry);
 	}
-	close(fd);
 	return;
 }
 
@@ -176,31 +164,23 @@ static void check_wtmp(struct wdgt *w)
 	static int wtmp_fd;
 	struct user_t *u;
 	struct list_head *h;
-	struct utmp entry;
+	struct utmpx entry;
 	int i, changed = 0;
 	if(!wtmp_fd) open_wtmp(&wtmp_fd);	
 	
 	while((i = read(wtmp_fd, &entry, sizeof entry)) > 0){ 
 		if (i < sizeof entry) prg_exit("Error reading wtmp");
 		/* user just logged in */
-#ifdef HAVE_USER_PROCESS
 		if(entry.ut_type == USER_PROCESS) {
-#else
-		if(entry.ut_user[0]) {
-#endif
 			u = new_user(&entry);
 			changed = 1;
 			continue;
 		}
-#ifdef HAVE_DEAD_PROCESS
 		if(entry.ut_type != DEAD_PROCESS) continue;
-#else
-//		if(entry.ut_line[0]) continue;
-#endif
 	/* user just logged out */
 		list_for_each(h, &users_l) {
 			u = list_entry(h, struct user_t, head);
-			if(strncmp(u->tty, entry.ut_line, UT_LINESIZE)) 
+			if(strncmp(u->tty, entry.ut_line, sizeof(entry.ut_line))) 
 				continue;
 			udel(u, w);	
 			changed = 1;


[FILE:584:patches/patch-src_ulist.h]
--- src/ulist.h.orig	2013-10-07 12:11:29 UTC
+++ src/ulist.h
@@ -16,11 +16,11 @@
 struct user_t
 {
         struct list_head head;
-        char 	name[UT_NAMESIZE + 1];     
-        char 	tty[UT_LINESIZE + 1];      
+        char 	name[sizeof(((struct utmpx *)0)->ut_user)];     
+        char 	tty[sizeof(((struct utmpx *)0)->ut_line)];      
         int 	pid;                       
         char 	parent[16];                
-        char 	host[UT_HOSTSIZE + 1];     
+        char 	host[sizeof(((struct utmpx *)0)->ut_host)];     
         int 	line;                 	   
 };
 


[FILE:474:patches/patch-src_whowatch.c]
--- src/whowatch.c.orig	2013-10-07 12:11:29 UTC
+++ src/whowatch.c
@@ -436,12 +436,16 @@ int main(int argc, char **argv)
 		gettimeofday(&after, 0);
 		tv.tv_sec -= (after.tv_sec - before.tv_sec);
 		if(retval > 0) {
-			int key = read_key();
+			key = getkey();
+			if(key == KBD_MORE) {
+				usleep(10000);
+				key = getkey();
+			}
 			key_action(key);
 		}
 		if(tv.tv_sec <= 0) {
 			ticks++;
-			periodic();
+			main_periodic();
 			tv.tv_sec = TIMEOUT;
 		}
 #endif


[FILE:408:patches/patch-src_whowatch.h]
--- src/whowatch.h.orig	2013-10-07 12:11:29 UTC
+++ src/whowatch.h
@@ -4,7 +4,7 @@
 #include <stdlib.h>
 #include <unistd.h>
 #include <fcntl.h>
-#include <utmp.h>
+#include <utmpx.h>
 #include <string.h>
 #include <signal.h>
 #include <sys/stat.h>
@@ -216,3 +216,6 @@ int getkey();
 /* term.c */
 void term_raw();
 
+/* forgotten */
+void info_reg(struct wdgt *);
+void scr_crsr_jmp(struct wdgt *w, int l);

