# Buildsheet autogenerated by ravenadm tool -- Do not edit.

NAMEBASE=		lldb
VERSION=		20.1.4
KEYWORDS=		lang sysutils
VARIANTS=		std
SDESC[std]=		Linker from the LLVM project
HOMEPAGE=		http://llvm.org/
CONTACT=		nobody

DOWNLOAD_GROUPS=	main
SITES[main]=		https://github.com/llvm/llvm-project/releases/download/llvmorg-20.1.4/
			http://llvm.org/releases/20.1.4/
DISTFILE[1]=		lldb-20.1.4.src.tar.xz:main
DISTFILE[2]=		cmake-20.1.4.src.tar.xz:main
DF_INDEX=		1 2
SPKGS[std]=		set
			primary
			dev

OPTIONS_AVAILABLE=	none
OPTIONS_STANDARD=	none

BUILD_DEPENDS=		llvm:dev:std
			llvm:tools:std
			swig:primary:std
			clang:compiler:std
			clang:extra:std
BUILDRUN_DEPENDS=	llvm:primary:std
			clang:dynlibs:std

USES=			cpe cmake c++:primary zlib:build execinfo python
			ninja ncurses xz lua:5.3
GNOME_COMPONENTS=	libxml2

DISTNAME=		lldb-20.1.4.src

LICENSE=		CUSTOM1:primary
LICENSE_NAME=		CUSTOM1:"University of Illinois/NCSA Open Source License"
LICENSE_FILE=		CUSTOM1:{{WRKSRC}}/LICENSE.TXT
LICENSE_SCHEME=		solo

CMAKE_BUILD_TYPE=	Release
CPE_PRODUCT=		llvm
CPE_VENDOR=		llvm

SINGLE_JOB=		yes

SOVERSION=		20.1.4
PLIST_SUB=		SOMAJMIN=20.1
			SOEXTENSION={{SOEXTENSION}}

LDFLAGS=		-lpthread
CMAKE_ARGS=		-DLLVM_COMMON_CMAKE_UTILS={{WRKDIR}}/cmake-20.1.4.src
			-DLLDB_INCLUDE_TESTS:BOOL=OFF
			-DLUA_INCLUDE_DIR={{LOCALBASE}}/include/lua{{LUA_VER_STR}}
			-DLUA_LIBRARY={{LOCALBASE}}/lib/liblua-{{LUA_VER}}.so
VAR_OPSYS[linux]=	MAKEFILE_LINE=SOEXTENSION=-x86_64-linux-gnu

post-install:
	# set python cache
	(cd ${STAGEDIR}${PREFIX}/lib && ${PYTHON_CMD} -m compileall -d / . ||:)
	# strip
	${STRIP_CMD} ${STAGEDIR}${PREFIX}/bin/lldb*
	${STRIP_CMD} ${STAGEDIR}${PREFIX}/lib/liblldb.so

post-extract:
	# DragonFly support
	${MKDIR} ${WRKSRC}/source/Host/dragonfly
	${MKDIR} ${WRKSRC}/include/lldb/Host/dragonfly
	${MKDIR} ${WRKSRC}/source/Plugins/Process/DragonFly
	${INSTALL_DATA} ${FILESDIR}/DragonFlyHost.cpp ${WRKSRC}/source/Host/dragonfly/Host.cpp
	${INSTALL_DATA} ${FILESDIR}/HostInfoDragonFly.cpp ${WRKSRC}/source/Host/dragonfly/
	${INSTALL_DATA} ${FILESDIR}/HostInfoDragonFly.h ${WRKSRC}/include/lldb/Host/dragonfly/
	${INSTALL_DATA} ${FILESDIR}/DFProc.CMakeLists.txt ${WRKSRC}/source/Plugins/Process/DragonFly/CMakeLists.txt
	${INSTALL_DATA} ${FILESDIR}/Native* ${WRKSRC}/source/Plugins/Process/DragonFly/

[FILE:226:descriptions/desc.primary]
LLDB is a next generation, high-performance debugger. It is built as a set
of reusable components which highly leverage existing libraries in the
larger LLVM Project, such as the Clang expression parser and LLVM
disassembler.


[FILE:203:distinfo]
f7b93fc0cd94849f727f64c1baf36662985dc0e60c67b41dee9f1ca6e2589df5     10855348 lldb-20.1.4.src.tar.xz
d6fe52e4fd709590284127cfef143f67ff1b917865f1b4731f6600c330bf9c27         8648 cmake-20.1.4.src.tar.xz


[FILE:1592:manifests/plist.primary]
%%ONLY-LINUX%%lib/liblldbIntelFeatures.so.%%SOMAJMIN%%
%%PYTHON_SITELIBDIR%%/lldb/
 __init__.py
 _lldb.cpython-%%PYTHON_SUFFIX%%%%SOEXTENSION%%.so
 embedded_interpreter.py
 lldb-argdumper
%%PYTHON_SITELIBDIR%%/lldb/__pycache__/
 __init__.cpython-312.pyc
 embedded_interpreter.cpython-312.pyc
%%PYTHON_SITELIBDIR%%/lldb/formatters/
 Logger.py
 __init__.py
 attrib_fromdict.py
 cache.py
 metrics.py
 synth.py
%%PYTHON_SITELIBDIR%%/lldb/formatters/__pycache__/
 Logger.cpython-312.pyc
 __init__.cpython-312.pyc
 attrib_fromdict.cpython-312.pyc
 cache.cpython-312.pyc
 metrics.cpython-312.pyc
 synth.cpython-312.pyc
%%PYTHON_SITELIBDIR%%/lldb/formatters/cpp/
 __init__.py
 gnu_libstdcpp.py
 libcxx.py
%%PYTHON_SITELIBDIR%%/lldb/formatters/cpp/__pycache__/
 __init__.cpython-312.pyc
 gnu_libstdcpp.cpython-312.pyc
 libcxx.cpython-312.pyc
%%PYTHON_SITELIBDIR%%/lldb/plugins/
 __init__.py
 operating_system.py
 parsed_cmd.py
 scripted_platform.py
 scripted_process.py
 scripted_thread_plan.py
%%PYTHON_SITELIBDIR%%/lldb/plugins/__pycache__/
 __init__.cpython-312.pyc
 operating_system.cpython-312.pyc
 parsed_cmd.cpython-312.pyc
 scripted_platform.cpython-312.pyc
 scripted_process.cpython-312.pyc
 scripted_thread_plan.cpython-312.pyc
%%PYTHON_SITELIBDIR%%/lldb/utils/
 __init__.py
 in_call_stack.py
 symbolication.py
%%PYTHON_SITELIBDIR%%/lldb/utils/__pycache__/
 __init__.cpython-312.pyc
 in_call_stack.cpython-312.pyc
 symbolication.cpython-312.pyc
bin/
 lldb
 lldb-argdumper
 lldb-dap
 lldb-instr
 lldb-server
lib/
 liblldb.so.%%SOMAJMIN%%
 liblldb.so.%%SOVERSION%%
lib/lua/%%LUA_VER%%/lldb.so


[FILE:10911:manifests/plist.dev]
%%ONLY-LINUX%%lib/liblldbIntelFeatures.so
include/lldb/
 lldb-defines.h
 lldb-enumerations.h
 lldb-forward.h
 lldb-private-enumerations.h
 lldb-private-forward.h
 lldb-private-interfaces.h
 lldb-private-types.h
 lldb-private.h
 lldb-public.h
 lldb-types.h
 lldb-versioning.h
include/lldb/API/
 LLDB.h
 SBAddress.h
 SBAddressRange.h
 SBAddressRangeList.h
 SBAttachInfo.h
 SBBlock.h
 SBBreakpoint.h
 SBBreakpointLocation.h
 SBBreakpointName.h
 SBBroadcaster.h
 SBCommandInterpreter.h
 SBCommandInterpreterRunOptions.h
 SBCommandReturnObject.h
 SBCommunication.h
 SBCompileUnit.h
 SBData.h
 SBDebugger.h
 SBDeclaration.h
 SBDefines.h
 SBEnvironment.h
 SBError.h
 SBEvent.h
 SBExecutionContext.h
 SBExpressionOptions.h
 SBFile.h
 SBFileSpec.h
 SBFileSpecList.h
 SBFormat.h
 SBFrame.h
 SBFunction.h
 SBHostOS.h
 SBInstruction.h
 SBInstructionList.h
 SBLanguageRuntime.h
 SBLanguages.h
 SBLaunchInfo.h
 SBLineEntry.h
 SBListener.h
 SBMemoryRegionInfo.h
 SBMemoryRegionInfoList.h
 SBModule.h
 SBModuleSpec.h
 SBPlatform.h
 SBProcess.h
 SBProcessInfo.h
 SBProcessInfoList.h
 SBProgress.h
 SBQueue.h
 SBQueueItem.h
 SBReproducer.h
 SBSaveCoreOptions.h
 SBScriptObject.h
 SBSection.h
 SBSourceManager.h
 SBStatisticsOptions.h
 SBStream.h
 SBStringList.h
 SBStructuredData.h
 SBSymbol.h
 SBSymbolContext.h
 SBSymbolContextList.h
 SBTarget.h
 SBThread.h
 SBThreadCollection.h
 SBThreadPlan.h
 SBTrace.h
 SBTraceCursor.h
 SBType.h
 SBTypeCategory.h
 SBTypeEnumMember.h
 SBTypeFilter.h
 SBTypeFormat.h
 SBTypeNameSpecifier.h
 SBTypeSummary.h
 SBTypeSynthetic.h
 SBUnixSignals.h
 SBValue.h
 SBValueList.h
 SBVariablesOptions.h
 SBWatchpoint.h
 SBWatchpointOptions.h
include/lldb/Breakpoint/
 Breakpoint.h
 BreakpointID.h
 BreakpointIDList.h
 BreakpointList.h
 BreakpointLocation.h
 BreakpointLocationCollection.h
 BreakpointLocationList.h
 BreakpointName.h
 BreakpointOptions.h
 BreakpointPrecondition.h
 BreakpointResolver.h
 BreakpointResolverAddress.h
 BreakpointResolverFileLine.h
 BreakpointResolverFileRegex.h
 BreakpointResolverName.h
 BreakpointResolverScripted.h
 BreakpointSite.h
 StopPointSiteList.h
 Stoppoint.h
 StoppointCallbackContext.h
 StoppointHitCounter.h
 StoppointSite.h
 Watchpoint.h
 WatchpointAlgorithms.h
 WatchpointList.h
 WatchpointOptions.h
 WatchpointResource.h
include/lldb/Core/
 Address.h
 AddressRange.h
 AddressRangeListImpl.h
 AddressResolver.h
 AddressResolverFileLine.h
 Architecture.h
 Communication.h
 DataFileCache.h
 Debugger.h
 DebuggerEvents.h
 Declaration.h
 Disassembler.h
 DumpDataExtractor.h
 DumpRegisterInfo.h
 DumpRegisterValue.h
 EmulateInstruction.h
 FileLineResolver.h
 FormatEntity.h
 Highlighter.h
 IOHandler.h
 IOHandlerCursesGUI.h
 LoadedModuleInfoList.h
 Mangled.h
 Module.h
 ModuleChild.h
 ModuleList.h
 ModuleSpec.h
 Opcode.h
 PluginInterface.h
 PluginManager.h
 Progress.h
 RichManglingContext.h
 SearchFilter.h
 Section.h
 SourceLocationSpec.h
 SourceManager.h
 StreamAsynchronousIO.h
 StructuredDataImpl.h
 ThreadSafeDenseSet.h
 ThreadSafeValue.h
 ThreadedCommunication.h
 UniqueCStringMap.h
 UserSettingsController.h
 Value.h
 dwarf.h
include/lldb/DataFormatters/
 CXXFunctionPointer.h
 DataVisualization.h
 DumpValueObjectOptions.h
 FormatCache.h
 FormatClasses.h
 FormatManager.h
 FormatterSection.h
 FormattersContainer.h
 FormattersHelpers.h
 LanguageCategory.h
 StringPrinter.h
 TypeCategory.h
 TypeCategoryMap.h
 TypeFormat.h
 TypeSummary.h
 TypeSynthetic.h
 ValueObjectPrinter.h
 VectorIterator.h
 VectorType.h
include/lldb/Expression/
 DWARFExpression.h
 DWARFExpressionList.h
 DiagnosticManager.h
 DynamicCheckerFunctions.h
 Expression.h
 ExpressionParser.h
 ExpressionSourceCode.h
 ExpressionTypeSystemHelper.h
 ExpressionVariable.h
 FunctionCaller.h
 IRExecutionUnit.h
 IRInterpreter.h
 IRMemoryMap.h
 LLVMUserExpression.h
 Materializer.h
 ObjectFileJIT.h
 REPL.h
 UserExpression.h
 UtilityFunction.h
include/lldb/Host/
 Alarm.h
 Config.h
 ConnectionFileDescriptor.h
 Debug.h
 Editline.h
 File.h
 FileAction.h
 FileCache.h
 FileSystem.h
 Host.h
 HostGetOpt.h
 HostInfo.h
 HostInfoBase.h
 HostNativeProcess.h
 HostNativeProcessBase.h
 HostNativeThread.h
 HostNativeThreadBase.h
 HostNativeThreadForward.h
 HostProcess.h
 HostThread.h
 LZMA.h
 LockFile.h
 LockFileBase.h
 MainLoop.h
 MainLoopBase.h
 MonitoringProcessLauncher.h
 OptionParser.h
 Pipe.h
 PipeBase.h
 PosixApi.h
 ProcessLaunchInfo.h
 ProcessLauncher.h
 ProcessRunLock.h
 PseudoTerminal.h
 SafeMachO.h
 Socket.h
 SocketAddress.h
 StreamFile.h
 Terminal.h
 ThreadLauncher.h
 Time.h
 XML.h
include/lldb/Host/aix/HostInfoAIX.h
include/lldb/Host/android/HostInfoAndroid.h
include/lldb/Host/common/
 GetOptInc.h
 NativeBreakpointList.h
 NativeProcessProtocol.h
 NativeRegisterContext.h
 NativeThreadProtocol.h
 NativeWatchpointList.h
 TCPSocket.h
 UDPSocket.h
 ZipFileResolver.h
include/lldb/Host/dragonfly/HostInfoDragonFly.h
include/lldb/Host/freebsd/HostInfoFreeBSD.h
include/lldb/Host/linux/
 AbstractSocket.h
 Host.h
 HostInfoLinux.h
 Ptrace.h
 Support.h
 Uio.h
include/lldb/Host/macosx/
 HostInfoMacOSX.h
 HostThreadMacOSX.h
include/lldb/Host/netbsd/HostInfoNetBSD.h
include/lldb/Host/openbsd/HostInfoOpenBSD.h
include/lldb/Host/posix/
 ConnectionFileDescriptorPosix.h
 DomainSocket.h
 HostInfoPosix.h
 HostProcessPosix.h
 HostThreadPosix.h
 LockFilePosix.h
 MainLoopPosix.h
 PipePosix.h
 ProcessLauncherPosixFork.h
include/lldb/Host/windows/
 AutoHandle.h
 ConnectionGenericFileWindows.h
 HostInfoWindows.h
 HostProcessWindows.h
 HostThreadWindows.h
 LockFileWindows.h
 MainLoopWindows.h
 PipeWindows.h
 PosixApi.h
 ProcessLauncherWindows.h
 windows.h
include/lldb/Initialization/
 SystemInitializer.h
 SystemInitializerCommon.h
 SystemLifetimeManager.h
include/lldb/Interpreter/
 CommandAlias.h
 CommandCompletions.h
 CommandHistory.h
 CommandInterpreter.h
 CommandObject.h
 CommandObjectMultiword.h
 CommandOptionArgumentTable.h
 CommandOptionValidators.h
 CommandReturnObject.h
 OptionArgParser.h
 OptionGroupArchitecture.h
 OptionGroupBoolean.h
 OptionGroupFile.h
 OptionGroupFormat.h
 OptionGroupMemoryTag.h
 OptionGroupOutputFile.h
 OptionGroupPlatform.h
 OptionGroupPythonClassWithDict.h
 OptionGroupString.h
 OptionGroupUInt64.h
 OptionGroupUUID.h
 OptionGroupValueObjectDisplay.h
 OptionGroupVariable.h
 OptionGroupWatchpoint.h
 OptionValue.h
 OptionValueArch.h
 OptionValueArgs.h
 OptionValueArray.h
 OptionValueBoolean.h
 OptionValueChar.h
 OptionValueDictionary.h
 OptionValueEnumeration.h
 OptionValueFileColonLine.h
 OptionValueFileSpec.h
 OptionValueFileSpecList.h
 OptionValueFormat.h
 OptionValueFormatEntity.h
 OptionValueLanguage.h
 OptionValuePathMappings.h
 OptionValueProperties.h
 OptionValueRegex.h
 OptionValueSInt64.h
 OptionValueString.h
 OptionValueUInt64.h
 OptionValueUUID.h
 OptionValues.h
 Options.h
 Property.h
 ScriptInterpreter.h
 ScriptObject.h
include/lldb/Interpreter/Interfaces/
 OperatingSystemInterface.h
 ScriptedInterface.h
 ScriptedInterfaceUsages.h
 ScriptedPlatformInterface.h
 ScriptedProcessInterface.h
 ScriptedStopHookInterface.h
 ScriptedThreadInterface.h
 ScriptedThreadPlanInterface.h
include/lldb/Symbol/
 ArmUnwindInfo.h
 Block.h
 CallFrameInfo.h
 CompactUnwindInfo.h
 CompileUnit.h
 CompilerDecl.h
 CompilerDeclContext.h
 CompilerType.h
 DWARFCallFrameInfo.h
 DebugMacros.h
 DeclVendor.h
 FuncUnwinders.h
 Function.h
 LineEntry.h
 LineTable.h
 LocateSymbolFile.h
 ObjectContainer.h
 ObjectFile.h
 PostfixExpression.h
 SaveCoreOptions.h
 SourceModule.h
 Symbol.h
 SymbolContext.h
 SymbolContextScope.h
 SymbolFile.h
 SymbolFileOnDemand.h
 SymbolLocation.h
 SymbolLocator.h
 SymbolVendor.h
 Symtab.h
 TaggedASTType.h
 Type.h
 TypeList.h
 TypeMap.h
 TypeSystem.h
 UnwindPlan.h
 UnwindTable.h
 Variable.h
 VariableList.h
include/lldb/Target/
 ABI.h
 AppleArm64ExceptionClass.h
 AssertFrameRecognizer.h
 CoreFileMemoryRanges.h
 DynamicLoader.h
 DynamicRegisterInfo.h
 ExecutionContext.h
 ExecutionContextScope.h
 InstrumentationRuntime.h
 InstrumentationRuntimeStopInfo.h
 JITLoader.h
 JITLoaderList.h
 Language.h
 LanguageRuntime.h
 Memory.h
 MemoryHistory.h
 MemoryRegionInfo.h
 MemoryTagManager.h
 MemoryTagMap.h
 ModuleCache.h
 OperatingSystem.h
 PathMappingList.h
 Platform.h
 PostMortemProcess.h
 Process.h
 ProcessStructReader.h
 ProcessTrace.h
 Queue.h
 QueueItem.h
 QueueList.h
 RegisterCheckpoint.h
 RegisterContext.h
 RegisterContextUnwind.h
 RegisterFlags.h
 RegisterNumber.h
 RegisterTypeBuilder.h
 RemoteAwarePlatform.h
 Runtime.h
 ScriptedThreadPlan.h
 SectionLoadHistory.h
 SectionLoadList.h
 StackFrame.h
 StackFrameList.h
 StackFrameRecognizer.h
 StackID.h
 Statistics.h
 StopInfo.h
 StructuredDataPlugin.h
 SystemRuntime.h
 Target.h
 TargetList.h
 Thread.h
 ThreadCollection.h
 ThreadList.h
 ThreadPlan.h
 ThreadPlanBase.h
 ThreadPlanCallFunction.h
 ThreadPlanCallFunctionUsingABI.h
 ThreadPlanCallOnFunctionExit.h
 ThreadPlanCallUserExpression.h
 ThreadPlanRunToAddress.h
 ThreadPlanShouldStopHere.h
 ThreadPlanSingleThreadTimeout.h
 ThreadPlanStack.h
 ThreadPlanStepInRange.h
 ThreadPlanStepInstruction.h
 ThreadPlanStepOut.h
 ThreadPlanStepOverBreakpoint.h
 ThreadPlanStepOverRange.h
 ThreadPlanStepRange.h
 ThreadPlanStepThrough.h
 ThreadPlanStepUntil.h
 ThreadPlanTracer.h
 ThreadSpec.h
 TimeoutResumeAll.h
 Trace.h
 TraceCursor.h
 TraceDumper.h
 TraceExporter.h
 UnixSignals.h
 Unwind.h
 UnwindAssembly.h
 UnwindLLDB.h
 VerboseTrapFrameRecognizer.h
include/lldb/Utility/
 AddressableBits.h
 AnsiTerminal.h
 AppleUuidCompatibility.h
 ArchSpec.h
 Args.h
 Baton.h
 Broadcaster.h
 Checksum.h
 Cloneable.h
 CompletionRequest.h
 Connection.h
 ConstString.h
 DataBuffer.h
 DataBufferHeap.h
 DataBufferLLVM.h
 DataEncoder.h
 DataExtractor.h
 Diagnostics.h
 DiagnosticsRendering.h
 Endian.h
 Environment.h
 ErrorMessages.h
 Event.h
 FileSpec.h
 FileSpecList.h
 Flags.h
 GDBRemote.h
 IOObject.h
 Instrumentation.h
 Iterable.h
 LLDBAssert.h
 LLDBLog.h
 Listener.h
 Log.h
 NameMatches.h
 OptionDefinition.h
 Predicate.h
 ProcessInfo.h
 RangeMap.h
 RealpathPrefixes.h
 RegisterValue.h
 RegularExpression.h
 Scalar.h
 ScriptedMetadata.h
 SelectHelper.h
 SharedCluster.h
 State.h
 Status.h
 Stream.h
 StreamBuffer.h
 StreamString.h
 StreamTee.h
 StringExtractor.h
 StringExtractorGDBRemote.h
 StringLexer.h
 StringList.h
 StructuredData.h
 SupportFile.h
 ThreadSafeDenseMap.h
 TildeExpressionResolver.h
 Timeout.h
 Timer.h
 TraceGDBRemotePackets.h
 TraceIntelPTGDBRemotePackets.h
 UUID.h
 UnimplementedError.h
 UriParser.h
 UserID.h
 UserIDResolver.h
 VASPrintf.h
 VMRange.h
 XcodeSDK.h
 ZipFile.h
include/lldb/ValueObject/
 ValueObject.h
 ValueObjectCast.h
 ValueObjectChild.h
 ValueObjectConstResult.h
 ValueObjectConstResultCast.h
 ValueObjectConstResultChild.h
 ValueObjectConstResultImpl.h
 ValueObjectDynamicValue.h
 ValueObjectList.h
 ValueObjectMemory.h
 ValueObjectRegister.h
 ValueObjectSyntheticFilter.h
 ValueObjectUpdater.h
 ValueObjectVTable.h
 ValueObjectVariable.h
include/lldb/Version/Version.h
lib/liblldb.so


[FILE:535:patches/patch-cmake_modules_LLDBConfig.cmake]
--- cmake/modules/LLDBConfig.cmake.orig	2025-04-29 23:05:17 UTC
+++ cmake/modules/LLDBConfig.cmake
@@ -292,7 +292,7 @@ endif()
 
 # Figure out if lldb could use lldb-server.  If so, then we'll
 # ensure we build lldb-server when an lldb target is being built.
-if (CMAKE_SYSTEM_NAME MATCHES "Android|Darwin|FreeBSD|Linux|NetBSD|OpenBSD|Windows")
+if (CMAKE_SYSTEM_NAME MATCHES "Android|Darwin|FreeBSD|Linux|NetBSD|OpenBSD|DragonFly|MidnightBSD|Windows")
   set(LLDB_CAN_USE_LLDB_SERVER ON)
 else()
   set(LLDB_CAN_USE_LLDB_SERVER OFF)


[FILE:496:patches/patch-include_lldb_Host_HostInfo.h]
--- include/lldb/Host/HostInfo.h.orig	2025-04-29 23:05:17 UTC
+++ include/lldb/Host/HostInfo.h
@@ -46,6 +46,9 @@
 #elif defined(__FreeBSD__) || defined(__FreeBSD_kernel__)
 #include "lldb/Host/freebsd/HostInfoFreeBSD.h"
 #define HOST_INFO_TYPE HostInfoFreeBSD
+#elif defined(__DragonFly__)
+#include "lldb/Host/dragonfly/HostInfoDragonFly.h"
+#define HOST_INFO_TYPE HostInfoDragonFly
 #elif defined(__NetBSD__)
 #include "lldb/Host/netbsd/HostInfoNetBSD.h"
 #define HOST_INFO_TYPE HostInfoNetBSD


[FILE:306:patches/patch-include_lldb_Host_SocketAddress.h]
--- include/lldb/Host/SocketAddress.h.orig	2025-04-29 23:05:17 UTC
+++ include/lldb/Host/SocketAddress.h
@@ -22,7 +22,7 @@ typedef ADDRESS_FAMILY sa_family_t;
 #include <sys/socket.h>
 #endif
 
-#if defined(__FreeBSD__)
+#if defined(__FreeBSD__) || defined(__DragonFly__)
 #include <sys/types.h>
 #endif
 


[FILE:667:patches/patch-source_Host_CMakeLists.txt]
--- source/Host/CMakeLists.txt.orig	2025-04-29 23:05:17 UTC
+++ source/Host/CMakeLists.txt
@@ -115,12 +115,18 @@ else()
         android/HostInfoAndroid.cpp
         )
     endif()
-  elseif (CMAKE_SYSTEM_NAME MATCHES "FreeBSD")
+  elseif (CMAKE_SYSTEM_NAME MATCHES "FreeBSD|MidnightBSD")
     add_host_subdirectory(freebsd
       freebsd/Host.cpp
       freebsd/HostInfoFreeBSD.cpp
       )
 
+  elseif (CMAKE_SYSTEM_NAME MATCHES "DragonFly")
+    add_host_subdirectory(dragonfly
+      dragonfly/Host.cpp
+      dragonfly/HostInfoDragonFly.cpp
+      )
+
   elseif (CMAKE_SYSTEM_NAME MATCHES "NetBSD")
     add_host_subdirectory(netbsd
       netbsd/HostNetBSD.cpp


[FILE:429:patches/patch-source_Host_posix_DomainSocket.cpp]
--- source/Host/posix/DomainSocket.cpp.orig	2025-04-29 23:05:17 UTC
+++ source/Host/posix/DomainSocket.cpp
@@ -43,6 +43,7 @@ static bool SetSockAddr(llvm::StringRef
         offsetof(struct sockaddr_un, sun_path) + name_offset + name.size();
 
 #if defined(__APPLE__) || defined(__FreeBSD__) || defined(__NetBSD__) ||       \
+    defined(__DragonFly__) ||\
     defined(__OpenBSD__)
   saddr_un->sun_len = saddr_un_len;
 #endif


[FILE:439:patches/patch-source_Host_posix_HostThreadPosix.cpp]
--- source/Host/posix/HostThreadPosix.cpp.orig	2025-04-29 23:05:17 UTC
+++ source/Host/posix/HostThreadPosix.cpp
@@ -40,7 +40,7 @@ Status HostThreadPosix::Join(lldb::threa
 Status HostThreadPosix::Cancel() {
   Status error;
   if (IsJoinable()) {
-#ifndef __FreeBSD__
+#if !defined(__FreeBSD__) && !defined(__DragonFly__)
     llvm_unreachable("someone is calling HostThread::Cancel()");
 #else
     int err = ::pthread_cancel(m_thread);


[FILE:436:patches/patch-source_Host_posix_PipePosix.cpp]
--- source/Host/posix/PipePosix.cpp.orig	2025-04-29 23:05:17 UTC
+++ source/Host/posix/PipePosix.cpp
@@ -32,6 +32,7 @@ enum PIPES { READ, WRITE }; // Constants
 // pipe2 is supported by a limited set of platforms
 // TODO: Add more platforms that support pipe2.
 #if defined(__linux__) || defined(__FreeBSD__) || defined(__NetBSD__) ||       \
+    defined(__DragonFly__) ||\
     defined(__OpenBSD__)
 #define PIPE2_SUPPORTED 1
 #else


[FILE:341:patches/patch-source_Initialization_CMakeLists.txt]
--- source/Initialization/CMakeLists.txt.orig	2025-04-29 23:05:17 UTC
+++ source/Initialization/CMakeLists.txt
@@ -1,4 +1,4 @@
-if ( CMAKE_SYSTEM_NAME MATCHES "Linux|Android|FreeBSD|NetBSD|OpenBSD" )
+if ( CMAKE_SYSTEM_NAME MATCHES "Linux|Android|FreeBSD|NetBSD|MidnightBSD" )
   list(APPEND EXTRA_PLUGINS lldbPluginProcessPOSIX)
 endif()
 


[FILE:689:patches/patch-source_Initialization_SystemInitializerCommon.cpp]
--- source/Initialization/SystemInitializerCommon.cpp.orig	2025-04-29 23:05:17 UTC
+++ source/Initialization/SystemInitializerCommon.cpp
@@ -19,6 +19,7 @@
 #include "lldb/Version/Version.h"
 
 #if defined(__linux__) || defined(__FreeBSD__) || defined(__NetBSD__) ||       \
+    defined(__FreeBSD__) ||\
     defined(__OpenBSD__)
 #include "Plugins/Process/POSIX/ProcessPOSIXLog.h"
 #endif
@@ -79,6 +80,7 @@ llvm::Error SystemInitializerCommon::Ini
   process_gdb_remote::ProcessGDBRemoteLog::Initialize();
 
 #if defined(__linux__) || defined(__FreeBSD__) || defined(__NetBSD__) ||       \
+    defined(__FreeBSD__) ||\
     defined(__OpenBSD__)
   ProcessPOSIXLog::Initialize();
 #endif


[FILE:906:patches/patch-source_Plugins_Platform_FreeBSD_PlatformFreeBSD.cpp]
--- source/Plugins/Platform/FreeBSD/PlatformFreeBSD.cpp.orig	2025-04-29 23:05:17 UTC
+++ source/Plugins/Platform/FreeBSD/PlatformFreeBSD.cpp
@@ -59,7 +59,7 @@ PlatformSP PlatformFreeBSD::CreateInstan
       create = true;
       break;
 
-#if defined(__FreeBSD__)
+#if defined(__FreeBSD__) || defined(__DragonFly__)
     // Only accept "unknown" for the OS if the host is BSD and it "unknown"
     // wasn't specified (it was just returned because it was NOT specified)
     case llvm::Triple::OSType::UnknownOS:
@@ -87,7 +87,7 @@ void PlatformFreeBSD::Initialize() {
   Platform::Initialize();
 
   if (g_initialize_count++ == 0) {
-#if defined(__FreeBSD__)
+#if defined(__FreeBSD__) || defined(__DragonFly__)
     PlatformSP default_platform_sp(new PlatformFreeBSD(true));
     default_platform_sp->SetSystemArchitecture(HostInfo::GetArchitecture());
     Platform::SetHostPlatform(default_platform_sp);


[FILE:598:patches/patch-source_Plugins_Process_CMakeLists.txt]
--- source/Plugins/Process/CMakeLists.txt.orig	2025-04-29 23:05:17 UTC
+++ source/Plugins/Process/CMakeLists.txt
@@ -1,9 +1,12 @@
 if (CMAKE_SYSTEM_NAME MATCHES "Linux|Android")
   add_subdirectory(Linux)
   add_subdirectory(POSIX)
-elseif (CMAKE_SYSTEM_NAME MATCHES "FreeBSD")
+elseif (CMAKE_SYSTEM_NAME MATCHES "FreeBSD|MidnightBSD")
   add_subdirectory(FreeBSD)
   add_subdirectory(POSIX)
+elseif (CMAKE_SYSTEM_NAME MATCHES "DragonFly")
+  add_subdirectory(DragonFly)
+  add_subdirectory(POSIX)
 elseif (CMAKE_SYSTEM_NAME MATCHES "NetBSD")
   add_subdirectory(NetBSD)
   add_subdirectory(POSIX)


[FILE:553:patches/patch-source_Plugins_SymbolLocator_Default_SymbolLocatorDefault.cpp]
--- source/Plugins/SymbolLocator/Default/SymbolLocatorDefault.cpp.orig	2025-04-29 23:05:17 UTC
+++ source/Plugins/SymbolLocator/Default/SymbolLocatorDefault.cpp
@@ -145,7 +145,7 @@ std::optional<FileSpec> SymbolLocatorDef
       FileSystem::Instance().Resolve(file_spec);
       debug_file_search_paths.AppendIfUnique(file_spec);
     }
-#if defined(__FreeBSD__)
+#if defined(__FreeBSD__) && !defined(__MidnightBSD__)
     // Add $LOCALBASE/lib/debug directory, where LOCALBASE is
     // usually /usr/local, but may be adjusted by the end user.
     {


[FILE:596:patches/patch-tools_lldb-server_CMakeLists.txt]
--- tools/lldb-server/CMakeLists.txt.orig	2025-04-29 23:05:17 UTC
+++ tools/lldb-server/CMakeLists.txt
@@ -8,10 +8,14 @@ if(CMAKE_SYSTEM_NAME MATCHES "Linux|Andr
   list(APPEND LLDB_PLUGINS lldbPluginProcessLinux)
 endif()
 
-if(CMAKE_SYSTEM_NAME MATCHES "FreeBSD")
+if(CMAKE_SYSTEM_NAME MATCHES "FreeBSD|MidnightBSD")
   list(APPEND LLDB_PLUGINS lldbPluginProcessFreeBSD)
 endif()
 
+if(CMAKE_SYSTEM_NAME MATCHES "DragonFly")
+  list(APPEND LLDB_PLUGINS lldbPluginProcessDragonFly)
+endif()
+
 if(CMAKE_SYSTEM_NAME MATCHES "NetBSD")
   list(APPEND LLDB_PLUGINS lldbPluginProcessNetBSD)
 endif()


[FILE:919:patches/patch-tools_lldb-server_lldb-gdbserver.cpp]
--- tools/lldb-server/lldb-gdbserver.cpp.orig	2025-04-29 23:05:17 UTC
+++ tools/lldb-server/lldb-gdbserver.cpp
@@ -41,6 +41,8 @@
 #include "Plugins/Process/Linux/NativeProcessLinux.h"
 #elif defined(__FreeBSD__)
 #include "Plugins/Process/FreeBSD/NativeProcessFreeBSD.h"
+#elif defined(__DragonFly__)
+#include "Plugins/Process/DragonFly/NativeProcessDragonFly.h"
 #elif defined(__NetBSD__)
 #include "Plugins/Process/NetBSD/NativeProcessNetBSD.h"
 #elif defined(_WIN32)
@@ -66,6 +68,8 @@ namespace {
 typedef process_linux::NativeProcessLinux::Manager NativeProcessManager;
 #elif defined(__FreeBSD__)
 typedef process_freebsd::NativeProcessFreeBSD::Manager NativeProcessManager;
+#elif defined(__DragonFly__)
+typedef process_dragonfly::NativeProcessDragonFly::Manager NativeProcessManager;
 #elif defined(__NetBSD__)
 typedef process_netbsd::NativeProcessNetBSD::Manager NativeProcessManager;
 #elif defined(_WIN32)


[FILE:479:patches/patch-unittests_Process_Utility_CMakeLists.txt]
--- unittests/Process/Utility/CMakeLists.txt.orig	2025-04-29 23:05:17 UTC
+++ unittests/Process/Utility/CMakeLists.txt
@@ -4,7 +4,7 @@ set(NETBSD_SOURCES
   RegisterContextNetBSDTest_i386.cpp
   RegisterContextNetBSDTest_x86_64.cpp)
 
-if (CMAKE_SYSTEM_NAME MATCHES "FreeBSD")
+if (CMAKE_SYSTEM_NAME MATCHES "FreeBSD|MidnightBSD")
   list(APPEND PLATFORM_SOURCES ${FREEBSD_SOURCES})
 elseif (CMAKE_SYSTEM_NAME MATCHES "NetBSD")
   list(APPEND PLATFORM_SOURCES ${NETBSD_SOURCES})


[FILE:344:files/DFProc.CMakeLists.txt]
add_lldb_library(lldbPluginProcessDragonFly
  NativeProcessDragonFly.cpp
  NativeRegisterContextDragonFly.cpp
  NativeRegisterContextDragonFly_x86_64.cpp
  NativeThreadDragonFly.cpp

  LINK_LIBS
    lldbHost
    lldbSymbol
    lldbTarget
    lldbUtility
    lldbPluginProcessPOSIX
    lldbPluginProcessUtility
  LINK_COMPONENTS
    Support
  )


[FILE:7666:files/DragonFlyHost.cpp]
//===-- source/Host/dragonfly/Host.cpp --------------------------------------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//

#include <sys/types.h>

#include <sys/exec.h>
#include <sys/ptrace.h>
#include <sys/sysctl.h>
#include <sys/user.h>

#include <machine/elf.h>

#include <cstdio>
#include <dlfcn.h>
#include <execinfo.h>

#include "lldb/Host/Host.h"
#include "lldb/Host/HostInfo.h"
#include "lldb/Utility/DataBufferHeap.h"
#include "lldb/Utility/DataExtractor.h"
#include "lldb/Utility/Endian.h"
#include "lldb/Utility/Log.h"
#include "lldb/Utility/NameMatches.h"
#include "lldb/Utility/ProcessInfo.h"
#include "lldb/Utility/Status.h"
#include "lldb/Utility/StreamString.h"

#include "llvm/TargetParser/Host.h"

namespace lldb_private {
class ProcessLaunchInfo;
}

using namespace lldb;
using namespace lldb_private;

static bool
GetDragonFlyProcessArgs(const ProcessInstanceInfoMatch *match_info_ptr,
                      ProcessInstanceInfo &process_info) {
  if (!process_info.ProcessIDIsValid())
    return false;

  int pid = process_info.GetProcessID();

  int mib[4] = {CTL_KERN, KERN_PROC, KERN_PROC_ARGS, pid};

  char arg_data[8192];
  size_t arg_data_size = sizeof(arg_data);
  if (::sysctl(mib, 4, arg_data, &arg_data_size, NULL, 0) != 0)
    return false;

  DataExtractor data(arg_data, arg_data_size, endian::InlHostByteOrder(),
                     sizeof(void *));
  lldb::offset_t offset = 0;
  const char *cstr;

  cstr = data.GetCStr(&offset);
  if (!cstr)
    return false;

  // Get pathname for pid. If that fails fall back to argv[0].
  char pathname[MAXPATHLEN];
  size_t pathname_len = sizeof(pathname);
  mib[2] = KERN_PROC_PATHNAME;
  if (::sysctl(mib, 4, pathname, &pathname_len, NULL, 0) == 0)
    process_info.GetExecutableFile().SetFile(pathname, FileSpec::Style::native);
  else
    process_info.GetExecutableFile().SetFile(cstr, FileSpec::Style::native);

  if (!(match_info_ptr == NULL ||
        NameMatches(process_info.GetExecutableFile().GetFilename().GetCString(),
                    match_info_ptr->GetNameMatchType(),
                    match_info_ptr->GetProcessInfo().GetName())))
    return false;

  process_info.SetArg0(cstr);
  Args &proc_args = process_info.GetArguments();
  while (1) {
    const uint8_t *p = data.PeekData(offset, 1);
    while ((p != NULL) && (*p == '\0') && offset < arg_data_size) {
      ++offset;
      p = data.PeekData(offset, 1);
    }
    if (p == NULL || offset >= arg_data_size)
      break;

    cstr = data.GetCStr(&offset);
    if (!cstr)
      break;

    proc_args.AppendArgument(llvm::StringRef(cstr));
  }

  return true;
}

static bool GetDragonFlyProcessCPUType(ProcessInstanceInfo &process_info) {
  if (process_info.ProcessIDIsValid()) {
    process_info.GetArchitecture() =
        HostInfo::GetArchitecture(HostInfo::eArchKindDefault);
    return true;
  }
  process_info.GetArchitecture().Clear();
  return false;
}

static bool GetDragonFlyProcessUserAndGroup(ProcessInstanceInfo &process_info) {
  struct kinfo_proc proc_kinfo;
  size_t proc_kinfo_size;
  const int pid = process_info.GetProcessID();
  int mib[4] = {CTL_KERN, KERN_PROC, KERN_PROC_PID, pid};

  if (!process_info.ProcessIDIsValid())
    goto error;

  proc_kinfo_size = sizeof(struct kinfo_proc);

  if (::sysctl(mib, 4, &proc_kinfo, &proc_kinfo_size, NULL, 0) != 0)
    goto error;

  if (proc_kinfo_size == 0)
    goto error;

  process_info.SetParentProcessID(proc_kinfo.kp_ppid);
  process_info.SetUserID(proc_kinfo.kp_ruid);
  process_info.SetGroupID(proc_kinfo.kp_rgid);
  process_info.SetEffectiveUserID(proc_kinfo.kp_uid);
  if (proc_kinfo.kp_ngroups > 0)
    process_info.SetEffectiveGroupID(proc_kinfo.kp_groups[0]);
  else
    process_info.SetEffectiveGroupID(UINT32_MAX);
  return true;

error:
  process_info.SetParentProcessID(LLDB_INVALID_PROCESS_ID);
  process_info.SetUserID(UINT32_MAX);
  process_info.SetGroupID(UINT32_MAX);
  process_info.SetEffectiveUserID(UINT32_MAX);
  process_info.SetEffectiveGroupID(UINT32_MAX);
  return false;
}

uint32_t Host::FindProcessesImpl(const ProcessInstanceInfoMatch &match_info,
                                 ProcessInstanceInfoList &process_infos) {
  const ::pid_t our_pid = ::getpid();
  const ::uid_t our_uid = ::getuid();
  std::vector<struct kinfo_proc> kinfos;
  // Special case, if lldb is being run as root we can attach to anything.
  bool all_users = match_info.GetMatchAllUsers() || (our_uid == 0);

  int mib[3] = {CTL_KERN, KERN_PROC, KERN_PROC_ALL};

  size_t pid_data_size = 0;
  if (::sysctl(mib, 3, NULL, &pid_data_size, NULL, 0) != 0)
    return 0;

  // Add a few extra in case a few more show up
  const size_t estimated_pid_count =
      (pid_data_size / sizeof(struct kinfo_proc)) + 10;

  kinfos.resize(estimated_pid_count);
  pid_data_size = kinfos.size() * sizeof(struct kinfo_proc);

  if (::sysctl(mib, 3, &kinfos[0], &pid_data_size, NULL, 0) != 0)
    return 0;

  const size_t actual_pid_count = (pid_data_size / sizeof(struct kinfo_proc));

  ProcessInstanceInfoMatch match_info_noname{match_info};
  match_info_noname.SetNameMatchType(NameMatch::Ignore);

  for (size_t i = 0; i < actual_pid_count; i++) {
    const struct kinfo_proc &kinfo = kinfos[i];

    /* Make sure the user is acceptable */
    if (!all_users && kinfo.kp_ruid != our_uid)
      continue;

    if (kinfo.kp_pid == our_pid ||   // Skip this process
        kinfo.kp_pid == 0 ||         // Skip kernel (kernel pid is 0)
        kinfo.kp_stat == SZOMB ||    // Zombies are bad
        kinfo.kp_flags & P_TRACED || // Being debugged?
        kinfo.kp_flags & P_WEXIT)    // Working on exiting
      continue;

    // Every thread is a process in DragonFly, but all the threads of a single
    // process have the same pid. Do not store the process info in the result
    // list if a process with given identifier is already registered there.
    bool already_registered = false;
    for (uint32_t pi = 0;
         !already_registered && (const int)kinfo.kp_nthreads > 1 &&
         pi < (const uint32_t)process_infos.size();
         pi++)
      already_registered =
          (process_infos[pi].GetProcessID() == (uint32_t)kinfo.kp_pid);

    if (already_registered)
      continue;

    ProcessInstanceInfo process_info;
    process_info.SetProcessID(kinfo.kp_pid);
    process_info.SetParentProcessID(kinfo.kp_ppid);
    process_info.SetUserID(kinfo.kp_ruid);
    process_info.SetGroupID(kinfo.kp_rgid);
    process_info.SetEffectiveUserID(kinfo.kp_svuid);
    process_info.SetEffectiveGroupID(kinfo.kp_svgid);

    // Make sure our info matches before we go fetch the name and cpu type
    if (match_info_noname.Matches(process_info) &&
        GetDragonFlyProcessArgs(&match_info, process_info)) {
      GetDragonFlyProcessCPUType(process_info);
      if (match_info.Matches(process_info))
        process_infos.push_back(process_info);
    }
  }

  return process_infos.size();
}

bool Host::GetProcessInfo(lldb::pid_t pid, ProcessInstanceInfo &process_info) {
  process_info.SetProcessID(pid);

  if (GetDragonFlyProcessArgs(NULL, process_info)) {
    // should use libprocstat instead of going right into sysctl?
    GetDragonFlyProcessCPUType(process_info);
    GetDragonFlyProcessUserAndGroup(process_info);
    return true;
  }

  process_info.Clear();
  return false;
}

Status Host::ShellExpandArguments(ProcessLaunchInfo &launch_info) {
  return Status("unimplemented");
}


[FILE:1723:files/HostInfoDragonFly.cpp]
//===-- HostInfoDragonFly.cpp -----------------------------------------------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//

#include "lldb/Host/dragonfly/HostInfoDragonFly.h"
#include "llvm/Support/FormatVariadic.h"
#include <cstdio>
#include <cstring>
#include <optional>
#include <sys/sysctl.h>
#include <sys/types.h>
#include <sys/utsname.h>
#include <unistd.h>

using namespace lldb_private;

llvm::VersionTuple HostInfoDragonFly::GetOSVersion() {
  struct utsname un;

  ::memset(&un, 0, sizeof(utsname));
  if (uname(&un) < 0)
    return llvm::VersionTuple();

  unsigned major, minor;
  if (2 == sscanf(un.release, "%u.%u", &major, &minor))
    return llvm::VersionTuple(major, minor);
  return llvm::VersionTuple();
}

std::optional<std::string> HostInfoDragonFly::GetOSBuildString() {
  int mib[2] = {CTL_KERN, KERN_OSREV};
  uint32_t osrev = 0;
  size_t osrev_len = sizeof(osrev);

  if (::sysctl(mib, 2, &osrev, &osrev_len, NULL, 0) == 0)
    return llvm::formatv("{0,8:8}", osrev).str();

  return std::nullopt;
}

FileSpec HostInfoDragonFly::GetProgramFileSpec() {
  static FileSpec g_program_filespec;
  if (!g_program_filespec) {
    int exe_path_mib[4] = {CTL_KERN, KERN_PROC, KERN_PROC_PATHNAME, getpid()};
    char exe_path[PATH_MAX];
    size_t exe_path_size = sizeof(exe_path);
    if (sysctl(exe_path_mib, 4, exe_path, &exe_path_size, NULL, 0) == 0)
      g_program_filespec.SetFile(exe_path, FileSpec::Style::native);
  }
  return g_program_filespec;
}


[FILE:845:files/HostInfoDragonFly.h]
//===-- HostInfoDragonFly.h ---------------------------------------*- C++ -*-===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//

#ifndef lldb_Host_dragonfly_HostInfoDragonFly_h_
#define lldb_Host_dragonfly_HostInfoDragonFly_h_

#include "lldb/Host/posix/HostInfoPosix.h"
#include "lldb/Utility/FileSpec.h"
#include "llvm/Support/VersionTuple.h"
#include <optional>

namespace lldb_private {

class HostInfoDragonFly : public HostInfoPosix {
public:
  static llvm::VersionTuple GetOSVersion();
  static std::optional<std::string> GetOSBuildString();
  static FileSpec GetProgramFileSpec();
};
}

#endif


[FILE:24076:files/NativeProcessDragonFly.cpp]
//===-- NativeProcessDragonFly.cpp ------------------------------------------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//

#include "NativeProcessDragonFly.h"

// clang-format off
#include <sys/types.h>
#include <sys/ptrace.h>
#include <sys/sysctl.h>
#include <sys/user.h>
#include <sys/wait.h>
#include <machine/elf.h>
// clang-format on

#include "Plugins/Process/POSIX/ProcessPOSIXLog.h"
#include "lldb/Host/HostProcess.h"
#include "lldb/Host/posix/ProcessLauncherPosixFork.h"
#include "lldb/Target/Process.h"
#include "lldb/Utility/State.h"
#include "llvm/Support/Errno.h"

using namespace lldb;
using namespace lldb_private;
using namespace lldb_private::process_dragonfly;
using namespace llvm;

// Simple helper function to ensure flags are enabled on the given file
// descriptor.
static Status EnsureFDFlags(int fd, int flags) {
  Status error;

  int status = fcntl(fd, F_GETFL);
  if (status == -1) {
    error = Status::FromErrno();
    return error;
  }

  if (fcntl(fd, F_SETFL, status | flags) == -1) {
    error = Status::FromErrno();
    return error;
  }

  return error;
}

static Status CanTrace() {
  int proc_debug, ret;
  size_t len = sizeof(proc_debug);
  ret = ::sysctlbyname("security.bsd.unprivileged_proc_debug", &proc_debug,
                       &len, nullptr, 0);
  if (ret != 0)
    return Status::FromErrorString("sysctlbyname() security.bsd.unprivileged_proc_debug failed");

  if (proc_debug < 1)
    return Status::FromErrorString(
        "process debug disabled by security.bsd.unprivileged_proc_debug oid");

  return {};
}

// Public Static Methods

llvm::Expected<std::unique_ptr<NativeProcessProtocol>>
NativeProcessDragonFly::Manager::Launch(ProcessLaunchInfo &launch_info,
                                      NativeDelegate &native_delegate) {
  Log *log = GetLog(POSIXLog::Process);
  Status status;

  ::pid_t pid = ProcessLauncherPosixFork()
                    .LaunchProcess(launch_info, status)
                    .GetProcessId();
  LLDB_LOG(log, "pid = {0:x}", pid);
  if (status.Fail()) {
    LLDB_LOG(log, "failed to launch process: {0}", status);
    auto error = CanTrace();
    if (error.Fail())
      return error.ToError();
    return status.ToError();
  }

  // Wait for the child process to trap on its call to execve.
  int wstatus;
  ::pid_t wpid = llvm::sys::RetryAfterSignal(-1, ::waitpid, pid, &wstatus, 0);
  assert(wpid == pid);
  UNUSED_IF_ASSERT_DISABLED(wpid);
  if (!WIFSTOPPED(wstatus)) {
    LLDB_LOG(log, "Could not sync with inferior process: wstatus={1}",
             WaitStatus::Decode(wstatus));
    return llvm::make_error<StringError>("Could not sync with inferior process",
                                         llvm::inconvertibleErrorCode());
  }
  LLDB_LOG(log, "inferior started, now in stopped state");

  ProcessInstanceInfo Info;
  if (!Host::GetProcessInfo(pid, Info)) {
    return llvm::make_error<StringError>("Cannot get process architecture",
                                         llvm::inconvertibleErrorCode());
  }

  // Set the architecture to the exe architecture.
  LLDB_LOG(log, "pid = {0:x}, detected architecture {1}", pid,
           Info.GetArchitecture().GetArchitectureName());

  std::unique_ptr<NativeProcessDragonFly> process_up(new NativeProcessDragonFly(
      pid, launch_info.GetPTY().ReleasePrimaryFileDescriptor(), native_delegate,
      Info.GetArchitecture(), m_mainloop));

  status = process_up->SetupTrace();
  if (status.Fail())
    return status.ToError();

  for (const auto &thread : process_up->m_threads)
    static_cast<NativeThreadDragonFly &>(*thread).SetStoppedBySignal(SIGSTOP);
  process_up->SetState(StateType::eStateStopped, false);

  return std::move(process_up);
}

llvm::Expected<std::unique_ptr<NativeProcessProtocol>>
NativeProcessDragonFly::Manager::Attach(
    lldb::pid_t pid, NativeProcessProtocol::NativeDelegate &native_delegate) {
  Log *log = GetLog(POSIXLog::Process);
  LLDB_LOG(log, "pid = {0:x}", pid);

  // Retrieve the architecture for the running process.
  ProcessInstanceInfo Info;
  if (!Host::GetProcessInfo(pid, Info)) {
    return llvm::make_error<StringError>("Cannot get process architecture",
                                         llvm::inconvertibleErrorCode());
  }

  std::unique_ptr<NativeProcessDragonFly> process_up(new NativeProcessDragonFly(
      pid, -1, native_delegate, Info.GetArchitecture(), m_mainloop));

  Status status = process_up->Attach();
  if (!status.Success())
    return status.ToError();

  return std::move(process_up);
}

NativeProcessDragonFly::Extension
NativeProcessDragonFly::Manager::GetSupportedExtensions() const {
  return
#if defined(PT_COREDUMP)
      Extension::savecore |
#endif
      Extension::multiprocess | Extension::fork | Extension::vfork |
      Extension::pass_signals | Extension::auxv | Extension::libraries_svr4 |
      Extension::siginfo_read;
}

// Public Instance Methods

NativeProcessDragonFly::NativeProcessDragonFly(::pid_t pid, int terminal_fd,
                                           NativeDelegate &delegate,
                                           const ArchSpec &arch,
                                           MainLoop &mainloop)
    : NativeProcessELF(pid, terminal_fd, delegate), m_arch(arch),
      m_main_loop(mainloop) {
  if (m_terminal_fd != -1) {
    Status status = EnsureFDFlags(m_terminal_fd, O_NONBLOCK);
    assert(status.Success());
  }

  Status status;
  m_sigchld_handle = mainloop.RegisterSignal(
      SIGCHLD, [this](MainLoopBase &) { SigchldHandler(); }, status);
  assert(m_sigchld_handle && status.Success());
}

// Handles all waitpid events from the inferior process.
void NativeProcessDragonFly::MonitorCallback(lldb::pid_t pid, int signal) {
  switch (signal) {
  case SIGTRAP:
    return MonitorSIGTRAP(pid);
  case SIGSTOP:
    return MonitorSIGSTOP(pid);
  default:
    return MonitorSignal(pid, signal);
  }
}

void NativeProcessDragonFly::MonitorExited(lldb::pid_t pid, WaitStatus status) {
  Log *log = GetLog(POSIXLog::Process);

  LLDB_LOG(log, "got exit signal({0}) , pid = {1}", status, pid);

  /* Stop Tracking All Threads attached to Process */
  m_threads.clear();

  SetExitStatus(status, true);

  // Notify delegate that our process has exited.
  SetState(StateType::eStateExited, true);
}

void NativeProcessDragonFly::MonitorSIGSTOP(lldb::pid_t pid) {
  /* Stop all Threads attached to Process */
  for (const auto &thread : m_threads) {
    static_cast<NativeThreadDragonFly &>(*thread).SetStoppedBySignal(SIGSTOP,
                                                                   nullptr);
  }
  SetState(StateType::eStateStopped, true);
}

void NativeProcessDragonFly::MonitorSIGTRAP(lldb::pid_t pid) {
  Log *log = GetLog(POSIXLog::Process);

  // DragonFly ptrace can't query kernel threads for signal information
  LLDB_LOG(log, "SIGTRAP, passing to generic handler");
  MonitorSignal(pid, SIGTRAP);
}

void NativeProcessDragonFly::MonitorSignal(lldb::pid_t pid, int signal) {
  Log *log = GetLog(POSIXLog::Process);
  
  // DragonFly ptrace can't query kernel threads for signal information
  LLDB_LOG(log, "SIGNAL {0} received, marked stopped", signal);
  SetState(StateType::eStateStopped, true);
}

Status NativeProcessDragonFly::PtraceWrapper(int req, lldb::pid_t pid, void *addr,
                                           int data, int *result) {
  Log *log = GetLog(POSIXLog::Ptrace);
  Status error;
  int ret;

  errno = 0;
  ret =
      ptrace(req, static_cast<::pid_t>(pid), static_cast<caddr_t>(addr), data);

  if (ret == -1) {
    error = CanTrace();
    if (error.Success())
      error = Status::FromErrno();
  }

  if (result)
    *result = ret;

  LLDB_LOG(log, "ptrace({0}, {1}, {2}, {3})={4:x}", req, pid, addr, data, ret);

  if (error.Fail())
    LLDB_LOG(log, "ptrace() failed: {0}", error);

  return error;
}

llvm::Expected<llvm::ArrayRef<uint8_t>>
NativeProcessDragonFly::GetSoftwareBreakpointTrapOpcode(size_t size_hint) {
  static const uint8_t g_arm_opcode[] = {0xfe, 0xde, 0xff, 0xe7};
  static const uint8_t g_thumb_opcode[] = {0x01, 0xde};

  switch (GetArchitecture().GetMachine()) {
  case llvm::Triple::arm:
    switch (size_hint) {
    case 2:
      return llvm::ArrayRef(g_thumb_opcode);
    case 4:
      return llvm::ArrayRef(g_arm_opcode);
    default:
      return llvm::createStringError(llvm::inconvertibleErrorCode(),
                                     "Unrecognised trap opcode size hint!");
    }
  default:
    return NativeProcessProtocol::GetSoftwareBreakpointTrapOpcode(size_hint);
  }
}

Status NativeProcessDragonFly::Resume(const ResumeActionList &resume_actions) {
  Log *log = GetLog(POSIXLog::Process);
  LLDB_LOG(log, "pid {0}", GetID());

  Status ret;

  int signal = 0;
  for (const auto &abs_thread : m_threads) {
    assert(abs_thread && "thread list should not contain NULL threads");
    NativeThreadDragonFly &thread =
        static_cast<NativeThreadDragonFly &>(*abs_thread);

    const ResumeAction *action =
        resume_actions.GetActionForThread(thread.GetID(), true);
    // we need to explicit issue suspend requests, so it is simpler to map it
    // into proper action
    ResumeAction suspend_action{thread.GetID(), eStateSuspended,
                                LLDB_INVALID_SIGNAL_NUMBER};

    if (action == nullptr) {
      LLDB_LOG(log, "no action specified for pid {0} tid {1}", GetID(),
               thread.GetID());
      action = &suspend_action;
    }

    LLDB_LOG(
        log,
        "processing resume action state {0} signal {1} for pid {2} tid {3}",
        action->state, action->signal, GetID(), thread.GetID());

    switch (action->state) {
    case eStateRunning:
      ret = thread.Resume();
      break;
    case eStateStepping:
      ret = thread.SingleStep();
      break;
    case eStateSuspended:
    case eStateStopped:
      if (action->signal != LLDB_INVALID_SIGNAL_NUMBER)
        return Status::FromErrorString("Passing signal to suspended thread unsupported");

      ret = thread.Suspend();
      break;

    default:
      return Status::FromErrorStringWithFormat(
          "NativeProcessDragonFly::%s (): unexpected state %s specified "
          "for pid %" PRIu64 ", tid %" PRIu64,
          __FUNCTION__, StateAsCString(action->state), GetID(), thread.GetID());
    }

    if (!ret.Success())
      return ret;
    if (action->signal != LLDB_INVALID_SIGNAL_NUMBER)
      signal = action->signal;
  }

  ret =
      PtraceWrapper(PT_CONTINUE, GetID(), reinterpret_cast<void *>(1), signal);
  if (ret.Success())
    SetState(eStateRunning, true);
  return ret;
}

Status NativeProcessDragonFly::Halt() {
  Status error;

  // Do not try to stop a process that's already stopped, this may cause
  // the SIGSTOP to get queued and stop the process again once resumed.
  if (StateIsStoppedState(m_state, false))
    return error;
  if (kill(GetID(), SIGSTOP) != 0)
    error = Status::FromErrno();
  return error;
}

Status NativeProcessDragonFly::Detach() {
  Status error;

  // Stop monitoring the inferior.
  m_sigchld_handle.reset();

  // Tell ptrace to detach from the process.
  if (GetID() == LLDB_INVALID_PROCESS_ID)
    return error;

  return PtraceWrapper(PT_DETACH, GetID());
}

Status NativeProcessDragonFly::Signal(int signo) {
  Status error;

  if (kill(GetID(), signo))
    error = Status::FromErrno();

  return error;
}

Status NativeProcessDragonFly::Interrupt() { return Halt(); }

Status NativeProcessDragonFly::Kill() {
  Log *log = GetLog(POSIXLog::Process);
  LLDB_LOG(log, "pid {0}", GetID());

  Status error;

  switch (m_state) {
  case StateType::eStateInvalid:
  case StateType::eStateExited:
  case StateType::eStateCrashed:
  case StateType::eStateDetached:
  case StateType::eStateUnloaded:
    // Nothing to do - the process is already dead.
    LLDB_LOG(log, "ignored for PID {0} due to current state: {1}", GetID(),
             StateAsCString(m_state));
    return error;

  case StateType::eStateConnected:
  case StateType::eStateAttaching:
  case StateType::eStateLaunching:
  case StateType::eStateStopped:
  case StateType::eStateRunning:
  case StateType::eStateStepping:
  case StateType::eStateSuspended:
    // We can try to kill a process in these states.
    break;
  }

  return PtraceWrapper(PT_KILL, m_pid);
}

Status NativeProcessDragonFly::GetMemoryRegionInfo(lldb::addr_t load_addr,
                                                 MemoryRegionInfo &range_info) {

  if (m_supports_mem_region == LazyBool::eLazyBoolNo) {
    // We're done.
    return Status::FromErrorString("unsupported");
  }

  Status error = PopulateMemoryRegionCache();
  if (error.Fail()) {
    return error;
  }

  lldb::addr_t prev_base_address = 0;
  // FIXME start by finding the last region that is <= target address using
  // binary search.  Data is sorted.
  // There can be a ton of regions on pthreads apps with lots of threads.
  for (auto it = m_mem_region_cache.begin(); it != m_mem_region_cache.end();
       ++it) {
    MemoryRegionInfo &proc_entry_info = it->first;
    // Sanity check assumption that memory map entries are ascending.
    assert((proc_entry_info.GetRange().GetRangeBase() >= prev_base_address) &&
           "descending memory map entries detected, unexpected");
    prev_base_address = proc_entry_info.GetRange().GetRangeBase();
    UNUSED_IF_ASSERT_DISABLED(prev_base_address);
    // If the target address comes before this entry, indicate distance to next
    // region.
    if (load_addr < proc_entry_info.GetRange().GetRangeBase()) {
      range_info.GetRange().SetRangeBase(load_addr);
      range_info.GetRange().SetByteSize(
          proc_entry_info.GetRange().GetRangeBase() - load_addr);
      range_info.SetReadable(MemoryRegionInfo::OptionalBool::eNo);
      range_info.SetWritable(MemoryRegionInfo::OptionalBool::eNo);
      range_info.SetExecutable(MemoryRegionInfo::OptionalBool::eNo);
      range_info.SetMapped(MemoryRegionInfo::OptionalBool::eNo);
      return error;
    } else if (proc_entry_info.GetRange().Contains(load_addr)) {
      // The target address is within the memory region we're processing here.
      range_info = proc_entry_info;
      return error;
    }
    // The target memory address comes somewhere after the region we just
    // parsed.
  }
  // If we made it here, we didn't find an entry that contained the given
  // address. Return the load_addr as start and the amount of bytes betwwen
  // load address and the end of the memory as size.
  range_info.GetRange().SetRangeBase(load_addr);
  range_info.GetRange().SetRangeEnd(LLDB_INVALID_ADDRESS);
  range_info.SetReadable(MemoryRegionInfo::OptionalBool::eNo);
  range_info.SetWritable(MemoryRegionInfo::OptionalBool::eNo);
  range_info.SetExecutable(MemoryRegionInfo::OptionalBool::eNo);
  range_info.SetMapped(MemoryRegionInfo::OptionalBool::eNo);
  return error;
}

Status NativeProcessDragonFly::PopulateMemoryRegionCache() {
  Log *log = GetLog(POSIXLog::Process);
  // If our cache is empty, pull the latest.  There should always be at least
  // one memory region if memory region handling is supported.
  if (!m_mem_region_cache.empty()) {
    LLDB_LOG(log, "reusing {0} cached memory region entries",
             m_mem_region_cache.size());
    return Status();
  }

  m_supports_mem_region = LazyBool::eLazyBoolNo;
  return Status::FromErrorString("PopulateMemoryRegionCache Unimplemented");
}

size_t NativeProcessDragonFly::UpdateThreads() { return m_threads.size(); }

Status NativeProcessDragonFly::SetBreakpoint(lldb::addr_t addr, uint32_t size,
                                           bool hardware) {
  if (hardware)
    return SetHardwareBreakpoint(addr, size);
  return SetSoftwareBreakpoint(addr, size);
}

Status NativeProcessDragonFly::GetLoadedModuleFileSpec(const char *module_path,
                                                     FileSpec &file_spec) {
  Status error = PopulateMemoryRegionCache();
  if (error.Fail()) {
    auto status = CanTrace();
    if (status.Fail())
      return status;
    return error;
  }

  FileSpec module_file_spec(module_path);
  FileSystem::Instance().Resolve(module_file_spec);

  file_spec.Clear();
  for (const auto &it : m_mem_region_cache) {
    if (it.second.GetFilename() == module_file_spec.GetFilename()) {
      file_spec = it.second;
      return Status();
    }
  }
  return Status::FromErrorStringWithFormat(
    "Module file (%s) not found in process' memory map!",
    module_file_spec.GetFilename().AsCString());
}

Status
NativeProcessDragonFly::GetFileLoadAddress(const llvm::StringRef &file_name,
                                         lldb::addr_t &load_addr) {
  load_addr = LLDB_INVALID_ADDRESS;
  Status error = PopulateMemoryRegionCache();
  if (error.Fail()) {
    auto status = CanTrace();
    if (status.Fail())
      return status;
    return error;
  }

  FileSpec file(file_name);
  for (const auto &it : m_mem_region_cache) {
    if (it.second == file) {
      load_addr = it.first.GetRange().GetRangeBase();
      return Status();
    }
  }
  return Status::FromErrorStringWithFormat(
    "No load address found for file %s.",
    file_name.str().c_str());
}

void NativeProcessDragonFly::SigchldHandler() {
  Log *log = GetLog(POSIXLog::Process);
  int status;
  ::pid_t wait_pid =
      llvm::sys::RetryAfterSignal(-1, waitpid, GetID(), &status, WNOHANG);

  if (wait_pid == 0)
    return;

  if (wait_pid == -1) {
    Status error(errno, eErrorTypePOSIX);
    LLDB_LOG(log, "waitpid ({0}, &status, _) failed: {1}", GetID(), error);
    return;
  }

  WaitStatus wait_status = WaitStatus::Decode(status);
  bool exited = wait_status.type == WaitStatus::Exit ||
                (wait_status.type == WaitStatus::Signal &&
                 wait_pid == static_cast<::pid_t>(GetID()));

  LLDB_LOG(log,
           "waitpid ({0}, &status, _) => pid = {1}, status = {2}, exited = {3}",
           GetID(), wait_pid, status, exited);

  if (exited)
    MonitorExited(wait_pid, wait_status);
  else {
    assert(wait_status.type == WaitStatus::Stop);
    MonitorCallback(wait_pid, wait_status.status);
  }
}

bool NativeProcessDragonFly::HasThreadNoLock(lldb::tid_t thread_id) {
  for (const auto &thread : m_threads) {
    assert(thread && "thread list should not contain NULL threads");
    if (thread->GetID() == thread_id) {
      // We have this thread.
      return true;
    }
  }

  // We don't have this thread.
  return false;
}

NativeThreadDragonFly &NativeProcessDragonFly::AddThread(lldb::tid_t thread_id) {
  Log *log = GetLog(POSIXLog::Thread);
  LLDB_LOG(log, "pid {0} adding thread with tid {1}", GetID(), thread_id);

  assert(thread_id > 0);
  assert(!HasThreadNoLock(thread_id) &&
         "attempted to add a thread by id that already exists");

  // If this is the first thread, save it as the current thread
  if (m_threads.empty())
    SetCurrentThreadID(thread_id);

  m_threads.push_back(std::make_unique<NativeThreadDragonFly>(*this, thread_id));
  return static_cast<NativeThreadDragonFly &>(*m_threads.back());
}

void NativeProcessDragonFly::RemoveThread(lldb::tid_t thread_id) {
  Log *log = GetLog(POSIXLog::Thread);
  LLDB_LOG(log, "pid {0} removing thread with tid {1}", GetID(), thread_id);

  assert(thread_id > 0);
  assert(HasThreadNoLock(thread_id) &&
         "attempted to remove a thread that does not exist");

  for (auto it = m_threads.begin(); it != m_threads.end(); ++it) {
    if ((*it)->GetID() == thread_id) {
      m_threads.erase(it);
      break;
    }
  }

  if (GetCurrentThreadID() == thread_id)
    SetCurrentThreadID(m_threads.front()->GetID());
}

Status NativeProcessDragonFly::Attach() {
  // Attach to the requested process.
  // An attach will cause the thread to stop with a SIGSTOP.
  Status status = PtraceWrapper(PT_ATTACH, m_pid);
  if (status.Fail())
    return status;

  int wstatus;
  // Need to use WALLSIG otherwise we receive an error with errno=ECHLD At this
  // point we should have a thread stopped if waitpid succeeds.
  if ((wstatus = llvm::sys::RetryAfterSignal(-1, waitpid, m_pid, nullptr, 0)) <
      0)
    return Status(errno, eErrorTypePOSIX);

  // Initialize threads and tracing status
  // NB: this needs to be called before we set thread state
  status = SetupTrace();
  if (status.Fail())
    return status;

  for (const auto &thread : m_threads)
    static_cast<NativeThreadDragonFly &>(*thread).SetStoppedBySignal(SIGSTOP);

  // Let our process instance know the thread has stopped.
  SetCurrentThreadID(m_threads.front()->GetID());
  SetState(StateType::eStateStopped, false);
  return Status();
}

Status NativeProcessDragonFly::ReadMemory(lldb::addr_t addr, void *buf,
                                        size_t size, size_t &bytes_read) {
  unsigned char *dst = static_cast<unsigned char *>(buf);
  struct ptrace_io_desc io;

  Log *log = GetLog(POSIXLog::Memory);
  LLDB_LOG(log, "addr = {0}, buf = {1}, size = {2}", addr, buf, size);

  bytes_read = 0;
  io.piod_op = PIOD_READ_D;
  io.piod_len = size;

  do {
    io.piod_offs = (void *)(addr + bytes_read);
    io.piod_addr = dst + bytes_read;

    Status error = NativeProcessDragonFly::PtraceWrapper(PT_IO, GetID(), &io);
    if (error.Fail() || io.piod_len == 0)
      return error;

    bytes_read += io.piod_len;
    io.piod_len = size - bytes_read;
  } while (bytes_read < size);

  return Status();
}

Status NativeProcessDragonFly::WriteMemory(lldb::addr_t addr, const void *buf,
                                         size_t size, size_t &bytes_written) {
  const unsigned char *src = static_cast<const unsigned char *>(buf);
  Status error;
  struct ptrace_io_desc io;

  Log *log = GetLog(POSIXLog::Memory);
  LLDB_LOG(log, "addr = {0}, buf = {1}, size = {2}", addr, buf, size);

  bytes_written = 0;
  io.piod_op = PIOD_WRITE_D;
  io.piod_len = size;

  do {
    io.piod_addr =
        const_cast<void *>(static_cast<const void *>(src + bytes_written));
    io.piod_offs = (void *)(addr + bytes_written);

    Status error = NativeProcessDragonFly::PtraceWrapper(PT_IO, GetID(), &io);
    if (error.Fail() || io.piod_len == 0)
      return error;

    bytes_written += io.piod_len;
    io.piod_len = size - bytes_written;
  } while (bytes_written < size);

  return error;
}

llvm::ErrorOr<std::unique_ptr<llvm::MemoryBuffer>>
NativeProcessDragonFly::GetAuxvData() const {
  Log *log = GetLog(POSIXLog::Process);
  LLDB_LOG(log, "Tracing auxv data is not supported");
  return std::error_code(1, std::generic_category());
}

Status NativeProcessDragonFly::SetupTrace() {
  return Status::FromErrorString("trace setup not implemented");
}

Status NativeProcessDragonFly::ReinitializeThreads() {
  return Status::FromErrorString("reinitialize threads not implemented");
}

bool NativeProcessDragonFly::SupportHardwareSingleStepping() const {
  return true;
}

void NativeProcessDragonFly::MonitorClone(::pid_t child_pid, bool is_vfork,
                                        NativeThreadDragonFly &parent_thread) {
  Log *log = GetLog(POSIXLog::Process);
  LLDB_LOG(log, "fork, child_pid={0}", child_pid);

  int status;
  ::pid_t wait_pid =
      llvm::sys::RetryAfterSignal(-1, ::waitpid, child_pid, &status, 0);
  if (wait_pid != child_pid) {
    LLDB_LOG(log,
             "waiting for pid {0} failed. Assuming the pid has "
             "disappeared in the meantime",
             child_pid);
    return;
  }
  if (WIFEXITED(status)) {
    LLDB_LOG(log,
             "waiting for pid {0} returned an 'exited' event. Not "
             "tracking it.",
             child_pid);
    return;
  }

  LLDB_LOG(log, "MonitorClone unsupported");
  return;

}

llvm::Expected<std::string>
NativeProcessDragonFly::SaveCore(llvm::StringRef path_hint) {
  return llvm::createStringError(
      llvm::inconvertibleErrorCode(),
      "PT_COREDUMP not supported on DragonFly");
}


[FILE:4748:files/NativeProcessDragonFly.h]
//===-- NativeProcessDragonFly.h -------------------------------- -*- C++ -*-===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//

#ifndef liblldb_NativeProcessDragonFly_H_
#define liblldb_NativeProcessDragonFly_H_

#include "Plugins/Process/POSIX/NativeProcessELF.h"
#include "Plugins/Process/Utility/NativeProcessSoftwareSingleStep.h"

#include "lldb/Target/MemoryRegionInfo.h"
#include "lldb/Utility/ArchSpec.h"
#include "lldb/Utility/FileSpec.h"

#include "NativeThreadDragonFly.h"

namespace lldb_private {
namespace process_dragonfly {
/// \class NativeProcessDragonFly
/// Manages communication with the inferior (debugee) process.
///
/// Upon construction, this class prepares and launches an inferior process
/// for debugging.
///
/// Changes in the inferior process state are broadcasted.
class NativeProcessDragonFly : public NativeProcessELF,
                             private NativeProcessSoftwareSingleStep {
public:
  class Manager : public NativeProcessProtocol::Manager {
  public:
    using NativeProcessProtocol::Manager::Manager;

    llvm::Expected<std::unique_ptr<NativeProcessProtocol>>
    Launch(ProcessLaunchInfo &launch_info,
           NativeDelegate &native_delegate) override;

    llvm::Expected<std::unique_ptr<NativeProcessProtocol>>
    Attach(lldb::pid_t pid, NativeDelegate &native_delegate) override;

    Extension GetSupportedExtensions() const override;
  };

  // NativeProcessProtocol Interface
  Status Resume(const ResumeActionList &resume_actions) override;

  Status Halt() override;

  Status Detach() override;

  Status Signal(int signo) override;

  Status Interrupt() override;

  Status Kill() override;

  Status GetMemoryRegionInfo(lldb::addr_t load_addr,
                             MemoryRegionInfo &range_info) override;

  Status ReadMemory(lldb::addr_t addr, void *buf, size_t size,
                    size_t &bytes_read) override;

  Status WriteMemory(lldb::addr_t addr, const void *buf, size_t size,
                     size_t &bytes_written) override;

  size_t UpdateThreads() override;

  const ArchSpec &GetArchitecture() const override { return m_arch; }

  Status SetBreakpoint(lldb::addr_t addr, uint32_t size,
                       bool hardware) override;

  // The two following methods are probably not necessary and probably
  // will never be called.  Nevertheless, we implement them right now
  // to reduce the differences between different platforms and reduce
  // the risk of the lack of implementation actually breaking something,
  // at least for the time being.
  Status GetLoadedModuleFileSpec(const char *module_path,
                                 FileSpec &file_spec) override;
  Status GetFileLoadAddress(const llvm::StringRef &file_name,
                            lldb::addr_t &load_addr) override;

  llvm::ErrorOr<std::unique_ptr<llvm::MemoryBuffer>>
  GetAuxvData() const override;

  // Interface used by NativeRegisterContext-derived classes.
  static Status PtraceWrapper(int req, lldb::pid_t pid, void *addr = nullptr,
                              int data = 0, int *result = nullptr);

  bool SupportHardwareSingleStepping() const;

  llvm::Expected<std::string> SaveCore(llvm::StringRef path_hint) override;

protected:
  llvm::Expected<llvm::ArrayRef<uint8_t>>
  GetSoftwareBreakpointTrapOpcode(size_t size_hint) override;

private:
  MainLoop::SignalHandleUP m_sigchld_handle;
  ArchSpec m_arch;
  MainLoop& m_main_loop;
  LazyBool m_supports_mem_region = eLazyBoolCalculate;
  std::vector<std::pair<MemoryRegionInfo, FileSpec>> m_mem_region_cache;

  // Private Instance Methods
  NativeProcessDragonFly(::pid_t pid, int terminal_fd, NativeDelegate &delegate,
                       const ArchSpec &arch, MainLoop &mainloop);

  bool HasThreadNoLock(lldb::tid_t thread_id);

  NativeThreadDragonFly &AddThread(lldb::tid_t thread_id);
  void RemoveThread(lldb::tid_t thread_id);

  void MonitorCallback(lldb::pid_t pid, int signal);
  void MonitorExited(lldb::pid_t pid, WaitStatus status);
  void MonitorSIGSTOP(lldb::pid_t pid);
  void MonitorSIGTRAP(lldb::pid_t pid);
  void MonitorSignal(lldb::pid_t pid, int signal);
  void MonitorClone(::pid_t child_pid, bool is_vfork,
                    NativeThreadDragonFly &parent_thread);

  Status PopulateMemoryRegionCache();
  void SigchldHandler();

  Status Attach();
  Status SetupTrace();
  Status ReinitializeThreads();
};

} // namespace process_dragonfly
} // namespace lldb_private

#endif // #ifndef liblldb_NativeProcessDragonFly_H_


[FILE:936:files/NativeRegisterContextDragonFly.cpp]
//===-- NativeRegisterContextDragonFly.cpp ----------------------------------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//

#include "NativeRegisterContextDragonFly.h"

#include "Plugins/Process/DragonFly/NativeProcessDragonFly.h"

#include "lldb/Host/common/NativeProcessProtocol.h"

using namespace lldb_private;
using namespace lldb_private::process_dragonfly;

// clang-format off
#include <sys/types.h>
#include <sys/ptrace.h>
// clang-format on

NativeProcessDragonFly &NativeRegisterContextDragonFly::GetProcess() {
  return static_cast<NativeProcessDragonFly &>(m_thread.GetProcess());
}

::pid_t NativeRegisterContextDragonFly::GetProcessPid() {
  return GetProcess().GetID();
}


[FILE:1579:files/NativeRegisterContextDragonFly.h]
//===-- NativeRegisterContextDragonFly.h --------------------------*- C++ -*-===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//

#ifndef lldb_NativeRegisterContextDragonFly_h
#define lldb_NativeRegisterContextDragonFly_h

#include "Plugins/Process/Utility/NativeRegisterContextRegisterInfo.h"

namespace lldb_private {
namespace process_dragonfly {

class NativeProcessDragonFly;
class NativeThreadDragonFly;

class NativeRegisterContextDragonFly
    : public virtual NativeRegisterContextRegisterInfo {
public:
  // This function is implemented in the NativeRegisterContextDragonFly_*
  // subclasses to create a new instance of the host specific
  // NativeRegisterContextDragonFly. The implementations can't collide as only one
  // NativeRegisterContextDragonFly_* variant should be compiled into the final
  // executable.
  static NativeRegisterContextDragonFly *
  CreateHostNativeRegisterContextDragonFly(const ArchSpec &target_arch,
                                         NativeThreadDragonFly &native_thread);
  virtual llvm::Error
  CopyHardwareWatchpointsFrom(NativeRegisterContextDragonFly &source) = 0;

protected:
  virtual NativeProcessDragonFly &GetProcess();
  virtual ::pid_t GetProcessPid();
};

} // namespace process_dragonfly
} // namespace lldb_private

#endif // #ifndef lldb_NativeRegisterContextDragonFly_h


[FILE:18816:files/NativeRegisterContextDragonFly_x86_64.cpp]
//===-- NativeRegisterContextDragonFly_x86_64.cpp ---------------------------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//

#if defined(__x86_64__)

#include "NativeRegisterContextDragonFly_x86_64.h"

// clang-format off
#include <machine/npx.h>
// clang-format on

#include "lldb/Host/HostInfo.h"
#include "lldb/Utility/DataBufferHeap.h"
#include "lldb/Utility/Log.h"
#include "lldb/Utility/RegisterValue.h"
#include "lldb/Utility/Status.h"

#include "NativeProcessDragonFly.h"
#include "Plugins/Process/Utility/RegisterContextFreeBSD_x86_64.h"
#include <optional>

using namespace lldb_private;
using namespace lldb_private::process_dragonfly;

// x86 64-bit general purpose registers.
static const uint32_t g_gpr_regnums_x86_64[] = {
    lldb_rax_x86_64,    lldb_rbx_x86_64,    lldb_rcx_x86_64, lldb_rdx_x86_64,
    lldb_rdi_x86_64,    lldb_rsi_x86_64,    lldb_rbp_x86_64, lldb_rsp_x86_64,
    lldb_r8_x86_64,     lldb_r9_x86_64,     lldb_r10_x86_64, lldb_r11_x86_64,
    lldb_r12_x86_64,    lldb_r13_x86_64,    lldb_r14_x86_64, lldb_r15_x86_64,
    lldb_rip_x86_64,    lldb_rflags_x86_64, lldb_cs_x86_64,  lldb_fs_x86_64,
    lldb_gs_x86_64,     lldb_ss_x86_64,     lldb_ds_x86_64,  lldb_es_x86_64,
    lldb_eax_x86_64,    lldb_ebx_x86_64,    lldb_ecx_x86_64, lldb_edx_x86_64,
    lldb_edi_x86_64,    lldb_esi_x86_64,    lldb_ebp_x86_64, lldb_esp_x86_64,
    lldb_r8d_x86_64,  // Low 32 bits or r8
    lldb_r9d_x86_64,  // Low 32 bits or r9
    lldb_r10d_x86_64, // Low 32 bits or r10
    lldb_r11d_x86_64, // Low 32 bits or r11
    lldb_r12d_x86_64, // Low 32 bits or r12
    lldb_r13d_x86_64, // Low 32 bits or r13
    lldb_r14d_x86_64, // Low 32 bits or r14
    lldb_r15d_x86_64, // Low 32 bits or r15
    lldb_ax_x86_64,     lldb_bx_x86_64,     lldb_cx_x86_64,  lldb_dx_x86_64,
    lldb_di_x86_64,     lldb_si_x86_64,     lldb_bp_x86_64,  lldb_sp_x86_64,
    lldb_r8w_x86_64,  // Low 16 bits or r8
    lldb_r9w_x86_64,  // Low 16 bits or r9
    lldb_r10w_x86_64, // Low 16 bits or r10
    lldb_r11w_x86_64, // Low 16 bits or r11
    lldb_r12w_x86_64, // Low 16 bits or r12
    lldb_r13w_x86_64, // Low 16 bits or r13
    lldb_r14w_x86_64, // Low 16 bits or r14
    lldb_r15w_x86_64, // Low 16 bits or r15
    lldb_ah_x86_64,     lldb_bh_x86_64,     lldb_ch_x86_64,  lldb_dh_x86_64,
    lldb_al_x86_64,     lldb_bl_x86_64,     lldb_cl_x86_64,  lldb_dl_x86_64,
    lldb_dil_x86_64,    lldb_sil_x86_64,    lldb_bpl_x86_64, lldb_spl_x86_64,
    lldb_r8l_x86_64,    // Low 8 bits or r8
    lldb_r9l_x86_64,    // Low 8 bits or r9
    lldb_r10l_x86_64,   // Low 8 bits or r10
    lldb_r11l_x86_64,   // Low 8 bits or r11
    lldb_r12l_x86_64,   // Low 8 bits or r12
    lldb_r13l_x86_64,   // Low 8 bits or r13
    lldb_r14l_x86_64,   // Low 8 bits or r14
    lldb_r15l_x86_64,   // Low 8 bits or r15
    LLDB_INVALID_REGNUM // register sets need to end with this flag
};
static_assert((sizeof(g_gpr_regnums_x86_64) / sizeof(g_gpr_regnums_x86_64[0])) -
                      1 ==
                  k_num_gpr_registers_x86_64,
              "g_gpr_regnums_x86_64 has wrong number of register infos");

// x86 64-bit floating point registers.
static const uint32_t g_fpu_regnums_x86_64[] = {
    lldb_fctrl_x86_64,  lldb_fstat_x86_64, lldb_ftag_x86_64,
    lldb_fop_x86_64,    lldb_fiseg_x86_64, lldb_fioff_x86_64,
    lldb_fip_x86_64,    lldb_foseg_x86_64, lldb_fooff_x86_64,
    lldb_fdp_x86_64,    lldb_mxcsr_x86_64, lldb_mxcsrmask_x86_64,
    lldb_st0_x86_64,    lldb_st1_x86_64,   lldb_st2_x86_64,
    lldb_st3_x86_64,    lldb_st4_x86_64,   lldb_st5_x86_64,
    lldb_st6_x86_64,    lldb_st7_x86_64,   lldb_mm0_x86_64,
    lldb_mm1_x86_64,    lldb_mm2_x86_64,   lldb_mm3_x86_64,
    lldb_mm4_x86_64,    lldb_mm5_x86_64,   lldb_mm6_x86_64,
    lldb_mm7_x86_64,    lldb_xmm0_x86_64,  lldb_xmm1_x86_64,
    lldb_xmm2_x86_64,   lldb_xmm3_x86_64,  lldb_xmm4_x86_64,
    lldb_xmm5_x86_64,   lldb_xmm6_x86_64,  lldb_xmm7_x86_64,
    lldb_xmm8_x86_64,   lldb_xmm9_x86_64,  lldb_xmm10_x86_64,
    lldb_xmm11_x86_64,  lldb_xmm12_x86_64, lldb_xmm13_x86_64,
    lldb_xmm14_x86_64,  lldb_xmm15_x86_64,
    LLDB_INVALID_REGNUM // register sets need to end with this flag
};
static_assert((sizeof(g_fpu_regnums_x86_64) / sizeof(g_fpu_regnums_x86_64[0])) -
                      1 ==
                  k_num_fpr_registers_x86_64,
              "g_fpu_regnums_x86_64 has wrong number of register infos");

static const uint32_t g_avx_regnums_x86_64[] = {
    lldb_ymm0_x86_64,   lldb_ymm1_x86_64,  lldb_ymm2_x86_64,  lldb_ymm3_x86_64,
    lldb_ymm4_x86_64,   lldb_ymm5_x86_64,  lldb_ymm6_x86_64,  lldb_ymm7_x86_64,
    lldb_ymm8_x86_64,   lldb_ymm9_x86_64,  lldb_ymm10_x86_64, lldb_ymm11_x86_64,
    lldb_ymm12_x86_64,  lldb_ymm13_x86_64, lldb_ymm14_x86_64, lldb_ymm15_x86_64,
    LLDB_INVALID_REGNUM // register sets need to end with this flag
};
static_assert((sizeof(g_avx_regnums_x86_64) / sizeof(g_avx_regnums_x86_64[0])) -
                      1 ==
                  k_num_avx_registers_x86_64,
              "g_avx_regnums_x86_64 has wrong number of register infos");

static const uint32_t g_mpx_regnums_x86_64[] = {
    // Note: we currently do not provide them but this is needed to avoid
    // unnamed groups in SBFrame::GetRegisterContext().
    lldb_bnd0_x86_64,   lldb_bnd1_x86_64,    lldb_bnd2_x86_64,
    lldb_bnd3_x86_64,   lldb_bndcfgu_x86_64, lldb_bndstatus_x86_64,
    LLDB_INVALID_REGNUM // register sets need to end with this flag
};
static_assert((sizeof(g_mpx_regnums_x86_64) / sizeof(g_mpx_regnums_x86_64[0])) -
                      1 ==
                  k_num_mpx_registers_x86_64,
              "g_mpx_regnums_x86_64 has wrong number of register infos");

// x86 debug registers.
static const uint32_t g_dbr_regnums_x86_64[] = {
    lldb_dr0_x86_64,    lldb_dr1_x86_64, lldb_dr2_x86_64, lldb_dr3_x86_64,
    lldb_dr4_x86_64,    lldb_dr5_x86_64, lldb_dr6_x86_64, lldb_dr7_x86_64,
    LLDB_INVALID_REGNUM // register sets need to end with this flag
};
static_assert((sizeof(g_dbr_regnums_x86_64) / sizeof(g_dbr_regnums_x86_64[0])) -
                      1 ==
                  k_num_dbr_registers_x86_64,
              "g_dbr_regnums_x86_64 has wrong number of register infos");


// Number of register sets provided by this context.
enum { k_num_register_sets = 5 };

// Register sets for x86 64-bit.
static const RegisterSet g_reg_sets_x86_64[k_num_register_sets] = {
    {"General Purpose Registers", "gpr", k_num_gpr_registers_x86_64,
     g_gpr_regnums_x86_64},
    {"Floating Point Registers", "fpu", k_num_fpr_registers_x86_64,
     g_fpu_regnums_x86_64},
    {"Debug Registers", "dbr", k_num_dbr_registers_x86_64,
     g_dbr_regnums_x86_64},
    {"Advanced Vector Extensions", "avx", k_num_avx_registers_x86_64,
     g_avx_regnums_x86_64},
    {"Memory Protection Extensions", "mpx", k_num_mpx_registers_x86_64,
     g_mpx_regnums_x86_64},
};

#define REG_CONTEXT_SIZE (GetRegisterInfoInterface().GetGPRSize())

NativeRegisterContextDragonFly *
NativeRegisterContextDragonFly::CreateHostNativeRegisterContextDragonFly(
    const ArchSpec &target_arch, NativeThreadDragonFly &native_thread) {
  return new NativeRegisterContextDragonFly_x86_64(target_arch, native_thread);
}

// NativeRegisterContextDragonFly_x86_64 members.

static RegisterInfoInterface *
CreateRegisterInfoInterface(const ArchSpec &target_arch) {
    assert((HostInfo::GetArchitecture().GetAddressByteSize() == 8) &&
           "Register setting path assumes this is a 64-bit host");
    // X86_64 hosts know how to work with 64-bit and 32-bit EXEs using the
    // x86_64 register context.
    return new RegisterContextFreeBSD_x86_64(target_arch);
}

NativeRegisterContextDragonFly_x86_64::NativeRegisterContextDragonFly_x86_64(
    const ArchSpec &target_arch, NativeThreadDragonFly &native_thread)
    : NativeRegisterContextRegisterInfo(
          native_thread, CreateRegisterInfoInterface(target_arch)),
      NativeRegisterContextDBReg_x86(native_thread), m_regset_offsets({0}) {
  assert(m_gpr.size() == GetRegisterInfoInterface().GetGPRSize());
  std::array<uint32_t, MaxRegSet + 1> first_regnos;

  first_regnos[FPRegSet] = lldb_fctrl_x86_64;
  first_regnos[DBRegSet] = lldb_dr0_x86_64;

  for (int i : {FPRegSet, DBRegSet})
    m_regset_offsets[i] = GetRegisterInfoInterface()
                              .GetRegisterInfo()[first_regnos[i]]
                              .byte_offset;
}

uint32_t NativeRegisterContextDragonFly_x86_64::GetRegisterSetCount() const {
  return k_num_register_sets;
}

const RegisterSet *
NativeRegisterContextDragonFly_x86_64::GetRegisterSet(uint32_t set_index) const {
  return &g_reg_sets_x86_64[set_index];
}

std::optional<NativeRegisterContextDragonFly_x86_64::RegSetKind>
NativeRegisterContextDragonFly_x86_64::GetSetForNativeRegNum(uint32_t reg_num) const {
  if (reg_num >= k_first_gpr_x86_64 && reg_num <= k_last_gpr_x86_64)
      return GPRegSet;
  if (reg_num >= k_first_fpr_x86_64 && reg_num <= k_last_fpr_x86_64)
      return FPRegSet;
  if (reg_num >= k_first_avx_x86_64 && reg_num <= k_last_avx_x86_64)
      return YMMRegSet;
  if (reg_num >= k_first_mpxr_x86_64 && reg_num <= k_last_mpxr_x86_64)
      return std::nullopt; // MPXR
  if (reg_num >= k_first_mpxc_x86_64 && reg_num <= k_last_mpxc_x86_64)
      return std::nullopt; // MPXC
  if (reg_num >= k_first_dbr_x86_64 && reg_num <= k_last_dbr_x86_64)
      return DBRegSet; // DBR

  llvm_unreachable("Register does not belong to any register set");
}

Status NativeRegisterContextDragonFly_x86_64::ReadRegisterSet(RegSetKind set) {
  switch (set) {
  case GPRegSet:
    return NativeProcessDragonFly::PtraceWrapper(PT_GETREGS, m_thread.GetID(),
                                               m_gpr.data());
  case FPRegSet:
    return NativeProcessDragonFly::PtraceWrapper(PT_GETFPREGS, m_thread.GetID(),
                                               m_fpr.data());
  case DBRegSet:
    return NativeProcessDragonFly::PtraceWrapper(PT_GETDBREGS, m_thread.GetID(),
                                               m_dbr.data());
  case YMMRegSet:
  case MPXRegSet: {
       Status error;
       error = Status::FromErrorString("YMM/MPX registers not supported");
       return error;
    }
  }
  llvm_unreachable("NativeRegisterContextDragonFly_x86_64::ReadRegisterSet");
}

Status NativeRegisterContextDragonFly_x86_64::WriteRegisterSet(RegSetKind set) {
  switch (set) {
  case GPRegSet:
    return NativeProcessDragonFly::PtraceWrapper(PT_SETREGS, m_thread.GetID(),
                                               m_gpr.data());
  case FPRegSet:
    return NativeProcessDragonFly::PtraceWrapper(PT_SETFPREGS, m_thread.GetID(),
                                               m_fpr.data());
  case DBRegSet:
    return NativeProcessDragonFly::PtraceWrapper(PT_SETDBREGS, m_thread.GetID(),
                                               m_dbr.data());
  case YMMRegSet:
  case MPXRegSet: {
    // ReadRegisterSet() must always be called before WriteRegisterSet().
       Status error;
       error = Status::FromErrorString("YMM/MPX registers not supported");
       return error;
    }
  }
  llvm_unreachable("NativeRegisterContextDragonFly_x86_64::WriteRegisterSet");
}

Status
NativeRegisterContextDragonFly_x86_64::ReadRegister(const RegisterInfo *reg_info,
                                                  RegisterValue &reg_value) {
  Status error;

  if (!reg_info) {
    error = Status::FromErrorString("reg_info NULL");
    return error;
  }

  uint32_t reg = reg_info->kinds[lldb::eRegisterKindLLDB];
  if (reg == LLDB_INVALID_REGNUM) {
    // This is likely an internal register for lldb use only and should not be
    // directly queried.
    error = Status::FromErrorStringWithFormat(
        "register \"%s\" is an internal-only lldb register, cannot read directly",
        reg_info->name);
    return error;
  }

  std::optional<RegSetKind> opt_set = GetSetForNativeRegNum(reg);
  if (!opt_set) {
    // This is likely an internal register for lldb use only and should not be
    // directly queried.
    error = Status::FromErrorStringWithFormat(
        "register \"%s\" is in unrecognized set",
        reg_info->name);
    return error;
  }

  RegSetKind set = opt_set.value();
  error = ReadRegisterSet(set);
  if (error.Fail())
    return error;

  switch (set) {
  case GPRegSet:
  case FPRegSet:
  case DBRegSet: {
    void *data = GetOffsetRegSetData(set, reg_info->byte_offset);
    FXSAVE *fpr = reinterpret_cast<FXSAVE *>(m_fpr.data());
    if (data == &fpr->ftag) // ftag
      reg_value.SetUInt16(
          AbridgedToFullTagWord(fpr->ftag, fpr->fstat, fpr->stmm));
    else
      reg_value.SetBytes(data, reg_info->byte_size, endian::InlHostByteOrder());
    break;
  }
  case YMMRegSet: {
    std::optional<YMMSplitPtr> ymm_reg = GetYMMSplitReg(reg);
    if (!ymm_reg) {
      error = Status::FromErrorStringWithFormat(
          "register \"%s\" not supported by CPU/kernel", reg_info->name);
    } else {
      YMMReg ymm = XStateToYMM(ymm_reg->xmm, ymm_reg->ymm_hi);
      reg_value.SetBytes(ymm.bytes, reg_info->byte_size,
                         endian::InlHostByteOrder());
    }
    break;
  }
  case MPXRegSet:
    llvm_unreachable("MPX regset should have returned error");
  }

  return error;
}

Status NativeRegisterContextDragonFly_x86_64::WriteRegister(
    const RegisterInfo *reg_info, const RegisterValue &reg_value) {

  Status error;

  if (!reg_info) {
    error = Status::FromErrorString("reg_info NULL");
    return error;
  }

  uint32_t reg = reg_info->kinds[lldb::eRegisterKindLLDB];
  if (reg == LLDB_INVALID_REGNUM) {
    // This is likely an internal register for lldb use only and should not be
    // directly queried.
    error = Status::FromErrorStringWithFormat(
      "register \"%s\" is an internal-only lldb register, cannot read directly",
      reg_info->name);
    return error;
  }

  std::optional<RegSetKind> opt_set = GetSetForNativeRegNum(reg);
  if (!opt_set) {
    // This is likely an internal register for lldb use only and should not be
    // directly queried.
    error = Status::FromErrorStringWithFormat(
      "register \"%s\" is in unrecognized set",
      reg_info->name);
    return error;
  }

  RegSetKind set = opt_set.value();
  error = ReadRegisterSet(set);
  if (error.Fail())
    return error;

  switch (set) {
  case GPRegSet:
  case FPRegSet:
  case DBRegSet: {
    void *data = GetOffsetRegSetData(set, reg_info->byte_offset);
    FXSAVE *fpr = reinterpret_cast<FXSAVE *>(m_fpr.data());
    if (data == &fpr->ftag) // ftag
      fpr->ftag = FullToAbridgedTagWord(reg_value.GetAsUInt16());
    else
      ::memcpy(data, reg_value.GetBytes(), reg_value.GetByteSize());
    break;
  }
  case YMMRegSet: {
    std::optional<YMMSplitPtr> ymm_reg = GetYMMSplitReg(reg);
    if (!ymm_reg) {
      error = Status::FromErrorStringWithFormat(
          "register \"%s\" not supported by CPU/kernel", reg_info->name);
    } else {
      YMMReg ymm;
      ::memcpy(ymm.bytes, reg_value.GetBytes(), reg_value.GetByteSize());
      YMMToXState(ymm, ymm_reg->xmm, ymm_reg->ymm_hi);
    }
    break;
  }
  case MPXRegSet:
    llvm_unreachable("MPX regset should have returned error");
  }

  return WriteRegisterSet(set);
}

Status NativeRegisterContextDragonFly_x86_64::ReadAllRegisterValues(
    lldb::WritableDataBufferSP &data_sp) {
  Status error;

  data_sp.reset(new DataBufferHeap(REG_CONTEXT_SIZE, 0));
  error = ReadRegisterSet(GPRegSet);
  if (error.Fail())
    return error;

  uint8_t *dst = data_sp->GetBytes();
  ::memcpy(dst, m_gpr.data(), GetRegisterInfoInterface().GetGPRSize());
  dst += GetRegisterInfoInterface().GetGPRSize();

  return error;
}

Status NativeRegisterContextDragonFly_x86_64::WriteAllRegisterValues(
    const lldb::DataBufferSP &data_sp) {
  Status error;

  if (!data_sp) {
    error = Status::FromErrorStringWithFormat(
        "NativeRegisterContextDragonFly_x86_64::%s invalid data_sp provided",
        __FUNCTION__);
    return error;
  }

  if (data_sp->GetByteSize() != REG_CONTEXT_SIZE) {
    error = Status::FromErrorStringWithFormat(
        "NativeRegisterContextDragonFly_x86_64::%s data_sp contained mismatched "
        "data size, expected %zu, actual %" PRIu64,
        __FUNCTION__, REG_CONTEXT_SIZE, data_sp->GetByteSize());
    return error;
  }

  const uint8_t *src = data_sp->GetBytes();
  if (src == nullptr) {
    error = Status::FromErrorStringWithFormat(
      "NativeRegisterContextDragonFly_x86_64::%s DataBuffer::GetBytes() returned a null pointer",
      __FUNCTION__);
    return error;
  }
  ::memcpy(m_gpr.data(), src, GetRegisterInfoInterface().GetGPRSize());

  error = WriteRegisterSet(GPRegSet);
  if (error.Fail())
    return error;
  src += GetRegisterInfoInterface().GetGPRSize();

  return error;
}

llvm::Error NativeRegisterContextDragonFly_x86_64::CopyHardwareWatchpointsFrom(
    NativeRegisterContextDragonFly &source) {
  auto &r_source = static_cast<NativeRegisterContextDragonFly_x86_64 &>(source);
  // NB: This implicitly reads the whole dbreg set.
  RegisterValue dr7;
  Status res = r_source.ReadRegister(GetDR(7), dr7);
  if (!res.Fail()) {
    // copy dbregs only if any watchpoints were set
    if ((dr7.GetAsUInt64() & 0xFF) == 0)
      return llvm::Error::success();

    m_dbr = r_source.m_dbr;
    res = WriteRegisterSet(DBRegSet);
  }
  return res.ToError();
}

uint8_t *
NativeRegisterContextDragonFly_x86_64::GetOffsetRegSetData(RegSetKind set,
                                                         size_t reg_offset) {
  uint8_t *base;
  base = 0;
  switch (set) {
  case GPRegSet:
    base = m_gpr.data();
    break;
  case FPRegSet:
    base = m_fpr.data();
    break;
  case DBRegSet:
    base = m_dbr.data();
    break;
  case YMMRegSet:
    llvm_unreachable("GetRegSetData() is unsuitable for this regset.");
  case MPXRegSet:
    llvm_unreachable("MPX regset should have returned error");
  }
  assert(reg_offset >= m_regset_offsets[set]);
  return base + (reg_offset - m_regset_offsets[set]);
}

std::optional<NativeRegisterContextDragonFly_x86_64::YMMSplitPtr>
NativeRegisterContextDragonFly_x86_64::GetYMMSplitReg(uint32_t reg) {
  uint32_t offset = m_xsave_offsets[YMMRegSet];
  if (offset == LLDB_INVALID_XSAVE_OFFSET)
    return std::nullopt;

  uint32_t reg_index;
  reg_index = reg - lldb_ymm0_x86_64;

  auto *fpreg = reinterpret_cast<struct savexmm64 *>(m_xsave.data());
  auto *ymmreg = reinterpret_cast<struct ymmacc *>(m_xsave.data() + offset);

  return YMMSplitPtr{&fpreg->sv_xmm[reg_index], &ymmreg[reg_index]};
}

#endif // defined(__x86_64__)


[FILE:2949:files/NativeRegisterContextDragonFly_x86_64.h]
//===-- NativeRegisterContextDragonFly_x86_64.h -------------------*- C++ -*-===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//

#if defined(__x86_64__)

#ifndef lldb_NativeRegisterContextDragonFly_x86_64_h
#define lldb_NativeRegisterContextDragonFly_x86_64_h

// clang-format off
#include <sys/param.h>
#include <sys/ptrace.h>
#include <sys/types.h>
#include <machine/reg.h>
// clang-format on

#include <array>
#include <optional>

#include "Plugins/Process/DragonFly/NativeRegisterContextDragonFly.h"
#include "Plugins/Process/Utility/RegisterContext_x86.h"
#include "Plugins/Process/Utility/NativeRegisterContextDBReg_x86.h"
#include "Plugins/Process/Utility/lldb-x86-register-enums.h"

#define LLDB_INVALID_XSAVE_OFFSET UINT32_MAX

namespace lldb_private {
namespace process_dragonfly {

class NativeProcessDragonFly;

class NativeRegisterContextDragonFly_x86_64
    : public NativeRegisterContextDragonFly,
      public NativeRegisterContextDBReg_x86 {
public:
  NativeRegisterContextDragonFly_x86_64(const ArchSpec &target_arch,
                                      NativeThreadDragonFly &native_thread);
  uint32_t GetRegisterSetCount() const override;

  const RegisterSet *GetRegisterSet(uint32_t set_index) const override;

  Status ReadRegister(const RegisterInfo *reg_info,
                      RegisterValue &reg_value) override;

  Status WriteRegister(const RegisterInfo *reg_info,
                       const RegisterValue &reg_value) override;

  Status ReadAllRegisterValues(lldb::WritableDataBufferSP &data_sp) override;

  Status WriteAllRegisterValues(const lldb::DataBufferSP &data_sp) override;

  llvm::Error
  CopyHardwareWatchpointsFrom(NativeRegisterContextDragonFly &source) override;

private:
  // Private member types.
  enum RegSetKind {
    GPRegSet,
    FPRegSet,
    DBRegSet,
    YMMRegSet,
    MPXRegSet,
    MaxRegSet = MPXRegSet,
  };

  // Private member variables.
  std::array<uint8_t, sizeof(struct reg)> m_gpr;
  std::array<uint8_t, 512> m_fpr; // FXSAVE
  std::array<uint8_t, sizeof(struct dbreg)> m_dbr;
  std::vector<uint8_t> m_xsave;
  std::array<uint32_t, MaxRegSet + 1> m_xsave_offsets;
  std::array<size_t, MaxRegSet + 1> m_regset_offsets;

  std::optional<RegSetKind> GetSetForNativeRegNum(uint32_t reg_num) const;

  Status ReadRegisterSet(RegSetKind set);
  Status WriteRegisterSet(RegSetKind set);

  uint8_t *GetOffsetRegSetData(RegSetKind set, size_t reg_offset);

  struct YMMSplitPtr {
    void *xmm;
    void *ymm_hi;
  };
  std::optional<YMMSplitPtr> GetYMMSplitReg(uint32_t reg);
};

} // namespace process_dragonfly
} // namespace lldb_private

#endif // #ifndef lldb_NativeRegisterContextDragonFly_x86_64_h

#endif // defined(__x86_64__)


[FILE:10116:files/NativeThreadDragonFly.cpp]
//===-- NativeThreadDragonFly.cpp -------------------------------------------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//

#include "NativeThreadDragonFly.h"
#include "NativeRegisterContextDragonFly.h"

#include "NativeProcessDragonFly.h"

#include "Plugins/Process/POSIX/CrashReason.h"
#include "Plugins/Process/POSIX/ProcessPOSIXLog.h"
#include "lldb/Utility/LLDBAssert.h"
#include "lldb/Utility/RegisterValue.h"
#include "lldb/Utility/State.h"
#include "llvm/Support/Errno.h"

// clang-format off
#include <sys/types.h>
#include <sys/ptrace.h>
#include <sys/sysctl.h>
#include <sys/user.h>
// clang-format on

#include <sstream>
#include <vector>

using namespace lldb;
using namespace lldb_private;
using namespace lldb_private::process_dragonfly;

NativeThreadDragonFly::NativeThreadDragonFly(NativeProcessDragonFly &process,
                                         lldb::tid_t tid)
    : NativeThreadProtocol(process, tid), m_state(StateType::eStateInvalid),
      m_stop_info(),
      m_reg_context_up(
          NativeRegisterContextDragonFly::CreateHostNativeRegisterContextDragonFly(
              process.GetArchitecture(), *this)),
      m_stop_description() {}


Status NativeThreadDragonFly::Resume() {
    return Status::FromErrorString("thread resume not implemented");
/*
  Status ret = NativeProcessDragonFly::PtraceWrapper(PT_RESUME, GetID());
  if (!ret.Success())
    return ret;
  ret = NativeProcessDragonFly::PtraceWrapper(PT_CLEARSTEP, GetID());
  // we can get EINVAL if the architecture in question does not support
  // hardware single-stepping -- that's fine, we have nothing to clear
  // then
  if (ret.GetError() == EINVAL)
    ret.Clear();
  if (ret.Success())
    SetRunning();
  return ret;
*/
}

Status NativeThreadDragonFly::SingleStep() {
    return Status::FromErrorString("thread single-step not implemented");
/*
  Status ret = NativeProcessDragonFly::PtraceWrapper(PT_RESUME, GetID());
  if (!ret.Success())
    return ret;
  ret = NativeProcessDragonFly::PtraceWrapper(PT_SETSTEP, GetID());
  if (ret.Success())
    SetStepping();
  return ret;
*/
}

Status NativeThreadDragonFly::Suspend() {
    return Status::FromErrorString("thread suspend not implemented");
/*
  Status ret = NativeProcessDragonFly::PtraceWrapper(PT_SUSPEND, GetID());
  if (ret.Success())
    SetStopped();
  return ret;
*/
}


void NativeThreadDragonFly::SetStoppedBySignal(uint32_t signo,
                                             const siginfo_t *info) {
  Log *log = GetLog(POSIXLog::Thread);
  LLDB_LOG(log, "tid = {0} in called with signal {1}", GetID(), signo);

  SetStopped();

  m_stop_info.reason = StopReason::eStopReasonSignal;
  m_stop_info.signo = signo;

  m_stop_description.clear();
  if (info) {
    switch (signo) {
    case SIGSEGV:
    case SIGBUS:
    case SIGFPE:
    case SIGILL:
      m_stop_description = GetCrashReasonString(*info);
      break;
    }
  }
}

void NativeThreadDragonFly::SetStoppedByBreakpoint() {
  SetStopped();
  m_stop_info.reason = StopReason::eStopReasonBreakpoint;
  m_stop_info.signo = SIGTRAP;
}

void NativeThreadDragonFly::SetStoppedByTrace() {
  SetStopped();
  m_stop_info.reason = StopReason::eStopReasonTrace;
  m_stop_info.signo = SIGTRAP;
}

void NativeThreadDragonFly::SetStoppedByExec() {
  SetStopped();
  m_stop_info.reason = StopReason::eStopReasonExec;
  m_stop_info.signo = SIGTRAP;
}

void NativeThreadDragonFly::SetStoppedByWatchpoint(uint32_t wp_index) {
  lldbassert(wp_index != LLDB_INVALID_INDEX32 && "wp_index cannot be invalid");

  std::ostringstream ostr;
  ostr << GetRegisterContext().GetWatchpointAddress(wp_index) << " ";
  ostr << wp_index;

  ostr << " " << GetRegisterContext().GetWatchpointHitAddress(wp_index);

  SetStopped();
  m_stop_description = ostr.str();
  m_stop_info.reason = StopReason::eStopReasonWatchpoint;
  m_stop_info.signo = SIGTRAP;
}

void NativeThreadDragonFly::SetStoppedByFork(lldb::pid_t child_pid,
                                           lldb::tid_t child_tid) {
  SetStopped();

  m_stop_info.reason = StopReason::eStopReasonFork;
  m_stop_info.signo = SIGTRAP;
  m_stop_info.details.fork.child_pid = child_pid;
  m_stop_info.details.fork.child_tid = child_tid;
}

void NativeThreadDragonFly::SetStoppedByVFork(lldb::pid_t child_pid,
                                            lldb::tid_t child_tid) {
  SetStopped();

  m_stop_info.reason = StopReason::eStopReasonVFork;
  m_stop_info.signo = SIGTRAP;
  m_stop_info.details.fork.child_pid = child_pid;
  m_stop_info.details.fork.child_tid = child_tid;
}

void NativeThreadDragonFly::SetStoppedByVForkDone() {
  SetStopped();

  m_stop_info.reason = StopReason::eStopReasonVForkDone;
  m_stop_info.signo = SIGTRAP;
}

void NativeThreadDragonFly::SetStoppedWithNoReason() {
  SetStopped();

  m_stop_info.reason = StopReason::eStopReasonNone;
  m_stop_info.signo = 0;
}

void NativeThreadDragonFly::SetStopped() {
  const StateType new_state = StateType::eStateStopped;
  m_state = new_state;
  m_stop_description.clear();
}

void NativeThreadDragonFly::SetRunning() {
  m_state = StateType::eStateRunning;
  m_stop_info.reason = StopReason::eStopReasonNone;
}

void NativeThreadDragonFly::SetStepping() {
  m_state = StateType::eStateStepping;
  m_stop_info.reason = StopReason::eStopReasonNone;
}

std::string NativeThreadDragonFly::GetName() {
  Log *log = GetLog(POSIXLog::Thread);

  std::vector<struct kinfo_proc> kp;
  int mib[4] = {CTL_KERN, KERN_PROC, KERN_PROC_PID,
                static_cast<int>(GetProcess().GetID())};

  while (1) {
    size_t len = kp.size() * sizeof(struct kinfo_proc);
    void *ptr = len == 0 ? nullptr : kp.data();
    int error = ::sysctl(mib, 4, ptr, &len, nullptr, 0);
    if (ptr == nullptr || (error != 0 && errno == ENOMEM)) {
      kp.resize(len / sizeof(struct kinfo_proc));
      continue;
    }
    if (error != 0) {
      len = 0;
      LLDB_LOG(log, "tid = {0} in state {1} failed to get thread name: {2}",
               GetID(), m_state, strerror(errno));
    }
    kp.resize(len / sizeof(struct kinfo_proc));
    break;
  }

  for (auto &procinfo : kp) {
    if (procinfo.kp_lwp.kl_tid == static_cast<lwpid_t>(GetID()))
      return procinfo.kp_lwp.kl_comm;
  }

  return "";
}

lldb::StateType NativeThreadDragonFly::GetState() { return m_state; }

bool NativeThreadDragonFly::GetStopReason(ThreadStopInfo &stop_info,
                                        std::string &description) {
  Log *log = GetLog(POSIXLog::Thread);
  description.clear();

  switch (m_state) {
  case eStateStopped:
  case eStateCrashed:
  case eStateExited:
  case eStateSuspended:
  case eStateUnloaded:
    stop_info = m_stop_info;
    description = m_stop_description;

    return true;

  case eStateInvalid:
  case eStateConnected:
  case eStateAttaching:
  case eStateLaunching:
  case eStateRunning:
  case eStateStepping:
  case eStateDetached:
    LLDB_LOG(log, "tid = {0} in state {1} cannot answer stop reason", GetID(),
             StateAsCString(m_state));
    return false;
  }
  llvm_unreachable("unhandled StateType!");
}

NativeRegisterContextDragonFly &NativeThreadDragonFly::GetRegisterContext() {
  assert(m_reg_context_up);
  return *m_reg_context_up;
}

Status NativeThreadDragonFly::SetWatchpoint(lldb::addr_t addr, size_t size,
                                          uint32_t watch_flags, bool hardware) {
  assert(m_state == eStateStopped);
  if (!hardware)
    return Status::FromErrorString("not implemented");
  Status error = RemoveWatchpoint(addr);
  if (error.Fail())
    return error;
  uint32_t wp_index =
      GetRegisterContext().SetHardwareWatchpoint(addr, size, watch_flags);
  if (wp_index == LLDB_INVALID_INDEX32)
    return Status::FromErrorString("Setting hardware watchpoint failed.");
  m_watchpoint_index_map.insert({addr, wp_index});
  return Status();
}

Status NativeThreadDragonFly::RemoveWatchpoint(lldb::addr_t addr) {
  auto wp = m_watchpoint_index_map.find(addr);
  if (wp == m_watchpoint_index_map.end())
    return Status();
  uint32_t wp_index = wp->second;
  m_watchpoint_index_map.erase(wp);
  if (GetRegisterContext().ClearHardwareWatchpoint(wp_index))
    return Status();
  return Status::FromErrorString("Clearing hardware watchpoint failed.");
}

Status NativeThreadDragonFly::SetHardwareBreakpoint(lldb::addr_t addr,
                                                  size_t size) {
  assert(m_state == eStateStopped);
  Status error = RemoveHardwareBreakpoint(addr);
  if (error.Fail())
    return error;

  uint32_t bp_index = GetRegisterContext().SetHardwareBreakpoint(addr, size);

  if (bp_index == LLDB_INVALID_INDEX32)
    return Status::FromErrorString("Setting hardware breakpoint failed.");

  m_hw_break_index_map.insert({addr, bp_index});
  return Status();
}

Status NativeThreadDragonFly::RemoveHardwareBreakpoint(lldb::addr_t addr) {
  auto bp = m_hw_break_index_map.find(addr);
  if (bp == m_hw_break_index_map.end())
    return Status();

  uint32_t bp_index = bp->second;
  if (GetRegisterContext().ClearHardwareBreakpoint(bp_index)) {
    m_hw_break_index_map.erase(bp);
    return Status();
  }

  return Status::FromErrorString("Clearing hardware breakpoint failed.");
}

llvm::Error
NativeThreadDragonFly::CopyWatchpointsFrom(NativeThreadDragonFly &source) {
  llvm::Error s = GetRegisterContext().CopyHardwareWatchpointsFrom(
      source.GetRegisterContext());
  if (!s) {
    m_watchpoint_index_map = source.m_watchpoint_index_map;
    m_hw_break_index_map = source.m_hw_break_index_map;
  }
  return s;
}

NativeProcessDragonFly &NativeThreadDragonFly::GetProcess() {
  return static_cast<NativeProcessDragonFly &>(m_process);
}

llvm::Expected<std::unique_ptr<llvm::MemoryBuffer>>
NativeThreadDragonFly::GetSiginfo() const {
   return llvm::createStringError(llvm::inconvertibleErrorCode(),
                                   "GetSiginfo not supported");
}


[FILE:2814:files/NativeThreadDragonFly.h]
//===-- NativeThreadDragonFly.h --------------------------------- -*- C++ -*-===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//

#ifndef liblldb_NativeThreadDragonFly_H_
#define liblldb_NativeThreadDragonFly_H_

#include "lldb/Host/common/NativeThreadProtocol.h"

#include "Plugins/Process/DragonFly/NativeRegisterContextDragonFly.h"

#include <csignal>
#include <map>
#include <string>

namespace lldb_private {
namespace process_dragonfly {

class NativeProcessDragonFly;

class NativeThreadDragonFly : public NativeThreadProtocol {
  friend class NativeProcessDragonFly;

public:
  NativeThreadDragonFly(NativeProcessDragonFly &process, lldb::tid_t tid);

  // NativeThreadProtocol Interface
  std::string GetName() override;

  lldb::StateType GetState() override;

  bool GetStopReason(ThreadStopInfo &stop_info,
                     std::string &description) override;

  NativeRegisterContextDragonFly &GetRegisterContext() override;

  Status SetWatchpoint(lldb::addr_t addr, size_t size, uint32_t watch_flags,
                       bool hardware) override;

  Status RemoveWatchpoint(lldb::addr_t addr) override;

  Status SetHardwareBreakpoint(lldb::addr_t addr, size_t size) override;

  Status RemoveHardwareBreakpoint(lldb::addr_t addr) override;

  NativeProcessDragonFly &GetProcess();

  llvm::Expected<std::unique_ptr<llvm::MemoryBuffer>>
  GetSiginfo() const override;

private:
  // Interface for friend classes

  Status Resume();
  Status SingleStep();
  Status Suspend();

  void SetStoppedBySignal(uint32_t signo, const siginfo_t *info = nullptr);
  void SetStoppedByBreakpoint();
  void SetStoppedByTrace();
  void SetStoppedByExec();
  void SetStoppedByWatchpoint(uint32_t wp_index);
  void SetStoppedByFork(lldb::pid_t child_pid, lldb::tid_t child_tid);
  void SetStoppedByVFork(lldb::pid_t child_pid, lldb::tid_t child_tid);
  void SetStoppedByVForkDone();
  void SetStoppedWithNoReason();
  void SetStopped();
  void SetRunning();
  void SetStepping();

  llvm::Error CopyWatchpointsFrom(NativeThreadDragonFly &source);

  // Member Variables
  lldb::StateType m_state;
  ThreadStopInfo m_stop_info;
  std::unique_ptr<NativeRegisterContextDragonFly> m_reg_context_up;
  std::string m_stop_description;
  using WatchpointIndexMap = std::map<lldb::addr_t, uint32_t>;
  WatchpointIndexMap m_watchpoint_index_map;
  WatchpointIndexMap m_hw_break_index_map;
};

typedef std::shared_ptr<NativeThreadDragonFly> NativeThreadDragonFlySP;
} // namespace process_dragonfly
} // namespace lldb_private

#endif // #ifndef liblldb_NativeThreadDragonFly_H_


[FILE:969:files/df_support_notes.txt]
Ptrace functionality needed for DragonFly's lldb support
========================================================

PT_LWPINFO        (Kernel thread info)  
                  - equivalent of ptrace_lwpinfo + Flags 
                  - (NetBSD's rough equivalent is PT_GET_SIGINFO)
PT_GETNUMLWPS     (Kthreads of process)
PT_GETLWPLIST     (current thread list)
PT_GETXMMREGS     (copy XMM FPU state)
PT_SETXMMREGS     (load XMM FPU state)
PT_GETXSTATE      (content of thread XSAVE)
PT_SETXSTATE      (Load thread XSAVE state)
PT_GETXSTATE_INFO (XSAVE FPU extensions info)

PT_GET_EVENT_MASK
PT_SET_EVENT_MASK
PTRACE_LWP        (event flag)
PTRACE_FORK       (event flag)
PTRACE_VFORK      (event flag)

PT_SUSPEND        (suspend the specified thread)
PT_RESUME         (resume the specified thread)
PT_SETSTEP        (turn on single stepping of process)
PT_CLEARSTEP      (turn off single stepping of process)

OPTIONAL:
=========
PT_COREDUMP (for savecore extension)

