# Buildsheet autogenerated by ravenadm tool -- Do not edit.

NAMEBASE=		mesa
VERSION=		19.2.6
KEYWORDS=		graphics
VARIANTS=		standard
SDESC[standard]=	Mesa 3D Graphics Library
HOMEPAGE=		https://www.mesa3d.org/
CONTACT=		nobody

DOWNLOAD_GROUPS=	main
SITES[main]=		https://mesa.freedesktop.org/archive/
			ftp://ftp.freedesktop.org/pub/mesa/
DISTFILE[1]=		mesa-19.2.6.tar.xz:main
DF_INDEX=		1
SPKGS[standard]=	complete
			libs
			drivers

OPTIONS_AVAILABLE=	X86_DRIVERS ARM_DRIVERS LLVMPIPE WAYLAND
OPTIONS_STANDARD=	X86_DRIVERS ARM_DRIVERS LLVMPIPE
OPT_ON[freebsd]=	LLVMPIPE//i386|x86_64
OPT_ON[aarch64]=	ARM_DRIVERS
OPT_ON[linux]=		LLVMPIPE//i386|x86_64
OPT_ON[x86_64]=		X86_DRIVERS
OPT_ON[dragonfly]=	LLVMPIPE//i386|x86_64
OPT_ON[i386]=		X86_DRIVERS

BUILD_DEPENDS=		autoselect-python:single:standard
			python-Mako:single:python_used
			libpthread-stubs:single:standard
			zlib:static:standard
			libelf:single:standard
			libvdpau:single:standard
			libva:single:standard
			expat:static:standard
BUILDRUN_DEPENDS=	expat:shared:standard
			zlib:shared:standard
			libdrm:single:standard
EXRUN[drivers]=		mesa:libs:standard
			libelf:single:standard

USES=			bison gettext-tools gmake meson pkgconfig
			python:build shebangfix solaris-funcs
			c++:libs,drivers
XORG_COMPONENTS=	x11 xdamage xext xfixes xshmfence xxf86vm xv xrandr
			xcb

LICENSE=		MIT:libs CUSTOM1:libs CUSTOM2:libs
LICENSE_NAME=		CUSTOM1:"Kronos License (MIT with modifications)"
			CUSTOM2:"SGI Free Software License B"
LICENSE_FILE=		MIT:{{WRKDIR}}/LICENSE_MIT
			CUSTOM1:{{WRKDIR}}/LICENSE_KHRONOS
			CUSTOM2:{{WRKDIR}}/LICENSE_SGI
LICENSE_AWK=		MIT:"^$$"
			CUSTOM2:"^$$"
LICENSE_SOURCE=		MIT:{{WRKSRC}}/include/GL/gl.h
			CUSTOM2:{{WRKSRC}}/src/glx/eval.c
LICENSE_SCHEME=		multi

FPC_EQUIVALENT=		graphics/mesa-libs
MESON_ARGS=		-Dplatforms=x11,drm{{WAYPLAT}}
			-Ddri3=true
			-Ddri-drivers={{DRI_DRIVERS:tW:tl:C/[[:space:]]/,/g}}
			-Dgallium-drivers={{GALLIUM_DRIVERS:tW:tl:C/[[:space:]]/,/g}}
			-Dgallium-vdpau=true
			-Dosmesa=gallium
			-Dlibunwind=false
			-Dgles1=false
			-Dvulkan-drivers={{VULKAN_DRIVERS:tW:tl:C/[[:space:]]/,/g}}
SHEBANG_FILES=		src/gallium/*/*/*.py
			src/gallium/tools/trace/*.py
			src/gallium/drivers/svga/svgadump/svga_dump.py
			src/mapi/glapi/gen/*.py
			src/mapi/mapi_abi.py
			src/util/xmlpool/gen_xmlpool.py
			src/mesa/main/get_*.py
			src/util/format_srgb.py
			src/amd/*/*.py
			src/intel/genxml/gen_pack_header.py
SHEBANG_OLD_PYTHON=	/usr/bin/env[[:space:]]python2
			/usr/bin/python2
			/bin/env[[:space:]]python
SOL_FUNCTIONS=		dirfd:src/util/disk_cache.c
			asprintf:src/util/anon_file.c
			asprintf:src/mesa/drivers/dri/common/megadriver_stub.c
			asprintf:src/loader/loader.c
			asprintf:src/egl/main/eglcurrent.c
			asprintf:src/util/u_string.h
			strnlen:src/util/ralloc.c
			strnlen:src/mesa/main/errors.c
			strndup:src/util/xmlconfig.c
			strndup:src/loader/loader.c
			strndup:src/egl/drivers/dri2/platform_x11.c

INVALID_RPATH=		yes
CONFIGURE_ENV=		ax_cv_check_cflags___Wno_initializer_overrides=no

INSTALL_TARGET=		install-strip
INSTALL_REQ_TOOLCHAIN=	yes

VAR_OPSYS[sunos]=	CPPFLAGS=-D__EXTENSIONS__=1
			CPPFLAGS=-Wno-unused-function
			CXXFLAGS=-Drestrict=__restrict__
			CFLAGS=-D_POSIX_PTHREAD_SEMANTICS
			CFLAGS=-DF_DUPFD_CLOEXEC=F_DUPFD
			LDFLAGS=-lsocket
			LDFLAGS=-lnsl

[ARM_DRIVERS].DESCRIPTION=		Build drivers for aarch64 architecture
[ARM_DRIVERS].MAKEFILE_ON=		GALLIUM_DRIVERS+=FREEDRENO
					GALLIUM_DRIVERS+=VC4

[X86_DRIVERS].DESCRIPTION=		Build drivers for i386 and x86_64 architectures
[X86_DRIVERS].MAKEFILE_ON=		DRI_DRIVERS+=R100
					DRI_DRIVERS+=R200
					DRI_DRIVERS+=I915
					DRI_DRIVERS+=I965
					GALLIUM_DRIVERS+=R300
					GALLIUM_DRIVERS+=SVGA
					GALLIUM_DRIVERS+={{GALLIUM_LLVM_DRIVERS}}
					VULKAN_DRIVERS+={{VULKAN_DRIVERS_X86}}

[WAYLAND].DESCRIPTION=			Build Vulkan drivers for Wayland platform
[WAYLAND].BUILDRUN_DEPENDS_ON=		wayland:primary:standard
[WAYLAND].BUILD_DEPENDS_ON=		wayland-protocols:single:standard
					python-Mako:single:python_default
[WAYLAND].MAKEFILE_ON=			WAYPLAT=,surfaceless,wayland
					VULKAN_DRIVERS+=INTEL
					VULKAN_DRIVERS_X86+=RADEON

[LLVMPIPE].DESCRIPTION=			Build LLVM-based drivers and libraries
[LLVMPIPE].BUILDRUN_DEPENDS_ON=		llvm:single:standard
					opencl:single:standard
					ocl-icd:primary:standard
[LLVMPIPE].BUILD_DEPENDS_ON=		libclc:single:standard
					clang:compiler:standard
[LLVMPIPE].MAKEFILE_OFF=		MESON_ARGS+=-Dgallium-opencl=disabled
[LLVMPIPE].MAKEFILE_ON=			GALLIUM_LLVM_DRIVERS+=R600
					GALLIUM_LLVM_DRIVERS+=RADEONSI
					MESON_ARGS+=-Dllvm=true
					MESON_ARGS+=-Dgallium-xvmc=true
					MESON_ARGS+=-Dgallium-va=true
					MESON_ARGS+=-Dgallium-opencl=icd
[LLVMPIPE].XORG_COMPONENTS_ON=		xvmc

post-patch:
	${REINPLACE_CMD} -e 's|/etc/|${PREFIX}/etc/|g' \
		${WRKSRC}/src/util/xmlconfig.c

post-extract:
	${AWK} '/Copyright/,/DEALINGS/' ${WRKSRC}/include/GL/glext.h \
		> ${WRKDIR}/LICENSE_KHRONOS

[FILE:1198:descriptions/desc.libs]
The Mesa project began as an open-source implementation of the OpenGL
specification - a system for rendering interactive 3D graphics.

Over the years the project has grown to implement more graphics APIs,
including OpenGL ES (versions 1, 2, 3), OpenCL, OpenMAX, VDPAU, VA API,
XvMC and Vulkan.

A variety of device drivers allows the Mesa libraries to be used in many
different environments ranging from software emulation to complete
hardware acceleration for modern GPUs.

Mesa ties into several other open-source projects: the Direct Rendering
Infrastructure and X.org to provide OpenGL support on Linux, FreeBSD
and other operating systems.

This package contains the Mesa OpenGL libraries for GLX and EGL clients.
These include libOSMesa, libEGL, libGL, and libglesv2 as well as utility
libraries libglapi and gbm.  The OSMesa library is an Off-Screen version
of Mesa in order to do off-screen rendering in other packages like VTK.
Offscreen rendering is useful for a number of things, such as batch
processing, parallel processing, and remote processing.

This package also contains Mesa's libOpenCL implementation "Clover".  It is
built upon GALLIUM and currently only supports Radeon GPUs.


[FILE:162:descriptions/desc.drivers]
This package contains the Mesa OpenGL libraries for GLX and EGL clients.
These include libEGL, libGL, and libglesv2 as well as utlity libraries
libglapi and gbm.


[FILE:97:distinfo]
9d7b24fa60c82db34788196450042a55ce6cb2d70c7a8d5c31401619b6907797     11460244 mesa-19.2.6.tar.xz


[FILE:981:manifests/plist.libs]
%%LLVMPIPE-ON%%etc/OpenCL/vendors/mesa.icd
%%LLVMPIPE-ON%%lib/
 libMesaOpenCL.so
 libMesaOpenCL.so.1
 libMesaOpenCL.so.1.0.0
%%LLVMPIPE-ON%%lib/gallium-pipe/
 pipe_r300.so
 pipe_r600.so
 pipe_radeonsi.so
 pipe_swrast.so
 pipe_vmwgfx.so
include/
 gbm.h
 xa_composite.h
 xa_context.h
 xa_tracker.h
include/EGL/
 egl.h
 eglext.h
 eglextchromium.h
 eglmesaext.h
 eglplatform.h
include/GL/
 gl.h
 glcorearb.h
 glext.h
 glx.h
 glxext.h
 osmesa.h
include/GLES2/
 gl2.h
 gl2ext.h
 gl2platform.h
include/GLES3/
 gl3.h
 gl31.h
 gl32.h
 gl3ext.h
 gl3platform.h
include/KHR/khrplatform.h
lib/
 libEGL.so
 libEGL.so.1
 libEGL.so.1.0.0
 libGL.so
 libGL.so.1
 libGL.so.1.2.0
 libGLESv2.so
 libGLESv2.so.2
 libGLESv2.so.2.0.0
 libOSMesa.so
 libOSMesa.so.8
 libOSMesa.so.8.0.0
 libgbm.so
 libgbm.so.1
 libgbm.so.1.0.0
 libglapi.so
 libglapi.so.0
 libglapi.so.0.0.0
 libxatracker.so
 libxatracker.so.2
 libxatracker.so.2.5.0
lib/pkgconfig/
 egl.pc
 gbm.pc
 gl.pc
 glesv2.pc
 osmesa.pc
 xatracker.pc


[FILE:762:manifests/plist.drivers]
%%ARM_DRIVERS-ON%%lib/dri/
 kgsl_dri.so
 msm_dri.so
 vc4_dri.so
%%LLVMPIPE-ON%%lib/libXvMCr600.so
%%LLVMPIPE-ON%%lib/dri/
 r600_dri.so
 r600_drv_video.so
 radeonsi_dri.so
 radeonsi_drv_video.so
%%LLVMPIPE-ON%%lib/vdpau/
 libvdpau_r600.so
 libvdpau_r600.so.1
 libvdpau_r600.so.1.0
 libvdpau_r600.so.1.0.0
 libvdpau_radeonsi.so
 libvdpau_radeonsi.so.1
 libvdpau_radeonsi.so.1.0
 libvdpau_radeonsi.so.1.0.0
%%X86_DRIVERS-ON%%lib/dri/
 i915_dri.so
 i965_dri.so
 r200_dri.so
 r300_dri.so
 radeon_dri.so
 vmwgfx_dri.so
%%X86_DRIVERS-ON%%lib/vdpau/
 libvdpau_r300.so
 libvdpau_r300.so.1
 libvdpau_r300.so.1.0
 libvdpau_r300.so.1.0.0
include/GL/internal/dri_interface.h
lib/dri/
 kms_swrast_dri.so
 swrast_dri.so
lib/pkgconfig/dri.pc
share/drirc.d/00-mesa-defaults.conf


[FILE:511:patches/patch-include_GL_internal_dri__interface.h]
GCC on 9.x doesn't allow types to be overwritten, these types are defined
in drm.h also, which causes build issues in xorg-server.

--- include/GL/internal/dri_interface.h.orig	2019-11-22 00:06:57 UTC
+++ include/GL/internal/dri_interface.h
@@ -40,13 +40,7 @@
 #ifndef DRI_INTERFACE_H
 #define DRI_INTERFACE_H
 
-#ifdef HAVE_LIBDRM
 #include <drm.h>
-#else
-typedef unsigned int drm_context_t;
-typedef unsigned int drm_drawable_t;
-typedef struct drm_clip_rect drm_clip_rect_t;
-#endif
 
 #include <GL/gl.h>
 


[FILE:629:patches/patch-src_amd_common_ac__debug.c]
--- src/amd/common/ac_debug.c.orig	2019-11-22 00:06:57 UTC
+++ src/amd/common/ac_debug.c
@@ -573,6 +573,10 @@ void ac_parse_ib_chunk(FILE *f, uint32_t
 		       unsigned trace_id_count, enum chip_class chip_class,
                        ac_debug_addr_callback addr_callback, void *addr_callback_data)
 {
+#ifdef __sun__
+	printf("\nac_parse_ib_chunk: open_memstream unsupported on solaris");
+	exit (1);
+#else
 	struct ac_ib_parser ib = {};
 	ib.ib = ib_ptr;
 	ib.num_dw = num_dw;
@@ -598,6 +602,7 @@ void ac_parse_ib_chunk(FILE *f, uint32_t
 		printf("\nPacket ends after the end of IB.\n");
 		exit(1);
 	}
+#endif
 }
 
 /**


[FILE:485:patches/patch-src_amd_vulkan_radv__device.c]
- Define CLOCK_MONOTONIC_RAW if missing

--- src/amd/vulkan/radv_device.c.orig	2019-11-22 00:06:57 UTC
+++ src/amd/vulkan/radv_device.c
@@ -49,6 +49,14 @@
 #include "compiler/glsl_types.h"
 #include "util/xmlpool.h"
 
+#ifndef CLOCK_MONOTONIC_RAW
+# ifdef CLOCK_MONOTONIC_FAST
+#  define CLOCK_MONOTONIC_RAW CLOCK_MONOTONIC_FAST
+# else
+#  define CLOCK_MONOTONIC_RAW CLOCK_MONOTONIC
+# endif
+#endif
+
 static int
 radv_device_get_cache_uuid(enum radeon_family family, void *uuid)
 {


[FILE:321:patches/patch-src_amd_vulkan_winsys_amdgpu_radv__amdgpu__cs.c]
- Define ETIME if missing

--- src/amd/vulkan/winsys/amdgpu/radv_amdgpu_cs.c.orig	2019-11-22 00:06:57 UTC
+++ src/amd/vulkan/winsys/amdgpu/radv_amdgpu_cs.c
@@ -35,6 +35,9 @@
 #include "radv_amdgpu_bo.h"
 #include "sid.h"
 
+#ifndef ETIME
+#define ETIME ETIMEDOUT
+#endif
 
 enum {
 	VIRTUAL_BUFFER_HASH_TABLE_SIZE = 1024


[FILE:784:patches/patch-src_compiler_glsl_linker.cpp]
--- src/compiler/glsl/linker.cpp.orig	2019-11-22 00:06:57 UTC
+++ src/compiler/glsl/linker.cpp
@@ -91,6 +91,38 @@
 #include "main/enums.h"
 #include "main/mtypes.h"
 
+#ifdef __sun__
+/* uses libbsd4sol prototypes, so can't be static */
+#include <stdlib.h>
+#include <stdint.h>
+#include <string.h>
+
+size_t
+strnlen(const char *s, size_t maxlen)
+{
+	size_t len;
+	for (len = 0; len < maxlen; len++, s++) {
+		if (!*s) break;
+	}
+	return (len);
+}
+
+char *
+strndup(const char *str, size_t n)
+{
+    size_t len;
+    char *copy;
+
+    len = strlen(str);
+    if (len <= n)
+        return strdup(str);
+    if ((copy = (char *)malloc(len + 1)) == NULL)
+        return (NULL);
+    memcpy(copy, str, len);
+    copy[len] = '\0';
+    return (copy);
+}
+#endif
 
 namespace {
 


[FILE:586:patches/patch-src_egl_drivers_dri2_platform__x11.c]
# work-around for https://bugs.freedesktop.org/show_bug.cgi?id=100627
#
--- src/egl/drivers/dri2/platform_x11.c.orig	2019-11-22 00:06:57 UTC
+++ src/egl/drivers/dri2/platform_x11.c
@@ -1539,6 +1539,9 @@ dri2_initialize_x11(_EGLDriver *drv, _EG
 
    if (!disp->Options.ForceSoftware) {
 #ifdef HAVE_DRI3
+#if (defined(__FreeBSD__) || defined(__FreeBSD_kernel__)) && !defined(__DRM_NEXT__)
+      if (env_var_as_boolean("LIBGL_DRI3_ENABLE", false))
+#endif
       if (!env_var_as_boolean("LIBGL_DRI3_DISABLE", false))
          initialized = dri2_initialize_x11_dri3(drv, disp);
 #endif


[FILE:3256:patches/patch-src_gallium_auxiliary_pipe-loader_pipe__loader__drm.c]
Revert the following commit.

FreeBSD and DragonFly don't have the required render nodes.

-------

From 69a1b9959e59653da262185c4e2cf57d24939b19 Mon Sep 17 00:00:00 2001
From: Emil Velikov <emil.l.velikov@gmail.com>
Date: Mon, 29 Jun 2015 12:36:45 +0100
Subject: pipe-loader: drop support for non-render node devices

Render nodes have been around for quite some time. Removing support via
the master/primary node allows us to clean up the conditional
compilation and simplify the build greatly.

For example currently we the pipe-loader, which explicitly links against
xcb and friends (for X auth) if found at compile-time. That
would cause problems as one will be forced to use X/xcb, even if it's a
headless system that is used for opencl.

v2: Clarify the linking topic in the commit message.

Cc: Tom Stellard <thomas.stellard@amd.com>
Signed-off-by: Emil Velikov <emil.l.velikov@gmail.com>
Reviewed-by: Francisco Jerez <currojerez@riseup.net>


--- src/gallium/auxiliary/pipe-loader/pipe_loader_drm.c.orig	2019-11-22 00:06:57 UTC
+++ src/gallium/auxiliary/pipe-loader/pipe_loader_drm.c
@@ -241,6 +241,14 @@ pipe_loader_drm_probe_fd(struct pipe_loa
 }
 
 static int
+open_drm_minor(int minor)
+{
+   char path[PATH_MAX];
+   snprintf(path, sizeof(path), DRM_DEV_NAME, DRM_DIR_NAME, minor);
+   return open(path, O_RDWR, 0);
+}
+
+static int
 open_drm_render_node_minor(int minor)
 {
    char path[PATH_MAX];
@@ -252,8 +260,15 @@ open_drm_render_node_minor(int minor)
 int
 pipe_loader_drm_probe(struct pipe_loader_device **devs, int ndev)
 {
-   int i, j, fd;
+   int i, k, fd, num_render_node_devs;
+   int j = 0;
+
+   struct {
+      unsigned vendor_id;
+      unsigned chip_id;
+   } render_node_devs[DRM_RENDER_NODE_MAX_NODES];
 
+   /* Look for render nodes first */
    for (i = DRM_RENDER_NODE_MIN_MINOR, j = 0;
         i <= DRM_RENDER_NODE_MAX_MINOR; i++) {
       struct pipe_loader_device *dev;
@@ -267,6 +282,9 @@ pipe_loader_drm_probe(struct pipe_loader
          continue;
       }
 
+      render_node_devs[j].vendor_id = dev->u.pci.vendor_id;
+      render_node_devs[j].chip_id = dev->u.pci.chip_id;
+
       if (j < ndev) {
          devs[j] = dev;
       } else {
@@ -276,6 +294,46 @@ pipe_loader_drm_probe(struct pipe_loader
       j++;
    }
 
+   num_render_node_devs = j;
+
+   /* Next look for drm devices. */
+   for (i = 0; i < DRM_MAX_MINOR; i++) {
+      struct pipe_loader_device *dev;
+      boolean duplicate = FALSE;
+      fd = open_drm_minor(i);
+      if (fd < 0)
+         continue;
+
+      if (!pipe_loader_drm_probe_fd(&dev, fd)) {
+         close(fd);
+         continue;
+      }
+
+      /* Check to make sure we aren't already accessing this device via
+       * render nodes.
+       */
+      for (k = 0; k < num_render_node_devs; k++) {
+         if (dev->u.pci.vendor_id == render_node_devs[k].vendor_id &&
+             dev->u.pci.chip_id == render_node_devs[k].chip_id) {
+            close(fd);
+            dev->ops->release(&dev);
+            duplicate = TRUE;
+            break;
+         }
+      }
+
+      if (duplicate)
+         continue;
+
+      if (j < ndev) {
+         devs[j] = dev;
+      } else {
+         dev->ops->release(&dev);
+      }
+
+      j++;
+   }
+
    return j;
 }
 


[FILE:271:patches/patch-src_gallium_auxiliary_rbug_rbug__texture.c]
--- src/gallium/auxiliary/rbug/rbug_texture.c.orig	2019-11-22 00:06:57 UTC
+++ src/gallium/auxiliary/rbug/rbug_texture.c
@@ -36,6 +36,10 @@
 
 #include "c99_alloca.h"
 
+#ifdef __sun
+#include <alloca.h>
+#endif
+
 #include "rbug_internal.h"
 #include "rbug_texture.h"
 


[FILE:326:patches/patch-src_gallium_auxiliary_renderonly_renderonly.c]
--- src/gallium/auxiliary/renderonly/renderonly.c.orig	2019-11-22 00:06:57 UTC
+++ src/gallium/auxiliary/renderonly/renderonly.c
@@ -37,6 +37,10 @@
 #include "util/u_inlines.h"
 #include "util/u_memory.h"
 
+#ifndef O_CLOEXEC
+#define O_CLOEXEC	0
+#endif
+
 struct renderonly *
 renderonly_dup(const struct renderonly *ro)
 {


[FILE:6358:patches/patch-src_gallium_auxiliary_util_u__format__rgtc.c]
--- src/gallium/auxiliary/util/u_format_rgtc.c.orig	2019-11-22 00:06:57 UTC
+++ src/gallium/auxiliary/util/u_format_rgtc.c
@@ -175,13 +175,13 @@ util_format_rgtc1_snorm_pack_rgba_float(
    for(y = 0; y < height; y += bh) {
       int8_t *dst = (int8_t *)dst_row;
       for(x = 0; x < width; x += bw) {
-         int8_t tmp[4][4];  /* [bh][bw][comps] */
+         signed char tmp[4][4];  /* [bh][bw][comps] */
          for(j = 0; j < bh; ++j) {
             for(i = 0; i < bw; ++i) {
-	       tmp[j][i] = float_to_byte_tex(src_row[(y + j)*src_stride/sizeof(*src_row) + (x + i)*4]);
+	       tmp[j][i] = (signed char)float_to_byte_tex(src_row[(y + j)*src_stride/sizeof(*src_row) + (x + i)*4]);
             }
          }
-         util_format_signed_encode_rgtc_ubyte(dst, tmp, 4, 4);
+         util_format_signed_encode_rgtc_ubyte((signed char *)dst, tmp, 4, 4);
          dst += bytes_per_block;
       }
       dst_row += dst_stride / sizeof(*dst_row);
@@ -194,14 +194,14 @@ util_format_rgtc1_snorm_unpack_rgba_floa
    unsigned x, y, i, j;
    int block_size = 8;
    for(y = 0; y < height; y += 4) {
-      const int8_t *src = (int8_t *)src_row;
+      const signed char *src = (signed char *)src_row;
       for(x = 0; x < width; x += 4) {
          for(j = 0; j < 4; ++j) {
             for(i = 0; i < 4; ++i) {
                float *dst = dst_row + (y + j)*dst_stride/sizeof(*dst_row) + (x + i)*4;
-               int8_t tmp_r;
+               signed char tmp_r;
                util_format_signed_fetch_texel_rgtc(0, src, i, j, &tmp_r, 1);
-               dst[0] = byte_to_float_tex(tmp_r);
+               dst[0] = byte_to_float_tex((int8_t)tmp_r);
                dst[1] = 0.0;
                dst[2] = 0.0;
                dst[3] = 1.0;
@@ -216,9 +216,9 @@ util_format_rgtc1_snorm_unpack_rgba_floa
 void
 util_format_rgtc1_snorm_fetch_rgba_float(float *dst, const uint8_t *src, unsigned i, unsigned j)
 {
-   int8_t tmp_r;
-   util_format_signed_fetch_texel_rgtc(0, (int8_t *)src, i, j, &tmp_r, 1);
-   dst[0] = byte_to_float_tex(tmp_r);
+   signed char tmp_r;
+   util_format_signed_fetch_texel_rgtc(0, (signed char *)src, i, j, &tmp_r, 1);
+   dst[0] = byte_to_float_tex((int8_t)tmp_r);
    dst[1] = 0.0;
    dst[2] = 0.0;
    dst[3] = 1.0;
@@ -268,16 +268,16 @@ util_format_rgtc2_unorm_pack_rgba_8unorm
    for(y = 0; y < height; y += bh) {
       uint8_t *dst = dst_row;
       for(x = 0; x < width; x += bw) {
-         uint8_t tmp_r[4][4];  /* [bh][bw] */
-         uint8_t tmp_g[4][4];  /* [bh][bw] */
+         unsigned char tmp_r[4][4];  /* [bh][bw] */
+         unsigned char tmp_g[4][4];  /* [bh][bw] */
          for(j = 0; j < bh; ++j) {
             for(i = 0; i < bw; ++i) {
-	       tmp_r[j][i] = src_row[(y + j)*src_stride/sizeof(*src_row) + (x + i)*4];
-	       tmp_g[j][i] = src_row[((y + j)*src_stride/sizeof(*src_row) + (x + i)*4) + 1];
+	       tmp_r[j][i] = (unsigned char)src_row[(y + j)*src_stride/sizeof(*src_row) + (x + i)*4];
+	       tmp_g[j][i] = (unsigned char)src_row[((y + j)*src_stride/sizeof(*src_row) + (x + i)*4) + 1];
             }
          }
-         util_format_unsigned_encode_rgtc_ubyte(dst, tmp_r, 4, 4);
-         util_format_unsigned_encode_rgtc_ubyte(dst + 8, tmp_g, 4, 4);
+         util_format_unsigned_encode_rgtc_ubyte((unsigned char *)dst, tmp_r, 4, 4);
+         util_format_unsigned_encode_rgtc_ubyte((unsigned char *)(dst + 8), tmp_g, 4, 4);
          dst += bytes_per_block;
       }
       dst_row += dst_stride / sizeof(*dst_row);
@@ -383,16 +383,16 @@ util_format_rgtc2_snorm_unpack_rgba_floa
    unsigned x, y, i, j;
    int block_size = 16;
    for(y = 0; y < height; y += 4) {
-      const int8_t *src = (int8_t *)src_row;
+      const signed char *src = (signed char *)src_row;
       for(x = 0; x < width; x += 4) {
          for(j = 0; j < 4; ++j) {
             for(i = 0; i < 4; ++i) {
                float *dst = dst_row + (y + j)*dst_stride/sizeof(*dst_row) + (x + i)*4;
-               int8_t tmp_r, tmp_g;
+               signed char tmp_r, tmp_g;
                util_format_signed_fetch_texel_rgtc(0, src, i, j, &tmp_r, 2);
                util_format_signed_fetch_texel_rgtc(0, src + 8, i, j, &tmp_g, 2);
-               dst[0] = byte_to_float_tex(tmp_r);
-               dst[1] = byte_to_float_tex(tmp_g);
+               dst[0] = byte_to_float_tex((int8_t)tmp_r);
+               dst[1] = byte_to_float_tex((int8_t)tmp_g);
                dst[2] = 0.0;
                dst[3] = 1.0;
             }
@@ -410,14 +410,14 @@ util_format_rxtc2_snorm_pack_rgba_float(
    unsigned x, y, i, j;
 
    for(y = 0; y < height; y += bh) {
-      int8_t *dst = (int8_t *)dst_row;
+      signed char *dst = (signed char *)dst_row;
       for(x = 0; x < width; x += bw) {
-         int8_t tmp_r[4][4];  /* [bh][bw][comps] */
-         int8_t tmp_g[4][4];  /* [bh][bw][comps] */
+         signed char tmp_r[4][4];  /* [bh][bw][comps] */
+         signed char tmp_g[4][4];  /* [bh][bw][comps] */
          for(j = 0; j < bh; ++j) {
             for(i = 0; i < bw; ++i) {
-	       tmp_r[j][i] = float_to_byte_tex(src_row[(y + j)*src_stride/sizeof(*src_row) + (x + i)*4]);
-               tmp_g[j][i] = float_to_byte_tex(src_row[(y + j)*src_stride/sizeof(*src_row) + (x + i)*4 + chan2off]);
+	       tmp_r[j][i] = (signed char)float_to_byte_tex(src_row[(y + j)*src_stride/sizeof(*src_row) + (x + i)*4]);
+              tmp_g[j][i] = (signed char)float_to_byte_tex(src_row[(y + j)*src_stride/sizeof(*src_row) + (x + i)*4 + chan2off]);
             }
          }
          util_format_signed_encode_rgtc_ubyte(dst, tmp_r, 4, 4);
@@ -437,11 +437,11 @@ util_format_rgtc2_snorm_pack_rgba_float(
 void
 util_format_rgtc2_snorm_fetch_rgba_float(float *dst, const uint8_t *src, unsigned i, unsigned j)
 {
-   int8_t tmp_r, tmp_g;
-   util_format_signed_fetch_texel_rgtc(0, (int8_t *)src, i, j, &tmp_r, 2);
-   util_format_signed_fetch_texel_rgtc(0, (int8_t *)src + 8, i, j, &tmp_g, 2);
-   dst[0] = byte_to_float_tex(tmp_r);
-   dst[1] = byte_to_float_tex(tmp_g);
+   signed char tmp_r, tmp_g;
+   util_format_signed_fetch_texel_rgtc(0, (signed char *)src, i, j, &tmp_r, 2);
+   util_format_signed_fetch_texel_rgtc(0, (signed char *)src + 8, i, j, &tmp_g, 2);
+   dst[0] = byte_to_float_tex((int8_t)tmp_r);
+   dst[1] = byte_to_float_tex((int8_t)tmp_g);
    dst[2] = 0.0;
    dst[3] = 1.0;
 }


[FILE:338:patches/patch-src_gallium_drivers_radeonsi_si__shader.c]
--- src/gallium/drivers/radeonsi/si_shader.c.orig	2019-11-22 00:06:57 UTC
+++ src/gallium/drivers/radeonsi/si_shader.c
@@ -22,6 +22,10 @@
  * USE OR OTHER DEALINGS IN THE SOFTWARE.
  */
 
+#ifdef __sun__
+#include <alloca.h> /* for alloca */
+#endif
+
 #include "util/u_memory.h"
 #include "util/u_string.h"
 #include "tgsi/tgsi_build.h"


[FILE:511:patches/patch-src_gallium_drivers_radeonsi_si__state__shaders.c]
--- src/gallium/drivers/radeonsi/si_state_shaders.c.orig	2019-11-22 00:06:57 UTC
+++ src/gallium/drivers/radeonsi/si_state_shaders.c
@@ -2112,6 +2112,7 @@ static void si_build_shader_variant(stru
 		return;
 	}
 
+#ifndef __sun__
 	if (shader->compiler_ctx_state.is_debug_context) {
 		FILE *f = open_memstream(&shader->shader_log,
 					 &shader->shader_log_size);
@@ -2120,6 +2121,7 @@ static void si_build_shader_variant(stru
 			fclose(f);
 		}
 	}
+#endif
 
 	si_shader_init_pm4_state(sscreen, shader);
 }


[FILE:360:patches/patch-src_gallium_drivers_vc4_vc4__bufmgr.c]
# define ETIME as ETIMEOUT same as in intel driver
#
--- src/gallium/drivers/vc4/vc4_bufmgr.c.orig	2019-11-22 00:06:57 UTC
+++ src/gallium/drivers/vc4/vc4_bufmgr.c
@@ -27,6 +27,9 @@
 #include <fcntl.h>
 #include <xf86drm.h>
 #include <xf86drmMode.h>
+#ifndef ETIME
+#define ETIME ETIMEDOUT
+#endif
 
 #include "util/u_hash_table.h"
 #include "util/u_memory.h"


[FILE:1604:patches/patch-src_gallium_state__trackers_clover_llvm_invocation.cpp]
# fix errors like the following
#
# llvm/invocation.cpp:(.text+0x1275): undefined reference to `std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::c_str()
 const'
# /usr/bin/ld: ../../../../src/gallium/state_trackers/clover/.libs/libclover.a(libclllvm_la-invocation.o): relocation R_X86_64_PC32 against `_ZNKSt3__112bas
ic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE5c_strEv' can not be used when making a shared object; recompile with -fPIC
# /usr/bin/ld: final link failed: Bad value
#
--- src/gallium/state_trackers/clover/llvm/invocation.cpp.orig	2019-11-22 00:06:57 UTC
+++ src/gallium/state_trackers/clover/llvm/invocation.cpp
@@ -181,6 +181,8 @@ namespace {
       return get_lang_standard_from_version_str(device_version);
    }
 
+   const char* cstr(const std::string& str) { return str.c_str(); }
+
    std::unique_ptr<clang::CompilerInstance>
    create_compiler_instance(const device &dev,
                             const std::vector<std::string> &opts,
@@ -193,8 +195,8 @@ namespace {
       // Parse the compiler options.  A file name should be present at the end
       // and must have the .cl extension in order for the CompilerInvocation
       // class to recognize it as an OpenCL source file.
-      const std::vector<const char *> copts =
-         map(std::mem_fn(&std::string::c_str), opts);
+      std::vector<const char *> copts(opts.size());
+      std::transform(opts.begin(), opts.end(), copts.begin(), cstr);
 
       const target &target = dev.ir_target();
       const std::string &device_clc_version = dev.device_clc_version();


[FILE:635:patches/patch-src_gallium_state__trackers_clover_llvm_metadata.hpp]
# Fix error: no matching constructor for initialization of 'std::vector<const ::llvm::MDNode *>' 
#
--- src/gallium/state_trackers/clover/llvm/metadata.hpp.orig	2019-11-22 00:06:57 UTC
+++ src/gallium/state_trackers/clover/llvm/metadata.hpp
@@ -42,7 +42,7 @@ namespace clover {
          get_kernel_nodes(const ::llvm::Module &mod) {
             if (const ::llvm::NamedMDNode *n =
                    mod.getNamedMetadata("opencl.kernels"))
-               return { n->op_begin(), n->op_end() };
+               return { n->getOperand(0), n->getOperand(n->getNumOperands()) };
             else
                return {};
          }


[FILE:1150:patches/patch-src_gallium_state__trackers_clover_util_range.hpp]
From b95533b981af9a6687b41418e7cc2a5652fc2bdb Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Jean-S=C3=A9bastien=20P=C3=A9dron?= <dumbbell@FreeBSD.org>
Date: Fri, 7 Mar 2014 15:16:08 +0100
Subject: [PATCH 3/3] Work around for clang 3.4 which fails to build Clover

See:
  https://bugs.freedesktop.org/show_bug.cgi?id=74098#c3
--- src/gallium/state_trackers/clover/util/range.hpp.orig	2019-11-22 00:06:57 UTC
+++ src/gallium/state_trackers/clover/util/range.hpp
@@ -362,6 +362,12 @@ namespace clover {
       return { i, i + n };
    }
 
+   namespace detail {
+      template<typename T>
+      using fixup_function_type =
+         typename std::conditional<std::is_function<T>::value, T &, T>::type;
+   }
+
    ///
    /// Create a range by transforming the contents of a number of
    /// source ranges \a rs element-wise using a provided functor \a f.
@@ -369,7 +375,7 @@ namespace clover {
    /// \sa adaptor_range.
    ///
    template<typename F, typename... Rs>
-   adaptor_range<F, Rs...>
+   adaptor_range<detail::fixup_function_type<F>, Rs...>
    map(F &&f, Rs &&... rs) {
       return { std::forward<F>(f), std::forward<Rs>(rs)... };
    }


[FILE:816:patches/patch-src_gallium_targets_dri_meson.build]
--- src/gallium/targets/dri/meson.build.orig	2019-11-22 00:06:57 UTC
+++ src/gallium/targets/dri/meson.build
@@ -46,11 +46,12 @@ libgallium_dri = shared_library(
   ],
   c_args : [c_vis_args],
   cpp_args : [cpp_vis_args],
-  link_args : [ld_args_build_id, ld_args_gc_sections, gallium_dri_ld_args],
+  link_args : [ld_args_gc_sections, gallium_dri_ld_args],
   link_depends : gallium_dri_link_depends,
+  link_whole : [libdricommon, libgallium, libr300, libdri, libnir],
   link_with : [
-    libmesa_gallium, libdricommon, libmegadriver_stub, libdri, libgalliumvl,
-    libgallium, libglapi, libpipe_loader_static, libws_null, libwsw, libswdri,
+    libmesa_gallium, libmegadriver_stub, libgalliumvl,
+    libglapi, libpipe_loader_static, libws_null, libwsw, libswdri,
     libswkmsdri,
   ],
   dependencies : [


[FILE:572:patches/patch-src_gallium_targets_osmesa_meson.build]
--- src/gallium/targets/osmesa/meson.build.orig	2019-11-22 00:06:57 UTC
+++ src/gallium/targets/osmesa/meson.build
@@ -43,9 +43,9 @@ libosmesa = shared_library(
     inc_gallium_drivers,
   ],
   link_depends : osmesa_link_deps,
-  link_whole : [libosmesa_st, libglapi_static],
+  link_whole : [libosmesa_st, libglapi_static, libsoftpipe, libgallium, libnir],
   link_with : [
-    libmesa_gallium, libgallium, libws_null, osmesa_link_with,
+    libmesa_gallium, libws_null, osmesa_link_with,
   ],
   dependencies : [
     dep_selinux, dep_thread, dep_clock, dep_unwind,


[FILE:613:patches/patch-src_gallium_targets_vdpau_meson.build]
--- src/gallium/targets/vdpau/meson.build.orig	2019-11-22 00:06:57 UTC
+++ src/gallium/targets/vdpau/meson.build
@@ -45,10 +45,10 @@ libvdpau_gallium = shared_library(
   include_directories : [
     inc_common, inc_util, inc_gallium_winsys, inc_gallium_drivers,
   ],
-  link_whole : [libvdpau_st],
+  link_whole : [libvdpau_st, libr300, libradeonwinsys, libpipe_loader_static],
   link_with : [
     libgalliumvlwinsys, libgalliumvl, libgallium,
-    libpipe_loader_static, libws_null, libwsw, libswdri, libswkmsdri,
+    libws_null, libwsw, libswdri, libswkmsdri,
   ],
   dependencies : [
     idep_mesautil,


[FILE:558:patches/patch-src_gallium_targets_xa_meson.build]
--- src/gallium/targets/xa/meson.build.orig	2019-11-22 00:06:57 UTC
+++ src/gallium/targets/xa/meson.build
@@ -41,9 +41,9 @@ libxatracker = shared_library(
   include_directories : [
     inc_common, inc_util, inc_gallium_winsys, inc_gallium_drivers,
   ],
-  link_whole : [libxa_st],
+  link_whole : [libxa_st, libsvga, libsvgadrm, libpipe_loader_static],
   link_with : [
-    libgalliumvl_stub, libgallium, libpipe_loader_static,
+    libgalliumvl_stub, libgallium,
     libws_null, libwsw, libswdri, libswkmsdri,
   ],
   link_depends : xa_link_depends,


[FILE:324:patches/patch-src_gallium_winsys_amdgpu_drm_amdgpu__cs.c]
--- src/gallium/winsys/amdgpu/drm/amdgpu_cs.c.orig	2019-11-22 00:06:58 UTC
+++ src/gallium/winsys/amdgpu/drm/amdgpu_cs.c
@@ -33,6 +33,10 @@
 
 #include "amd/common/sid.h"
 
+#ifdef __sun__
+#include <alloca.h>
+#endif
+
 DEBUG_GET_ONCE_BOOL_OPTION(noop, "RADEON_NOOP", false)
 
 #ifndef AMDGPU_IB_FLAG_RESET_GDS_MAX_WAVE_ID


[FILE:426:patches/patch-src_gbm_meson.build]
--- src/gbm/meson.build.orig	2019-11-22 00:06:58 UTC
+++ src/gbm/meson.build
@@ -50,7 +50,7 @@ libgbm = shared_library(
   c_args : [c_vis_args, args_gbm],
   link_args : [ld_args_gc_sections],
   link_with : libloader,
-  dependencies : [deps_gbm, dep_dl, dep_thread, idep_mesautil, idep_xmlconfig],
+  dependencies : [deps_gbm, dep_dl, dep_thread, idep_xmlconfig, idep_mesautil],
   version : '1.0.0',
   install : true,
 )


[FILE:575:patches/patch-src_glx_glxext.c]
# work-around for https://bugs.freedesktop.org/show_bug.cgi?id=100627
#
--- src/glx/glxext.c.orig	2019-11-22 00:06:58 UTC
+++ src/glx/glxext.c
@@ -914,6 +914,9 @@ __glXInitialize(Display * dpy)
 #if defined(GLX_USE_DRM)
    if (glx_direct && glx_accel) {
 #if defined(HAVE_DRI3)
+#if (defined(__FreeBSD__) || defined(__FreeBSD_kernel__)) && !defined(__DRM_NEXT__)
+      if (env_var_as_boolean("LIBGL_DRI3_ENABLE", false))
+#endif
       if (!env_var_as_boolean("LIBGL_DRI3_DISABLE", false))
          dpyPriv->dri3Display = dri3_create_display(dpy);
 #endif /* HAVE_DRI3 */


[FILE:318:patches/patch-src_glx_meson.build]
--- src/glx/meson.build.orig	2019-11-22 00:06:58 UTC
+++ src/glx/meson.build
@@ -149,7 +149,7 @@ libglx = static_library(
     extra_libs_libglx,
   ],
   dependencies : [
-    idep_mesautil, idep_xmlconfig,
+    idep_xmlconfig, idep_mesautil,
     dep_libdrm, dep_dri2proto, dep_glproto, dep_x11, dep_glvnd,
   ],
 )


[FILE:995:patches/patch-src_intel_compiler_brw__eu__validate.c]
--- src/intel/compiler/brw_eu_validate.c.orig	2019-11-22 00:06:58 UTC
+++ src/intel/compiler/brw_eu_validate.c
@@ -40,6 +40,39 @@
 
 #include "brw_eu.h"
 
+#ifdef __sun__
+#include <string.h>
+
+static void *
+memmem(const void *l, size_t l_len, const void *s, size_t s_len)
+{
+	char *cur, *last;
+	const char *cl = (const char *)l;
+	const char *cs = (const char *)s;
+
+	/* we need something to compare */
+	if (l_len == 0 || s_len == 0)
+		return NULL;
+
+	/* "s" must be smaller or equal to "l" */
+	if (l_len < s_len)
+		return NULL;
+
+	/* special case where s_len == 1 */
+	if (s_len == 1)
+		return memchr(l, (int)*cs, l_len);
+
+	/* the last position where its possible to find "s" in "l" */
+	last = (char *)cl + l_len - s_len;
+
+	for (cur = (char *)cl; cur <= last; cur++)
+		if (cur[0] == cs[0] && memcmp(cur, cs, s_len) == 0)
+			return cur;
+
+	return NULL;
+}
+#endif
+
 /* We're going to do lots of string concatenation, so this should help. */
 struct string {
    char *str;


[FILE:954:patches/patch-src_intel_compiler_brw__fs__bank__conflicts.cpp]
--- src/intel/compiler/brw_fs_bank_conflicts.cpp.orig	2019-11-22 00:06:58 UTC
+++ src/intel/compiler/brw_fs_bank_conflicts.cpp
@@ -309,8 +309,13 @@ namespace {
          const unsigned align = MAX2(sizeof(void *), __alignof__(vector_type));
          const unsigned size = DIV_ROUND_UP(n, vector_width) * sizeof(vector_type);
          void *p;
+#ifdef __sun
+	p = memalign(align, size);
+	if (p == NULL) return NULL;
+#else
          if (posix_memalign(&p, align, size))
             return NULL;
+#endif
          memset(p, 0, size);
          return reinterpret_cast<vector_type *>(p);
       }
@@ -728,7 +733,7 @@ namespace {
                    const weight_vector_type &conflicts)
    {
       const unsigned m = DIV_ROUND_UP(conflicts.size, vector_width);
-      vector_type s_p = {}, s_n = {};
+      vector_type s_p = {0}, s_n = {0};
 
       for (unsigned r = 0; r < m; r++) {
          s_p = adds(s_p, mask(bank_mask_p.v[r], conflicts.v[r]));


[FILE:225:patches/patch-src_intel_isl_isl.h]
--- src/intel/isl/isl.h.orig	2019-11-22 00:06:58 UTC
+++ src/intel/isl/isl.h
@@ -46,6 +46,9 @@
 #include "util/macros.h"
 
 #ifdef __cplusplus
+# ifdef __sun__
+# define restrict	__restrict__
+# endif
 extern "C" {
 #endif
 


[FILE:1594:patches/patch-src_intel_perf_gen__perf.c]
$NetBSD: patch-src_intel_perf_gen__perf.c,v 1.1 2019/08/24 20:11:19 nia Exp $

SunOS does not have d_type in DIR structure.

--- src/intel/perf/gen_perf.c.orig	2019-11-22 00:06:58 UTC
+++ src/intel/perf/gen_perf.c
@@ -394,6 +394,9 @@ get_sysfs_dev_dir(struct gen_perf_config
    DIR *drmdir;
    struct dirent *drm_entry;
    int len;
+#ifdef __sun
+   struct stat s;
+#endif
 
    perf->sysfs_dev_dir[0] = '\0';
 
@@ -425,8 +428,14 @@ get_sysfs_dev_dir(struct gen_perf_config
    }
 
    while ((drm_entry = readdir(drmdir))) {
+#ifdef __sun
+      stat(drm_entry->d_name, &s);
+      if ((s.st_mode == S_IFDIR ||
+           s.st_mode == S_IFLNK) &&
+#else
       if ((drm_entry->d_type == DT_DIR ||
            drm_entry->d_type == DT_LNK) &&
+#endif
           strncmp(drm_entry->d_name, "card", 4) == 0)
       {
          len = snprintf(perf->sysfs_dev_dir,
@@ -527,6 +536,9 @@ enumerate_sysfs_metrics(struct gen_perf_
    struct dirent *metric_entry;
    char buf[256];
    int len;
+#ifdef __sun
+   struct stat s;
+#endif
 
    len = snprintf(buf, sizeof(buf), "%s/metrics", perf->sysfs_dev_dir);
    if (len < 0 || len >= sizeof(buf)) {
@@ -543,8 +555,14 @@ enumerate_sysfs_metrics(struct gen_perf_
    while ((metric_entry = readdir(metricsdir))) {
       struct hash_entry *entry;
 
+#ifdef __sun
+      stat(metric_entry->d_name, &s);
+      if ((s.st_mode != S_IFDIR &&
+           s.st_mode != S_IFLNK) ||
+#else
       if ((metric_entry->d_type != DT_DIR &&
            metric_entry->d_type != DT_LNK) ||
+#endif
           metric_entry->d_name[0] == '.')
          continue;
 


[FILE:302:patches/patch-src_intel_tools_aubinator__error__decode.c]
# expose getline in FreeBSD's stdio.h
#
--- src/intel/tools/aubinator_error_decode.c.orig	2019-11-22 00:06:58 UTC
+++ src/intel/tools/aubinator_error_decode.c
@@ -22,6 +22,9 @@
  *
  */
 
+#ifdef __FreeBSD__
+#define _WITH_GETLINE
+#endif
 #include <stdbool.h>
 #include <stdio.h>
 #include <stdlib.h>


[FILE:238:patches/patch-src_intel_tools_error2aub.c]
--- src/intel/tools/error2aub.c.orig	2019-11-22 00:06:58 UTC
+++ src/intel/tools/error2aub.c
@@ -22,6 +22,9 @@
  *
  */
 
+#ifdef __FreeBSD__
+#define _WITH_GETLINE
+#endif
 #include <assert.h>
 #include <getopt.h>
 #include <inttypes.h>


[FILE:1096:patches/patch-src_intel_vulkan_anv__device.c]
- Without sysinfo() fall back to sysconf()
- Define ETIME if missing

--- src/intel/vulkan/anv_device.c.orig	2019-11-22 00:06:58 UTC
+++ src/intel/vulkan/anv_device.c
@@ -25,7 +25,9 @@
 #include <stdbool.h>
 #include <string.h>
 #include <sys/mman.h>
+#ifdef __GLIBC__
 #include <sys/sysinfo.h>
+#endif
 #include <unistd.h>
 #include <fcntl.h>
 #include <xf86drm.h>
@@ -60,6 +62,10 @@ DRI_CONF_END;
  */
 #define MAX_DEBUG_MESSAGE_LENGTH    4096
 
+#ifndef ETIME
+#define ETIME ETIMEDOUT
+#endif
+
 static void
 compiler_debug_log(void *data, const char *fmt, ...)
 {
@@ -96,10 +102,15 @@ static uint64_t
 anv_compute_heap_size(int fd, uint64_t gtt_size)
 {
    /* Query the total ram from the system */
+#ifdef __GLIBC__
    struct sysinfo info;
    sysinfo(&info);
 
    uint64_t total_ram = (uint64_t)info.totalram * (uint64_t)info.mem_unit;
+#else
+   uint64_t total_ram = sysconf(_SC_PHYS_PAGES) * sysconf(_SC_PAGE_SIZE);
+#endif
+
 
    /* We don't want to burn too much ram with the GPU.  If the user has 4GiB
     * or less, we use at most half.  If they have more than 4GiB, we use 3/4.


[FILE:354:patches/patch-src_loader_loader.c]
$NetBSD: patch-src_loader_loader.c,v 1.5 2019/08/29 14:12:57 nia Exp $

Include limits.h for PATH_MAX.

--- src/loader/loader.c.orig	2019-11-22 00:06:58 UTC
+++ src/loader/loader.c
@@ -36,6 +36,7 @@
 #include <string.h>
 #include <unistd.h>
 #include <stdlib.h>
+#include <limits.h>
 #include <sys/param.h>
 #ifdef MAJOR_IN_MKDEV
 #include <sys/mkdev.h>


[FILE:944:patches/patch-src_mesa_drivers_dri_i965_brw__bufmgr.c]
--- src/mesa/drivers/dri/i965/brw_bufmgr.c.orig	2019-11-22 00:06:59 UTC
+++ src/mesa/drivers/dri/i965/brw_bufmgr.c
@@ -74,6 +74,10 @@
 #define VG(x)
 #endif
 
+#ifndef O_CLOEXEC
+#define O_CLOEXEC	0
+#endif
+
 /* VALGRIND_FREELIKE_BLOCK unfortunately does not actually undo the earlier
  * VALGRIND_MALLOCLIKE_BLOCK but instead leaves vg convinced the memory is
  * leaked. All because it does not call VG(cli_free) from its
@@ -1723,8 +1727,12 @@ brw_bufmgr_init(struct gen_device_info *
       bufmgr->initial_kflags |= EXEC_OBJECT_SUPPORTS_48B_ADDRESS;
 
       /* Allocate VMA in userspace if we have softpin and full PPGTT. */
+#ifdef __DragonFly__
+      if (false) {
+#else
       if (gem_param(fd, I915_PARAM_HAS_EXEC_SOFTPIN) > 0 &&
           gem_param(fd, I915_PARAM_HAS_ALIASING_PPGTT) > 1) {
+#endif
          bufmgr->initial_kflags |= EXEC_OBJECT_PINNED;
 
          util_vma_heap_init(&bufmgr->vma_allocator[BRW_MEMZONE_LOW_4G],


[FILE:710:patches/patch-src_mesa_drivers_dri_i965_brw__disk__cache.c]
--- src/mesa/drivers/dri/i965/brw_disk_cache.c.orig	2019-11-22 00:06:59 UTC
+++ src/mesa/drivers/dri/i965/brw_disk_cache.c
@@ -394,6 +394,7 @@ brw_disk_cache_init(struct intel_screen
    if (INTEL_DEBUG & DEBUG_DISK_CACHE_DISABLE_MASK)
       return;
 
+# ifdef HAVE_DL_ITERATE_PHDR
    /* array length: print length + null char + 1 extra to verify it is unused */
    char renderer[11];
    ASSERTED int len = snprintf(renderer, sizeof(renderer), "i965_%04x",
@@ -413,5 +414,6 @@ brw_disk_cache_init(struct intel_screen
    const uint64_t driver_flags =
       brw_get_compiler_config_value(screen->compiler);
    screen->disk_cache = disk_cache_create(renderer, timestamp, driver_flags);
+# endif
 #endif
 }


[FILE:851:patches/patch-src_mesa_drivers_dri_i965_brw__program__binary.c]
--- src/mesa/drivers/dri/i965/brw_program_binary.c.orig	2019-11-22 00:06:59 UTC
+++ src/mesa/drivers/dri/i965/brw_program_binary.c
@@ -36,9 +36,11 @@ static uint8_t driver_sha1[20];
 void
 brw_program_binary_init(unsigned device_id)
 {
+#ifdef HAVE_DL_ITERATE_PHDR
    const struct build_id_note *note =
       build_id_find_nhdr_for_addr(brw_program_binary_init);
    assert(note);
+#endif
 
    /**
     * With Mesa's megadrivers, taking the sha1 of i965_dri.so may not be
@@ -52,7 +54,9 @@ brw_program_binary_init(unsigned device_
    int len = snprintf(renderer, sizeof(renderer), "i965_%04x", device_id);
    assert(len == sizeof(renderer) - 1);
    _mesa_sha1_update(&ctx, renderer, len);
+#ifdef HAVE_DL_ITERATE_PHDR
    _mesa_sha1_update(&ctx, build_id_data(note), build_id_length(note));
+#endif
    _mesa_sha1_final(&ctx, driver_sha1);
 }
 


[FILE:1024:patches/patch-src_mesa_drivers_dri_i965_intel__batchbuffer.c]
--- src/mesa/drivers/dri/i965/intel_batchbuffer.c.orig	2019-11-22 00:06:59 UTC
+++ src/mesa/drivers/dri/i965/intel_batchbuffer.c
@@ -67,7 +67,7 @@ dump_validation_list(struct intel_batchb
       uint64_t flags = batch->validation_list[i].flags;
       assert(batch->validation_list[i].handle ==
              batch->exec_bos[i]->gem_handle);
-      fprintf(stderr, "[%2d]: %2d %-14s %p %s%-7s @ 0x%016llx%s (%"PRIu64"B)\n",
+      fprintf(stderr, "[%2d]: %2d %-14s %p %s%-7s @ 0x%016lx%s (%"PRIu64"B)\n",
               i,
               batch->validation_list[i].handle,
               batch->exec_bos[i]->name,
@@ -721,7 +721,7 @@ execbuffer(int fd,
 
       /* Update brw_bo::gtt_offset */
       if (batch->validation_list[i].offset != bo->gtt_offset) {
-         DBG("BO %d migrated: 0x%" PRIx64 " -> 0x%llx\n",
+         DBG("BO %d migrated: 0x%" PRIx64 " -> 0x%lx\n",
              bo->gem_handle, bo->gtt_offset,
              batch->validation_list[i].offset);
          assert(!(bo->kflags & EXEC_OBJECT_PINNED));


[FILE:967:patches/patch-src_mesa_drivers_dri_meson.build]
--- src/mesa/drivers/dri/meson.build.orig	2019-11-22 00:06:59 UTC
+++ src/mesa/drivers/dri/meson.build
@@ -20,7 +20,7 @@
 
 subdir('common')
 
-_dri_drivers = []
+_dri_drivers = [ libnir, libmesa_classic, libintel_compiler, libglcpp, libdricommon ]
 _dri_link = []
 if with_dri_swrast
   subdir('swrast')
@@ -59,14 +59,13 @@ if _dri_drivers != []
     [],
     link_whole : _dri_drivers,
     link_with : [
-      libmegadriver_stub, libdricommon, libglapi,
-      libmesa_classic,
+      libmegadriver_stub, libglapi,
     ],
     dependencies : [
       dep_selinux, dep_libdrm, dep_m, dep_thread, dep_dl,
-      idep_nir, idep_xmlconfig, idep_mesautil,
+      idep_xmlconfig, idep_mesautil,
     ],
-    link_args : [ld_args_build_id, ld_args_bsymbolic, ld_args_gc_sections],
+    link_args : [ld_args_bsymbolic, ld_args_gc_sections],
     # Will be deleted during installation, see install_megadrivers.py
     install : true,
     install_dir : dri_drivers_path,


[FILE:406:patches/patch-src_mesa_main_compiler.h]
--- src/mesa/main/compiler.h.orig	2019-11-22 00:06:59 UTC
+++ src/mesa/main/compiler.h
@@ -51,6 +51,9 @@
 #if defined(__linux__)
 #include <byteswap.h>
 #define CPU_TO_LE32( x )	bswap_32( x )
+#elif defined(__FreeBSD__)
+#include <sys/endian.h>
+#define CPU_TO_LE32( x )	bswap32( x )
 #elif defined(__APPLE__)
 #include <CoreFoundation/CFByteOrder.h>
 #define CPU_TO_LE32( x )	CFSwapInt32HostToLittle( x )


[FILE:476:patches/patch-src_mesa_main_imports.c]
--- src/mesa/main/imports.c.orig	2019-11-22 00:06:59 UTC
+++ src/mesa/main/imports.c
@@ -83,11 +83,15 @@ void *
 _mesa_align_malloc(size_t bytes, unsigned long alignment)
 {
 #if defined(HAVE_POSIX_MEMALIGN)
+# ifdef __sun__
+   return memalign(alignment, bytes);
+# else
    void *mem;
    int err = posix_memalign(& mem, alignment, bytes);
    if (err)
       return NULL;
    return mem;
+# endif
 #elif defined(_WIN32)
    return _aligned_malloc(bytes, alignment);
 #else


[FILE:237:patches/patch-src_mesa_main_macros.h]
--- src/mesa/main/macros.h.orig	2019-11-22 00:06:59 UTC
+++ src/mesa/main/macros.h
@@ -36,6 +36,7 @@
 #include "util/rounding.h"
 #include "imports.h"
 
+#undef ALIGN
 
 /**
  * \name Integer / float conversion for colors, normals, etc.


[FILE:227:patches/patch-src_mesa_main_marshal.h]
--- src/mesa/main/marshal.h.orig	2019-11-22 00:06:59 UTC
+++ src/mesa/main/marshal.h
@@ -32,6 +32,7 @@
 
 #include "main/glthread.h"
 #include "main/context.h"
+#undef ALIGN
 #include "main/macros.h"
 
 struct marshal_cmd_base


[FILE:328:patches/patch-src_util_build__id.c]
# Elf_ doesn't exist, use Elf32_ or Elf64_
#
--- src/util/build_id.c.orig	2019-11-22 00:06:59 UTC
+++ src/util/build_id.c
@@ -35,7 +35,11 @@
 #endif
 
 #ifndef ElfW
-#define ElfW(type) Elf_##type
+#ifdef __LP64__
+#define ElfW(type) Elf64_##type
+#else
+#define ElfW(type) Elf32_##type
+#endif
 #endif
 
 struct build_id_note {


[FILE:282:patches/patch-src_util_disk__cache.c]
--- src/util/disk_cache.c.orig	2019-11-22 00:06:59 UTC
+++ src/util/disk_cache.c
@@ -52,6 +52,10 @@
 
 #include "disk_cache.h"
 
+#ifndef O_CLOEXEC
+#define O_CLOEXEC	0
+#endif
+
 /* Number of bits to mask off from a cache key to get an index. */
 #define CACHE_INDEX_KEY_BITS 16
 


[FILE:1482:patches/patch-src_util_futex.h]
- Implement futex_wake() and futex_wait() via _umtx_op()

--- src/util/futex.h.orig	2019-11-22 00:06:59 UTC
+++ src/util/futex.h
@@ -29,10 +29,35 @@
 #include <limits.h>
 #include <stdint.h>
 #include <unistd.h>
+#if defined(__FreeBSD__)
+#include <errno.h>
+# if __FreeBSD__ < 11
+#  include <machine/atomic.h>
+# endif
+#include <sys/umtx.h>
+#else
 #include <linux/futex.h>
 #include <sys/syscall.h>
+#endif
 #include <sys/time.h>
 
+#if defined(__FreeBSD__)
+static inline int futex_wake(uint32_t *addr, int count)
+{
+   return _umtx_op(addr, UMTX_OP_WAKE, (uint32_t)count, NULL, NULL) == -1 ? errno : 0;
+}
+
+static inline int futex_wait(uint32_t *addr, int32_t value, struct timespec *timeout)
+{
+   void *uaddr = NULL, *uaddr2 = NULL;
+   if (timeout != NULL) {
+      const struct _umtx_time tmo = { ._timeout = *timeout, ._flags = UMTX_ABSTIME, ._clockid = CLOCK_MONOTONIC };
+      uaddr = (void *)(uintptr_t)sizeof(tmo);
+      uaddr2 = (void *)&tmo;
+   }
+   return _umtx_op(addr, UMTX_OP_WAIT_UINT, (uint32_t)value, uaddr, uaddr2) == -1 ? errno : 0;
+}
+#else
 static inline long sys_futex(void *addr1, int op, int val1, const struct timespec *timeout, void *addr2, int val3)
 {
    return syscall(SYS_futex, addr1, op, val1, timeout, addr2, val3);
@@ -50,6 +75,7 @@ static inline int futex_wait(uint32_t *a
    return sys_futex(addr, FUTEX_WAIT_BITSET, value, timeout, NULL,
                     FUTEX_BITSET_MATCH_ANY);
 }
+#endif
 
 #elif defined(__FreeBSD__)
 


[FILE:544:patches/patch-src_util_os__memory__stdc.h]
--- src/util/os_memory_stdc.h.orig	2019-11-22 00:06:59 UTC
+++ src/util/os_memory_stdc.h
@@ -51,11 +51,16 @@
 static inline void *
 os_malloc_aligned(size_t size, size_t alignment)
 {
+#ifdef __sun
+   alignment = (alignment + sizeof(void*) - 1) & ~(sizeof(void*) - 1);
+   return memalign(alignment, size);
+#else
    void *ptr;
    alignment = (alignment + sizeof(void*) - 1) & ~(sizeof(void*) - 1);
    if(posix_memalign(&ptr, alignment, size) != 0)
       return NULL;
    return ptr;
+#endif
 }
 
 #define os_free_aligned(_ptr) free(_ptr)


[FILE:430:patches/patch-src_util_u__atomic.h]
--- src/util/u_atomic.h.orig	2019-11-22 00:06:59 UTC
+++ src/util/u_atomic.h
@@ -20,11 +20,7 @@
  * locally coded assembly, compiler intrinsic or ultimately a
  * mutex-based implementation.
  */
-#if defined(__sun)
-#define PIPE_ATOMIC_OS_SOLARIS
-#elif defined(_MSC_VER)
-#define PIPE_ATOMIC_MSVC_INTRINSIC
-#elif defined(__GNUC__)
+#if defined(__GNUC__)
 #define PIPE_ATOMIC_GCC_INTRINSIC
 #else
 #error "Unsupported platform"


[FILE:1026:patches/patch-src_util_u__thread.h]
--- src/util/u_thread.h.orig	2019-11-22 00:06:59 UTC
+++ src/util/u_thread.h
@@ -69,16 +69,14 @@ static inline thrd_t u_thread_create(int
 static inline void u_thread_setname( const char *name )
 {
 #if defined(HAVE_PTHREAD)
-#if DETECT_OS_LINUX || DETECT_OS_CYGWIN || DETECT_OS_SOLARIS
+#if DETECT_OS_LINUX || DETECT_OS_CYGWIN
    pthread_setname_np(pthread_self(), name);
-#elif DETECT_OS_FREEBSD || DETECT_OS_OPENBSD
+#elif DETECT_OS_FREEBSD || DETECT_OS_OPENBSD || DETECT_OS_DRAGONFLY
    pthread_set_name_np(pthread_self(), name);
 #elif DETECT_OS_NETBSD
    pthread_setname_np(pthread_self(), "%s", (void *)name);
 #elif DETECT_OS_APPLE
    pthread_setname_np(name);
-#else
-#error Not sure how to call pthread_setname_np
 #endif
 #endif
    (void)name;
@@ -149,7 +147,7 @@ util_get_L3_for_pinned_thread(thrd_t thr
 static inline int64_t
 u_thread_get_time_nano(thrd_t thread)
 {
-#if defined(__linux__) && defined(HAVE_PTHREAD)
+#if defined(HAVE_PTHREAD) && !defined(__sun)
    struct timespec ts;
    clockid_t cid;
 


[FILE:87:files/special.mk]
GALLIUM_DRIVERS+=	SWRAST

.if ${OPSYS:MSunOS}
MESON_ARGS+=	-Dshader-cache=false
.endif

