# Buildsheet autogenerated by ravenadm tool -- Do not edit.

NAMEBASE=		cdrdao
VERSION=		1.2.5
REVISION=		1
KEYWORDS=		sysutils
VARIANTS=		std
SDESC[std]=		Tool to write CD-Rs in Disk-At-Once Mode
HOMEPAGE=		https://cdrdao.sourceforge.net
CONTACT=		Michael_Reim[kraileth@elderlinux.org]

DOWNLOAD_GROUPS=	main
SITES[main]=		SF/cdrdao/rel_1_2_5
DISTFILE[1]=		cdrdao-1.2.5.tar.bz2:main
DF_INDEX=		1
SPKGS[std]=		single

OPTIONS_AVAILABLE=	none
OPTIONS_STANDARD=	none

BUILD_DEPENDS=		lame:dev:std
			libvorbis:dev:std
			libao:dev:std
			libmad:dev:std
BUILDRUN_DEPENDS=	lame:primary:std
			libao:primary:std
			libmad:primary:std
			libvorbis:primary:std

USES=			cpe gmake pkgconfig c++:single

CPE_VENDOR=		andreas_mueller
FPC_EQUIVALENT=		sysutils/cdrdao

MUST_CONFIGURE=		gnu
CONFIGURE_ARGS=		--with-gcdmaster=no
			--with-pcctsbin={{PREFIX}}/bin
			--with-pcctsinc={{PREFIX}}/include/pccts
			--with-posix-threads=no
CONFIGURE_ENV=		AO_LIBS=-lao
			MAD_LIBS=-lmad
			VORBISFILE_LIBS=-lvorbisfile

MAKE_ENV=		CCOM=cc

VAR_OPSYS[freebsd]=	CONFIGURE_ARGS=--with-scglib
VAR_OPSYS[sunos]=	CONFIGURE_ARGS=--with-scglib
			LDFLAGS=-lvolmgt
			LDFLAGS=-lnsl
VAR_OPSYS[dragonfly]=	CONFIGURE_ARGS=--with-scglib
VAR_OPSYS[midnightbsd]=	CONFIGURE_ARGS=--with-scglib

post-patch:
.for i in 45libdeflt 45libedc 45libfile 45libhfs_iso 45libparanoia 45libunls \
	45librscg 55cdda2wav 55cdrecord 55cmd 55mkisofs 55mkisofs!@!diag \
	55readcd 55scgcheck 55scgskeleton 55rscsi 85man
	${RM} ${WRKSRC}/scsilib/TARGETS/${i}
.endfor
.for i in cdrdao.man main.cc
	${REINPLACE_CMD} -e 's|%%PREFIX%%|${PREFIX}|g' ${WRKSRC}/dao/${i}
.endfor
	${REINPLACE_CMD} -E -e 's|(^CDRDAO_DATA_DIR.+=).+|\1 ${PREFIX}/share/cdrdao|' \
		${WRKSRC}/dao/Makefile.in
.for i in toc2cddb.1 toc2cue.1
	${REINPLACE_CMD} -e 's|1\.2\.2|1.2.5|g' ${WRKSRC}/utils/${i}
.endfor

do-install:
	${INSTALL_PROGRAM} ${WRKSRC}/dao/cdrdao ${STAGEDIR}${PREFIX}/bin
	${INSTALL_MAN} ${WRKSRC}/dao/cdrdao.man \
		${STAGEDIR}${MANPREFIX}/man/man1/cdrdao.1
.for f in cue2toc toc2cddb toc2cue
	${INSTALL_PROGRAM} ${WRKSRC}/utils/${f} ${STAGEDIR}${PREFIX}/bin
	${INSTALL_MAN} ${WRKSRC}/utils/${f}.1 ${STAGEDIR}${MANPREFIX}/man/man1/
.endfor
	${INSTALL_PROGRAM} ${WRKSRC}/utils/toc2mp3 ${STAGEDIR}${PREFIX}/bin
	${MKDIR} ${STAGEDIR}${PREFIX}/share/cdrdao
	${INSTALL_DATA} ${WRKSRC}/dao/cdrdao.drivers \
		${STAGEDIR}${PREFIX}/share/cdrdao/drivers

[FILE:231:descriptions/desc.single]
Cdrdao records audio or data CD-R[W]s in disc-at-once (DAO) mode based on
textual description of the CD contents (toc-file).

Among others, cdrdao can handle the bin/cue format commonly used for VCDs
or disks with subchannel data.


[FILE:99:distinfo]
d19b67c853c5dba2406afaab6cd788e77f35eebe634cac4679528477c7be01b6       870084 cdrdao-1.2.5.tar.bz2


[FILE:143:manifests/plist.single]
bin/
 cdrdao
 cue2toc
 toc2cddb
 toc2cue
 toc2mp3
share/cdrdao/drivers
share/man/man1/
 cdrdao.1.gz
 cue2toc.1.gz
 toc2cddb.1.gz
 toc2cue.1.gz


[FILE:746:patches/patch-configure]
--- configure.orig	2023-02-03 14:28:39 UTC
+++ configure
@@ -11410,7 +11410,7 @@ case "$host" in
       scsilib_objs="ScsiIf-linux.o sg_err.o"
       ;;
 
-  *-freebsd*)
+  *-freebsd*|*-dragonfly*|*-midnight*)
       scsilib_libs="-lcam"
       scsilib_objs="ScsiIf-freebsd-cam.o"
       ;;
@@ -11448,7 +11448,7 @@ case "$host" in
 esac
 
 case "$host" in
-  *-freebsd*)
+  *-freebsd*|*-dragonfly*|*-midnight*)
 	      if test "$use_pthreads" = yes; then
 		LDFLAGS="-pthread $LDFLAGS"
 		thread_libs=""
@@ -11465,7 +11465,7 @@ printf "%s\n" "#define _P1003_1B_VISIBLE
 esac
 
 case "$host" in
-  *-linux* | *-freebsd* | *-solaris*)
+  *-linux* | *-freebsd* | *-dragonfly* | *-solaris* | *-midnight*)
 	     sound_if_obj=SoundIF-ao.o
 	     ;;
 


[FILE:303:patches/patch-dao_GenericMMC.cc]
--- dao/GenericMMC.cc.orig	2023-02-03 14:46:06 UTC
+++ dao/GenericMMC.cc
@@ -2075,7 +2075,7 @@ CdRawToc *GenericMMC::getRawToc(int sess
     return NULL;
   }
 
-  dataLen = ((reqData[0] << 8) | reqData[1]) + 2;
+  dataLen = (dataLen + 1) & ~1;
   
   log_message(4, "Raw toc data len: %d", dataLen);
 


[FILE:561:patches/patch-dao_ScsiIf-freebsd-cam.cc]
--- dao/ScsiIf-freebsd-cam.cc.orig	2023-01-25 14:30:35 UTC
+++ dao/ScsiIf-freebsd-cam.cc
@@ -28,7 +28,11 @@
 #include <string.h>
 
 #include <camlib.h>
+#ifdef __DragonFly__
+#include <bus/cam/scsi/scsi_message.h>
+#else
 #include <cam/scsi/scsi_message.h>
+#endif
 
 #include "ScsiIf.h"
 #include "log.h"
@@ -220,6 +224,12 @@ int ScsiIf::inquiry()
 	for (i = 3; i >= 0 && revision_[i] == ' '; i--)
 		revision_[i] = 0;
 
+	if (vendor_[0] == 0)
+		strncpy(vendor_, "UNKNOWN", 8);
+
+	if (product_[0] == 0)
+		strncpy(product_, "UNKNOWN", 8);
+
 	return 0;
 }
 


[FILE:292:patches/patch-dao_ScsiIf-lib.cc]
--- dao/ScsiIf-lib.cc.orig	2021-03-15 09:13:15 UTC
+++ dao/ScsiIf-lib.cc
@@ -288,6 +288,12 @@ int ScsiIf::inquiry()
     revision_[i] = 0;
   }
 
+  if (vendor_[0] == 0)
+    strncpy(vendor_, "UNKNOWN", 8);
+
+  if (product_[0] == 0)
+    strncpy(product_, "UNKNOWN", 8);
+
   return 0;
 }
 


[FILE:510:patches/patch-dao_ScsiIf-linux.cc]
--- dao/ScsiIf-linux.cc.orig	2023-02-03 14:46:06 UTC
+++ dao/ScsiIf-linux.cc
@@ -33,6 +33,7 @@
 #include <asm/param.h>
 #include <scsi/scsi.h>
 #include <scsi/sg.h>
+#include <sys/stat.h>
 
 #include "ScsiIf.h"
 #include "sg_err.h"
@@ -272,7 +273,13 @@ int ScsiIf::inquiry()
     for (i = 3; i >= 0 && revision_[i] == ' '; i--) {
 	revision_[i] = 0;
     }
-  
+
+    if (vendor_[0] == 0)
+	strncpy(vendor_, "UNKNOWN", 8);
+
+    if (product_[0] == 0)
+	strncpy(product_, "UNKNOWN", 8); 
+
     return 0;
 }
 


[FILE:3580:patches/patch-dao_ScsiIf-netbsd.cc]
--- dao/ScsiIf-netbsd.cc.orig	2021-03-15 09:13:15 UTC
+++ dao/ScsiIf-netbsd.cc
@@ -22,9 +22,7 @@
 #include <unistd.h>
 
 #include "ScsiIf.h"
-
-/* can't include trackdb/util.h */
-extern void message(int level, const char *fmt, ...);
+#include "log.h"
 
 #include "decodeSense.cc"
 
@@ -91,7 +89,7 @@ int ScsiIf::init()
 {
 	if (impl_->name_ == NULL) return 1;
 	if ((impl_->fd_ = open(impl_->name_, O_RDWR, 0)) < 0) {
-		message(-2, "init: %s", strerror(errno));
+		log_message(-2, "init: %s", strerror(errno));
 		return 1;
 	}
 	if (inquiry()) return 2;
@@ -193,29 +191,29 @@ void ScsiIf::printError()
 		p += snprintf(p, s + sizeof(s) - p, ", BUF=%p", impl_->screq_.databuf);
 		p += snprintf(p, s + sizeof(s) - p, ", LEN=%lu", impl_->screq_.datalen);
 		p += snprintf(p, s + sizeof(s) - p, ", TO=%lu", impl_->screq_.timeout);
-		message(-2, s);
+		log_message(-2, s);
 	}
 	if (impl_->error_ != NULL) {
-		message(-2, impl_->error_);
+		log_message(-2, impl_->error_);
 	} else switch (impl_->screq_.retsts) {
 		case SCCMD_OK: switch (impl_->screq_.status) {
-			case 0x00: message(-2, "GOOD"); break;
-			case 0x02: message(-2, "CHECK CONDITION"); break;
-			case 0x04: message(-2, "CONDITION MET"); break;
-			case 0x08: message(-2, "BUSY"); break;
-			case 0x10: message(-2, "INTERMEDIATE"); break;
-			case 0x14: message(-2, "INTERMEDIATE, CONDITION MET"); break;
-			case 0x18: message(-2, "RESERVATION CONFLICT"); break;
-			case 0x22: message(-2, "COMMAND TERMINATED"); break;
-			case 0x28: message(-2, "QUEUE FULL"); break;
-			default: message(-2, "undefined status");
+			case 0x00: log_message(-2, "GOOD"); break;
+			case 0x02: log_message(-2, "CHECK CONDITION"); break;
+			case 0x04: log_message(-2, "CONDITION MET"); break;
+			case 0x08: log_message(-2, "BUSY"); break;
+			case 0x10: log_message(-2, "INTERMEDIATE"); break;
+			case 0x14: log_message(-2, "INTERMEDIATE, CONDITION MET"); break;
+			case 0x18: log_message(-2, "RESERVATION CONFLICT"); break;
+			case 0x22: log_message(-2, "COMMAND TERMINATED"); break;
+			case 0x28: log_message(-2, "QUEUE FULL"); break;
+			default: log_message(-2, "undefined status");
 		} break;
-		case SCCMD_TIMEOUT: message(-2, "timeout"); break;
-		case SCCMD_BUSY: message(-2, "busy"); break;
+		case SCCMD_TIMEOUT: log_message(-2, "timeout"); break;
+		case SCCMD_BUSY: log_message(-2, "busy"); break;
 		case SCCMD_SENSE: decodeSense(impl_->screq_.sense,
 		                              impl_->screq_.senselen_used); break;
-		case SCCMD_UNKNOWN: message(-2, "unknown error"); break;
-		default: message(-2, "undefined retsts"); break;
+		case SCCMD_UNKNOWN: log_message(-2, "unknown error"); break;
+		default: log_message(-2, "undefined retsts"); break;
 	}
 }
 
@@ -259,7 +257,7 @@ int ScsiIf::inquiry()
 	return inq(impl_->fd_, vendor_, product_, revision_);
 }
 
-ScsiIf::ScanData *ScsiIf::scan(int *len)
+ScsiIf::ScanData *ScsiIf::scan(int *len, char *devpath)
 {
 	DIR *dirp;
 	struct dirent *dp;
@@ -289,6 +287,9 @@ ScsiIf::ScanData *ScsiIf::scan(int *len)
 			strcat(s, dp->d_name);
 			if ((fd = open(s, O_RDWR, 0)) >= 0) {
 				if (ioctl(fd, SCIOCIDENTIFY, &saddr) >= 0) {
+#if 1
+					scanData[*len].dev = s;
+#else
 					switch (saddr.type) {
 						case TYPE_SCSI:
 							scanData[*len].bus = saddr.addr.scsi.scbus;
@@ -305,6 +306,7 @@ ScsiIf::ScanData *ScsiIf::scan(int *len)
 							scanData[*len].id =
 							scanData[*len].lun = -1;
 					}
+#endif
 					if (inq(fd, scanData[*len].vendor,
 					            scanData[*len].product,
 					            scanData[*len].revision) == 0) (*len)++;


[FILE:291:patches/patch-dao_ScsiIf-nt.cc]
--- dao/ScsiIf-nt.cc.orig	2021-03-15 09:13:15 UTC
+++ dao/ScsiIf-nt.cc
@@ -332,6 +332,12 @@ int ScsiIf::inquiry()
      revision_[i] = 0;
   }
 
+  if (vendor_[0] == 0)
+    strncpy(vendor_, "UNKNOWN", 8);
+
+  if (product_[0] == 0)
+    strncpy(product_, "UNKNOWN", 8);
+
   return 0;
 }
 


[FILE:666:patches/patch-dao_cdrdao.man]
--- dao/cdrdao.man.orig	2023-02-03 14:46:06 UTC
+++ dao/cdrdao.man
@@ -798,13 +798,9 @@ following locations. The files will be r
 .I cdrdao
 in that order:
 
-1. /etc/cdrdao.conf
+1. %%PREFIX%%/etc/cdrdao.conf
 
-2. /etc/defaults/cdrdao
-
-3. /etc/default/cdrdao
-
-4. $HOME/.cdrdao
+2. $HOME/.cdrdao
 
 
 Command line options will overwrite the loaded settings.
@@ -886,4 +882,4 @@ resources may not be released. Use ipcs(
 .ft R
 .fi
 .SH SEE ALSO
-.BR gcdmaster "(1), "cdrecord "(1), "cdda2wav "(1), "cdparanoia "(1), " sox "(1), "ipcs "(8), " ipcrm (8) 
+.BR gcdmaster "(1), "cdrecord "(1), "cdda2wav "(1), "cdparanoia "(1), " sox "(1), "ipcs "(1), " ipcrm (1) 


[FILE:514:patches/patch-dao_main.cc]
--- dao/main.cc.orig	2023-02-03 14:46:06 UTC
+++ dao/main.cc
@@ -2450,11 +2450,7 @@ int main(int argc, char **argv)
 
     Settings* settings = new Settings;
 
-    settingsPath = "/etc/cdrdao.conf";
-    if (settings->read(settingsPath) == 0)
-	log_message(3, "Read settings from \"%s\".", settingsPath);
-
-    settingsPath = "/etc/defaults/cdrdao";
+    settingsPath = "%%PREFIX%%/etc/defaults/cdrdao";
     if (settings->read(settingsPath) == 0)
 	log_message(3, "Read settings from \"%s\".", settingsPath);
 


[FILE:375:patches/patch-gcdmaster_SampleDisplay.cc]
--- gcdmaster/SampleDisplay.cc.orig	2023-02-03 14:46:06 UTC
+++ gcdmaster/SampleDisplay.cc
@@ -905,8 +905,6 @@ void SampleDisplay::updateSamples()
                 rcenter_ - pos1);
         }
 
-        if (&pixmap_ == 0)
-          std::cout << "null !!" << std::endl;
 
         if (0 && (gint) di < sampleEndX_) {
           pos = sampleBuf[len - 1].left() * halfHeight;


[FILE:656:patches/patch-gcdmaster_SoundIF-solaris.cc]
--- gcdmaster/SoundIF-solaris.cc.orig	2023-02-03 14:46:06 UTC
+++ gcdmaster/SoundIF-solaris.cc
@@ -45,6 +45,7 @@
  * Sound interface for Solaris. Thanks to Tobias Oetiker <oetiker@ee.ethz.ch>.
  */
 
+#include <sys/types.h>
 #include <sys/audioio.h>
 #include <stdio.h>
 #include <assert.h>
@@ -196,7 +197,7 @@ int SoundIFImpl::setupDevice()
   auinf.play.sample_rate=44100;
   auinf.play.channels=2;
   auinf.play.precision=16;
-  auinf.play.encoding=AUDIO_ENCODING_LINEAR;
+  auinf.play.encoding=AUDIO_ENCODING_SLINEAR_BE;
 
   if (ioctl(dspFd_, AUDIO_SETINFO, &auinf) < 0) {
     log_message(-1, _("Cannot setup audio interface: %s"), strerror(errno));


[FILE:304:patches/patch-trackdb_FormatOgg.cc]
--- trackdb/FormatOgg.cc.orig	2021-03-15 09:13:15 UTC
+++ trackdb/FormatOgg.cc
@@ -84,6 +84,7 @@ FormatSupport::Status FormatOgg::oggInit
       return FS_WRONG_FORMAT;
   }
 
+  memset(&outFormat_, 0, sizeof(outFormat_));
   outFormat_.bits = 16;
   outFormat_.rate = 44100;
   outFormat_.channels = 2;

