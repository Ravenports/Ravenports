# Buildsheet autogenerated by ravenadm tool -- Do not edit.

NAMEBASE=		cdrdao
VERSION=		1.2.4
KEYWORDS=		sysutils
VARIANTS=		standard
SDESC[standard]=	Tool to write CD-Rs in Disk-At-Once Mode
HOMEPAGE=		http://cdrdao.sourceforge.net
CONTACT=		Michael_Reim[kraileth@elderlinux.org]

DOWNLOAD_GROUPS=	main
SITES[main]=		SF/cdrdao
DISTFILE[1]=		cdrdao-1.2.4.tar.bz2:main
DF_INDEX=		1
SPKGS[standard]=	single

OPTIONS_AVAILABLE=	none
OPTIONS_STANDARD=	none

BUILDRUN_DEPENDS=	libao:primary:standard
			libmad:single:standard
			libvorbis:primary:standard
			lame:primary:standard

USES=			gmake pkgconfig c++:single

FPC_EQUIVALENT=		sysutils/cdrdao

MUST_CONFIGURE=		gnu
CONFIGURE_ARGS=		--with-gcdmaster=no
			--without-pcctsbin
			--without-pcctsinc
			--with-posix-threads=no
			--with-scglib
CONFIGURE_ENV=		AO_LIBS=-lao
			MAD_LIBS=-lmad
			VORBISFILE_LIBS=-lvorbisfile

MAKE_ENV=		CCOM=cc

post-patch:
.for i in 45libdeflt 45libedc 45libfile 45libhfs_iso 45libparanoia 45libunls \
	45librscg 55cdda2wav 55cdrecord 55cmd 55mkisofs 55mkisofs!@!diag \
	55readcd 55scgcheck 55scgskeleton 55rscsi 85man
	${RM} ${WRKSRC}/scsilib/TARGETS/${i}
.endfor
.for i in cdrdao.man main.cc
	${REINPLACE_CMD} -e 's|%%PREFIX%%|${PREFIX}|g' ${WRKSRC}/dao/${i}
.endfor
	${REINPLACE_CMD} -E -e 's|(^CDRDAO_DATA_DIR.+=).+|\1 ${PREFIX}/share/cdrdao|' \
		${WRKSRC}/dao/Makefile.in
.for i in toc2cddb.1 toc2cue.1
	${REINPLACE_CMD} -e 's|1\.2\.2|1.2.4|g' ${WRKSRC}/utils/${i}
.endfor

post-extract-dragonfly:
	(cd ${WRKSRC}/scsilib/RULES \
		&& ${CP} -p os-freebsd.id os-dragonfly.id \
		&& ${CP} -p i386-freebsd-cc.rul x86_64-freebsd-cc.rul)

do-install:
	${INSTALL_PROGRAM} ${WRKSRC}/dao/cdrdao ${STAGEDIR}${PREFIX}/bin
	${INSTALL_MAN} ${WRKSRC}/dao/cdrdao.man \
		${STAGEDIR}${MANPREFIX}/man/man1/cdrdao.1
.for f in cue2toc toc2cddb toc2cue
	${INSTALL_PROGRAM} ${WRKSRC}/utils/${f} ${STAGEDIR}${PREFIX}/bin
	${INSTALL_MAN} ${WRKSRC}/utils/${f}.1 ${STAGEDIR}${MANPREFIX}/man/man1/
.endfor
	${INSTALL_PROGRAM} ${WRKSRC}/utils/toc2mp3 ${STAGEDIR}${PREFIX}/bin
	${MKDIR} ${STAGEDIR}${PREFIX}/share/cdrdao
	${INSTALL_DATA} ${WRKSRC}/dao/cdrdao.drivers \
		${STAGEDIR}${PREFIX}/share/cdrdao/drivers

post-extract-freebsd:
	(cd ${WRKSRC}/scsilib/RULES \
		&& ${CP} -p i386-freebsd-cc.rul amd64-freebsd-cc.rul)

[FILE:231:descriptions/desc.single]
Cdrdao records audio or data CD-R[W]s in disc-at-once (DAO) mode based on
textual description of the CD contents (toc-file).

Among others, cdrdao can handle the bin/cue format commonly used for VCDs
or disks with subchannel data.


[FILE:99:distinfo]
358d9cb83370ceaecdc60564cbf14c2ea2636eac60a966e2461c011ba09853b4      1442181 cdrdao-1.2.4.tar.bz2


[FILE:143:manifests/plist.single]
bin/
 cdrdao
 cue2toc
 toc2cddb
 toc2cue
 toc2mp3
share/cdrdao/drivers
share/man/man1/
 cdrdao.1.gz
 cue2toc.1.gz
 toc2cddb.1.gz
 toc2cue.1.gz


[FILE:1038:patches/patch-configure]
--- configure.orig	2018-05-16 10:47:00 UTC
+++ configure
@@ -7436,7 +7436,7 @@ if test "$scglib" = yes; then
   scsilib_objs="ScsiIf-lib.o"
 
   case "$host" in
-    *-freebsd* | *-kfreebsd*-gnu)
+    *-freebsd* | *-kfreebsd*-gnu | *-dragonfly*)
 			       scsilib_libs="$scsilib_libs -lcam"
 			       ;;
   esac
@@ -7454,7 +7454,7 @@ else
 	       scsilib_objs="ScsiIf-linux.o sg_err.o"
 	       ;;
 
-    *-freebsd* | *-kfreebsd*-gnu)
+    *-freebsd* | *-kfreebsd*-gnu | *-dragonfly*)
 	       scsilib_libs="-lcam"
 	       scsilib_objs="ScsiIf-freebsd-cam.o"
 	       ;;
@@ -7492,7 +7492,7 @@ case "$host" in
 esac
 
 case "$host" in
-  *-freebsd*)
+  *-freebsd* | *-dragonfly*)
 	      if test "$use_pthreads" = yes; then
 		LDFLAGS="-pthread $LDFLAGS"
 		thread_libs=""
@@ -7508,7 +7508,7 @@ $as_echo "#define _P1003_1B_VISIBLE 1" >
 esac
 
 case "$host" in
-  *-linux* | *-freebsd* | *-kfreebsd*-gnu | *-solaris*)
+  *-linux* | *-freebsd* | *-kfreebsd*-gnu | *-dragonfly* | *-solaris*)
 	     sound_if_obj=SoundIF-ao.o
 	     ;;
 


[FILE:306:patches/patch-dao_ScsiIf-freebsd-cam.cc]
--- dao/ScsiIf-freebsd-cam.cc.orig	2018-05-16 10:46:39 UTC
+++ dao/ScsiIf-freebsd-cam.cc
@@ -28,7 +28,11 @@
 #include <string.h>
 
 #include <camlib.h>
+#ifdef __DragonFly__
+#include <bus/cam/scsi/scsi_message.h>
+#else
 #include <cam/scsi/scsi_message.h>
+#endif
 
 #include "ScsiIf.h"
 #include "log.h"


[FILE:666:patches/patch-dao_cdrdao.man]
--- dao/cdrdao.man.orig	2018-05-16 10:46:39 UTC
+++ dao/cdrdao.man
@@ -798,13 +798,9 @@ following locations. The files will be r
 .I cdrdao
 in that order:
 
-1. /etc/cdrdao.conf
+1. %%PREFIX%%/etc/cdrdao.conf
 
-2. /etc/defaults/cdrdao
-
-3. /etc/default/cdrdao
-
-4. $HOME/.cdrdao
+2. $HOME/.cdrdao
 
 
 Command line options will overwrite the loaded settings.
@@ -886,4 +882,4 @@ resources may not be released. Use ipcs(
 .ft R
 .fi
 .SH SEE ALSO
-.BR gcdmaster "(1), "cdrecord "(1), "cdda2wav "(1), "cdparanoia "(1), " sox "(1), "ipcs "(8), " ipcrm (8) 
+.BR gcdmaster "(1), "cdrecord "(1), "cdda2wav "(1), "cdparanoia "(1), " sox "(1), "ipcs "(1), " ipcrm (1) 


[FILE:661:patches/patch-dao_main.cc]
--- dao/main.cc.orig	2018-05-16 10:46:39 UTC
+++ dao/main.cc
@@ -2330,15 +2330,7 @@ int main(int argc, char **argv)
 
     Settings* settings = new Settings;
 
-    settingsPath = "/etc/cdrdao.conf";
-    if (settings->read(settingsPath) == 0)
-	log_message(3, "Read settings from \"%s\".", settingsPath);
-
-    settingsPath = "/etc/defaults/cdrdao";
-    if (settings->read(settingsPath) == 0)
-	log_message(3, "Read settings from \"%s\".", settingsPath);
-
-    settingsPath = "/etc/default/cdrdao";
+    settingsPath = "%%PREFIX%%/etc/cdrdao.conf";
     if (settings->read(settingsPath) == 0)
 	log_message(3, "Read settings from \"%s\".", settingsPath);
 


[FILE:1010:patches/patch-scsilib_RULES_i386-freebsd-cc.rul]
--- scsilib/RULES/i386-freebsd-cc.rul.orig	2002-10-15 20:43:39 UTC
+++ scsilib/RULES/i386-freebsd-cc.rul
@@ -24,7 +24,8 @@ include $(SRCROOT)/$(RULESDIR)/rules.prg
 ###########################################################################
 
 CPPFLAGS=	$(CPPOPTS) $(CPPOPTX)
-CFLAGS=		$(COPTS) $(CWARNOPTS) $(COPTOPT) $(GCCOPTOPT) $(COPTX)
+XCFLAGS:=	$(CFLAGS)
+CFLAGS=		$(COPTS) $(CWARNOPTS) $(XCFLAGS) $(GCCOPTOPT) $(COPTX)
 
 CPPOPTS=	-I. -I$(ARCHDIR) -I$(OINCSDIR) $(INCDIRS:%=-I%) $(OSDEFS)
 COPTS=
@@ -57,14 +58,14 @@ LNDYNLIB=	@$(SYMLINK) $(TARGET) $(PTARGE
 
 FLOAT_OPTIONS=	
 
-CC=		@echo "	==> COMPILING \"$@\""; gcc
-LDCC=		@echo "	==> LINKING \"$@\""; gcc
-DYNLD=		@echo "	==> LINKING dynamic library \"$@\""; gcc
-RANLIB=		@echo "	==> RANDOMIZING ARCHIVE \"$@\""; ranlib
+CCCOM=		$(CC)
+LDCC=		$(CCCOM)
+DYNLD=		$(CCCOM)
+RANLIB=		ranlib
 ARFLAGS=	cr
 LORDER=		lorder
 TSORT=		tsort
 
 RMDEP=		:
-MKDEP=		@echo "	==> MAKING DEPENDENCIES \"$@\""; $(RMDEP); gcc -M
+MKDEP=		$(CCCOM) -M
 MKDEP_OUT=


[FILE:258:patches/patch-scsilib_inc_avoffset.c]
--- scsilib/inc/avoffset.c.orig	2018-05-16 10:46:58 UTC
+++ scsilib/inc/avoffset.c
@@ -61,7 +61,7 @@ main(ac, av)
 {
 	int		stdir;
 #ifdef	HAVE_SCANSTACK
-	register struct frame *fp;
+	volatile struct frame *fp;
 	register int	i = 0;
 	register int	o = 0;
 


[FILE:440:patches/patch-scsilib_inc_getfp.c]
--- scsilib/inc/getfp.c.orig	2003-07-12 23:10:47 UTC
+++ scsilib/inc/getfp.c
@@ -56,7 +56,7 @@
 
 EXPORT	void	**___fpoff	__PR((char *cp));
 
-EXPORT void **
+EXPORT __noinline void **
 getfp()
 {
 		long	**dummy[1];
@@ -73,7 +73,7 @@ getfp()
  * We need this function to fool GCCs check for returning addresses
  * from outside the functions local address space.
  */
-EXPORT void **
+EXPORT __noinline void **
 ___fpoff(cp)
 	char	*cp;
 {


[FILE:866:patches/patch-scsilib_include_mconfig.h]
--- scsilib/include/mconfig.h.orig	2018-05-16 10:46:58 UTC
+++ scsilib/include/mconfig.h
@@ -72,12 +72,12 @@ extern "C" {
  * Types/Keywords
  */
 
-#if defined(__x86_64__) || defined(__ia64__) || defined(__powerpc64__) || defined(__s390x__) || defined(__sparc64__)
+#if defined(__aarch64__) || defined(__ia64__) || defined(__mips_n64) || defined(__powerpc64__) || defined(__s390x__) || defined(__sparc64__) || defined(__x86_64__)
 #define SIZEOF_LONG_INT 8
 #define SIZEOF_CHAR_P 8
 #define SIZEOF_UNSIGNED_LONG_INT 8
 #define SIZEOF_UNSIGNED_CHAR_P 8
-#elif defined(__i386__) || defined(__powerpc__) || defined(__s390__) || defined(__sparc__)
+#elif defined(__arm__) || defined(__i386__) || defined(__mips__) || defined(__powerpc__) || defined(__s390__) || defined(__sparc__)
 #define SIZEOF_LONG_INT 4
 #define SIZEOF_CHAR_P 4
 #define SIZEOF_UNSIGNED_LONG_INT 4


[FILE:539:patches/patch-scsilib_libscg_scsi-bsd.c]
--- scsilib/libscg/scsi-bsd.c.orig	2018-05-16 10:46:58 UTC
+++ scsilib/libscg/scsi-bsd.c
@@ -548,10 +548,17 @@ scgo_send(scgp)
 #define	scsi_sense CAM_scsi_sense
 #define	scsi_inquiry CAM_scsi_inquiry
 #include <sys/param.h>
+#ifdef __DragonFly__
+#include <bus/cam/cam.h>
+#include <bus/cam/cam_ccb.h>
+#include <bus/cam/scsi/scsi_message.h>
+#include <bus/cam/scsi/scsi_pass.h>
+#else
 #include <cam/cam.h>
 #include <cam/cam_ccb.h>
 #include <cam/scsi/scsi_message.h>
 #include <cam/scsi/scsi_pass.h>
+#endif
 #include <camlib.h>
 
 /*


[FILE:809:patches/patch-scsilib_libschily_format.c]
--- scsilib/libschily/format.c.orig	2003-10-18 13:26:50 UTC
+++ scsilib/libschily/format.c
@@ -166,6 +166,7 @@ format(fun, farg, fmt, args)
 	Ulong res;
 	char *rfmt;
 	f_args	fa;
+	va_list vl;
 
 	fa.outf = fun;
 	fa.farg = farg;
@@ -432,6 +433,7 @@ format(fun, farg, fmt, args)
 		case 'r':			/* recursive printf */
 		case 'R':			/* recursive printf */
 			rfmt  = va_arg(args, char *);
+			va_copy(vl, args);
 			/*
 			 * I don't know any portable way to get an arbitrary
 			 * C object from a var arg list so I use a
@@ -446,7 +448,8 @@ format(fun, farg, fmt, args)
 			 * It would be nice to have something like
 			 * __va_arg_list() in stdarg.h
 			 */
-			count += format(fun, farg, rfmt, __va_arg_list(args));
+			count += format(fun, farg, rfmt, vl);
+			va_end(vl);
 			continue;
 
 		case 'n':


[FILE:587:patches/patch-scsilib_libschily_getfp.c]
--- scsilib/libschily/getfp.c.orig	2003-07-12 23:10:47 UTC
+++ scsilib/libschily/getfp.c
@@ -23,6 +23,7 @@
 #include <mconfig.h>
 #include <standard.h>
 #include <schily.h>
+#include <sys/cdefs.h>
 
 #ifndef	IS_AVOFFSET
 /*
@@ -56,7 +57,7 @@
 
 EXPORT	void	**___fpoff	__PR((char *cp));
 
-EXPORT void **
+EXPORT __noinline void **
 getfp()
 {
 		long	**dummy[1];
@@ -73,7 +74,7 @@ getfp()
  * We need this function to fool GCCs check for returning addresses
  * from outside the functions local address space.
  */
-EXPORT void **
+EXPORT __noinline void **
 ___fpoff(cp)
 	char	*cp;
 {


[FILE:341:patches/patch-trackdb_FormatMp3.cc]
--- trackdb/FormatMp3.cc.orig	2018-05-15 13:30:52 UTC
+++ trackdb/FormatMp3.cc
@@ -111,6 +111,7 @@ FormatSupport::Status FormatMp3::madInit
 
   // Initialize libao for WAV output;
   ao_sample_format out_format;
+  memset(&out_format, 0, sizeof(out_format));
   out_format.bits = 16;
   out_format.rate = 44100;
   out_format.channels = 2;


[FILE:304:patches/patch-trackdb_FormatOgg.cc]
--- trackdb/FormatOgg.cc.orig	2018-05-15 13:30:52 UTC
+++ trackdb/FormatOgg.cc
@@ -84,6 +84,7 @@ FormatSupport::Status FormatOgg::oggInit
       return FS_WRONG_FORMAT;
   }
 
+  memset(&outFormat_, 0, sizeof(outFormat_));
   outFormat_.bits = 16;
   outFormat_.rate = 44100;
   outFormat_.channels = 2;

