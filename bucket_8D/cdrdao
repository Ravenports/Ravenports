# Buildsheet autogenerated by ravenadm tool -- Do not edit.

NAMEBASE=		cdrdao
VERSION=		1.2.4
REVISION=		1
KEYWORDS=		sysutils
VARIANTS=		standard
SDESC[standard]=	Tool to write CD-Rs in Disk-At-Once Mode
HOMEPAGE=		https://cdrdao.sourceforge.net
CONTACT=		Michael_Reim[kraileth@elderlinux.org]

DOWNLOAD_GROUPS=	main
SITES[main]=		SF/cdrdao
DISTFILE[1]=		cdrdao-1.2.4.tar.bz2:main
DF_INDEX=		1
SPKGS[standard]=	single

OPTIONS_AVAILABLE=	none
OPTIONS_STANDARD=	none

BUILDRUN_DEPENDS=	libao:primary:standard
			libmad:single:standard
			libvorbis:primary:standard
			lame:primary:standard

USES=			cpe gmake pkgconfig c++:single

CPE_VENDOR=		andreas_mueller
FPC_EQUIVALENT=		sysutils/cdrdao

MUST_CONFIGURE=		gnu
CONFIGURE_ARGS=		--with-gcdmaster=no
			--with-pcctsbin={{PREFIX}}/bin
			--with-pcctsinc={{PREFIX}}/include/pccts
			--with-posix-threads=no
CONFIGURE_ENV=		AO_LIBS=-lao
			MAD_LIBS=-lmad
			VORBISFILE_LIBS=-lvorbisfile

MAKE_ENV=		CCOM=cc

VAR_OPSYS[freebsd]=	CONFIGURE_ARGS=--with-scglib
VAR_OPSYS[sunos]=	CONFIGURE_ARGS=--with-scglib
			LDFLAGS=-lvolmgt
			LDFLAGS=-lnsl
VAR_OPSYS[dragonfly]=	CONFIGURE_ARGS=--with-scglib

post-patch:
.for i in 45libdeflt 45libedc 45libfile 45libhfs_iso 45libparanoia 45libunls \
	45librscg 55cdda2wav 55cdrecord 55cmd 55mkisofs 55mkisofs!@!diag \
	55readcd 55scgcheck 55scgskeleton 55rscsi 85man
	${RM} ${WRKSRC}/scsilib/TARGETS/${i}
.endfor
.for i in cdrdao.man main.cc
	${REINPLACE_CMD} -e 's|%%PREFIX%%|${PREFIX}|g' ${WRKSRC}/dao/${i}
.endfor
	${REINPLACE_CMD} -E -e 's|(^CDRDAO_DATA_DIR.+=).+|\1 ${PREFIX}/share/cdrdao|' \
		${WRKSRC}/dao/Makefile.in
.for i in toc2cddb.1 toc2cue.1
	${REINPLACE_CMD} -e 's|1\.2\.2|1.2.4|g' ${WRKSRC}/utils/${i}
.endfor

post-extract-dragonfly:
	(cd ${WRKSRC}/scsilib/RULES \
		&& ${CP} -p os-freebsd.id os-dragonfly.id \
		&& ${CP} -p i386-freebsd-cc.rul x86_64-freebsd-cc.rul)

do-install:
	${INSTALL_PROGRAM} ${WRKSRC}/dao/cdrdao ${STAGEDIR}${PREFIX}/bin
	${INSTALL_MAN} ${WRKSRC}/dao/cdrdao.man \
		${STAGEDIR}${MANPREFIX}/man/man1/cdrdao.1
.for f in cue2toc toc2cddb toc2cue
	${INSTALL_PROGRAM} ${WRKSRC}/utils/${f} ${STAGEDIR}${PREFIX}/bin
	${INSTALL_MAN} ${WRKSRC}/utils/${f}.1 ${STAGEDIR}${MANPREFIX}/man/man1/
.endfor
	${INSTALL_PROGRAM} ${WRKSRC}/utils/toc2mp3 ${STAGEDIR}${PREFIX}/bin
	${MKDIR} ${STAGEDIR}${PREFIX}/share/cdrdao
	${INSTALL_DATA} ${WRKSRC}/dao/cdrdao.drivers \
		${STAGEDIR}${PREFIX}/share/cdrdao/drivers

post-extract-netbsd:
	(cd ${WRKSRC}/scsilib/RULES \
		&& ${CP} -p i386-netbsd-cc.rul x86_64-netbsd-cc.rul)

post-extract-freebsd:
	(cd ${WRKSRC}/scsilib/RULES \
		&& ${CP} -p i386-freebsd-cc.rul amd64-freebsd-cc.rul)

[FILE:231:descriptions/desc.single]
Cdrdao records audio or data CD-R[W]s in disc-at-once (DAO) mode based on
textual description of the CD contents (toc-file).

Among others, cdrdao can handle the bin/cue format commonly used for VCDs
or disks with subchannel data.


[FILE:99:distinfo]
358d9cb83370ceaecdc60564cbf14c2ea2636eac60a966e2461c011ba09853b4      1442181 cdrdao-1.2.4.tar.bz2


[FILE:143:manifests/plist.single]
bin/
 cdrdao
 cue2toc
 toc2cddb
 toc2cue
 toc2mp3
share/cdrdao/drivers
share/man/man1/
 cdrdao.1.gz
 cue2toc.1.gz
 toc2cddb.1.gz
 toc2cue.1.gz


[FILE:1032:patches/patch-configure]
--- configure.orig	2018-05-16 10:47:00 UTC
+++ configure
@@ -7436,7 +7436,7 @@ if test "$scglib" = yes; then
   scsilib_objs="ScsiIf-lib.o"
 
   case "$host" in
-    *-freebsd* | *-kfreebsd*-gnu)
+    *-freebsd* | *-kfreebsd*-gnu | *-dragonfly*)
 			       scsilib_libs="$scsilib_libs -lcam"
 			       ;;
   esac
@@ -7454,7 +7454,7 @@ else
 	       scsilib_objs="ScsiIf-linux.o sg_err.o"
 	       ;;
 
-    *-freebsd* | *-kfreebsd*-gnu)
+    *-freebsd* | *-kfreebsd*-gnu | *-dragonfly*)
 	       scsilib_libs="-lcam"
 	       scsilib_objs="ScsiIf-freebsd-cam.o"
 	       ;;
@@ -7492,7 +7492,7 @@ case "$host" in
 esac
 
 case "$host" in
-  *-freebsd*)
+  *-freebsd* | *-dragonfly*)
 	      if test "$use_pthreads" = yes; then
 		LDFLAGS="-pthread $LDFLAGS"
 		thread_libs=""
@@ -7508,7 +7508,7 @@ $as_echo "#define _P1003_1B_VISIBLE 1" >
 esac
 
 case "$host" in
-  *-linux* | *-freebsd* | *-kfreebsd*-gnu | *-solaris*)
+  *-linux* | *-freebsd* | *-netbsd* | *-dragonfly* | *-solaris*)
 	     sound_if_obj=SoundIF-ao.o
 	     ;;
 


[FILE:303:patches/patch-dao_GenericMMC.cc]
--- dao/GenericMMC.cc.orig	2018-05-15 13:30:52 UTC
+++ dao/GenericMMC.cc
@@ -2064,7 +2064,7 @@ CdRawToc *GenericMMC::getRawToc(int sess
     return NULL;
   }
 
-  dataLen = ((reqData[0] << 8) | reqData[1]) + 2;
+  dataLen = (dataLen + 1) & ~1;
   
   log_message(4, "Raw toc data len: %d", dataLen);
 


[FILE:561:patches/patch-dao_ScsiIf-freebsd-cam.cc]
--- dao/ScsiIf-freebsd-cam.cc.orig	2018-05-16 10:46:39 UTC
+++ dao/ScsiIf-freebsd-cam.cc
@@ -28,7 +28,11 @@
 #include <string.h>
 
 #include <camlib.h>
+#ifdef __DragonFly__
+#include <bus/cam/scsi/scsi_message.h>
+#else
 #include <cam/scsi/scsi_message.h>
+#endif
 
 #include "ScsiIf.h"
 #include "log.h"
@@ -221,6 +225,12 @@ int ScsiIf::inquiry()
 	for (i = 3; i >= 0 && revision_[i] == ' '; i--)
 		revision_[i] = 0;
 
+	if (vendor_[0] == 0)
+		strncpy(vendor_, "UNKNOWN", 8);
+
+	if (product_[0] == 0)
+		strncpy(product_, "UNKNOWN", 8);
+
 	return 0;
 }
 


[FILE:292:patches/patch-dao_ScsiIf-lib.cc]
--- dao/ScsiIf-lib.cc.orig	2018-05-15 13:30:52 UTC
+++ dao/ScsiIf-lib.cc
@@ -288,6 +288,12 @@ int ScsiIf::inquiry()
     revision_[i] = 0;
   }
 
+  if (vendor_[0] == 0)
+    strncpy(vendor_, "UNKNOWN", 8);
+
+  if (product_[0] == 0)
+    strncpy(product_, "UNKNOWN", 8);
+
   return 0;
 }
 


[FILE:510:patches/patch-dao_ScsiIf-linux.cc]
--- dao/ScsiIf-linux.cc.orig	2018-05-16 10:46:39 UTC
+++ dao/ScsiIf-linux.cc
@@ -33,6 +33,7 @@
 #include <asm/param.h>
 #include <scsi/scsi.h>
 #include <scsi/sg.h>
+#include <sys/stat.h>
 
 #include "ScsiIf.h"
 #include "sg_err.h"
@@ -276,7 +277,13 @@ int ScsiIf::inquiry()
     for (i = 3; i >= 0 && revision_[i] == ' '; i--) {
 	revision_[i] = 0;
     }
-  
+
+    if (vendor_[0] == 0)
+	strncpy(vendor_, "UNKNOWN", 8);
+
+    if (product_[0] == 0)
+	strncpy(product_, "UNKNOWN", 8); 
+
     return 0;
 }
 


[FILE:3580:patches/patch-dao_ScsiIf-netbsd.cc]
--- dao/ScsiIf-netbsd.cc.orig	2018-05-15 13:30:52 UTC
+++ dao/ScsiIf-netbsd.cc
@@ -22,9 +22,7 @@
 #include <unistd.h>
 
 #include "ScsiIf.h"
-
-/* can't include trackdb/util.h */
-extern void message(int level, const char *fmt, ...);
+#include "log.h"
 
 #include "decodeSense.cc"
 
@@ -91,7 +89,7 @@ int ScsiIf::init()
 {
 	if (impl_->name_ == NULL) return 1;
 	if ((impl_->fd_ = open(impl_->name_, O_RDWR, 0)) < 0) {
-		message(-2, "init: %s", strerror(errno));
+		log_message(-2, "init: %s", strerror(errno));
 		return 1;
 	}
 	if (inquiry()) return 2;
@@ -193,29 +191,29 @@ void ScsiIf::printError()
 		p += snprintf(p, s + sizeof(s) - p, ", BUF=%p", impl_->screq_.databuf);
 		p += snprintf(p, s + sizeof(s) - p, ", LEN=%lu", impl_->screq_.datalen);
 		p += snprintf(p, s + sizeof(s) - p, ", TO=%lu", impl_->screq_.timeout);
-		message(-2, s);
+		log_message(-2, s);
 	}
 	if (impl_->error_ != NULL) {
-		message(-2, impl_->error_);
+		log_message(-2, impl_->error_);
 	} else switch (impl_->screq_.retsts) {
 		case SCCMD_OK: switch (impl_->screq_.status) {
-			case 0x00: message(-2, "GOOD"); break;
-			case 0x02: message(-2, "CHECK CONDITION"); break;
-			case 0x04: message(-2, "CONDITION MET"); break;
-			case 0x08: message(-2, "BUSY"); break;
-			case 0x10: message(-2, "INTERMEDIATE"); break;
-			case 0x14: message(-2, "INTERMEDIATE, CONDITION MET"); break;
-			case 0x18: message(-2, "RESERVATION CONFLICT"); break;
-			case 0x22: message(-2, "COMMAND TERMINATED"); break;
-			case 0x28: message(-2, "QUEUE FULL"); break;
-			default: message(-2, "undefined status");
+			case 0x00: log_message(-2, "GOOD"); break;
+			case 0x02: log_message(-2, "CHECK CONDITION"); break;
+			case 0x04: log_message(-2, "CONDITION MET"); break;
+			case 0x08: log_message(-2, "BUSY"); break;
+			case 0x10: log_message(-2, "INTERMEDIATE"); break;
+			case 0x14: log_message(-2, "INTERMEDIATE, CONDITION MET"); break;
+			case 0x18: log_message(-2, "RESERVATION CONFLICT"); break;
+			case 0x22: log_message(-2, "COMMAND TERMINATED"); break;
+			case 0x28: log_message(-2, "QUEUE FULL"); break;
+			default: log_message(-2, "undefined status");
 		} break;
-		case SCCMD_TIMEOUT: message(-2, "timeout"); break;
-		case SCCMD_BUSY: message(-2, "busy"); break;
+		case SCCMD_TIMEOUT: log_message(-2, "timeout"); break;
+		case SCCMD_BUSY: log_message(-2, "busy"); break;
 		case SCCMD_SENSE: decodeSense(impl_->screq_.sense,
 		                              impl_->screq_.senselen_used); break;
-		case SCCMD_UNKNOWN: message(-2, "unknown error"); break;
-		default: message(-2, "undefined retsts"); break;
+		case SCCMD_UNKNOWN: log_message(-2, "unknown error"); break;
+		default: log_message(-2, "undefined retsts"); break;
 	}
 }
 
@@ -259,7 +257,7 @@ int ScsiIf::inquiry()
 	return inq(impl_->fd_, vendor_, product_, revision_);
 }
 
-ScsiIf::ScanData *ScsiIf::scan(int *len)
+ScsiIf::ScanData *ScsiIf::scan(int *len, char *devpath)
 {
 	DIR *dirp;
 	struct dirent *dp;
@@ -289,6 +287,9 @@ ScsiIf::ScanData *ScsiIf::scan(int *len)
 			strcat(s, dp->d_name);
 			if ((fd = open(s, O_RDWR, 0)) >= 0) {
 				if (ioctl(fd, SCIOCIDENTIFY, &saddr) >= 0) {
+#if 1
+					scanData[*len].dev = s;
+#else
 					switch (saddr.type) {
 						case TYPE_SCSI:
 							scanData[*len].bus = saddr.addr.scsi.scbus;
@@ -305,6 +306,7 @@ ScsiIf::ScanData *ScsiIf::scan(int *len)
 							scanData[*len].id =
 							scanData[*len].lun = -1;
 					}
+#endif
 					if (inq(fd, scanData[*len].vendor,
 					            scanData[*len].product,
 					            scanData[*len].revision) == 0) (*len)++;


[FILE:291:patches/patch-dao_ScsiIf-nt.cc]
--- dao/ScsiIf-nt.cc.orig	2018-05-15 13:30:52 UTC
+++ dao/ScsiIf-nt.cc
@@ -332,6 +332,12 @@ int ScsiIf::inquiry()
      revision_[i] = 0;
   }
 
+  if (vendor_[0] == 0)
+    strncpy(vendor_, "UNKNOWN", 8);
+
+  if (product_[0] == 0)
+    strncpy(product_, "UNKNOWN", 8);
+
   return 0;
 }
 


[FILE:666:patches/patch-dao_cdrdao.man]
--- dao/cdrdao.man.orig	2018-05-16 10:46:39 UTC
+++ dao/cdrdao.man
@@ -798,13 +798,9 @@ following locations. The files will be r
 .I cdrdao
 in that order:
 
-1. /etc/cdrdao.conf
+1. %%PREFIX%%/etc/cdrdao.conf
 
-2. /etc/defaults/cdrdao
-
-3. /etc/default/cdrdao
-
-4. $HOME/.cdrdao
+2. $HOME/.cdrdao
 
 
 Command line options will overwrite the loaded settings.
@@ -886,4 +882,4 @@ resources may not be released. Use ipcs(
 .ft R
 .fi
 .SH SEE ALSO
-.BR gcdmaster "(1), "cdrecord "(1), "cdda2wav "(1), "cdparanoia "(1), " sox "(1), "ipcs "(8), " ipcrm (8) 
+.BR gcdmaster "(1), "cdrecord "(1), "cdda2wav "(1), "cdparanoia "(1), " sox "(1), "ipcs "(1), " ipcrm (1) 


[FILE:661:patches/patch-dao_main.cc]
--- dao/main.cc.orig	2018-05-16 10:46:39 UTC
+++ dao/main.cc
@@ -2330,15 +2330,7 @@ int main(int argc, char **argv)
 
     Settings* settings = new Settings;
 
-    settingsPath = "/etc/cdrdao.conf";
-    if (settings->read(settingsPath) == 0)
-	log_message(3, "Read settings from \"%s\".", settingsPath);
-
-    settingsPath = "/etc/defaults/cdrdao";
-    if (settings->read(settingsPath) == 0)
-	log_message(3, "Read settings from \"%s\".", settingsPath);
-
-    settingsPath = "/etc/default/cdrdao";
+    settingsPath = "%%PREFIX%%/etc/cdrdao.conf";
     if (settings->read(settingsPath) == 0)
 	log_message(3, "Read settings from \"%s\".", settingsPath);
 


[FILE:307:patches/patch-gcdmaster_SampleDisplay.cc]
--- gcdmaster/SampleDisplay.cc.orig	2018-05-16 10:25:12 UTC
+++ gcdmaster/SampleDisplay.cc
@@ -1025,8 +1025,6 @@ void SampleDisplay::updateSamples()
 
 	}
 
-	if (&pixmap_ == 0)
-	  std::cout << "null !!" << std::endl;
 
 	if (0 && (gint)di < sampleEndX_) {
 	  pos = sampleBuf[len -1].left() * halfHeight;


[FILE:656:patches/patch-gcdmaster_SoundIF-solaris.cc]
--- gcdmaster/SoundIF-solaris.cc.orig	2018-05-16 10:25:12 UTC
+++ gcdmaster/SoundIF-solaris.cc
@@ -45,6 +45,7 @@
  * Sound interface for Solaris. Thanks to Tobias Oetiker <oetiker@ee.ethz.ch>.
  */
 
+#include <sys/types.h>
 #include <sys/audioio.h>
 #include <stdio.h>
 #include <assert.h>
@@ -197,7 +198,7 @@ int SoundIFImpl::setupDevice()
   auinf.play.sample_rate=44100;
   auinf.play.channels=2;
   auinf.play.precision=16;
-  auinf.play.encoding=AUDIO_ENCODING_LINEAR;
+  auinf.play.encoding=AUDIO_ENCODING_SLINEAR_BE;
 
   if (ioctl(dspFd_, AUDIO_SETINFO, &auinf) < 0) {
     log_message(-1, _("Cannot setup audio interface: %s"), strerror(errno));


[FILE:1010:patches/patch-scsilib_RULES_i386-freebsd-cc.rul]
--- scsilib/RULES/i386-freebsd-cc.rul.orig	2002-10-15 20:43:39 UTC
+++ scsilib/RULES/i386-freebsd-cc.rul
@@ -24,7 +24,8 @@ include $(SRCROOT)/$(RULESDIR)/rules.prg
 ###########################################################################
 
 CPPFLAGS=	$(CPPOPTS) $(CPPOPTX)
-CFLAGS=		$(COPTS) $(CWARNOPTS) $(COPTOPT) $(GCCOPTOPT) $(COPTX)
+XCFLAGS:=	$(CFLAGS)
+CFLAGS=		$(COPTS) $(CWARNOPTS) $(XCFLAGS) $(GCCOPTOPT) $(COPTX)
 
 CPPOPTS=	-I. -I$(ARCHDIR) -I$(OINCSDIR) $(INCDIRS:%=-I%) $(OSDEFS)
 COPTS=
@@ -57,14 +58,14 @@ LNDYNLIB=	@$(SYMLINK) $(TARGET) $(PTARGE
 
 FLOAT_OPTIONS=	
 
-CC=		@echo "	==> COMPILING \"$@\""; gcc
-LDCC=		@echo "	==> LINKING \"$@\""; gcc
-DYNLD=		@echo "	==> LINKING dynamic library \"$@\""; gcc
-RANLIB=		@echo "	==> RANDOMIZING ARCHIVE \"$@\""; ranlib
+CCCOM=		$(CC)
+LDCC=		$(CCCOM)
+DYNLD=		$(CCCOM)
+RANLIB=		ranlib
 ARFLAGS=	cr
 LORDER=		lorder
 TSORT=		tsort
 
 RMDEP=		:
-MKDEP=		@echo "	==> MAKING DEPENDENCIES \"$@\""; $(RMDEP); gcc -M
+MKDEP=		$(CCCOM) -M
 MKDEP_OUT=


[FILE:1000:patches/patch-scsilib_RULES_i386-netbsd-cc.rul]
--- scsilib/RULES/i386-netbsd-cc.rul.orig	2002-10-15 20:43:40 UTC
+++ scsilib/RULES/i386-netbsd-cc.rul
@@ -24,7 +24,7 @@ include $(SRCROOT)/$(RULESDIR)/rules.prg
 ###########################################################################
 
 CPPFLAGS=	$(CPPOPTS) $(CPPOPTX)
-CFLAGS=		$(COPTS) $(CWARNOPTS) $(COPTOPT) $(GCCOPTOPT) $(COPTX)
+CFLAGS=		$(COPTS) $(CWARNOPTS) $(XCFLAGS) $(GCCOPTOPT) $(COPTX)
 
 #OSDEFS=		-DIS_UNIX
 CPPOPTS=	-I. -I$(ARCHDIR) -I$(OINCSDIR) $(INCDIRS:%=-I%) $(OSDEFS)
@@ -58,14 +58,14 @@ LNDYNLIB=	@$(SYMLINK) $(TARGET) $(PTARGE
 
 FLOAT_OPTIONS=	
 
-CC=		@echo "	==> COMPILING \"$@\""; gcc
-LDCC=		@echo "	==> LINKING \"$@\""; gcc
-DYNLD=		@echo "	==> LINKING dynamic library \"$@\""; gcc
-RANLIB=		@echo "	==> RANDOMIZING ARCHIVE \"$@\""; ranlib
+CCCOM=		$(CC)
+LDCC=		$(CCCOM)
+DYNLD=		$(CCCOM)
+RANLIB=		ranlib
 ARFLAGS=	cr
 LORDER=		lorder
 TSORT=		tsort
 
 RMDEP=		:
-MKDEP=		@echo "	==> MAKING DEPENDENCIES \"$@\""; $(RMDEP); gcc -M
+MKDEP=		$(CCCOM) -M
 MKDEP_OUT=


[FILE:258:patches/patch-scsilib_inc_avoffset.c]
--- scsilib/inc/avoffset.c.orig	2018-05-16 10:46:58 UTC
+++ scsilib/inc/avoffset.c
@@ -61,7 +61,7 @@ main(ac, av)
 {
 	int		stdir;
 #ifdef	HAVE_SCANSTACK
-	register struct frame *fp;
+	volatile struct frame *fp;
 	register int	i = 0;
 	register int	o = 0;
 


[FILE:472:patches/patch-scsilib_inc_getfp.c]
--- scsilib/inc/getfp.c.orig	2003-07-12 23:10:47 UTC
+++ scsilib/inc/getfp.c
@@ -56,7 +56,7 @@
 
 EXPORT	void	**___fpoff	__PR((char *cp));
 
-EXPORT void **
+EXPORT __attribute__ ((noinline)) void **
 getfp()
 {
 		long	**dummy[1];
@@ -73,7 +73,7 @@ getfp()
  * We need this function to fool GCCs check for returning addresses
  * from outside the functions local address space.
  */
-EXPORT void **
+EXPORT __attribute__ ((noinline)) void **
 ___fpoff(cp)
 	char	*cp;
 {


[FILE:866:patches/patch-scsilib_include_mconfig.h]
--- scsilib/include/mconfig.h.orig	2018-05-16 10:46:58 UTC
+++ scsilib/include/mconfig.h
@@ -72,12 +72,12 @@ extern "C" {
  * Types/Keywords
  */
 
-#if defined(__x86_64__) || defined(__ia64__) || defined(__powerpc64__) || defined(__s390x__) || defined(__sparc64__)
+#if defined(__aarch64__) || defined(__ia64__) || defined(__mips_n64) || defined(__powerpc64__) || defined(__s390x__) || defined(__sparc64__) || defined(__x86_64__)
 #define SIZEOF_LONG_INT 8
 #define SIZEOF_CHAR_P 8
 #define SIZEOF_UNSIGNED_LONG_INT 8
 #define SIZEOF_UNSIGNED_CHAR_P 8
-#elif defined(__i386__) || defined(__powerpc__) || defined(__s390__) || defined(__sparc__)
+#elif defined(__arm__) || defined(__i386__) || defined(__mips__) || defined(__powerpc__) || defined(__s390__) || defined(__sparc__)
 #define SIZEOF_LONG_INT 4
 #define SIZEOF_CHAR_P 4
 #define SIZEOF_UNSIGNED_LONG_INT 4


[FILE:539:patches/patch-scsilib_libscg_scsi-bsd.c]
--- scsilib/libscg/scsi-bsd.c.orig	2018-05-16 10:46:58 UTC
+++ scsilib/libscg/scsi-bsd.c
@@ -548,10 +548,17 @@ scgo_send(scgp)
 #define	scsi_sense CAM_scsi_sense
 #define	scsi_inquiry CAM_scsi_inquiry
 #include <sys/param.h>
+#ifdef __DragonFly__
+#include <bus/cam/cam.h>
+#include <bus/cam/cam_ccb.h>
+#include <bus/cam/scsi/scsi_message.h>
+#include <bus/cam/scsi/scsi_pass.h>
+#else
 #include <cam/cam.h>
 #include <cam/cam_ccb.h>
 #include <cam/scsi/scsi_message.h>
 #include <cam/scsi/scsi_pass.h>
+#endif
 #include <camlib.h>
 
 /*


[FILE:809:patches/patch-scsilib_libschily_format.c]
--- scsilib/libschily/format.c.orig	2003-10-18 13:26:50 UTC
+++ scsilib/libschily/format.c
@@ -166,6 +166,7 @@ format(fun, farg, fmt, args)
 	Ulong res;
 	char *rfmt;
 	f_args	fa;
+	va_list vl;
 
 	fa.outf = fun;
 	fa.farg = farg;
@@ -432,6 +433,7 @@ format(fun, farg, fmt, args)
 		case 'r':			/* recursive printf */
 		case 'R':			/* recursive printf */
 			rfmt  = va_arg(args, char *);
+			va_copy(vl, args);
 			/*
 			 * I don't know any portable way to get an arbitrary
 			 * C object from a var arg list so I use a
@@ -446,7 +448,8 @@ format(fun, farg, fmt, args)
 			 * It would be nice to have something like
 			 * __va_arg_list() in stdarg.h
 			 */
-			count += format(fun, farg, rfmt, __va_arg_list(args));
+			count += format(fun, farg, rfmt, vl);
+			va_end(vl);
 			continue;
 
 		case 'n':


[FILE:587:patches/patch-scsilib_libschily_getfp.c]
--- scsilib/libschily/getfp.c.orig	2003-07-12 23:10:47 UTC
+++ scsilib/libschily/getfp.c
@@ -23,6 +23,7 @@
 #include <mconfig.h>
 #include <standard.h>
 #include <schily.h>
+#include <sys/cdefs.h>
 
 #ifndef	IS_AVOFFSET
 /*
@@ -56,7 +57,7 @@
 
 EXPORT	void	**___fpoff	__PR((char *cp));
 
-EXPORT void **
+EXPORT __noinline void **
 getfp()
 {
 		long	**dummy[1];
@@ -73,7 +74,7 @@ getfp()
  * We need this function to fool GCCs check for returning addresses
  * from outside the functions local address space.
  */
-EXPORT void **
+EXPORT __noinline void **
 ___fpoff(cp)
 	char	*cp;
 {


[FILE:341:patches/patch-trackdb_FormatMp3.cc]
--- trackdb/FormatMp3.cc.orig	2018-05-15 13:30:52 UTC
+++ trackdb/FormatMp3.cc
@@ -111,6 +111,7 @@ FormatSupport::Status FormatMp3::madInit
 
   // Initialize libao for WAV output;
   ao_sample_format out_format;
+  memset(&out_format, 0, sizeof(out_format));
   out_format.bits = 16;
   out_format.rate = 44100;
   out_format.channels = 2;


[FILE:304:patches/patch-trackdb_FormatOgg.cc]
--- trackdb/FormatOgg.cc.orig	2018-05-15 13:30:52 UTC
+++ trackdb/FormatOgg.cc
@@ -84,6 +84,7 @@ FormatSupport::Status FormatOgg::oggInit
       return FS_WRONG_FORMAT;
   }
 
+  memset(&outFormat_, 0, sizeof(outFormat_));
   outFormat_.bits = 16;
   outFormat_.rate = 44100;
   outFormat_.channels = 2;


[FILE:1109:patches/patch-trackdb_TrackData.cc]
--- trackdb/TrackData.cc.orig	2018-05-15 13:30:52 UTC
+++ trackdb/TrackData.cc
@@ -642,7 +642,7 @@ int TrackData::waveLength(const char *fi
   char magic[4];
   long headerLen = 0;
   long len;
-  short waveFormat;
+  unsigned short waveFormat;
   short waveChannels;
   long waveRate;
   short waveBits;
@@ -715,7 +715,7 @@ int TrackData::waveLength(const char *fi
 
   waveFormat = readShort(fp);
 
-  if (waveFormat != 1) {
+  if (waveFormat != 1 && waveFormat != 0xfffe) {
     // not PCM format
     log_message(-2, "%s: not in PCM format.", filename);
     fclose(fp);
@@ -749,7 +749,21 @@ int TrackData::waveLength(const char *fi
     return 2;
   }
   
-  len -= 16;
+  if (waveFormat == 1)
+    len -= 16;
+  else {
+    readShort(fp); // cbsize
+    readShort(fp); // validbits
+    readLong(fp); // channelmask
+    waveFormat = readShort(fp); // subformat
+    if (waveFormat != 1) {
+      // not PCM format
+      log_message(-2, "%s: not in PCM format.", filename);
+      fclose(fp);
+      return 2;
+    }
+    len -= 26;
+  }
 
   // skip chunk data
   if (fseek(fp, len, SEEK_CUR) != 0) {

