# Buildsheet autogenerated by ravenadm tool -- Do not edit.

NAMEBASE=		libuuid
VERSION=		2.40.3
KEYWORDS=		misc devel
VARIANTS=		std
SDESC[std]=		Tool/Lib for generating Universally Unique IDs
HOMEPAGE=		https://github.com/karelzak/util-linux
CONTACT=		nobody

DOWNLOAD_GROUPS=	main
SITES[main]=		https://mirrors.edge.kernel.org/pub/linux/utils/util-linux/v2.40/
DISTFILE[1]=		util-linux-2.40.3.tar.xz:main
DF_INDEX=		1
SPKGS[std]=		set
			primary
			tools
			dev
			man

OPTIONS_AVAILABLE=	NOSETPROC
OPTIONS_STANDARD=	NOSETPROC
OPT_ON[freebsd]=	NOSETPROC
OPT_ON[sunos]=		NOSETPROC
OPT_ON[dragonfly]=	NOSETPROC
OPT_ON[midnightbsd]=	NOSETPROC

BUILD_DEPENDS=		bison:primary:std
			ruby-asciidoctor:single:ruby_default
B_DEPS[sunos]=		libbsd4sol:single:std
EXRUN[tools]=		libuuid:primary:std

USES=			autoreconf:build cpe libtool:build pkgconfig
			gettext:build
C_USES[sunos]=		perl:build

DISTNAME=		util-linux-2.40.3

LICENSE=		BSD3CLAUSE:primary
LICENSE_FILE=		BSD3CLAUSE:{{WRKDIR}}/BSD3
LICENSE_AWK=		BSD3CLAUSE:"^$$"
LICENSE_SOURCE=		BSD3CLAUSE:{{WRKSRC}}/libuuid/src/uuid.h
LICENSE_SCHEME=		solo

CPE_PRODUCT=		util-linux
CPE_VENDOR=		kernel

MUST_CONFIGURE=		gnu
CONFIGURE_ARGS=		--disable-all-programs
			--disable-bash-completion
			--enable-libuuid
			--enable-uuidgen
			--enable-asciidoc
			--without-ncurses
			--without-ncursesw
			--disable-nls
CONFIGURE_ENV=		ax_cv_check_vscript_flag=unsupported
			ac_cv_type_cpu_set_t=no

INSTALL_TARGET=		install-strip
SOVERSION=		1.3.0

CFLAGS=			-Wno-implicit-function-declaration
VAR_OPSYS[sunos]=	CFLAGS=-I{{LOCALBASE}}/include/bsd
			LDFLAGS=-lbsd
			CFLAGS=-DHAVE_STRNLEN
			CFLAGS=-DHAVE_STRNDUP

[NOSETPROC].DESCRIPTION=		Omit built-in setproctitle support

post-patch-NOSETPROC-ON:
	${REINPLACE_CMD} -e '/setproctitle.c/d' ${WRKSRC}/lib/Makemodule.am

post-install:
	${RM} -r ${STAGEDIR}${PREFIX}/share/bash-completion

pre-configure:
	cd ${WRKSRC} && ${SH} ./autogen.sh

post-patch-sunos:
	# there's a problem with nls, just mass-remove the macro
	${GREP} -rl '_(".*")' ${WRKSRC} | ${XARGS} \
		${PERL} -p -i.pbak -e 's|[_][(]["](.*?)["][)]|"\1"|g'

[FILE:568:descriptions/desc.primary]
The UUID library is used to generate unique identifiers for objects
that may be accessible beyond the local system.  This library
generates UUIDs compatible with those created by the Open Software
Foundation (OSF) Distributed Computing Environment (DCE) utility
uuidgen.

The UUIDs generated by this library can be reasonably expected to be
unique within a system, and unique across all systems.  They could
be used, for instance, to generate unique HTTP cookies across multiple
web servers without communication between the servers, and without fear
of a name clash.


[FILE:40:descriptions/desc.tools]
This package contains the uuidgen tool.


[FILE:103:distinfo]
0d6429d0cc474eafb972b0f4fee6b9c3d3f31c7bbada012bb3a1e255f00612c5      8865864 util-linux-2.40.3.tar.xz


[FILE:55:manifests/plist.primary]
lib/
 libuuid.so.%%SOMAJOR%%
 libuuid.so.%%SOVERSION%%


[FILE:12:manifests/plist.tools]
bin/uuidgen


[FILE:70:manifests/plist.dev]
include/uuid/uuid.h
lib/
 libuuid.a
 libuuid.so
lib/pkgconfig/uuid.pc


[FILE:276:manifests/plist.man]
share/man/man1/uuidgen.1
share/man/man3/
 uuid.3
 uuid_clear.3
 uuid_compare.3
 uuid_copy.3
 uuid_generate.3
 uuid_generate_random.3
 uuid_generate_time.3
 uuid_generate_time_safe.3
 uuid_is_null.3
 uuid_parse.3
 uuid_time.3
 uuid_unparse.3
share/man/man5/terminal-colors.d.5


[FILE:1174:patches/patch-configure.ac]
--- configure.ac.orig	2025-01-09 11:53:12 UTC
+++ configure.ac
@@ -1225,6 +1225,11 @@ AC_SUBST([LIBUUID_VERSION])
 AC_SUBST([LIBUUID_VERSION_INFO])
 AM_CONDITIONAL(BUILD_LIBUUID, test "x$build_libuuid" = xyes)
 
+AC_ARG_ENABLE([uuidgen],
+  AS_HELP_STRING([--disable-uuidgen], [do not build uuidgen]),
+  [], [UL_DEFAULT_ENABLE([uuidgen], [yes])]
+)
+
 AC_ARG_ENABLE([libuuid-force-uuidd],
   AS_HELP_STRING([--enable-libuuid-force-uuidd], [support uuidd even though the daemon is not built]),
   [], [enable_libuuid_force_uuidd=no]
@@ -1470,7 +1475,6 @@ AC_ARG_ENABLE([uuidgen],
   [], [UL_DEFAULT_ENABLE([uuidgen], [check])]
 )
 UL_BUILD_INIT([uuidgen])
-UL_REQUIRES_BUILD([uuidgen], [libuuid])
 AM_CONDITIONAL([BUILD_UUIDGEN], [test "x$build_uuidgen" = xyes])
 
 UL_BUILD_INIT([uuidparse], [check])
@@ -1925,6 +1929,11 @@ AC_ARG_ENABLE([logger],
 UL_BUILD_INIT([logger])
 AM_CONDITIONAL([BUILD_LOGGER], [test "x$build_logger" = xyes])
 
+AC_ARG_ENABLE([mcookie],
+  AS_HELP_STRING([--disable-mcookie], [do not build mcookie]),
+  [], [UL_DEFAULT_ENABLE([mcookie], [check])]
+)
+
 UL_BUILD_INIT([look], [yes])
 AM_CONDITIONAL([BUILD_LOOK], [test "x$build_look" = xyes])
 


[FILE:340:patches/patch-include_c.h]
Add NAME_MAX compat.

--- include/c.h.orig	2025-01-09 10:14:54 UTC
+++ include/c.h
@@ -37,6 +37,10 @@
 # define NAME_MAX PATH_MAX
 #endif
 
+#ifndef NAME_MAX
+# define NAME_MAX PATH_MAX
+#endif
+
 /*
  * __GNUC_PREREQ is deprecated in favour of __has_attribute() and
  * __has_feature(). The __has macros are supported by clang and gcc>=5.


[FILE:1519:patches/patch-include_ttyutils.h]
Define values if missing.

--- include/ttyutils.h.orig	2025-01-09 10:14:54 UTC
+++ include/ttyutils.h
@@ -99,6 +99,18 @@ extern int get_terminal_name(const char
 static inline void reset_virtual_console(struct termios *tp, int flags)
 {
 	/* Use defaults of <sys/ttydefaults.h> for base settings */
+#ifndef TTYDEF_IFLAG
+#define TTYDEF_IFLAG	(BRKINT | ICRNL | IMAXBEL | IXON | IXANY)
+#endif
+#ifndef TTYDEF_OFLAG
+#define TTYDEF_OFLAG	(OPOST | ONLCR /*| OXTABS*/)
+#endif
+#ifndef TTYDEF_LFLAG
+#define TTYDEF_LFLAG	(ECHO | ICANON | ISIG | IEXTEN | ECHOE|ECHOKE|ECHOCTL)
+#endif
+#ifndef TTYDEF_CFLAG
+#define TTYDEF_CFLAG	(CREAD | CS8 | HUPCL)
+#endif
 	tp->c_iflag |= TTYDEF_IFLAG;
 	tp->c_oflag |= TTYDEF_OFLAG;
 	tp->c_lflag |= TTYDEF_LFLAG;
@@ -159,6 +171,13 @@ static inline void reset_virtual_console
 # define TABDLY 0
 #endif
 
+#ifndef TAB0
+#define TAB0 0
+#endif
+#ifndef TABDLY
+#define TABDLY 0
+#endif
+
 	tp->c_iflag |=  (BRKINT | ICRNL | IMAXBEL);
 	tp->c_iflag &= ~(IGNBRK | INLCR | IGNCR | IXOFF | IUCLC | IXANY | ISTRIP);
 	tp->c_oflag |=  (OPOST | ONLCR | NL0 | CR0 | TAB0 | BS0 | VT0 | FF0);
@@ -203,7 +222,13 @@ static inline void reset_virtual_console
 	tp->c_cc[VSTOP]    = CSTOP;
 	tp->c_cc[VSUSP]    = CSUSP;
 	tp->c_cc[VEOL]     = _POSIX_VDISABLE;
+#ifndef CREPRINT
+#define CREPRINT	('r' & 037)
+#endif
 	tp->c_cc[VREPRINT] = CREPRINT;
+#ifndef CDISCARD
+#define CDISCARD	('o' & 037)
+#endif
 	tp->c_cc[VDISCARD] = CDISCARD;
 	tp->c_cc[VWERASE]  = CWERASE;
 	tp->c_cc[VLNEXT]   = CLNEXT;


[FILE:331:patches/patch-lib_randutils.c]
O_CLOEXEC is not available on every platform (e.g. MacOS X < 10.7). It
was introduced in POSIX 2008.

--- lib/randutils.c.orig	2025-01-09 10:14:54 UTC
+++ lib/randutils.c
@@ -78,6 +78,10 @@ static void crank_random(void)
 		rand();
 }
 
+#if !defined(O_CLOEXEC)
+#define O_CLOEXEC 0
+#endif
+
 int random_get_fd(void)
 {
 	int fd;


[FILE:1489:patches/patch-libuuid_src_gen__uuid.c]
fcntl is portable, flock is not.
Solaris does not have ifr.ifr_hwaddr.

--- libuuid/src/gen_uuid.c.orig	2025-01-09 10:14:54 UTC
+++ libuuid/src/gen_uuid.c
@@ -167,7 +167,7 @@ static int get_node_id(unsigned char *no
 	for (i = 0; i < n; i+= ifreq_size(*ifrp) ) {
 		ifrp = (struct ifreq *)((char *) ifc.ifc_buf+i);
 		strncpy(ifr.ifr_name, ifrp->ifr_name, IFNAMSIZ);
-#ifdef SIOCGIFHWADDR
+#if defined(SIOCGIFHWADDR) && !defined(__sun)
 		if (ioctl(sd, SIOCGIFHWADDR, &ifr) < 0)
 			continue;
 		a = (unsigned char *) &ifr.ifr_hwaddr.sa_data;
@@ -246,16 +246,22 @@ static int get_clock(uint32_t *clock_hig
 	THREAD_LOCAL int		state_fd = STATE_FD_INIT;
 	THREAD_LOCAL FILE		*state_f;
 	THREAD_LOCAL uint16_t		clock_seq;
+	struct flock			lock;
 	struct timeval			tv;
 	uint64_t			clock_reg;
 	int				ret = 0;
 
+	lock.l_whence = SEEK_SET;
+	lock.l_start = 0;
+	lock.l_len = 0;
+
 	if (state_fd == STATE_FD_INIT)
 		state_fd = state_fd_init(LIBUUID_CLOCK_FILE, &state_f);
 
 	if (state_fd >= 0) {
 		rewind(state_f);
-		while (flock(state_fd, LOCK_EX) < 0) {
+		lock.l_type = F_WRLCK;
+		while (fcntl(state_fd, F_SETLKW, &lock) < 0) {
 			if ((errno == EAGAIN) || (errno == EINTR))
 				continue;
 			fclose(state_f);
@@ -334,7 +340,8 @@ try_again:
 			      clock_seq, (long)last.tv_sec, (long)last.tv_usec, adjustment);
 		fflush(state_f);
 		rewind(state_f);
-		flock(state_fd, LOCK_UN);
+		lock.l_type = F_UNLCK;
+		fcntl(state_fd, F_SETLK, &lock);
 	}
 
 	*clock_high = clock_reg >> 32;

