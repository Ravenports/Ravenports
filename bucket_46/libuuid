# Buildsheet autogenerated by ravenadm tool -- Do not edit.

NAMEBASE=		libuuid
VERSION=		2.36
KEYWORDS=		misc devel
VARIANTS=		standard
SDESC[standard]=	Tool/Lib for generating Universally Unique IDs
HOMEPAGE=		https://github.com/karelzak/util-linux
CONTACT=		nobody

DOWNLOAD_GROUPS=	main
SITES[main]=		https://mirrors.edge.kernel.org/pub/linux/utils/util-linux/v2.36/
DISTFILE[1]=		util-linux-2.36.tar.xz:main
DF_INDEX=		1
SPKGS[standard]=	single

OPTIONS_AVAILABLE=	NOSETPROC
OPTIONS_STANDARD=	NOSETPROC
OPT_ON[freebsd]=	NOSETPROC
OPT_ON[sunos]=		NOSETPROC
OPT_ON[dragonfly]=	NOSETPROC

B_DEPS[sunos]=		libbsd4sol:single:standard

USES=			autoreconf cpe libtool pkgconfig gettext-tools:build
C_USES[sunos]=		perl:build

DISTNAME=		util-linux-2.36

LICENSE=		BSD3CLAUSE:single
LICENSE_FILE=		BSD3CLAUSE:{{WRKDIR}}/BSD3
LICENSE_AWK=		BSD3CLAUSE:"^$$"
LICENSE_SOURCE=		BSD3CLAUSE:{{WRKSRC}}/libuuid/src/uuid.h
LICENSE_SCHEME=		solo

CPE_PRODUCT=		util-linux
CPE_VENDOR=		kernel

MUST_CONFIGURE=		gnu
CONFIGURE_ARGS=		--disable-all-programs
			--disable-bash-completion
			--enable-libuuid
			--enable-uuidgen
			--without-ncurses
			--without-ncursesw
			--disable-nls
CONFIGURE_ENV=		ax_cv_check_vscript_flag=unsupported

INSTALL_TARGET=		install-strip
SOVERSION=		1.3.0

VAR_OPSYS[sunos]=	CFLAGS=-I{{LOCALBASE}}/include/bsd
			LDFLAGS=-lbsd
			CFLAGS=-DHAVE_STRNLEN
			CFLAGS=-DHAVE_STRNDUP

[NOSETPROC].DESCRIPTION=		Omit built-in setproctitle support

post-patch-NOSETPROC-ON:
	${REINPLACE_CMD} -e '/setproctitle.c/d' ${WRKSRC}/lib/Makemodule.am

post-install:
	${RM} -r ${STAGEDIR}${PREFIX}/share/bash-completion

post-patch-sunos:
	# there's a problem with nls, just mass-remove the macro
	${GREP} -rl '_(".*")' ${WRKSRC} | ${XARGS} \
		${PERL} -p -i.pbak -e 's|[_][(]["](.*?)["][)]|"\1"|g'

[FILE:568:descriptions/desc.single]
The UUID library is used to generate unique identifiers for objects
that may be accessible beyond the local system.  This library
generates UUIDs compatible with those created by the Open Software
Foundation (OSF) Distributed Computing Environment (DCE) utility
uuidgen.

The UUIDs generated by this library can be reasonably expected to be
unique within a system, and unique across all systems.  They could
be used, for instance, to generate unique HTTP cookies across multiple
web servers without communication between the servers, and without fear
of a name clash.


[FILE:101:distinfo]
9e4b1c67eb13b9b67feb32ae1dc0d50e08ce9e5d82e1cccd0ee771ad2fa9e0b1      5242420 util-linux-2.36.tar.xz


[FILE:412:manifests/plist.single]
bin/uuidgen
include/uuid/uuid.h
lib/
 libuuid.a
 libuuid.so
 libuuid.so.%%SOMAJOR%%
 libuuid.so.%%SOVERSION%%
lib/pkgconfig/uuid.pc
share/man/man1/uuidgen.1.gz
share/man/man3/
 uuid.3.gz
 uuid_clear.3.gz
 uuid_compare.3.gz
 uuid_copy.3.gz
 uuid_generate.3.gz
 uuid_generate_random.3.gz
 uuid_generate_time.3.gz
 uuid_generate_time_safe.3.gz
 uuid_is_null.3.gz
 uuid_parse.3.gz
 uuid_time.3.gz
 uuid_unparse.3.gz


[FILE:1241:patches/patch-configure.ac]
--- configure.ac.orig	2020-07-23 09:23:58 UTC
+++ configure.ac
@@ -1088,6 +1088,11 @@ AC_SUBST([LIBUUID_VERSION])
 AC_SUBST([LIBUUID_VERSION_INFO])
 AM_CONDITIONAL(BUILD_LIBUUID, test "x$build_libuuid" = xyes)
 
+AC_ARG_ENABLE([uuidgen],
+  AS_HELP_STRING([--disable-uuidgen], [do not build uuidgen]),
+  [], [UL_DEFAULT_ENABLE([uuidgen], [yes])]
+)
+
 AC_ARG_ENABLE([libuuid-force-uuidd],
   AS_HELP_STRING([--enable-libuuid-force-uuidd], [support uuidd even though the daemon is not built]),
   [], [enable_libuuid_force_uuidd=no]
@@ -1289,8 +1294,7 @@ AS_IF([test "x$build_uuidd" = xyes || te
 AM_CONDITIONAL([BUILD_UUIDD], [test "x$build_uuidd" = xyes])
 
 
-UL_BUILD_INIT([uuidgen], [check])
-UL_REQUIRES_BUILD([uuidgen], [libuuid])
+UL_BUILD_INIT([uuidgen])
 AM_CONDITIONAL([BUILD_UUIDGEN], [test "x$build_uuidgen" = xyes])
 
 UL_BUILD_INIT([uuidparse], [check])
@@ -1682,6 +1686,11 @@ AC_ARG_ENABLE([logger],
 UL_BUILD_INIT([logger])
 AM_CONDITIONAL([BUILD_LOGGER], [test "x$build_logger" = xyes])
 
+AC_ARG_ENABLE([mcookie],
+  AS_HELP_STRING([--disable-mcookie], [do not build mcookie]),
+  [], [UL_DEFAULT_ENABLE([mcookie], [check])]
+)
+
 UL_BUILD_INIT([look], [yes])
 AM_CONDITIONAL([BUILD_LOOK], [test "x$build_look" = xyes])
 


[FILE:340:patches/patch-include_c.h]
Add NAME_MAX compat.

--- include/c.h.orig	2020-07-01 10:38:43 UTC
+++ include/c.h
@@ -35,6 +35,10 @@
 # define NAME_MAX PATH_MAX
 #endif
 
+#ifndef NAME_MAX
+# define NAME_MAX PATH_MAX
+#endif
+
 /*
  * __GNUC_PREREQ is deprecated in favour of __has_attribute() and
  * __has_feature(). The __has macros are supported by clang and gcc>=5.


[FILE:1519:patches/patch-include_ttyutils.h]
Define values if missing.

--- include/ttyutils.h.orig	2020-02-27 09:26:34 UTC
+++ include/ttyutils.h
@@ -91,6 +91,18 @@ extern int get_terminal_name(const char
 static inline void reset_virtual_console(struct termios *tp, int flags)
 {
 	/* Use defaults of <sys/ttydefaults.h> for base settings */
+#ifndef TTYDEF_IFLAG
+#define TTYDEF_IFLAG	(BRKINT | ICRNL | IMAXBEL | IXON | IXANY)
+#endif
+#ifndef TTYDEF_OFLAG
+#define TTYDEF_OFLAG	(OPOST | ONLCR /*| OXTABS*/)
+#endif
+#ifndef TTYDEF_LFLAG
+#define TTYDEF_LFLAG	(ECHO | ICANON | ISIG | IEXTEN | ECHOE|ECHOKE|ECHOCTL)
+#endif
+#ifndef TTYDEF_CFLAG
+#define TTYDEF_CFLAG	(CREAD | CS8 | HUPCL)
+#endif
 	tp->c_iflag |= TTYDEF_IFLAG;
 	tp->c_oflag |= TTYDEF_OFLAG;
 	tp->c_lflag |= TTYDEF_LFLAG;
@@ -151,6 +163,13 @@ static inline void reset_virtual_console
 # define TABDLY 0
 #endif
 
+#ifndef TAB0
+#define TAB0 0
+#endif
+#ifndef TABDLY
+#define TABDLY 0
+#endif
+
 	tp->c_iflag |=  (BRKINT | ICRNL | IMAXBEL);
 	tp->c_iflag &= ~(IGNBRK | INLCR | IGNCR | IXOFF | IUCLC | IXANY | ISTRIP);
 	tp->c_oflag |=  (OPOST | ONLCR | NL0 | CR0 | TAB0 | BS0 | VT0 | FF0);
@@ -195,7 +214,13 @@ static inline void reset_virtual_console
 	tp->c_cc[VSTOP]    = CSTOP;
 	tp->c_cc[VSUSP]    = CSUSP;
 	tp->c_cc[VEOL]     = _POSIX_VDISABLE;
+#ifndef CREPRINT
+#define CREPRINT	('r' & 037)
+#endif
 	tp->c_cc[VREPRINT] = CREPRINT;
+#ifndef CDISCARD
+#define CDISCARD	('o' & 037)
+#endif
 	tp->c_cc[VDISCARD] = CDISCARD;
 	tp->c_cc[VWERASE]  = CWERASE;
 	tp->c_cc[VLNEXT]   = CLNEXT;


[FILE:693:patches/patch-lib_Makemodule.am]
Do not build common libraries.
Do not install terminal-colors.d.5.

--- lib/Makemodule.am.orig	2020-07-22 08:06:46 UTC
+++ lib/Makemodule.am
@@ -1,5 +1,4 @@
 
-noinst_LTLIBRARIES += libcommon.la
 libcommon_la_CFLAGS = $(AM_CFLAGS)
 libcommon_la_SOURCES = \
 	lib/blkdev.c \
@@ -56,7 +55,6 @@ libcommon_la_SOURCES += lib/sysfs.c
 endif
 endif
 
-noinst_LTLIBRARIES += libtcolors.la
 libtcolors_la_CFLAGS = $(AM_CFLAGS)
 libtcolors_la_SOURCES = lib/colors.c lib/color-names.c include/colors.h include/color-names.h
 libtcolors_la_LIBADD =
@@ -71,7 +69,6 @@ libtcolors_la_CFLAGS += $(NCURSES_CFLAGS
 endif
 endif # !HAVE_TINFO
 
-dist_man_MANS += lib/terminal-colors.d.5
 
 
 check_PROGRAMS += \


[FILE:334:patches/patch-lib_randutils.c]
O_CLOEXEC is not available on every platform (e.g. MacOS X < 10.7). It
was introduced in POSIX 2008.

--- lib/randutils.c.orig	2020-07-22 08:06:46 UTC
+++ lib/randutils.c
@@ -78,6 +78,10 @@ static void crank_random(void)
 		rand();
 }
 
+#if !defined(O_CLOEXEC)
+#define O_CLOEXEC 0
+#endif
+
 int random_get_fd(void)
 {
 	int i, fd;


[FILE:1457:patches/patch-libuuid_src_gen__uuid.c]
fcntl is portable, flock is not.
Solaris does not have ifr.ifr_hwaddr.

--- libuuid/src/gen_uuid.c.orig	2020-07-22 08:06:46 UTC
+++ libuuid/src/gen_uuid.c
@@ -169,7 +169,7 @@ static int get_node_id(unsigned char *no
 	for (i = 0; i < n; i+= ifreq_size(*ifrp) ) {
 		ifrp = (struct ifreq *)((char *) ifc.ifc_buf+i);
 		strncpy(ifr.ifr_name, ifrp->ifr_name, IFNAMSIZ);
-#ifdef SIOCGIFHWADDR
+#if defined(SIOCGIFHWADDR) && !defined(__sun)
 		if (ioctl(sd, SIOCGIFHWADDR, &ifr) < 0)
 			continue;
 		a = (unsigned char *) &ifr.ifr_hwaddr.sa_data;
@@ -224,12 +224,17 @@ static int get_clock(uint32_t *clock_hig
 	THREAD_LOCAL int		state_fd = -2;
 	THREAD_LOCAL FILE		*state_f;
 	THREAD_LOCAL uint16_t		clock_seq;
+	struct flock			lock;
 	struct timeval			tv;
 	uint64_t			clock_reg;
 	mode_t				save_umask;
 	int				len;
 	int				ret = 0;
 
+	lock.l_whence = SEEK_SET;
+	lock.l_start = 0;
+	lock.l_len = 0;
+
 	if (state_fd == -1)
 		ret = -1;
 
@@ -250,7 +255,8 @@ static int get_clock(uint32_t *clock_hig
 	}
 	if (state_fd >= 0) {
 		rewind(state_f);
-		while (flock(state_fd, LOCK_EX) < 0) {
+		lock.l_type = F_WRLCK;
+		while (fcntl(state_fd, F_SETLKW, &lock) < 0) {
 			if ((errno == EAGAIN) || (errno == EINTR))
 				continue;
 			fclose(state_f);
@@ -322,7 +328,8 @@ try_again:
 			fflush(state_f);
 		}
 		rewind(state_f);
-		flock(state_fd, LOCK_UN);
+		lock.l_type = F_UNLCK;
+		fcntl(state_fd, F_SETLK, &lock);
 	}
 
 	*clock_high = clock_reg >> 32;

