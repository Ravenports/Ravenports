# Buildsheet autogenerated by ravenadm tool -- Do not edit.

NAMEBASE=		unzoo
VERSION=		4.4
REVISION=		2
KEYWORDS=		archivers
VARIANTS=		std
SDESC[std]=		ZOO archive extractor
HOMEPAGE=		https://github.com/museoa/unzoo/
CONTACT=		nobody

DOWNLOAD_GROUPS=	main
SITES[main]=		GITHUB/museoa:unzoo:4.4
DISTFILE[1]=		generated:main
DF_INDEX=		1
SPKGS[std]=		set
			primary
			docs

OPTIONS_AVAILABLE=	none
OPTIONS_STANDARD=	none

USES=			cpe

LICENSE=		PUBDOM:primary
LICENSE_FILE=		PUBDOM:{{WRKDIR}}/LICENSE
LICENSE_AWK=		PUBDOM:"SYNTAX"
LICENSE_SOURCE=		PUBDOM:{{WRKSRC}}/src/unzoo.c
LICENSE_SCHEME=		solo

FPC_EQUIVALENT=		archivers/unzoo

CFLAGS=			-DSYS_IS_UNIX
			-DSYS_HAS_MKDIR
CVE_FIXED=		CVE-2007-1673 CVE-2015-1845

do-build:
	cd ${WRKSRC}/src && ${CC} ${CFLAGS} -o unzoo unzoo.c

do-install:
	${MKDIR} ${STAGEDIR}${STD_DOCDIR}
	${INSTALL_PROGRAM} ${WRKSRC}/src/unzoo ${STAGEDIR}${PREFIX}/bin
	${INSTALL_DATA} ${WRKSRC}/README.TXT ${STAGEDIR}${STD_DOCDIR}/unzoo.txt

[FILE:195:descriptions/desc.primary]
Unzoo is a zoo archive extractor written by Martin Schoenert. If unzoo is
called with no arguments, it will first print a summary of the commands
and then prompt for command lines interactively.


[FILE:102:distinfo]
929a4e0ae68478617bd6f4794c48586b40ce5109fabe594aa3d91d3e56b92f35        26954 museoa-unzoo-4.4.tar.gz


[FILE:10:manifests/plist.primary]
bin/unzoo


[FILE:26:manifests/plist.docs]
share/doc/unzoo/unzoo.txt


[FILE:4692:patches/patch-000-CVE-2015-1845]
Addresses CVE-2015-1845

Buffer overflow in the EntrReadArch function in unzoo might allow remote
attackers to execute arbitrary code via unspecified vectors.

--- src/unzoo.c.orig	2025-04-23 17:10:34 UTC
+++ src/unzoo.c
@@ -247,6 +247,7 @@
 *H
 */
 #include        <stdio.h>
+#include        <string.h>
 
 
 /****************************************************************************
@@ -508,16 +509,16 @@ FILE *          WritBinr;
 **  want to use the universal conversion function 'ConvName'.
 */
 #ifdef  SYS_IS_UNIX
-#define CONV_NAME(naml,namu)    strcpy( (naml), (namu) )
+#define CONV_NAME(naml,namu)    strncpy( (naml), (namu), sizeof((naml)) - 1 )
 #endif
 #ifdef  SYS_IS_DOS_DJGPP
 #define CONV_NAME(naml,namu)    ConvName( (naml), (namu), 8L, 3L, '_' )
 #endif
 #ifdef  SYS_IS_OS2_EMX
-#define CONV_NAME(naml,namu)    strcpy( (naml), (namu) )
+#define CONV_NAME(naml,namu)    strncpy( (naml), (namu), sizeof((naml)) - 1 )
 #endif
 #ifdef  SYS_IS_TOS_GCC
-#define CONV_NAME(naml,namu)    strcpy( (naml), (namu) )
+#define CONV_NAME(naml,namu)    strncpy( (naml), (namu), sizeof((naml)) - 1 )
 #endif
 #ifdef  SYS_IS_VMS
 #define CONV_NAME(naml,namu)    ConvName( (naml), (namu), 39L, 39L, '_' )
@@ -1224,9 +1225,13 @@ int             MakeDirs ( pre, patu )
         *d = '\0';  *n = '\0';
         CONV_DIRE( dirl, diru );
         CONV_NAME( naml, namu );
-        strcpy( patl, pre  );
-        strcat( patl, dirl );
-        strcat( patl, naml );
+        strncpy( patl, pre,  sizeof(patl) - 1 );
+        if ( sizeof(patl) - strnlen( patl, sizeof(patl) ) >
+             strnlen( dirl, sizeof( dirl ) ) + 1)
+            strncat( patl, dirl, sizeof( dirl ) );
+        if ( sizeof(patl) - strnlen( patl, sizeof(patl) ) >
+             strnlen( naml, sizeof( naml ) ) + 1)
+            strncat( patl, naml, sizeof(naml) );
         /*N 1993/11/03 martin what should I do with the return code?       */
         /*N 1993/11/03 martin it could be 0 if the directory exists!       */
         MAKE_DIRE( patl );
@@ -1583,14 +1588,17 @@ int             EntrReadArch ()
         CONV_NAME( Entry.naml, (Entry.lnamu ? Entry.namu : Entry.nams) );
     }
     else {
-        strcpy( Entry.dirl, Entry.diru );
-        strcpy( Entry.naml, (Entry.lnamu ? Entry.namu : Entry.nams) );
-    }
-    strcpy( Entry.patl, Entry.dirl );
-    strcat( Entry.patl, Entry.naml );
+        strncpy( Entry.dirl, Entry.diru, sizeof(Entry.dirl) - 1 );
+        strncpy( Entry.naml, (Entry.lnamu ? Entry.namu : Entry.nams),
+	         sizeof(Entry.naml) - 1 );
+    }
+    strncpy( Entry.patl, Entry.dirl, sizeof(Entry.patl) - 1 );
+    if ( sizeof( Entry.patl) - strnlen( Entry.patl, sizeof( Entry.patl ) ) >
+         strnlen( Entry.naml, sizeof( Entry.naml ) ) + 1 )
+        strncat( Entry.patl, Entry.naml, sizeof( Entry.naml ) );
 
     /* create the name with the version appended                           */
-    strcpy( Entry.patv, Entry.patl );
+    strncpy( Entry.patv, Entry.patl, sizeof(Entry.patv) - 1 );
     p = Entry.patv;  while ( *p != '\0' )  p++;
     *p++ = ';';
     for ( l = 10000; 0 < l; l /= 10 )
@@ -2349,7 +2357,9 @@ int             ListArch ( ver, arc, fil
     unsigned long       i;              /* loop variable                   */
 
     /* try to open the archive under various names                         */
-    strcpy(arczoo,arc);  strcat(arczoo,".zoo");
+    strncpy(arczoo,arc,sizeof(arczoo)-1);
+    if (sizeof(arczoo) - strnlen(arczoo, sizeof(arczoo)) > 5)
+    	strncat(arczoo,".zoo",4);
     if ( OpenReadArch(arc) ) {
         if ( ! DescReadArch() ) {
             ClosReadArch();
@@ -2504,7 +2514,9 @@ int             ExtrArch ( bim, out, ovr
     unsigned long       i;              /* loop variable                   */
 
     /* try to open the archive under various names                         */
-    strcpy(arczoo,arc);  strcat(arczoo,".zoo");
+    strncpy(arczoo,arc,sizeof(arczoo)-1);
+    if (sizeof(arczoo) - strnlen(arczoo, sizeof(arczoo)) > 5)
+    	strncat(arczoo,".zoo",4);
     if ( OpenReadArch(arc) ) {
         if ( ! DescReadArch() ) {
             ClosReadArch();
@@ -2577,7 +2589,10 @@ int             ExtrArch ( bim, out, ovr
         }
 
         /* check that such a file does not already exist                   */
-        strcpy( patl, pre );  strcat( patl, Entry.patl );
+        strncpy( patl, pre, sizeof( patl ) - 1 );
+        if ( sizeof(patl) - strnlen( patl, sizeof(patl) ) >
+             strnlen( Entry.patl, sizeof( Entry.patl ) ) + 1)
+            strncat( patl, Entry.patl, sizeof( Entry.patl ) );
         if ( out == 2 && ovr == 0 && OpenReadFile(patl,0L) ) {
             ClosReadFile();
             do {


[FILE:1525:patches/patch-001-CVE-2007-1673]
Addresses CVE-2007-1673

unzoo.c, as used in multiple products including AMaViS 2.4.1 and earlier,
allows remote attackers to cause a denial of service (infinite loop) via
a ZOO archive with a direntry structure that points to a previous file.
--- src/unzoo.c.orig	2025-04-23 17:10:34 UTC
+++ src/unzoo.c
@@ -2402,9 +2402,11 @@ int             ListArch ( ver, arc, fil
     /* loop over the members of the archive                                */
     Entry.posnxt = Descript.posent;
     while ( 1 ) {
+	unsigned long oldpos = Entry.posnxt;
 
         /* read the directory entry for the next member                    */
-        if ( ! GotoReadArch( Entry.posnxt ) || ! EntrReadArch() ) {
+        if ( ! GotoReadArch( Entry.posnxt ) || ! EntrReadArch() ||
+             Entry.posnxt <= oldpos ) {
             printf("unzoo: found bad directory entry in archive '%s'\n",arc);
             return 0;
         }
@@ -2558,9 +2560,11 @@ int             ExtrArch ( bim, out, ovr
     /* loop over the members of the archive                                */
     Entry.posnxt = Descript.posent;
     while ( 1 ) {
+	unsigned long oldpos = Entry.posnxt;
 
         /* read the directory entry for the next member                    */
-        if ( ! GotoReadArch( Entry.posnxt ) || ! EntrReadArch() ) {
+        if ( ! GotoReadArch( Entry.posnxt ) || ! EntrReadArch() ||
+             Entry.posnxt <= oldpos ) {
             printf("unzoo: found bad directory entry in archive '%s'\n",arc);
             return 0;
         }


[FILE:1322:patches/patch-002-fix-warnings]
--- src/unzoo.c.orig	2022-01-02 12:42:42 UTC
+++ src/unzoo.c
@@ -270,6 +270,11 @@
 **  must be opened in binary mode, so that for example no  <cr>/<lf> <-> <lf>
 **  translation happens.  You must supply a definition for each new port.
 */
+#include        <stdlib.h>
+#include        <sys/stat.h>
+#include        <sys/types.h>
+#include        <utime.h>
+
 #ifdef  SYS_IS_UNIX
 FILE *          ReadArch;
 #define OPEN_READ_ARCH(patl)    ((ReadArch = fopen( (patl), "r" )) != 0)
@@ -613,8 +618,8 @@ char            Cmd [256];
 **  members with the correct time as stored in the archive.
 */
 #ifdef  SYS_IS_UNIX
-unsigned int   Secs [2];
-#define SETF_TIME(patl,secs)    (Secs[0]=Secs[1]=(secs),!utime((patl),Secs))
+struct  utimbuf Secs;
+#define SETF_TIME(patl,secs)    (Secs.actime=Secs.modtime=(secs),!utime((patl),&Secs))
 #endif
 #ifdef  SYS_IS_DOS_DJGPP
 unsigned long   Secs [2];
@@ -1461,7 +1466,7 @@ struct {
 int             DescReadArch ()
 {
     /* read the text at the beginning                                      */
-    BlckReadArch(Descript.text,20L);  Descript.text[20] = '\0';
+    BlckReadArch(Descript.text,20L);  Descript.text[19] = '\0';
 
     /* try to read the magic words                                         */
     if ( (Descript.magic = WordReadArch()) != (unsigned long)0xfdc4a7dcL )

