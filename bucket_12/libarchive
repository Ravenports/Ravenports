# Buildsheet autogenerated by ravenadm tool -- Do not edit.

NAMEBASE=		libarchive
VERSION=		3.4.0
KEYWORDS=		archivers
VARIANTS=		standard static extended ravensw
SDESC[standard]=	Library to handle many streaming archive formats
SDESC[extended]=	Extended libarchive with lzo and lz4 capability
SDESC[static]=		Static build of libarchive
SDESC[ravensw]=		Zstd-only libarchive for ravensw
HOMEPAGE=		http://libarchive.org/
CONTACT=		nobody

DOWNLOAD_GROUPS=	main
SITES[main]=		http://libarchive.org/downloads/
			https://www.libarchive.de/downloads/
DISTFILE[1]=		libarchive-3.4.0.tar.gz:main
DF_INDEX=		1
SPKGS[standard]=	single
SPKGS[extended]=	single
SPKGS[static]=		single
SPKGS[ravensw]=		single

OPTIONS_AVAILABLE=	NOT_STD STATIC EXTENDED RAVENSW
OPTIONS_STANDARD=	none
VOPTS[extended]=	NOT_STD=ON STATIC=OFF EXTENDED=ON RAVENSW=OFF
VOPTS[static]=		NOT_STD=ON STATIC=ON EXTENDED=OFF RAVENSW=OFF
VOPTS[ravensw]=		NOT_STD=ON STATIC=OFF EXTENDED=OFF RAVENSW=ON

BUILD_DEPENDS=		expat:static:standard
			Zstandard:static:standard

USES=			cpe libtool

LICENSE=		BSD2CLAUSE:single BSD3CLAUSE:single PUBDOM:single
LICENSE_FILE=		BSD2CLAUSE:{{WRKSRC}}/COPYING
			BSD3CLAUSE:{{WRKSRC}}/COPYING
			PUBDOM:{{WRKSRC}}/COPYING
LICENSE_SCHEME=		multi

FPC_EQUIVALENT=		archivers/libarchive

INVALID_RPATH=		yes
MUST_CONFIGURE=		gnu
CONFIGURE_ARGS=		--without-xml2
			--without-iconv
			--disable-acl

INSTALL_TARGET=		install-strip
SOVERSION=		13.4.0

LDFLAGS=		-lpthread

[STATIC].DESCRIPTION=			Build version for raven sysroots
[STATIC].BUILD_DEPENDS_ON=		libressl:single:static
					xz:single:static
					bzip2:static:standard
					zlib:static:standard
[STATIC].CONFIGURE_ARGS_ON=		--enable-shared=no
					--enable-static=yes

[RAVENSW].DESCRIPTION=			Build zstd-only version for ravensw
[RAVENSW].BUILD_DEPENDS_ON=		libressl:single:static
					Zstandard:shared:standard
					expat:shared:standard
[RAVENSW].CONFIGURE_ARGS_ON=		--enable-shared=yes
					--enable-static=yes
					--without-zlib
					--without-bz2lib
					--without-libb2
					--without-lz4
					--without-lzo2
					--without-lzma
					--enable-bsdtar=no
					--enable-bsdcat=no
					--enable-bsdcpio=no

[EXTENDED].DESCRIPTION=			Build loaded version (common + lzo + lz4)
[EXTENDED].BUILDRUN_DEPENDS_ON=		expat:shared:standard
					Zstandard:shared:standard
					libressl:single:standard
					xz:single:standard
					bzip2:shared:standard
					zlib:shared:standard
					lzo:shared:standard
					lz4:shared:standard
[EXTENDED].BUILD_DEPENDS_ON=		bzip2:static:standard
					zlib:static:standard
					lzo:static:standard
					lz4:static:standard
[EXTENDED].CONFIGURE_ARGS_ON=		--enable-shared=yes
					--with-lzo2
					--with-lz4

[NOT_STD].DESCRIPTION=			Don't build common user version
[NOT_STD].BUILDRUN_DEPENDS_OFF=		libressl:single:standard
					expat:shared:standard
					xz:single:standard
					bzip2:shared:standard
					zlib:shared:standard
					Zstandard:shared:standard
[NOT_STD].BUILD_DEPENDS_OFF=		bzip2:static:standard
					zlib:static:standard
[NOT_STD].CONFIGURE_ARGS_OFF=		--enable-shared=yes

post-build-RAVENSW-ON:
	# assemble PIC library
	(cd ${WRKSRC}/libarchive/.libs &&\
	 ${AR} -cruv libarchive_pic.a *.o &&\
	 ranlib libarchive_pic.a)

do-test:
	(cd ${WRKSRC} && ${SETENV} ${MAKE_ENV} ${MAKE_CMD} check)

post-install-RAVENSW-ON:
	${RM} -r ${STAGEDIR}${MANPREFIX}/man/man[135]
	${RM} ${STAGEDIR}${PREFIX}/lib/libarchive.so*
	# install our PIC library
	${INSTALL_DATA} ${WRKSRC}/libarchive/.libs/libarchive_pic.a \
		${STAGEDIR}${PREFIX}/lib/

[FILE:1042:descriptions/desc.single]
The libarchive library features:
 * Support for a variety of archive and compression formats.
 * Robust automatic format detection, including archive/compression
   combinations such as tar.gz.
 * Zero-copy internal architecture for high performance.
 * Streaming architecture eliminates all limits on size of archive,
   limits on entry sizes depend on particular formats.
 * Carefully factored code to minimize bloat when programs are
   statically linked.
 * Growing test suite to verify correctness of new ports.
 * Works on most POSIX-like systems (including FreeBSD, Linux,
   Solaris, etc.)

The bsdtar and bsdcpio command-line utilities are feature- and
performance-competitive with other tar and cpio implementations:
 * Reads a variety of formats, including tar, pax, cpio, zip, xar,
   lha, ar, cab, mtree, rar, and ISO images.
 * Writes tar, pax, cpio, zip, xar, ar, ISO, mtree, and shar archives.
 * Automatically handles archives compressed with gzip, bzip2, lzip,
   xz, lzma, or compress.
 * Unique format conversion feature.


[FILE:102:distinfo]
8643d50ed40c759f5412a3af4e353cffbce4fdf3b5cf321cb72cacf06b2d825e      6908093 libarchive-3.4.0.tar.gz


[FILE:1281:manifests/plist.single]
bin/
 bsdcat
 bsdcpio
 bsdtar
include/
 archive.h
 archive_entry.h
lib/
 libarchive.a
 libarchive.so
 libarchive.so.%%SOMAJOR%%
 libarchive.so.%%SOVERSION%%
lib/pkgconfig/libarchive.pc
share/man/man1/
 bsdcat.1.gz
 bsdcpio.1.gz
 bsdtar.1.gz
share/man/man3/
 archive_entry.3.gz
 archive_entry_acl.3.gz
 archive_entry_linkify.3.gz
 archive_entry_misc.3.gz
 archive_entry_paths.3.gz
 archive_entry_perms.3.gz
 archive_entry_stat.3.gz
 archive_entry_time.3.gz
 archive_read.3.gz
 archive_read_add_passphrase.3.gz
 archive_read_data.3.gz
 archive_read_disk.3.gz
 archive_read_extract.3.gz
 archive_read_filter.3.gz
 archive_read_format.3.gz
 archive_read_free.3.gz
 archive_read_header.3.gz
 archive_read_new.3.gz
 archive_read_open.3.gz
 archive_read_set_options.3.gz
 archive_util.3.gz
 archive_write.3.gz
 archive_write_blocksize.3.gz
 archive_write_data.3.gz
 archive_write_disk.3.gz
 archive_write_filter.3.gz
 archive_write_finish_entry.3.gz
 archive_write_format.3.gz
 archive_write_free.3.gz
 archive_write_header.3.gz
 archive_write_new.3.gz
 archive_write_open.3.gz
 archive_write_set_options.3.gz
 archive_write_set_passphrase.3.gz
 libarchive.3.gz
 libarchive_changes.3.gz
 libarchive_internals.3.gz
share/man/man5/
 cpio.5.gz
 libarchive-formats.5.gz
 mtree.5.gz
 tar.5.gz


[FILE:1208:manifests/plist.single.static]
bin/
 bsdcat
 bsdcpio
 bsdtar
include/
 archive.h
 archive_entry.h
lib/libarchive.a
lib/pkgconfig/libarchive.pc
share/man/man1/
 bsdcat.1.gz
 bsdcpio.1.gz
 bsdtar.1.gz
share/man/man3/
 archive_entry.3.gz
 archive_entry_acl.3.gz
 archive_entry_linkify.3.gz
 archive_entry_misc.3.gz
 archive_entry_paths.3.gz
 archive_entry_perms.3.gz
 archive_entry_stat.3.gz
 archive_entry_time.3.gz
 archive_read.3.gz
 archive_read_add_passphrase.3.gz
 archive_read_data.3.gz
 archive_read_disk.3.gz
 archive_read_extract.3.gz
 archive_read_filter.3.gz
 archive_read_format.3.gz
 archive_read_free.3.gz
 archive_read_header.3.gz
 archive_read_new.3.gz
 archive_read_open.3.gz
 archive_read_set_options.3.gz
 archive_util.3.gz
 archive_write.3.gz
 archive_write_blocksize.3.gz
 archive_write_data.3.gz
 archive_write_disk.3.gz
 archive_write_filter.3.gz
 archive_write_finish_entry.3.gz
 archive_write_format.3.gz
 archive_write_free.3.gz
 archive_write_header.3.gz
 archive_write_new.3.gz
 archive_write_open.3.gz
 archive_write_set_options.3.gz
 archive_write_set_passphrase.3.gz
 libarchive.3.gz
 libarchive_changes.3.gz
 libarchive_internals.3.gz
share/man/man5/
 cpio.5.gz
 libarchive-formats.5.gz
 mtree.5.gz
 tar.5.gz


[FILE:102:manifests/plist.single.ravensw]
include/
 archive.h
 archive_entry.h
lib/
 libarchive.a
 libarchive_pic.a
lib/pkgconfig/libarchive.pc


[FILE:4574:patches/patch-fix-without-zlib]
From 64333cef68d7bcc67bef6ecf177fbeaa549b9139 Mon Sep 17 00:00:00 2001
From: Martin Matuska <martin@matuska.org>
Date: Sat, 29 Jun 2019 00:20:58 +0200
Subject: [PATCH] Unbreak compilation without zlib

Fixes #1214
---
 libarchive/archive_read_support_filter_gzip.c | 54 ++++++++++++-------
 libarchive/test/test_read_format_raw.c        |  4 ++
 2 files changed, 39 insertions(+), 19 deletions(-)

--- libarchive/archive_read_support_filter_gzip.c
+++ libarchive/archive_read_support_filter_gzip.c
@@ -131,12 +131,20 @@ archive_read_support_filter_gzip(struct archive *_a)
  */
 static ssize_t
 peek_at_header(struct archive_read_filter *filter, int *pbits,
-	       struct private_data *state)
+#ifdef HAVE_ZLIB_H
+	       struct private_data *state
+#else
+	       void *state
+#endif
+	      )
 {
 	const unsigned char *p;
 	ssize_t avail, len;
 	int bits = 0;
 	int header_flags;
+#ifndef HAVE_ZLIB_H
+	(void)state; /* UNUSED */
+#endif
 
 	/* Start by looking at the first ten bytes of the header, which
 	 * is all fixed layout. */
@@ -153,8 +161,10 @@ peek_at_header(struct archive_read_filter *filter, int *pbits,
 	bits += 3;
 	header_flags = p[3];
 	/* Bytes 4-7 are mod time in little endian. */
+#ifdef HAVE_ZLIB_H
 	if (state)
 		state->mtime = archive_le32dec(p + 4);
+#endif
 	/* Byte 8 is deflate flags. */
 	/* XXXX TODO: return deflate flags back to consume_header for use
 	   in initializing the decompressor. */
@@ -171,7 +181,9 @@ peek_at_header(struct archive_read_filter *filter, int *pbits,
 
 	/* Null-terminated optional filename. */
 	if (header_flags & 8) {
+#ifdef HAVE_ZLIB_H
 		ssize_t file_start = len;
+#endif
 		do {
 			++len;
 			if (avail < len)
@@ -181,11 +193,13 @@ peek_at_header(struct archive_read_filter *filter, int *pbits,
 				return (0);
 		} while (p[len - 1] != 0);
 
+#ifdef HAVE_ZLIB_H
 		if (state) {
 			/* Reset the name in case of repeat header reads. */
 			free(state->name);
 			state->name = strdup((const char *)&p[file_start]);
 		}
+#endif
 	}
 
 	/* Null-terminated optional comment. */
@@ -236,24 +250,6 @@ gzip_bidder_bid(struct archive_read_filter_bidder *self,
 	return (0);
 }
 
-static int
-gzip_read_header(struct archive_read_filter *self, struct archive_entry *entry)
-{
-	struct private_data *state;
-
-	state = (struct private_data *)self->data;
-
-	/* A mtime of 0 is considered invalid/missing. */
-	if (state->mtime != 0)
-		archive_entry_set_mtime(entry, state->mtime, 0);
-
-	/* If the name is available, extract it. */
-	if (state->name)
-		archive_entry_set_pathname(entry, state->name);
-
-	return (ARCHIVE_OK);
-}
-
 #ifndef HAVE_ZLIB_H
 
 /*
@@ -277,6 +273,24 @@ gzip_bidder_init(struct archive_read_filter *self)
 
 #else
 
+static int
+gzip_read_header(struct archive_read_filter *self, struct archive_entry *entry)
+{
+	struct private_data *state;
+
+	state = (struct private_data *)self->data;
+
+	/* A mtime of 0 is considered invalid/missing. */
+	if (state->mtime != 0)
+		archive_entry_set_mtime(entry, state->mtime, 0);
+
+	/* If the name is available, extract it. */
+	if (state->name)
+		archive_entry_set_pathname(entry, state->name);
+
+	return (ARCHIVE_OK);
+}
+
 /*
  * Initialize the filter object.
  */
@@ -306,7 +320,9 @@ gzip_bidder_init(struct archive_read_filter *self)
 	self->read = gzip_filter_read;
 	self->skip = NULL; /* not supported */
 	self->close = gzip_filter_close;
+#ifdef HAVE_ZLIB_H
 	self->read_header = gzip_read_header;
+#endif
 
 	state->in_stream = 0; /* We're not actually within a stream yet. */
 
--- libarchive/test/test_read_format_raw.c
+++ libarchive/test/test_read_format_raw.c
@@ -36,7 +36,9 @@ DEFINE_TEST(test_read_format_raw)
 	const char *reffile1 = "test_read_format_raw.data";
 	const char *reffile2 = "test_read_format_raw.data.Z";
 	const char *reffile3 = "test_read_format_raw.bufr";
+#ifdef HAVE_ZLIB_H
 	const char *reffile4 = "test_read_format_raw.data.gz";
+#endif
 
 	/* First, try pulling data out of an uninterpretable file. */
 	extract_reference_file(reffile1);
@@ -119,6 +121,7 @@ DEFINE_TEST(test_read_format_raw)
 	assertEqualIntA(a, ARCHIVE_OK, archive_read_close(a));
 	assertEqualInt(ARCHIVE_OK, archive_read_free(a));
 
+#ifdef HAVE_ZLIB_H
 	/* Fourth, try with gzip which has metadata. */
 	extract_reference_file(reffile4);
 	assert((a = archive_read_new()) != NULL);
@@ -144,4 +147,5 @@ DEFINE_TEST(test_read_format_raw)
 	assertEqualIntA(a, ARCHIVE_EOF, archive_read_next_header(a, &ae));
 	assertEqualIntA(a, ARCHIVE_OK, archive_read_close(a));
 	assertEqualInt(ARCHIVE_OK, archive_read_free(a));
+#endif
 }


[FILE:485:patches/patch-libarchive_archive__write__add__filter__zstd.c]
--- libarchive/archive_write_add_filter_zstd.c.orig	2019-06-12 21:05:16 UTC
+++ libarchive/archive_write_add_filter_zstd.c
@@ -96,7 +96,7 @@ archive_write_add_filter_zstd(struct arc
 	f->free = &archive_compressor_zstd_free;
 	f->code = ARCHIVE_FILTER_ZSTD;
 	f->name = "zstd";
-	data->compression_level = 3; /* Default level used by the zstd CLI */
+	data->compression_level = 7;
 #if HAVE_ZSTD_H && HAVE_LIBZSTD
 	data->cstream = ZSTD_createCStream();
 	if (data->cstream == NULL) {


[FILE:1625:patches/patch-libarchive_test_test__read__format__zip.c]
--- libarchive/test/test_read_format_zip.c.orig	2019-06-12 21:05:16 UTC
+++ libarchive/test/test_read_format_zip.c
@@ -139,7 +139,7 @@ verify_basic(struct archive *a, int seek
 	} else {
 		assertEqualInt(ARCHIVE_FAILED, archive_read_data(a, buff, 19));
 		assertEqualString(archive_error_string(a),
-		    "Unsupported ZIP compression method (deflation)");
+		    "Unsupported ZIP compression method (8: deflation)");
 		assert(archive_errno(a) != 0);
 	}
 
@@ -162,7 +162,7 @@ verify_basic(struct archive *a, int seek
 	} else {
 		assertEqualInt(ARCHIVE_FAILED, archive_read_data(a, buff, 19));
 		assertEqualString(archive_error_string(a),
-		    "Unsupported ZIP compression method (deflation)");
+		    "Unsupported ZIP compression method (8: deflation)");
 		assert(archive_errno(a) != 0);
 	}
 	assertEqualInt(ARCHIVE_EOF, archive_read_next_header(a, &ae));
@@ -231,7 +231,7 @@ verify_info_zip_ux(struct archive *a, in
 	} else {
 		assertEqualInt(ARCHIVE_FAILED, archive_read_data(a, buff, 19));
 		assertEqualString(archive_error_string(a),
-		    "Unsupported ZIP compression method (deflation)");
+		    "Unsupported ZIP compression method (8: deflation)");
 		assert(archive_errno(a) != 0);
 	}
 	assertEqualIntA(a, ARCHIVE_EOF, archive_read_next_header(a, &ae));
@@ -302,7 +302,7 @@ verify_extract_length_at_end(struct arch
 	} else {
 		assertEqualIntA(a, ARCHIVE_FAILED, archive_read_extract(a, ae, 0));
 		assertEqualString(archive_error_string(a),
-		    "Unsupported ZIP compression method (deflation)");
+		    "Unsupported ZIP compression method (8: deflation)");
 		assert(archive_errno(a) != 0);
 	}
 


[FILE:873:patches/patch-libarchive_test_test__read__format__zip__traditional__encryption__data.c]
--- libarchive/test/test_read_format_zip_traditional_encryption_data.c.orig	2019-06-12 21:05:16 UTC
+++ libarchive/test/test_read_format_zip_traditional_encryption_data.c
@@ -130,7 +130,7 @@ DEFINE_TEST(test_read_format_zip_traditi
 		assertEqualInt(ARCHIVE_FAILED,
 		    archive_read_data(a, buff, sizeof(buff)));
 		assertEqualString(archive_error_string(a),
-		    "Unsupported ZIP compression method (deflation)");
+		    "Unsupported ZIP compression method (8: deflation)");
 		assert(archive_errno(a) != 0);
 	}
 	
@@ -148,7 +148,7 @@ DEFINE_TEST(test_read_format_zip_traditi
 		assertEqualInt(ARCHIVE_FAILED,
 		    archive_read_data(a, buff, sizeof(buff)));
 		assertEqualString(archive_error_string(a),
-		    "Unsupported ZIP compression method (deflation)");
+		    "Unsupported ZIP compression method (8: deflation)");
 		assert(archive_errno(a) != 0);
 	}
 	


[FILE:530:patches/patch-libarchive_test_test__write__filter__zstd.c]
We changed the default from level 3 to level 7, so reverse the assert
accordingly.

--- libarchive/test/test_write_filter_zstd.c.orig	2019-06-12 21:05:16 UTC
+++ libarchive/test/test_write_filter_zstd.c
@@ -142,7 +142,7 @@ DEFINE_TEST(test_write_filter_zstd)
 
 	failure("compression-level=6 wrote %d bytes, default wrote %d bytes",
 	    (int)used2, (int)used1);
-	assert(used2 < used1);
+	assert(used2 > used1);
 
 	assert((a = archive_read_new()) != NULL);
 	assertEqualIntA(a, ARCHIVE_OK, archive_read_support_format_all(a));


[FILE:346:patches/patch-test__utils_test__main.c]
--- test_utils/test_main.c.orig	2019-06-12 21:05:16 UTC
+++ test_utils/test_main.c
@@ -3499,9 +3499,9 @@ static int
 test_run(int i, const char *tmpdir)
 {
 #ifdef PATH_MAX
-	char workdir[PATH_MAX];
+	char workdir[PATH_MAX+1];
 #else
-	char workdir[1024];
+	char workdir[1024+1];
 #endif
 	char logfilename[64];
 	int failures_before = failures;

