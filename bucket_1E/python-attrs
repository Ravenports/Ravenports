# Buildsheet autogenerated by ravenadm tool -- Do not edit.

NAMEBASE=		python-attrs
VERSION=		22.1.0
KEYWORDS=		python
VARIANTS=		py39 py310
SDESC[py310]=		Classes Without Boilerplate (3.10)
SDESC[py39]=		Classes Without Boilerplate (3.9)
HOMEPAGE=		https://www.attrs.org/
CONTACT=		Python_Automaton[python@ironwolf.systems]

DOWNLOAD_GROUPS=	main
SITES[main]=		PYPIWHL/f2/bc/d817287d1aa01878af07c19505fafd1165cd6a119e9d0821ca1d1c20312d
DISTFILE[1]=		attrs-22.1.0-py2.py3-none-any.whl:main
DF_INDEX=		1
SPKGS[py310]=		single
SPKGS[py39]=		single

OPTIONS_AVAILABLE=	PY39 PY310
OPTIONS_STANDARD=	none
VOPTS[py310]=		PY39=OFF PY310=ON
VOPTS[py39]=		PY39=ON PY310=OFF

DISTNAME=		attrs-22.1.0.dist-info

GENERATED=		yes

[PY39].USES_ON=				python:py39,wheel

[PY310].USES_ON=			python:py310,wheel

[FILE:2764:descriptions/desc.single]

.. image:: https://www.attrs.org/en/stable/_static/attrs_logo.png
   :alt: attrs logo
   :align: center

attrs is the Python package that will bring back the **joy** of **writing
classes** by relieving you from the drudgery of implementing object
protocols (aka [dunder methods]).
[Trusted by NASA] for Mars missions since 2020!

Its main goal is to help you to write **concise** and **correct** software
without slowing down your code.

.. teaser-end

For that, it gives you a class decorator and a way to declaratively define
the attributes on that class:

.. -code-begin-

.. code-block:: pycon

   >>> from attrs import asdict, define, make_class, Factory

   >>> @define
   ... class SomeClass:
   ...     a_number: int = 42
   ...     list_of_numbers: list[int] = Factory(list)
   ...
   ...     def hard_math(self, another_number):
   ...         return self.a_number + sum(self.list_of_numbers) *
another_number

   >>> sc = SomeClass(1, [1, 2, 3])
   >>> sc
   SomeClass(a_number=1, list_of_numbers=[1, 2, 3])

   >>> sc.hard_math(3)
   19
   >>> sc == SomeClass(1, [1, 2, 3])
   True
   >>> sc != SomeClass(2, [3, 2, 1])
   True

   >>> asdict(sc)
   {'a_number': 1, 'list_of_numbers': [1, 2, 3]}

   >>> SomeClass()
   SomeClass(a_number=42, list_of_numbers=[])

   >>> C = make_class("C", ["a", "b"])
   >>> C("foo", "bar")
   C(a='foo', b='bar')

After *declaring* your attributes, attrs gives you:

- a concise and explicit overview of the class's attributes,
- a nice human-readable __repr__,
- equality-checking methods,
- an initializer,
- and much more,

*without* writing dull boilerplate code again and again and *without*
runtime performance penalties.

**Hate type annotations**!?
No problem!
Types are entirely **optional** with attrs.
Simply assign ``attrs.field()`` to the attributes instead of annotating
them with types.

----

This example uses attrs's modern APIs that have been introduced in version
20.1.0, and the attrs package import name that has been added in version
21.3.0.
The classic APIs (``@attr.s``, ``attr.ib``, plus their serious-business
aliases) and the attr package import name will remain **indefinitely**.

Please check out [On The Core API Names] for a more in-depth explanation.

Data Classes
============

On the tin, attrs might remind you of dataclasses (and indeed, dataclasses
[are a descendant] of attrs).
In practice it does a lot more and is more flexible.
For instance it allows you to define [special handling of NumPy arrays for
equality checks], or allows more ways to [plug into the initialization
process].

For more details, please refer to our [comparison page].

.. -project-information-

Project Information
===================

- **License**: [MIT]
- **PyPI**: https://pypi.org/project/attrs/


[FILE:112:distinfo]
86efa402f67bf2df34f51a335487cf46b1ec130d02b8d39fd248abfd30da551c        58795 attrs-22.1.0-py2.py3-none-any.whl

