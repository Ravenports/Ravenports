# Buildsheet autogenerated by ravenadm tool -- Do not edit.

NAMEBASE=		python-attrs
VERSION=		21.4.0
KEYWORDS=		python
VARIANTS=		py39 py310
SDESC[py310]=		Classes Without Boilerplate (3.10)
SDESC[py39]=		Classes Without Boilerplate (3.9)
HOMEPAGE=		https://www.attrs.org/
CONTACT=		Python_Automaton[python@ironwolf.systems]

DOWNLOAD_GROUPS=	main
SITES[main]=		PYPIWHL/be/be/7abce643bfdf8ca01c48afa2ddf8308c2308b0c3b239a44e57d020afa0ef
DISTFILE[1]=		attrs-21.4.0-py2.py3-none-any.whl:main
DF_INDEX=		1
SPKGS[py310]=		single
SPKGS[py39]=		single

OPTIONS_AVAILABLE=	PY39 PY310
OPTIONS_STANDARD=	none
VOPTS[py310]=		PY39=OFF PY310=ON
VOPTS[py39]=		PY39=ON PY310=OFF

DISTNAME=		attrs-21.4.0.dist-info

GENERATED=		yes

[PY39].USES_ON=				python:py39,wheel

[PY310].USES_ON=			python:py310,wheel

[FILE:2747:descriptions/desc.single]

.. image:: https://www.attrs.org/en/stable/_static/attrs_logo.png
   :alt: attrs logo
   :align: center

attrs is the Python package that will bring back the **joy** of **writing
classes** by relieving you from the drudgery of implementing object
protocols (aka [dunder methods]).
[Trusted by NASA] for Mars missions since 2020!

Its main goal is to help you to write **concise** and **correct** software
without slowing down your code.

.. teaser-end

For that, it gives you a class decorator and a way to declaratively define
the attributes on that class:

.. -code-begin-

.. code-block:: pycon

   >>> from attrs import asdict, define, make_class, Factory

   >>> @define
   ... class SomeClass:
   ...     a_number: int = 42
   ...     list_of_numbers: list[int] = Factory(list)
   ...
   ...     def hard_math(self, another_number):
   ...         return self.a_number + sum(self.list_of_numbers) *
another_number

   >>> sc = SomeClass(1, [1, 2, 3])
   >>> sc
   SomeClass(a_number=1, list_of_numbers=[1, 2, 3])

   >>> sc.hard_math(3)
   19
   >>> sc == SomeClass(1, [1, 2, 3])
   True
   >>> sc != SomeClass(2, [3, 2, 1])
   True

   >>> asdict(sc)
   {'a_number': 1, 'list_of_numbers': [1, 2, 3]}

   >>> SomeClass()
   SomeClass(a_number=42, list_of_numbers=[])

   >>> C = make_class("C", ["a", "b"])
   >>> C("foo", "bar")
   C(a='foo', b='bar')

After *declaring* your attributes attrs gives you:

- a concise and explicit overview of the class's attributes,
- a nice human-readable __repr__,
- a equality-checking methods,
- an initializer,
- and much more,

*without* writing dull boilerplate code again and again and *without*
runtime performance penalties.

**Hate type annotations**!?
No problem!
Types are entirely **optional** with attrs.
Simply assign ``attrs.field()`` to the attributes instead of annotating
them with types.

----

This example uses attrs's modern APIs that have been introduced in version
20.1.0, and the attrs package import name that has been added in version
21.3.0.
The classic APIs (``@attr.s``, ``attr.ib``, plus their serious business
aliases) and the attr package import name will remain **indefinitely**.

Please check out [On The Core API Names] for a more in-depth explanation.

Data Classes
============

On the tin, attrs might remind you of dataclasses (and indeed, dataclasses
are a descendant of attrs).
In practice it does a lot more and is more flexible.
For instance it allows you to define [special handling of NumPy arrays for
equality checks], or allows more ways to [plug into the initialization
process].

For more details, please refer to our [comparison page].

.. -getting-help-

Getting Help
============

Please use the ``python-attrs`` tag on [Stack Overflow] to get help.



[FILE:112:distinfo]
2d27e3784d7a565d36ab851fe94887c5eccd6a463168875832a1be79c82828b4        60567 attrs-21.4.0-py2.py3-none-any.whl

