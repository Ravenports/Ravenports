# Buildsheet autogenerated by ravenadm tool -- Do not edit.

NAMEBASE=		vde2
VERSION=		2.3.2
KEYWORDS=		net
VARIANTS=		standard
SDESC[standard]=	User-mode virtual ethernet infrastructure
HOMEPAGE=		http://vde.sourceforge.net/
CONTACT=		nobody

DOWNLOAD_GROUPS=	main
SITES[main]=		SF/vde/vde2/2.3.2/
DISTFILE[1]=		vde2-2.3.2.tar.gz:main
DF_INDEX=		1
SPKGS[standard]=	single

OPTIONS_AVAILABLE=	none
OPTIONS_STANDARD=	none

BUILDRUN_DEPENDS=	libpcap:single:standard

USES=			gmake libtool ssl

LICENSE=		GPLv2+:single CUSTOM1:single
LICENSE_TERMS=		single:{{WRKDIR}}/TERMS
LICENSE_NAME=		CUSTOM1:"Slirp License"
LICENSE_FILE=		GPLv2+:{{WRKSRC}}/COPYING
			CUSTOM1:{{WRKSRC}}/COPYING.slirpvde
LICENSE_AWK=		TERMS:"^$$"
LICENSE_SOURCE=		TERMS:{{WRKSRC}}/include/libvdemgmt.h
LICENSE_SCHEME=		multi

FPC_EQUIVALENT=		net/vde2

MUST_CONFIGURE=		gnu
CONFIGURE_ARGS=		--disable-python

MAKE_ENV=		V=1
SINGLE_JOB=		yes

INSTALL_TARGET=		install-strip
INSTALL_REQ_TOOLCHAIN=	yes

VAR_OPSYS[linux]=	CFLAGS=-D_BSD_SOURCE=1

post-patch:
	${REINPLACE_CMD} -e '/-Wall/s|-O2||g' ${WRKSRC}/configure
	${REINPLACE_CMD} -e 's|$$(MAKE).*install-data-hook||g' \
		${WRKSRC}/man/Makefile.in
	${REINPLACE_CMD} -e 's|^AM_CFLAGS|#AM_CFLAGS|g' \
		${WRKSRC}/src/slirpvde/Makefile.in

post-install:
	${LN} -sf unixcmd.1 ${STAGEDIR}${MANPREFIX}/man/man1/vdecmd.1
	${LN} -sf vdeq.1 ${STAGEDIR}${MANPREFIX}/man/man1/vdeqemu.1
	${LN} -sf vdeq.1 ${STAGEDIR}${MANPREFIX}/man/man1/vdekvm.1

[FILE:312:descriptions/desc.single]
Virtual Distributed Ethernet is a user-mode virtual network (layer2)
infrastructure.  It can be used for network simulations, joining multiple
qemu instances together in a shared virtual network, or tunneling over the
Internet.  Physical hosts can be joined to the virtual network by means of
the tap(4) driver.


[FILE:96:distinfo]
22df546a63dac88320d35d61b7833bbbcbef13529ad009c7ce3c5cb32250af93       770257 vde2-2.3.2.tar.gz


[FILE:1202:manifests/plist.single]
%%ONLY-LINUX%%lib/vde2/
 libvdetap.a
 libvdetap.so
%%ONLY-LINUX%%libexec/vdetap
%%ONLY-LINUX%%sbin/vde_tunctl
bin/
 dpipe
 slirpvde
 unixcmd
 unixterm
 vde_autolink
 vde_cryptcab
 vde_l3
 vde_over_ns
 vde_pcapplug
 vde_plug
 vde_plug2tap
 vde_switch
 vdecmd
 vdekvm
 vdeq
 vdeqemu
 vdeterm
 wirefilter
etc/vde2/vdecmd
etc/vde2/libvdemgmt/
 asyncrecv.rc
 closemachine.rc
 openmachine.rc
 sendcmd.rc
include/
 libvdehist.h
 libvdemgmt.h
 libvdeplug.h
 libvdeplug_dyn.h
 libvdesnmp.h
lib/
 libvdehist.a
 libvdehist.so
 libvdehist.so.0
 libvdehist.so.0.0.1
 libvdemgmt.a
 libvdemgmt.so
 libvdemgmt.so.0
 libvdemgmt.so.0.0.1
 libvdeplug.a
 libvdeplug.so
 libvdeplug.so.3
 libvdeplug.so.3.0.1
 libvdesnmp.a
 libvdesnmp.so
 libvdesnmp.so.0
 libvdesnmp.so.0.0.1
lib/pkgconfig/
 vdehist.pc
 vdemgmt.pc
 vdeplug.pc
 vdesnmp.pc
lib/vde2/vde_l3/
 bfifo.so
 pfifo.so
 tbf.so
share/man/man1/
 dpipe.1.gz
 slirpvde.1.gz
 unixcmd.1.gz
 unixterm.1.gz
 vde_autolink.1.gz
 vde_cryptcab.1.gz
 vde_l3.1.gz
 vde_over_ns.1.gz
 vde_pcapplug.1.gz
 vde_plug.1.gz
 vde_plug2tap.1.gz
 vde_switch.1.gz
 vdecmd.1.gz
 vdekvm.1.gz
 vdeq.1.gz
 vdeqemu.1.gz
 vdetaplib.1.gz
 vdeterm.1.gz
 wirefilter.1.gz
share/man/man8/vde_tunctl.8.gz


[FILE:238:patches/patch-configure]
--- configure.orig	2019-01-04 20:38:31 UTC
+++ configure
@@ -17050,7 +17050,7 @@ $as_echo "#define VDE_DARWIN 1" >>confde
 
     darwin_gcc=yes
   ;;
-  freebsd*)
+  freebsd*|dragonfly*)
 
 $as_echo "#define VDE_FREEBSD 1" >>confdefs.h
 


[FILE:320:patches/patch-src_dpipe.c]
--- src/dpipe.c.orig	2011-11-23 16:41:18 UTC
+++ src/dpipe.c
@@ -201,7 +201,11 @@ int main(int argc, char *argv[])
 
 	if (daemonize != 0)
 		daemon(0,0);
+#ifdef __linux__
 	else if (setpgrp() != 0) {
+#else
+	else if (setpgrp(0,getpid()) != 0) {
+#endif
 		fprintf(stderr,"Err: cannot create pgrp\n");
 		exit(1);
 	}


[FILE:2723:patches/patch-src_vde__cryptcab_cryptcab.c]
--- src/vde_cryptcab/cryptcab.c.orig	2011-11-23 16:41:17 UTC
+++ src/vde_cryptcab/cryptcab.c
@@ -22,7 +22,11 @@ static void Usage(char *programname)
 	exit(1);
 }
 	
+#if OPENSSL_VERSION_NUMBER >= 0x1010100fL
+static EVP_CIPHER_CTX *ctx;
+#else
 static EVP_CIPHER_CTX ctx;
+#endif
 static int ctx_initialized = 0;
 static int encryption_disabled = 0;
 static int nfd;
@@ -103,19 +107,33 @@ int data_encrypt(unsigned char *src, uns
 	}
 
 	if (!ctx_initialized) {
+#if OPENSSL_VERSION_NUMBER >= 0x1010100fL
+		ctx = EVP_CIPHER_CTX_new();
+		EVP_CIPHER_CTX_init (ctx);
+#else
 		EVP_CIPHER_CTX_init (&ctx);
+#endif
 		ctx_initialized = 1;
 	}
 	
+#if OPENSSL_VERSION_NUMBER >= 0x1010100fL
+	EVP_EncryptInit (ctx, EVP_bf_cbc (), p->key, p->iv);
+	if (EVP_EncryptUpdate (ctx, dst, &olen, src, len) != 1)
+#else
 	EVP_EncryptInit (&ctx, EVP_bf_cbc (), p->key, p->iv);
 	if (EVP_EncryptUpdate (&ctx, dst, &olen, src, len) != 1)
+#endif
 	{
 		fprintf (stderr,"error in encrypt update\n");
 		olen = -1;
 		goto cleanup;
 	}
 
+#if OPENSSL_VERSION_NUMBER >= 0x1010100fL
+	if (EVP_EncryptFinal (ctx, dst + olen, &tlen) != 1)
+#else
 	if (EVP_EncryptFinal (&ctx, dst + olen, &tlen) != 1)
+#endif
 	{
 		fprintf (stderr,"error in encrypt final\n");
 		olen = -1;
@@ -124,7 +142,12 @@ int data_encrypt(unsigned char *src, uns
 	olen += tlen;
 
 cleanup:
-	EVP_CIPHER_CTX_cleanup(&ctx);	
+#if OPENSSL_VERSION_NUMBER >= 0x1010100fL
+	EVP_CIPHER_CTX_cleanup(ctx);	
+	EVP_CIPHER_CTX_free(ctx);
+#else
+	EVP_CIPHER_CTX_cleanup(&ctx);
+#endif
 	return olen;
 }
 
@@ -138,19 +161,33 @@ int data_decrypt(unsigned char *src, uns
 	}
 	
 	if (!ctx_initialized) {
+#if OPENSSL_VERSION_NUMBER >= 0x1010100fL
+		ctx = EVP_CIPHER_CTX_new();
+		EVP_CIPHER_CTX_init(ctx);
+#else
 		EVP_CIPHER_CTX_init (&ctx);
+#endif
 		ctx_initialized = 1;
 	}
 
+#if OPENSSL_VERSION_NUMBER >= 0x1010100fL
+	EVP_DecryptInit (ctx, EVP_bf_cbc (), p->key, p->iv);
+	if (EVP_DecryptUpdate (ctx, dst, &olen, src, len) != 1)
+#else
 	EVP_DecryptInit (&ctx, EVP_bf_cbc (), p->key, p->iv);
 	if (EVP_DecryptUpdate (&ctx, dst, &olen, src, len) != 1)
+#endif
 	{
 		fprintf (stderr,"error in decrypt update\n");
 		olen = -1;
 		goto cleanup;
 	}
 
+#if OPENSSL_VERSION_NUMBER >= 0x1010100fL
+	if (EVP_DecryptFinal (ctx, dst + olen, &tlen) != 1)
+#else
 	if (EVP_DecryptFinal (&ctx, dst + olen, &tlen) != 1)
+#endif
 	{
 		fprintf (stderr,"error in decrypt final\n");
 		olen = -1;
@@ -159,7 +196,12 @@ int data_decrypt(unsigned char *src, uns
 	olen += tlen;
 
 cleanup:
-	EVP_CIPHER_CTX_cleanup(&ctx);	
+#if OPENSSL_VERSION_NUMBER >= 0x1010100fL
+	EVP_CIPHER_CTX_cleanup(ctx);	
+	EVP_CIPHER_CTX_free(ctx);
+#else
+	EVP_CIPHER_CTX_cleanup(&ctx);
+#endif
 	return olen;
 }
 


[FILE:388:patches/patch-src_vde__pcapplug.c]
--- src/vde_pcapplug.c.orig	2011-11-23 16:41:18 UTC
+++ src/vde_pcapplug.c
@@ -196,7 +196,7 @@ void pcap_callback(u_char *u, const stru
 void setup_fd(int fd)
 {
 /* FreeBSD settings */
-#if defined(VDE_FREEBSD)
+#if 0 // BIOC* not defined by port libpcap 
 	/*
 	 * Tell the kernel that the header is fully-formed when it gets it.
 	 * This is required in order to fake the src address.


[FILE:313:patches/patch-src_vde__plug2tap.c]
--- src/vde_plug2tap.c.orig	2011-11-23 16:41:18 UTC
+++ src/vde_plug2tap.c
@@ -37,7 +37,11 @@
 #ifdef VDE_FREEBSD
 #include <sys/socket.h>
 #include <net/if.h>
+# ifdef __DragonFly__
+#include <net/tun/if_tun.h>
+# else
 #include <net/if_tun.h>
+# endif
 #endif
 
 #if defined(VDE_DARWIN) || defined(VDE_FREEBSD)

