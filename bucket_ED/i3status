# Buildsheet autogenerated by ravenadm tool -- Do not edit.

NAMEBASE=		i3status
VERSION=		2.14
REVISION=		1
KEYWORDS=		x11
VARIANTS=		standard
SDESC[standard]=	Status bar for i3bar, dzen2, xmobar or similar
HOMEPAGE=		https://i3wm.org/i3status/
CONTACT=		nobody

DOWNLOAD_GROUPS=	main
SITES[main]=		https://i3wm.org/i3status/
DISTFILE[1]=		i3status-2.14.tar.xz:main
DF_INDEX=		1
SPKGS[standard]=	single

OPTIONS_AVAILABLE=	none
OPTIONS_STANDARD=	none

BROKEN[linux]=		Assumes netlink and alsa headers present

BUILD_DEPENDS=		asciidoc:single:standard
			xmlto:single:standard
			bash:primary:standard
BUILDRUN_DEPENDS=	libconfuse:single:standard
			yajl:single:standard

USES=			meson pkgconfig perl:build

LICENSE=		BSD3CLAUSE:single
LICENSE_FILE=		BSD3CLAUSE:{{WRKSRC}}/LICENSE
LICENSE_SCHEME=		solo

FPC_EQUIVALENT=		x11/i3status
MESON_ARGS=		-Ddocs=true
			-Dmans=true
			-Dpulseaudio=false
			-Ddocdir=share/docs/i3status

post-install:
	${MV} ${STAGEDIR}${PREFIX}/etc/i3status.conf \
		${STAGEDIR}${PREFIX}/etc/i3status.conf.sample

pre-configure:
	${REINPLACE_CMD} -e 's|/etc|${PREFIX}/etc|g' ${WRKSRC}/i3status.c

[FILE:466:descriptions/desc.single]
i3status is a small program (about 1500 SLOC) for generating a status bar
for dzen2, xmobar or similar programs. It is designed to be very efficient
by issuing a very small number of system calls, as one generally wants to
update such a status line every second. This ensures that even under high
load, your status bar is updated correctly. Also, it saves a bit of energy
by not hogging your CPU as much as spawning the corresponding amount of
shell commands would.


[FILE:99:distinfo]
5c4d0273410f9fa3301fd32065deda32e9617fcae8b3cb34793061bf21644924        68900 i3status-2.14.tar.xz


[FILE:75:manifests/plist.single]
@sample etc/i3status.conf.sample
bin/i3status
share/man/man1/i3status.1.gz


[FILE:429:patches/patch-src_print__battery__info.c]
--- src/print_battery_info.c.orig	2021-11-09 07:27:11 UTC
+++ src/print_battery_info.c
@@ -593,7 +593,7 @@ void print_battery_info(battery_info_ctx
         ctx->format_percentage = "%.00f%s";
     }
 #endif
-#if defined(__FreeBSD__) || defined(__FreeBSD_kernel__) || defined(__DragonFly__) || defined(__OpenBSD__)
+#if defined(__OpenBSD__)
     /* These OSes report battery time in minutes. */
     hide_seconds = true;
 #endif


[FILE:1321:patches/patch-src_print__disk__info.c]
--- src/print_disk_info.c.orig	2021-11-09 07:27:11 UTC
+++ src/print_disk_info.c
@@ -63,7 +63,7 @@ static int print_bytes_human(char *outwa
  * Determines whether remaining bytes are below given threshold.
  *
  */
-#if defined(__FreeBSD__) || defined(__FreeBSD_kernel__) || defined(__OpenBSD__) || defined(__DragonFly__) || defined(__APPLE__)
+#if defined(__OpenBSD__) || defined(__APPLE__)
 static bool below_threshold(struct statfs buf, const char *prefix_type, const char *threshold_type, const double low_threshold) {
 #else
 static bool below_threshold(struct statvfs buf, const char *prefix_type, const char *threshold_type, const double low_threshold) {
@@ -124,17 +124,17 @@ void print_disk_info(disk_info_ctx_t *ct
 
     INSTANCE(ctx->path);
 
-#if defined(__FreeBSD__) || defined(__FreeBSD_kernel__) || defined(__OpenBSD__) || defined(__DragonFly__) || defined(__APPLE__)
+#if defined(__OpenBSD__) || defined(__APPLE__)
     struct statfs buf;
 
-    if (statfs(path, &buf) == -1)
+    if (statfs(ctx->path, &buf) == -1)
         return;
 
     mounted = true;
-#elif defined(__NetBSD__)
+#elif defined(__NetBSD__) || defined(__DragonFly__) || defined(__FreeBSD__)
     struct statvfs buf;
 
-    if (statvfs(path, &buf) == -1)
+    if (statvfs(ctx->path, &buf) == -1)
         return;
 
     mounted = true;


[FILE:1348:patches/patch-src_print__volume.c]
$NetBSD: patch-src_print__volume.c,v 1.3 2022/04/12 14:43:01 nia Exp $

Fix building on BSD. Upstream code was changed and the BSD paths
were not tested.

--- src/print_volume.c.orig	2021-11-09 07:27:11 UTC
+++ src/print_volume.c
@@ -250,8 +250,8 @@ void print_volume(volume_ctx_t *ctx) {
     const char *devicename = "UNSUPPORTED"; /* TODO: implement support for this */
     pbval = 1;
 
-    if (mixer_idx > 0)
-        asprintf(&mixerpath, "/dev/mixer%d", mixer_idx);
+    if (ctx->mixer_idx > 0)
+        asprintf(&mixerpath, "/dev/mixer%d", ctx->mixer_idx);
     else
         mixerpath = defaultmixer;
 
@@ -264,7 +264,7 @@ void print_volume(volume_ctx_t *ctx) {
         goto out;
     }
 
-    if (mixer_idx > 0)
+    if (ctx->mixer_idx > 0)
         free(mixerpath);
 
 #if defined(__NetBSD__) || defined(__OpenBSD__)
@@ -330,7 +330,7 @@ void print_volume(volume_ctx_t *ctx) {
 
         if (vinfo.un.ord) {
             START_COLOR("color_degraded");
-            fmt = fmt_muted;
+            ctx->fmt = ctx->fmt_muted;
             pbval = 0;
         }
     }
@@ -351,7 +351,7 @@ void print_volume(volume_ctx_t *ctx) {
     }
 
 #endif
-    buffer = apply_volume_format(fmt, buffer, vol & 0x7f, devicename);
+    ctx->buf = apply_volume_format(ctx->fmt, vol & 0x7f, devicename);
     close(mixfd);
     goto out_with_format;
 #endif

