# Buildsheet autogenerated by ravenadm tool -- Do not edit.

NAMEBASE=		libdrm
VERSION=		2.4.100
KEYWORDS=		graphics x11
VARIANTS=		standard
SDESC[standard]=	Direct Rendering Module services kernel interface
HOMEPAGE=		https://dri.freedesktop.org
CONTACT=		nobody

DOWNLOAD_GROUPS=	main
SITES[main]=		http://dri.freedesktop.org/libdrm/
DISTFILE[1]=		libdrm-2.4.100.tar.bz2:main
DF_INDEX=		1
SPKGS[standard]=	single

OPTIONS_AVAILABLE=	ARM X86
OPTIONS_STANDARD=	ARM X86
OPT_ON[aarch64]=	ARM
OPT_ON[x86_64]=		X86
OPT_ON[i386]=		X86

BUILD_DEPENDS=		libpthread-stubs:single:standard
			docbook-xsl:primary:standard
			libxslt:single:standard
			libxml2:single:standard

USES=			gmake libtool pkgconfig solaris-funcs
XORG_COMPONENTS=	pciaccess

LICENSE=		MIT:single
LICENSE_FILE=		MIT:{{WRKDIR}}/LICENSE_MIT
LICENSE_AWK=		MIT:"_XF86DRM_H_"
LICENSE_SOURCE=		MIT:{{WRKSRC}}/xf86drm.h
LICENSE_SCHEME=		solo

FPC_EQUIVALENT=		graphics/libdrm
SOL_FUNCTIONS=		getline:amdgpu/amdgpu_asic_id.c
			asprintf:tests/modetest/modetest.c
			strndup:tests/modetest/modetest.c

INVALID_RPATH=		yes
MUST_CONFIGURE=		gnu
CONFIGURE_ARGS=		--disable-cairo-tests
			--enable-install-test-programs
			--enable-manpages
			MISC_MAN_SUFFIX=7

INSTALL_TARGET=		install-strip
INSTALL_REQ_TOOLCHAIN=	yes

[X86].DESCRIPTION=			DRM Drivers for amd64 and i386 architectures

[ARM].DESCRIPTION=			DRM Drivers for AARCH64 architecture

post-patch:
	${REINPLACE_CMD} \
		-e '/^MANPAGES_STYLESHEET=/ s|".*"|"http://cdn.docbook.org/release/xsl/current/manpages/docbook.xsl"|' \
		${WRKSRC}/configure

[FILE:70:descriptions/desc.single]
Userspace interface to kernel DRM (Direct Rendering Module) services.


[FILE:101:distinfo]
c77cc828186c9ceec3e56ae202b43ee99eb932b4a87255038a80e8a1060d0a5d       855793 libdrm-2.4.100.tar.bz2


[FILE:2195:manifests/plist.single]
%%ARM-ON%%include/freedreno/
 freedreno_drmif.h
 freedreno_ringbuffer.h
%%ARM-ON%%include/libdrm/
 vc4_packet.h
 vc4_qpu_defines.h
%%ARM-ON%%lib/
 libdrm_freedreno.so
 libdrm_freedreno.so.1
 libdrm_freedreno.so.1.0.0
%%ARM-ON%%lib/pkgconfig/
 libdrm_freedreno.pc
 libdrm_vc4.pc
%%ONLY-DRAGONFLY%%bin/kmstest
%%ONLY-DRAGONFLY%%include/libkms/libkms.h
%%ONLY-DRAGONFLY%%lib/
 libkms.so
 libkms.so.1
 libkms.so.1.0.0
%%ONLY-DRAGONFLY%%lib/pkgconfig/libkms.pc
%%ONLY-FREEBSD%%bin/kmstest
%%ONLY-FREEBSD%%include/libkms/libkms.h
%%ONLY-FREEBSD%%lib/
 libkms.so
 libkms.so.1
 libkms.so.1.0.0
%%ONLY-FREEBSD%%lib/pkgconfig/libkms.pc
%%ONLY-LINUX%%bin/kmstest
%%ONLY-LINUX%%include/libkms/libkms.h
%%ONLY-LINUX%%lib/
 libkms.so
 libkms.so.1
 libkms.so.1.0.0
%%ONLY-LINUX%%lib/pkgconfig/libkms.pc
%%X86-ON%%include/libdrm/
 amdgpu.h
 amdgpu_drm.h
 intel_aub.h
 intel_bufmgr.h
 intel_debug.h
 r600_pci_ids.h
 radeon_bo.h
 radeon_bo_gem.h
 radeon_bo_int.h
 radeon_cs.h
 radeon_cs_gem.h
 radeon_cs_int.h
 radeon_surface.h
%%X86-ON%%include/libdrm/nouveau/nouveau.h
%%X86-ON%%include/libdrm/nouveau/nvif/
 cl0080.h
 cl9097.h
 class.h
 if0002.h
 if0003.h
 ioctl.h
 unpack.h
%%X86-ON%%lib/
 libdrm_amdgpu.so
 libdrm_amdgpu.so.1
 libdrm_amdgpu.so.1.0.0
 libdrm_intel.so
 libdrm_intel.so.1
 libdrm_intel.so.1.0.0
 libdrm_nouveau.so
 libdrm_nouveau.so.2
 libdrm_nouveau.so.2.0.0
 libdrm_radeon.so
 libdrm_radeon.so.1
 libdrm_radeon.so.1.0.1
%%X86-ON%%lib/pkgconfig/
 libdrm_amdgpu.pc
 libdrm_intel.pc
 libdrm_nouveau.pc
 libdrm_radeon.pc
%%X86-ON%%share/libdrm/amdgpu.ids
bin/
 drmdevice
 kms-steal-crtc
 kms-universal-planes
 modeprint
 modetest
 proptest
 vbltest
include/
 libsync.h
 xf86drm.h
 xf86drmMode.h
include/libdrm/
 drm.h
 drm_fourcc.h
 drm_mode.h
 drm_sarea.h
 i915_drm.h
 mach64_drm.h
 mga_drm.h
 msm_drm.h
 nouveau_drm.h
 qxl_drm.h
 r128_drm.h
 radeon_drm.h
 savage_drm.h
 sis_drm.h
 tegra_drm.h
 vc4_drm.h
 via_drm.h
 virtgpu_drm.h
 vmwgfx_drm.h
lib/
 libdrm.so
 libdrm.so.2
 libdrm.so.2.4.0
lib/pkgconfig/libdrm.pc
share/man/man3/
 drmAvailable.3.gz
 drmHandleEvent.3.gz
 drmModeGetResources.3.gz
share/man/man7/
 drm-gem.7.gz
 drm-kms.7.gz
 drm-memory.7.gz
 drm-mm.7.gz
 drm-ttm.7.gz
 drm.7.gz


[FILE:834:patches/patch-amdgpu_amdgpu__device.c]
--- amdgpu/amdgpu_device.c.orig	2019-10-16 21:36:48 UTC
+++ amdgpu/amdgpu_device.c
@@ -177,7 +177,12 @@ drm_public int amdgpu_device_initialize(
 			return r;
 		}
 		if ((flag_auth) && (!flag_authexist)) {
+#ifdef F_DUPFD_CLOEXEC
 			dev->flink_fd = fcntl(fd, F_DUPFD_CLOEXEC, 0);
+#else
+			dev->flink_fd = fcntl(fd, F_DUPFD, 0);
+			fcntl(dev->flink_fd, F_SETFD, FD_CLOEXEC);
+#endif
 		}
 		*major_version = dev->major_version;
 		*minor_version = dev->minor_version;
@@ -211,7 +216,12 @@ drm_public int amdgpu_device_initialize(
 		goto cleanup;
 	}
 
+#ifdef F_DUPFD_CLOEXEC
 	dev->fd = fcntl(fd, F_DUPFD_CLOEXEC, 0);
+#else
+	dev->fd = fcntl(fd, F_DUPFD, 0);
+	fcntl(dev->fd, F_SETFD, FD_CLOEXEC);
+#endif
 	dev->flink_fd = dev->fd;
 	dev->major_version = version->version_major;
 	dev->minor_version = version->version_minor;


[FILE:283:patches/patch-include_drm_drm.h]
--- include/drm/drm.h.orig	2019-10-16 21:36:48 UTC
+++ include/drm/drm.h
@@ -699,7 +699,11 @@ struct drm_set_client_cap {
 };
 
 #define DRM_RDWR O_RDWR
+#ifdef __sun__
+#define DRM_CLOEXEC 0
+#else
 #define DRM_CLOEXEC O_CLOEXEC
+#endif
 struct drm_prime_handle {
 	__u32 handle;
 


[FILE:691:patches/patch-intel_intel__bufmgr__gem.c]
--- intel/intel_bufmgr_gem.c.orig	2019-10-16 21:36:48 UTC
+++ intel/intel_bufmgr_gem.c
@@ -1005,6 +1005,27 @@ drm_intel_gem_bo_alloc_userptr(drm_intel
 	return &bo_gem->bo;
 }
 
+#ifdef __sun__
+#define posix_memalign	illumos_memalign
+static int
+posix_memalign(void **memptr, size_t alignment, size_t size)
+{
+	void *ptr = NULL;
+	int error = 0;
+
+	if (alignment == 0 ||
+	    (alignment & (sizeof (void *) - 1)) != 0 ||
+	    (alignment & (alignment - 1)) != 0)
+		error = EINVAL;
+	else if (size != 0 &&
+	    (ptr = memalign(alignment, size)) == NULL)
+		error = ENOMEM;
+
+	*memptr = ptr;
+	return (error);
+}
+#endif
+
 static bool
 has_userptr(drm_intel_bufmgr_gem *bufmgr_gem)
 {


[FILE:379:patches/patch-intel_test__decode.c]
--- intel/test_decode.c.orig	2019-10-16 21:36:48 UTC
+++ intel/test_decode.c
@@ -28,7 +28,13 @@
 #include <fcntl.h>
 #include <sys/types.h>
 #include <sys/stat.h>
+#ifdef __sun__
+#define errx(exitcode, format, args...) \
+	{ fprintf(stderr, format "\n", ## args); \
+	  exit(exitcode); }
+#else
 #include <err.h>
+#endif
 
 #include "libdrm_macros.h"
 #include "intel_bufmgr.h"


[FILE:852:patches/patch-libkms_vmwgfx.c]
# the defintion of ERESTART is behind a check for _KERNEL, but
# defining that causes errno to not be defined. fortunately, there's
# an alternative switch. unfortunately, those differ by platform and
# _WANT_KERNEL_ERRNO is too recent to be part of any release, so just
# define ERESTART if we still don't have it after including errno.h 
#
--- libkms/vmwgfx.c.orig	2019-10-16 21:36:48 UTC
+++ libkms/vmwgfx.c
@@ -26,10 +26,18 @@
  **************************************************************************/
 
 
+#if defined (__FreeBSD__) || defined (__FreeBSD_kernel__)
+#define _WANT_KERNEL_ERRNO
+#elif defined(__DragonFly__)
+#define _KERNEL_STRUCTURES
+#endif
 #include <errno.h>
 #include <stdlib.h>
 #include <string.h>
 #include "internal.h"
+#ifndef ERESTART
+#define ERESTART (-1)
+#endif
 
 #include "xf86drm.h"
 #include "libdrm_macros.h"


[FILE:521:patches/patch-libsync.h]
define ETIME as ETIMEOUT same as done in mesa

--- libsync.h.orig	2019-10-16 21:36:48 UTC
+++ libsync.h
@@ -35,6 +35,9 @@
 #include <sys/ioctl.h>
 #include <sys/poll.h>
 #include <unistd.h>
+#ifndef ETIME
+#define ETIME ETIMEDOUT
+#endif
 
 #if defined(__cplusplus)
 extern "C" {
@@ -53,6 +56,9 @@ struct sync_merge_data {
 	uint32_t	flags;
 	uint32_t	pad;
 };
+#ifdef __sun__
+#include <sys/ioccom.h>
+#endif
 #define SYNC_IOC_MAGIC		'>'
 #define SYNC_IOC_MERGE		_IOWR(SYNC_IOC_MAGIC, 3, struct sync_merge_data)
 #endif


[FILE:267:patches/patch-tests_drmdevice.c]
--- tests/drmdevice.c.orig	2019-10-16 21:36:48 UTC
+++ tests/drmdevice.c
@@ -31,6 +31,9 @@
 #include <unistd.h>
 #include <xf86drm.h>
 
+#ifndef O_CLOEXEC
+#define O_CLOEXEC 0
+#endif
 
 static void
 print_device_info(drmDevicePtr device, int i, bool print_revision)


[FILE:16850:patches/patch-xf86drm.c]
--- xf86drm.c.orig	2019-10-16 21:36:48 UTC
+++ xf86drm.c
@@ -31,6 +31,12 @@
  * DEALINGS IN THE SOFTWARE.
  */
 
+#if defined(__FreeBSD__) || defined(__FreeBSD_kernel__) || defined(__DragonFly__)
+#define FREEDFLY 1
+#else
+#define FREEDFLY 0
+#endif
+
 #include <stdio.h>
 #include <stdlib.h>
 #include <stdbool.h>
@@ -57,6 +63,12 @@
 #ifdef MAJOR_IN_SYSMACROS
 #include <sys/sysmacros.h>
 #endif
+#if FREEDFLY
+#include <sys/pciio.h>
+#endif
+#ifdef HAVE_SYS_SYSCTL_H
+#include <sys/sysctl.h>
+#endif
 #include <math.h>
 
 #define ARRAY_SIZE(a) (sizeof(a) / sizeof((a)[0]))
@@ -71,8 +83,12 @@
 
 #include "util_math.h"
 
-#if defined(__FreeBSD__) || defined(__FreeBSD_kernel__) || defined(__DragonFly__)
-#define DRM_MAJOR 145
+#ifndef O_CLOEXEC
+#define O_CLOEXEC 0
+#endif
+
+#if FREEDFLY
+#define DRM_MAJOR 0	/* Major ID unused on systems with devfs */
 #endif
 
 #ifdef __NetBSD__
@@ -212,6 +228,63 @@ drm_public drmHashEntry *drmGetEntry(int
     return entry;
 }
 
+#if FREEDFLY
+static int drmGetMinorBase(int type)
+{
+    switch (type) {
+        case DRM_NODE_PRIMARY:
+        case DRM_NODE_CONTROL:
+        case DRM_NODE_RENDER:
+            return type << 6;
+        default:
+            return -1;
+    };
+}
+
+static int drmGetMinorType(int minor)
+{
+    int type;
+
+    if (minor < 0)
+        return -1;
+
+    type = minor >> 6;
+    switch (type) {
+        case DRM_NODE_PRIMARY:
+        case DRM_NODE_CONTROL:
+        case DRM_NODE_RENDER:
+            return type;
+        default:
+            return -1;
+    }
+}
+
+static int drmGetNodeNumber(const char *name)
+{
+    size_t name_len = strnlen(name, DRM_NODE_NAME_MAX);
+    while (name_len && isdigit(name[name_len - 1]))
+        --name_len;
+    return strtol(name + name_len, NULL, 10);
+}
+#endif /* FREEDFLY */
+
+static int drmGetNodeType(const char *name)
+{
+    if (strncmp(name, DRM_PRIMARY_MINOR_NAME,
+                sizeof(DRM_PRIMARY_MINOR_NAME) - 1) == 0)
+        return DRM_NODE_PRIMARY;
+
+    if (strncmp(name, DRM_CONTROL_MINOR_NAME,
+                sizeof(DRM_CONTROL_MINOR_NAME ) - 1) == 0)
+        return DRM_NODE_CONTROL;
+
+    if (strncmp(name, DRM_RENDER_MINOR_NAME,
+                sizeof(DRM_RENDER_MINOR_NAME) - 1) == 0)
+        return DRM_NODE_RENDER;
+
+    return -EINVAL;
+}
+
 /**
  * Compare two busid strings
  *
@@ -343,7 +416,11 @@ static int drmOpenDevice(dev_t dev, int
     if (!dev_name)
         return -EINVAL;
 
+#if FREEDFLY
+    sprintf(buf, dev_name, DRM_DIR_NAME, minor + drmGetMinorBase(type));
+#else
     sprintf(buf, dev_name, DRM_DIR_NAME, minor);
+#endif
     drmMsg("drmOpenDevice: node name is %s\n", buf);
 
     if (drm_server_info && drm_server_info->get_perms) {
@@ -456,7 +533,11 @@ static int drmOpenMinor(int minor, int c
     if (!dev_name)
         return -EINVAL;
 
+#if FREEDFLY
+    sprintf(buf, dev_name, DRM_DIR_NAME, minor + drmGetMinorBase(type));
+#else
     sprintf(buf, dev_name, DRM_DIR_NAME, minor);
+#endif
     if ((fd = open(buf, O_RDWR | O_CLOEXEC, 0)) >= 0)
         return fd;
     return -errno;
@@ -497,6 +578,7 @@ drm_public int drmAvailable(void)
     return retval;
 }
 
+#if !FREEDFLY
 static int drmGetMinorBase(int type)
 {
     switch (type) {
@@ -527,7 +609,9 @@ static int drmGetMinorType(int minor)
         return -1;
     }
 }
+#endif /* !FREEDFLY */
 
+#ifdef __linux__
 static const char *drmGetMinorName(int type)
 {
     switch (type) {
@@ -541,6 +625,7 @@ static const char *drmGetMinorName(int t
         return NULL;
     }
 }
+#endif
 
 /**
  * Open the device by bus ID.
@@ -2552,7 +2637,7 @@ drm_public int drmCommandNone(int fd, un
 {
     unsigned long request;
 
-    request = DRM_IO( DRM_COMMAND_BASE + drmCommandIndex);
+    request = DRM_IO( (DRM_COMMAND_BASE + drmCommandIndex) );
 
     if (drmIoctl(fd, request, NULL)) {
         return -errno;
@@ -2744,7 +2829,6 @@ drm_public int drmIsMaster(int fd)
 
 drm_public char *drmGetDeviceNameFromFd(int fd)
 {
-    char name[128];
     struct stat sbuf;
     dev_t d;
     int i;
@@ -2758,14 +2842,12 @@ drm_public char *drmGetDeviceNameFromFd(
     d = sbuf.st_rdev;
 
     for (i = 0; i < DRM_MAX_MINOR; i++) {
+        char name[DRM_NODE_NAME_MAX];
         snprintf(name, sizeof name, DRM_DEV_NAME, DRM_DIR_NAME, i);
         if (stat(name, &sbuf) == 0 && sbuf.st_rdev == d)
-            break;
+            return strdup(name);
     }
-    if (i == DRM_MAX_MINOR)
-        return NULL;
-
-    return strdup(name);
+    return NULL;
 }
 
 static bool drmNodeIsDRM(int maj, int min)
@@ -2784,6 +2866,20 @@ static bool drmNodeIsDRM(int maj, int mi
 
 drm_public int drmGetNodeTypeFromFd(int fd)
 {
+#if FREEDFLY
+    char *name = drmGetDeviceNameFromFd2(fd);
+    int type;
+    if (!name) {
+        errno = ENODEV;
+        return -1;
+    }
+
+    type = drmGetNodeType(name);
+    free(name);
+    if (type < 0)
+        errno = ENODEV;
+    return type;
+#else
     struct stat sbuf;
     int maj, min, type;
 
@@ -2802,6 +2898,7 @@ drm_public int drmGetNodeTypeFromFd(int
     if (type == -1)
         errno = ENODEV;
     return type;
+#endif /* FREEDFLY */
 }
 
 drm_public int drmPrimeHandleToFD(int fd, uint32_t handle, uint32_t flags,
@@ -2880,6 +2977,23 @@ static char *drmGetMinorNameForFD(int fd
 
     closedir(sysdir);
     return NULL;
+#elif FREEDFLY
+    int oldnum, oldtype, newnum;
+    const char *dev_name = drmGetDeviceName(type);
+    char *name = drmGetDeviceNameFromFd2(fd);
+    if (!dev_name || !name)
+        return NULL;
+
+    oldnum = drmGetNodeNumber(name);
+    oldtype = drmGetMinorType(oldnum);
+    if (oldtype < 0) {
+        free(name);
+        return NULL;
+    }
+
+    newnum = oldnum - drmGetMinorBase(oldtype) + drmGetMinorBase(type);
+    snprintf(name, DRM_NODE_NAME_MAX, dev_name, DRM_DIR_NAME, newnum);
+    return name;
 #else
     struct stat sbuf;
     char buf[PATH_MAX + 1];
@@ -2900,7 +3014,7 @@ static char *drmGetMinorNameForFD(int fd
         return NULL;
 
     n = snprintf(buf, sizeof(buf), dev_name, DRM_DIR_NAME, min);
-    if (n == -1 || n >= sizeof(buf))
+    if (n == -1 || n >= (int)sizeof(buf))
         return NULL;
 
     return strdup(buf);
@@ -2998,7 +3112,7 @@ static int drmParseSubsystemType(int maj
     }
 
     return -EINVAL;
-#elif defined(__OpenBSD__) || defined(__DragonFly__)
+#elif defined(__OpenBSD__) || FREEDFLY
     return DRM_BUS_PCI;
 #else
 #warning "Missing implementation of drmParseSubsystemType"
@@ -3006,6 +3120,7 @@ static int drmParseSubsystemType(int maj
 #endif
 }
 
+#ifdef __linux__
 static void
 get_pci_path(int maj, int min, char *pci_path)
 {
@@ -3021,8 +3136,10 @@ get_pci_path(int maj, int min, char *pci
     if (term && strncmp(term, "/virtio", 7) == 0)
         *term = 0;
 }
+#endif
 
-static int drmParsePciBusInfo(int maj, int min, drmPciBusInfoPtr info)
+static int drmParsePciBusInfo(const char *node, int node_type,
+                              int maj, int min, drmPciBusInfoPtr info)
 {
 #ifdef __linux__
     unsigned int domain, bus, dev, func;
@@ -3047,7 +3164,62 @@ static int drmParsePciBusInfo(int maj, i
     info->func = func;
 
     return 0;
-#elif defined(__OpenBSD__) || defined(__DragonFly__)
+#elif FREEDFLY
+    /*
+     * Only the primary nodes can be mapped to hw.dri.%i via major/minor
+     * Determine the primary node by offset and use its major/minor pair
+     */
+    if (node_type != DRM_NODE_PRIMARY) {
+        char name[DRM_NODE_NAME_MAX];
+        stat_t sbuf;
+        snprintf(name, sizeof(name), DRM_DEV_NAME, DRM_DIR_NAME,
+                 drmGetNodeNumber(node) - drmGetMinorBase(node_type));
+
+        if (stat(name, &sbuf))
+            return -errno;
+
+        maj = major(sbuf.st_rdev);
+        min = minor(sbuf.st_rdev);
+    }
+    /*
+     * Major/minor appear after the driver name in the hw.dri.%i.name node
+     * Find the node with matching major/minor pair and parse the bus ID,
+     * which may be after the name or may be alone in hw.dri.%i.busid
+     */
+    #define bus_fmt "pci:%04x:%02x:%02x.%u"
+    #define name_fmt "%*s %x " bus_fmt
+    for (int i = 0; i < DRM_MAX_MINOR; ++i) {
+        char name[16], value[256];
+        unsigned int rdev = 0, domain = 0, bus = 0, slot = 0, func = 0;
+        int vals;
+        size_t length = sizeof(value);
+        snprintf(name, sizeof(name), "hw.dri.%i.name", i);
+        if (sysctlbyname(name, value, &length, NULL, 0))
+            continue;
+
+        value[length] = '\0';
+        vals = sscanf(value, name_fmt, &rdev, &domain, &bus, &slot, &func);
+
+	if (vals >= 1 && rdev == makedev(maj,min)) {
+            if (vals < 5) {
+                /* busid not in the name, try busid */
+                length = sizeof(value);
+                snprintf(name, sizeof(name), "hw.dri.%i.busid", i);
+                if (sysctlbyname(name, value, &length, NULL, 0))
+                    break;
+                value[length] = '\0';
+                if (sscanf(value, bus_fmt, &domain, &bus, &slot, &func) != 4)
+                    break;
+            }
+            info->domain = domain;
+            info->bus = bus;
+            info->dev = slot;
+            info->func = func;
+            return 0;
+        }
+    }
+    return -ENODEV;
+#elif defined(__OpenBSD__)
     struct drm_pciinfo pinfo;
     int fd, type;
 
@@ -3105,32 +3277,6 @@ drm_public int drmDevicesEqual(drmDevice
     return 0;
 }
 
-static int drmGetNodeType(const char *name)
-{
-    if (strncmp(name, DRM_CONTROL_MINOR_NAME,
-        sizeof(DRM_CONTROL_MINOR_NAME ) - 1) == 0)
-        return DRM_NODE_CONTROL;
-
-    if (strncmp(name, DRM_RENDER_MINOR_NAME,
-        sizeof(DRM_RENDER_MINOR_NAME) - 1) == 0)
-        return DRM_NODE_RENDER;
-
-    if (strncmp(name, DRM_PRIMARY_MINOR_NAME,
-        sizeof(DRM_PRIMARY_MINOR_NAME) - 1) == 0)
-        return DRM_NODE_PRIMARY;
-
-    return -EINVAL;
-}
-
-static int drmGetMaxNodeName(void)
-{
-    return sizeof(DRM_DIR_NAME) +
-           MAX3(sizeof(DRM_PRIMARY_MINOR_NAME),
-                sizeof(DRM_CONTROL_MINOR_NAME),
-                sizeof(DRM_RENDER_MINOR_NAME)) +
-           3 /* length of the node number */;
-}
-
 #ifdef __linux__
 static int parse_separate_sysfs_files(int maj, int min,
                                       drmPciDeviceInfoPtr device,
@@ -3202,6 +3348,7 @@ static int parse_config_sysfs_file(int m
 #endif
 
 static int drmParsePciDeviceInfo(int maj, int min,
+                                 drmPciBusInfoPtr info,
                                  drmPciDeviceInfoPtr device,
                                  uint32_t flags)
 {
@@ -3213,7 +3360,44 @@ static int drmParsePciDeviceInfo(int maj
         return parse_config_sysfs_file(maj, min, device);
 
     return 0;
-#elif defined(__OpenBSD__) || defined(__DragonFly__)
+#elif FREEDFLY
+    struct pci_conf_io pc;
+    struct pci_match_conf patterns[1];
+    struct pci_conf results[1];
+
+    int fd = open("/dev/pci", O_RDONLY, 0);
+    if (fd < 0)
+        return -errno;
+
+    bzero(&patterns, sizeof(patterns));
+    patterns[0].pc_sel.pc_domain = info->domain;
+    patterns[0].pc_sel.pc_bus = info->bus;
+    patterns[0].pc_sel.pc_dev = info->dev;
+    patterns[0].pc_sel.pc_func = info->func;
+    patterns[0].flags = PCI_GETCONF_MATCH_DOMAIN | PCI_GETCONF_MATCH_BUS
+                      | PCI_GETCONF_MATCH_DEV | PCI_GETCONF_MATCH_FUNC;
+    bzero(&pc, sizeof(struct pci_conf_io));
+    pc.num_patterns = 1;
+    pc.pat_buf_len = sizeof(patterns);
+    pc.patterns = patterns;
+    pc.match_buf_len = sizeof(results);
+    pc.matches = results;
+
+    if (ioctl(fd, PCIOCGETCONF, &pc) || pc.status == PCI_GETCONF_ERROR) {
+        int error = errno;
+        close(fd);
+        return -error;
+    }
+    close(fd);
+
+    device->vendor_id = results[0].pc_vendor;
+    device->device_id = results[0].pc_device;
+    device->subvendor_id = results[0].pc_subvendor;
+    device->subdevice_id = results[0].pc_subdevice;
+    device->revision_id = results[0].pc_revid;
+
+    return 0;
+#elif defined(__OpenBSD__)
     struct drm_pciinfo pinfo;
     int fd, type;
 
@@ -3318,7 +3502,7 @@ static drmDevicePtr drmDeviceAlloc(unsig
     unsigned int i;
     char *ptr;
 
-    max_node_length = ALIGN(drmGetMaxNodeName(), sizeof(void *));
+    max_node_length = ALIGN(DRM_NODE_NAME_MAX, sizeof(void *));
     extra = DRM_NODE_MAX * (sizeof(void *) + max_node_length);
 
     size = sizeof(*device) + extra + bus_size + device_size;
@@ -3364,7 +3548,7 @@ static int drmProcessPciDevice(drmDevice
 
     dev->businfo.pci = (drmPciBusInfoPtr)addr;
 
-    ret = drmParsePciBusInfo(maj, min, dev->businfo.pci);
+    ret = drmParsePciBusInfo(node, node_type, maj, min, dev->businfo.pci);
     if (ret)
         goto free_device;
 
@@ -3373,7 +3557,7 @@ static int drmProcessPciDevice(drmDevice
         addr += sizeof(drmPciBusInfo);
         dev->deviceinfo.pci = (drmPciDeviceInfoPtr)addr;
 
-        ret = drmParsePciDeviceInfo(maj, min, dev->deviceinfo.pci, flags);
+        ret = drmParsePciDeviceInfo(maj, min, dev->businfo.pci, dev->deviceinfo.pci, flags);
         if (ret)
             goto free_device;
     }
@@ -3675,7 +3859,7 @@ process_device(drmDevicePtr *device, con
                bool fetch_deviceinfo, uint32_t flags)
 {
     struct stat sbuf;
-    char node[PATH_MAX + 1];
+    char node[DRM_NODE_NAME_MAX];
     int node_type, subsystem_type;
     unsigned int maj, min;
 
@@ -3683,14 +3867,14 @@ process_device(drmDevicePtr *device, con
     if (node_type < 0)
         return -1;
 
-    snprintf(node, PATH_MAX, "%s/%s", DRM_DIR_NAME, d_name);
+    snprintf(node, sizeof(node), "%s/%s", DRM_DIR_NAME, d_name);
     if (stat(node, &sbuf))
         return -1;
 
     maj = major(sbuf.st_rdev);
     min = minor(sbuf.st_rdev);
 
-    if (!drmNodeIsDRM(maj, min) || !S_ISCHR(sbuf.st_mode))
+    if ((DRM_MAJOR && maj != DRM_MAJOR) || !S_ISCHR(sbuf.st_mode))
         return -1;
 
     subsystem_type = drmParseSubsystemType(maj, min);
@@ -3731,7 +3915,7 @@ static void drmFoldDuplicatedDevices(drm
                 local_devices[i]->available_nodes |= local_devices[j]->available_nodes;
                 node_type = log2(local_devices[j]->available_nodes);
                 memcpy(local_devices[i]->nodes[node_type],
-                       local_devices[j]->nodes[node_type], drmGetMaxNodeName());
+                       local_devices[j]->nodes[node_type], DRM_NODE_NAME_MAX);
                 drmFreeDevice(&local_devices[j]);
             }
         }
@@ -3790,7 +3974,7 @@ drm_public int drmGetDevice2(int fd, uin
      */
     drmDevicePtr     d;
     struct stat      sbuf;
-    char             node[PATH_MAX + 1];
+    char             node[DRM_NODE_NAME_MAX];
     const char      *dev_name;
     int              node_type, subsystem_type;
     int              maj, min, n, ret;
@@ -3804,7 +3988,7 @@ drm_public int drmGetDevice2(int fd, uin
     maj = major(sbuf.st_rdev);
     min = minor(sbuf.st_rdev);
 
-    if (!drmNodeIsDRM(maj, min) || !S_ISCHR(sbuf.st_mode))
+    if (DRM_MAJOR && !drmNodeIsDRM(maj, min) || !S_ISCHR(sbuf.st_mode))
         return -EINVAL;
 
     node_type = drmGetMinorType(min);
@@ -3815,8 +3999,8 @@ drm_public int drmGetDevice2(int fd, uin
     if (!dev_name)
         return -EINVAL;
 
-    n = snprintf(node, PATH_MAX, dev_name, DRM_DIR_NAME, min);
-    if (n == -1 || n >= PATH_MAX)
+    n = snprintf(node, sizeof(node), dev_name, DRM_DIR_NAME, min);
+    if (n == -1 || n >= (int)sizeof(node))
       return -errno;
     if (stat(node, &sbuf))
         return -EINVAL;
@@ -4030,9 +4214,27 @@ drm_public char *drmGetDeviceNameFromFd2
     free(value);
 
     return strdup(path);
+#elif FREEDFLY
+    stat_t sbuf;
+    dev_t rdev;
+    if (fstat(fd, &sbuf))
+        return NULL;
+
+    rdev = sbuf.st_rdev;
+    /* minor numbers don't depend on node name suffix, search for a match */
+    for (int i = 0; i < DRM_MAX_MINOR; ++i) {
+        char node[DRM_NODE_NAME_MAX];
+        for (int j = 0; j < DRM_NODE_MAX; ++j) {
+            snprintf(node, sizeof(node), drmGetDeviceName(j),
+                     DRM_DIR_NAME, drmGetMinorBase(j) + i);
+            if (stat(node, &sbuf) == 0 && sbuf.st_rdev == rdev)
+                return strdup(node);
+        }
+    }
+    return NULL;
 #else
     struct stat      sbuf;
-    char             node[PATH_MAX + 1];
+    char             node[DRM_NODE_NAME_MAX];
     const char      *dev_name;
     int              node_type;
     int              maj, min, n;
@@ -4054,8 +4256,8 @@ drm_public char *drmGetDeviceNameFromFd2
     if (!dev_name)
         return NULL;
 
-    n = snprintf(node, PATH_MAX, dev_name, DRM_DIR_NAME, min);
-    if (n == -1 || n >= PATH_MAX)
+    n = snprintf(node, sizeof(node), dev_name, DRM_DIR_NAME, min);
+    if (n == -1 || n >= (int)sizeof(node))
       return NULL;
 
     return strdup(node);


[FILE:397:patches/patch-xf86drm.h]
--- xf86drm.h.orig	2019-10-16 21:36:48 UTC
+++ xf86drm.h
@@ -59,6 +59,9 @@ extern "C" {
 #else /* One of the *BSDs */
 
 #include <sys/ioccom.h>
+#ifdef __sun__
+#define _IOC(inout,group,num,len)	(inout | ((len & IOCPARM_MASK) << 16) | ((group) << 8) | (num))
+#endif
 #define DRM_IOCTL_NR(n)         ((n) & 0xff)
 #define DRM_IOC_VOID            IOC_VOID
 #define DRM_IOC_READ            IOC_OUT


[FILE:3248:patches/patch-xf86drmMode.c]
--- xf86drmMode.c.orig	2019-10-16 21:36:48 UTC
+++ xf86drmMode.c
@@ -43,6 +43,7 @@
 #include <stdlib.h>
 #include <sys/ioctl.h>
 #ifdef HAVE_SYS_SYSCTL_H
+#include <sys/types.h>
 #include <sys/sysctl.h>
 #endif
 #include <stdio.h>
@@ -799,41 +800,59 @@ drm_public int drmCheckModesettingSuppor
 	closedir(sysdir);
 	if (found)
 		return 0;
-#elif defined (__FreeBSD__) || defined (__FreeBSD_kernel__)
-	char kbusid[1024], sbusid[1024];
-	char oid[128];
-	int domain, bus, dev, func;
-	int i, modesetting, ret;
-	size_t len;
+#elif defined (__FreeBSD__) || defined (__FreeBSD_kernel__) || defined (__DragonFly__)
+	#define bus_fmt "pci:%04x:%02x:%02x.%u"
+	#define name_fmt "%*s %*s " bus_fmt
+	unsigned int d1 = 0, b1 = 0, s1 = 0, f1 = 0;
+	if (sscanf(busid, bus_fmt, &d1, &b1, &s1, &f1) != 4)
+                return -EINVAL;
+	/*
+	 * hw.dri.%i.bus is not always present and hw.dri.%i.name does not
+	 * always contain the busid, so try both for best chance of success
+	 */
+	for (int i = 0; i < DRM_MAX_MINOR; ++i) {
+		char name[22], value[256];
+		unsigned int d2 = 0, b2 = 0, s2 = 0, f2 = 0;
+		size_t length = sizeof(value);
+		snprintf(name, sizeof(name), "hw.dri.%i.name", i);
+		if (sysctlbyname(name, value, &length, NULL, 0))
+			continue;
 
-	ret = sscanf(busid, "pci:%04x:%02x:%02x.%d", &domain, &bus, &dev,
-	    &func);
-	if (ret != 4)
-		return -EINVAL;
-	snprintf(kbusid, sizeof(kbusid), "pci:%04x:%02x:%02x.%d", domain, bus,
-	    dev, func);
+		value[length] = '\0';
+		switch (sscanf(value, name_fmt, &d2, &b2, &s2, &f2)) {
+		case 0: /* busid not in the name, try busid */
+			length = sizeof(value);
+			snprintf(name, sizeof(name), "hw.dri.%i.busid", i);
+			if (sysctlbyname(name, value, &length, NULL, 0))
+				continue;
 
-	/* How many GPUs do we expect in the machine ? */
-	for (i = 0; i < 16; i++) {
-		snprintf(oid, sizeof(oid), "hw.dri.%d.busid", i);
-		len = sizeof(sbusid);
-		ret = sysctlbyname(oid, sbusid, &len, NULL, 0);
-		if (ret == -1) {
-			if (errno == ENOENT)
+			value[length] = '\0';
+			if (sscanf(value, bus_fmt, &d2, &b2, &s2, &f2) != 4)
 				continue;
-			return -EINVAL;
+			/* fall through after parsing busid */
+
+		case 4: /* if we jumped here then busid was in the name */ 
+			if (d1 == d2 && b1 == b2 && s1 == s2 && f1 == f2) {
+			/*
+			 * Confirm the drm driver for this device supports KMS,
+			 * except on DragonFly where all the drm drivers do so
+			 * but only hw.dri.0.modesetting is present
+			 */ 
+			#ifndef __DragonFly__
+				int modesetting = 0;
+				length = sizeof(modesetting);
+				snprintf(name, sizeof(name), "hw.dri.%i.modesetting", i);
+				if (sysctlbyname(name, &modesetting, &length, NULL, 0)
+				 || length != sizeof(modesetting) || !modesetting)
+					return -ENOSYS;
+				else
+			#endif
+					return 0;
+			}
+		default:
+			break;
 		}
-		if (strcmp(sbusid, kbusid) != 0)
-			continue;
-		snprintf(oid, sizeof(oid), "hw.dri.%d.modesetting", i);
-		len = sizeof(modesetting);
-		ret = sysctlbyname(oid, &modesetting, &len, NULL, 0);
-		if (ret == -1 || len != sizeof(modesetting))
-			return -EINVAL;
-		return (modesetting ? 0 : -ENOSYS);
 	}
-#elif defined(__DragonFly__)
-	return 0;
 #elif defined(__OpenBSD__)
 	int	fd;
 	struct drm_mode_card_res res;

