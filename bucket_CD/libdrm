# Buildsheet autogenerated by ravenadm tool -- Do not edit.

NAMEBASE=		libdrm
VERSION=		2.4.84
REVISION=		1
KEYWORDS=		graphics x11
VARIANTS=		standard
SDESC[standard]=	Direct Rendering Module services kernel interface
HOMEPAGE=		https://dri.freedesktop.org
CONTACT=		nobody

DOWNLOAD_GROUPS=	main
SITES[main]=		http://dri.freedesktop.org/libdrm/
DISTFILE[1]=		libdrm-2.4.84.tar.bz2:main
DF_INDEX=		1
SPKGS[standard]=	single

OPTIONS_AVAILABLE=	ARM X86
OPTIONS_STANDARD=	ARM X86
OPT_ON[aarch64]=	ARM
OPT_ON[x86_64]=		X86
OPT_ON[i386]=		X86

BUILD_DEPENDS=		libpthread-stubs:single:standard
			docbook-xsl:primary:standard
			libxslt:single:standard
			libxml2:single:standard

USES=			gmake libtool pkgconfig
XORG_COMPONENTS=	pciaccess

FPC_EQUIVALENT=		graphics/libdrm

MUST_CONFIGURE=		gnu
CONFIGURE_ARGS=		--disable-cairo-tests
			--enable-install-test-programs
			--enable-manpages
			MANPAGES_STYLESHEET="http://cdn.docbook.org/release/xsl/current/manpages/docbook.xsl"

INSTALL_TARGET=		install-strip
INSTALL_REQ_TOOLCHAIN=	yes

[X86].DESCRIPTION=			DRM Drivers for amd64 and i386 architectures

[ARM].DESCRIPTION=			DRM Drivers for AARCH64 architecture

post-patch:
	${REINPLACE_CMD} -e '/^MANPAGES_STYLESHEET=/ s|".*"|"http://cdn.docbook.org/release/xsl/current/manpages/docbook.xsl"|' \
		${WRKSRC}/configure

[FILE:70:descriptions/desc.single]
Userspace interface to kernel DRM (Direct Rendering Module) services.


[FILE:100:distinfo]
7ae9c24d91139ac9a2cdee06fe46dbe1c401a1eda1c0bd2a6d1ecf72f479e0aa       794348 libdrm-2.4.84.tar.bz2


[FILE:1993:manifests/plist.single]
bin/
 kms-steal-crtc
 kms-universal-planes
 kmstest
 modeprint
 modetest
 proptest
 vbltest
%%ARM-ON%%include/freedreno/
 freedreno_drmif.h
 freedreno_ringbuffer.h
%%X86-ON%%include/libdrm/
 amdgpu.h
 amdgpu_drm.h
include/libdrm/
 drm.h
 drm_fourcc.h
 drm_mode.h
 drm_sarea.h
 i915_drm.h
%%X86-ON%%include/libdrm/
 intel_aub.h
 intel_bufmgr.h
 intel_debug.h
include/libdrm/
 mach64_drm.h
 mga_drm.h
%%X86-ON%%include/libdrm/nouveau/nouveau.h
%%X86-ON%%include/libdrm/nouveau/nvif/
 cl0080.h
 cl9097.h
 class.h
 if0002.h
 if0003.h
 ioctl.h
 unpack.h
include/libdrm/
 nouveau_drm.h
 qxl_drm.h
 r128_drm.h
%%X86-ON%%include/libdrm/
 r600_pci_ids.h
 radeon_bo.h
 radeon_bo_gem.h
 radeon_bo_int.h
 radeon_cs.h
 radeon_cs_gem.h
 radeon_cs_int.h
include/libdrm/
 radeon_drm.h
%%X86-ON%%include/libdrm/
 radeon_surface.h
include/libdrm/
 savage_drm.h
 sis_drm.h
 tegra_drm.h
 vc4_drm.h
%%ARM-ON%%include/libdrm/
 vc4_packet.h
 vc4_qpu_defines.h
include/libdrm/
 via_drm.h
 virtgpu_drm.h
 vmwgfx_drm.h
include/libkms/libkms.h
include/
 libsync.h
 xf86drm.h
 xf86drmMode.h
lib/
 libdrm.so
 libdrm.so.2
 libdrm.so.2.4.0
%%X86-ON%%lib/
 libdrm_amdgpu.so
 libdrm_amdgpu.so.1
 libdrm_amdgpu.so.1.0.0
%%ARM-ON%%lib/
 libdrm_freedreno.so
 libdrm_freedreno.so.1
 libdrm_freedreno.so.1.0.0
%%X86-ON%%lib/
 libdrm_intel.so
 libdrm_intel.so.1
 libdrm_intel.so.1.0.0
 libdrm_nouveau.so
 libdrm_nouveau.so.2
 libdrm_nouveau.so.2.0.0
 libdrm_radeon.so
 libdrm_radeon.so.1
 libdrm_radeon.so.1.0.1
lib/
 libkms.so
 libkms.so.1
 libkms.so.1.0.0
lib/pkgconfig/
 libdrm.pc
%%X86-ON%%lib/pkgconfig/
 libdrm_amdgpu.pc
%%ARM-ON%%lib/pkgconfig/
 libdrm_freedreno.pc
%%X86-ON%%lib/pkgconfig/
 libdrm_intel.pc
 libdrm_nouveau.pc
 libdrm_radeon.pc
%%ARM-ON%%lib/pkgconfig/
 libdrm_vc4.pc
lib/pkgconfig/
 libkms.pc
%%X86-ON%%share/libdrm/amdgpu.ids
share/man/man3/
 drmAvailable.3.gz
 drmHandleEvent.3.gz
 drmModeGetResources.3.gz
share/man/man7/
 drm-gem.7.gz
 drm-kms.7.gz
 drm-memory.7.gz
 drm-mm.7.gz
 drm-ttm.7.gz
 drm.7.gz


[FILE:801:patches/patch-libkms_vmwgfx.c]
# the defintion of ERESTART is behind a check for _KERNEL, but
# defining that causes errno to not be defined. fortunately, there's
# an alternative switch. unfortunately, those differ by platform and
# _WANT_KERNEL_ERRNO is too recent to be part of any release, so just
# define ERESTART if we still don't have it after including errno.h 
#
--- libkms/vmwgfx.c.orig	2017-04-14 23:29:46 UTC
+++ libkms/vmwgfx.c
@@ -30,10 +30,18 @@
 #include "config.h"
 #endif
 
+#if defined (__FreeBSD__) || defined (__FreeBSD_kernel__)
+#define _WANT_KERNEL_ERRNO
+#elif defined(__DragonFly__)
+#define _KERNEL_STRUCTURES
+#endif
 #include <errno.h>
 #include <stdlib.h>
 #include <string.h>
 #include "internal.h"
+#ifndef ERESTART
+#define ERESTART (-1)
+#endif
 
 #include "xf86drm.h"
 #include "libdrm_macros.h"


[FILE:283:patches/patch-libsync.h]
# define ETIME as ETIMEOUT same as done in Mesa
#
--- libsync.h.orig	2017-04-14 23:29:46 UTC
+++ libsync.h
@@ -35,6 +35,9 @@
 #include <sys/ioctl.h>
 #include <sys/poll.h>
 #include <unistd.h>
+#ifndef ETIME
+#define ETIME ETIMEDOUT
+#endif
 
 #if defined(__cplusplus)
 extern "C" {


[FILE:24053:patches/patch-xf86drm.c]
--- xf86drm.c.orig	2017-07-19 09:37:32 UTC
+++ xf86drm.c
@@ -49,6 +49,9 @@
 #include <signal.h>
 #include <time.h>
 #include <sys/types.h>
+#ifdef HAVE_SYS_SYSCTL_H
+#include <sys/sysctl.h>
+#endif
 #include <sys/stat.h>
 #define stat_t struct stat
 #include <sys/ioctl.h>
@@ -62,6 +65,10 @@
 #endif
 #include <math.h>
 
+#if defined(__FreeBSD__) || defined(__FreeBSD_kernel__) || defined(__DragonFly__)
+#include <sys/pciio.h>
+#endif
+
 /* Not all systems have MAP_FAILED defined */
 #ifndef MAP_FAILED
 #define MAP_FAILED ((void *)-1)
@@ -72,18 +79,8 @@
 
 #include "util_math.h"
 
-#ifdef __OpenBSD__
-#define DRM_PRIMARY_MINOR_NAME  "drm"
-#define DRM_CONTROL_MINOR_NAME  "drmC"
-#define DRM_RENDER_MINOR_NAME   "drmR"
-#else
-#define DRM_PRIMARY_MINOR_NAME  "card"
-#define DRM_CONTROL_MINOR_NAME  "controlD"
-#define DRM_RENDER_MINOR_NAME   "renderD"
-#endif
-
 #if defined(__FreeBSD__) || defined(__FreeBSD_kernel__) || defined(__DragonFly__)
-#define DRM_MAJOR 145
+#define DRM_MAJOR 0	/* Major ID unused on systems with devfs */
 #endif
 
 #ifdef __NetBSD__
@@ -180,7 +177,7 @@ void drmFree(void *pt)
 }
 
 /**
- * Call ioctl, restarting if it is interupted
+ * Call ioctl, restarting if it is interrupted
  */
 int
 drmIoctl(int fd, unsigned long request, void *arg)
@@ -223,6 +220,89 @@ drmHashEntry *drmGetEntry(int fd)
     return entry;
 }
 
+static int drmGetMinorBase(int type)
+{
+    switch (type) {
+        case DRM_NODE_PRIMARY:
+        case DRM_NODE_CONTROL:
+        case DRM_NODE_RENDER:
+            return type << 6;
+        default:
+            return -1;
+    };
+}
+
+static int drmGetMinorType(int minor)
+{
+    if (minor < 0)
+        return -1;
+
+    int type = minor >> 6;
+    switch (type) {
+        case DRM_NODE_PRIMARY:
+        case DRM_NODE_CONTROL:
+        case DRM_NODE_RENDER:
+            return type;
+        default:
+            return -1;
+    }
+}
+
+#ifdef __linux__
+static const char *drmGetMinorName(int type)
+{
+    switch (type) {
+        case DRM_NODE_PRIMARY:
+            return DRM_PRIMARY_MINOR_NAME;
+        case DRM_NODE_CONTROL:
+            return DRM_CONTROL_MINOR_NAME;
+        case DRM_NODE_RENDER:
+            return DRM_RENDER_MINOR_NAME;
+        default:
+            return NULL;
+    }
+}
+#endif
+
+static const char *drmGetDeviceName(int type)
+{
+    switch (type) {
+        case DRM_NODE_PRIMARY:
+            return DRM_DEV_NAME;
+        case DRM_NODE_CONTROL:
+            return DRM_CONTROL_DEV_NAME;
+        case DRM_NODE_RENDER:
+            return DRM_RENDER_DEV_NAME;
+        default:
+            return NULL;
+    }
+}
+
+static int drmGetNodeNumber(const char *name)
+{
+    size_t name_len = strnlen(name, DRM_NODE_NAME_MAX);
+    while (name_len && isdigit(name[name_len - 1]))
+        --name_len;
+    return strtol(name + name_len, NULL, 10);
+}
+
+static int drmGetNodeType(const char *name)
+{
+    if (strncmp(name, DRM_PRIMARY_MINOR_NAME,
+                sizeof(DRM_PRIMARY_MINOR_NAME) - 1) == 0)
+        return DRM_NODE_PRIMARY;
+
+    if (strncmp(name, DRM_CONTROL_MINOR_NAME,
+                sizeof(DRM_CONTROL_MINOR_NAME ) - 1) == 0)
+        return DRM_NODE_CONTROL;
+
+    if (strncmp(name, DRM_RENDER_MINOR_NAME,
+                sizeof(DRM_RENDER_MINOR_NAME) - 1) == 0)
+        return DRM_NODE_RENDER;
+
+    return -1;
+}
+
 /**
  * Compare two busid strings
  *
@@ -290,7 +370,7 @@ static int drmMatchBusID(const char *id1
  *
  * \internal
  * Checks for failure. If failure was caused by signal call chown again.
- * If any other failure happened then it will output error mesage using
+ * If any other failure happened then it will output error message using
  * drmMsg() call.
  */
 #if !defined(UDEV)
@@ -327,8 +407,8 @@ static int chown_check_return(const char
 static int drmOpenDevice(dev_t dev, int minor, int type)
 {
     stat_t          st;
-    const char      *dev_name;
-    char            buf[64];
+    const char      *dev_name = drmGetDeviceName(type);
+    char            buf[DRM_NODE_NAME_MAX];
     int             fd;
     mode_t          devmode = DRM_DEV_MODE, serv_mode;
     gid_t           serv_group;
@@ -338,21 +418,14 @@ static int drmOpenDevice(dev_t dev, int
     gid_t           group   = DRM_DEV_GID;
 #endif
 
-    switch (type) {
-    case DRM_NODE_PRIMARY:
-        dev_name = DRM_DEV_NAME;
-        break;
-    case DRM_NODE_CONTROL:
-        dev_name = DRM_CONTROL_DEV_NAME;
-        break;
-    case DRM_NODE_RENDER:
-        dev_name = DRM_RENDER_DEV_NAME;
-        break;
-    default:
+    if (!dev_name)
         return -EINVAL;
-    };
 
+#if defined(__FreeBSD__) || defined(__FreeBSD_kernel__) || defined(__DragonFly__)
+    sprintf(buf, dev_name, DRM_DIR_NAME, minor + drmGetMinorBase(type));
+#else
     sprintf(buf, dev_name, DRM_DIR_NAME, minor);
+#endif
     drmMsg("drmOpenDevice: node name is %s\n", buf);
 
     if (drm_server_info && drm_server_info->get_perms) {
@@ -456,27 +529,20 @@ wait_for_udev:
 static int drmOpenMinor(int minor, int create, int type)
 {
     int  fd;
-    char buf[64];
-    const char *dev_name;
+    char buf[DRM_NODE_NAME_MAX];
+    const char *dev_name = drmGetDeviceName(type);
 
     if (create)
         return drmOpenDevice(makedev(DRM_MAJOR, minor), minor, type);
 
-    switch (type) {
-    case DRM_NODE_PRIMARY:
-        dev_name = DRM_DEV_NAME;
-        break;
-    case DRM_NODE_CONTROL:
-        dev_name = DRM_CONTROL_DEV_NAME;
-        break;
-    case DRM_NODE_RENDER:
-        dev_name = DRM_RENDER_DEV_NAME;
-        break;
-    default:
+    if (!dev_name)
         return -EINVAL;
-    };
 
+#if defined(__FreeBSD__) || defined(__FreeBSD_kernel__) || defined(__DragonFly__)
+    sprintf(buf, dev_name, DRM_DIR_NAME, minor + drmGetMinorBase(type));
+#else
     sprintf(buf, dev_name, DRM_DIR_NAME, minor);
+#endif
     if ((fd = open(buf, O_RDWR, 0)) >= 0)
         return fd;
     return -errno;
@@ -517,51 +583,6 @@ int drmAvailable(void)
     return retval;
 }
 
-static int drmGetMinorBase(int type)
-{
-    switch (type) {
-    case DRM_NODE_PRIMARY:
-        return 0;
-    case DRM_NODE_CONTROL:
-        return 64;
-    case DRM_NODE_RENDER:
-        return 128;
-    default:
-        return -1;
-    };
-}
-
-static int drmGetMinorType(int minor)
-{
-    int type = minor >> 6;
-
-    if (minor < 0)
-        return -1;
-
-    switch (type) {
-    case DRM_NODE_PRIMARY:
-    case DRM_NODE_CONTROL:
-    case DRM_NODE_RENDER:
-        return type;
-    default:
-        return -1;
-    }
-}
-
-static const char *drmGetMinorName(int type)
-{
-    switch (type) {
-    case DRM_NODE_PRIMARY:
-        return DRM_PRIMARY_MINOR_NAME;
-    case DRM_NODE_CONTROL:
-        return DRM_CONTROL_MINOR_NAME;
-    case DRM_NODE_RENDER:
-        return DRM_RENDER_MINOR_NAME;
-    default:
-        return NULL;
-    }
-}
-
 /**
  * Open the device by bus ID.
  *
@@ -2703,33 +2724,40 @@ int drmDropMaster(int fd)
 
 char *drmGetDeviceNameFromFd(int fd)
 {
-    char name[128];
-    struct stat sbuf;
-    dev_t d;
-    int i;
-
     /* The whole drmOpen thing is a fiasco and we need to find a way
      * back to just using open(2).  For now, however, lets just make
      * things worse with even more ad hoc directory walking code to
      * discover the device file name. */
 
+    stat_t sbuf;
     fstat(fd, &sbuf);
-    d = sbuf.st_rdev;
+    dev_t d = sbuf.st_rdev;
 
-    for (i = 0; i < DRM_MAX_MINOR; i++) {
+    for (int i = 0; i < DRM_MAX_MINOR; i++) {
+        char name[DRM_NODE_NAME_MAX];
         snprintf(name, sizeof name, DRM_DEV_NAME, DRM_DIR_NAME, i);
         if (stat(name, &sbuf) == 0 && sbuf.st_rdev == d)
-            break;
+            return strdup(name);
     }
-    if (i == DRM_MAX_MINOR)
-        return NULL;
-
-    return strdup(name);
+    return NULL;
 }
 
 int drmGetNodeTypeFromFd(int fd)
 {
-    struct stat sbuf;
+#if defined(__FreeBSD__) || defined(__FreeBSD_kernel__) || defined(__DragonFly__)
+    char *name = drmGetDeviceNameFromFd2(fd);
+    if (!name) {
+        errno = ENODEV;
+        return -1;
+    }
+
+    int type = drmGetNodeType(name);
+    free(name);
+    if (type < 0)
+        errno = ENODEV;
+    return type;
+#else
+    stat_t sbuf;
     int maj, min, type;
 
     if (fstat(fd, &sbuf))
@@ -2747,6 +2775,7 @@ int drmGetNodeTypeFromFd(int fd)
     if (type == -1)
         errno = ENODEV;
     return type;
+#endif
 }
 
 int drmPrimeHandleToFD(int fd, uint32_t handle, uint32_t flags, int *prime_fd)
@@ -2786,7 +2815,7 @@ static char *drmGetMinorNameForFD(int fd
 #ifdef __linux__
     DIR *sysdir;
     struct dirent *pent, *ent;
-    struct stat sbuf;
+    stat_t sbuf;
     const char *name = drmGetMinorName(type);
     int len;
     char dev_name[64], buf[64];
@@ -2837,13 +2866,35 @@ static char *drmGetMinorNameForFD(int fd
 
 out_close_dir:
     closedir(sysdir);
+#elif defined(__FreeBSD__) || defined(__FreeBSD_kernel__) || defined(__DragonFly__)
+    const char *dev_name = drmGetDeviceName(type);
+    if (!dev_name)
+        return NULL;
+
+    char *name = drmGetDeviceNameFromFd2(fd);
+    if (!name)
+        return NULL;
+
+    int oldnum = drmGetNodeNumber(name);
+    int oldtype = drmGetMinorType(oldnum);
+    if (oldtype < 0) {
+        free(name);
+        return NULL;
+    }
+
+    int newnum = oldnum - drmGetMinorBase(oldtype) + drmGetMinorBase(type);
+    snprintf(name, DRM_NODE_NAME_MAX, dev_name, DRM_DIR_NAME, newnum);
+    return name;
 #else
-    struct stat sbuf;
-    char buf[PATH_MAX + 1];
-    const char *dev_name;
+    stat_t sbuf;
+    char buf[DRM_NODE_NAME_MAX];
+    const char *dev_name = drmGetDeviceName(type);
     unsigned int maj, min;
     int n, base;
 
+    if (!dev_name)
+        return NULL;
+
     if (fstat(fd, &sbuf))
         return NULL;
 
@@ -2853,20 +2904,6 @@ out_close_dir:
     if (maj != DRM_MAJOR || !S_ISCHR(sbuf.st_mode))
         return NULL;
 
-    switch (type) {
-    case DRM_NODE_PRIMARY:
-        dev_name = DRM_DEV_NAME;
-        break;
-    case DRM_NODE_CONTROL:
-        dev_name = DRM_CONTROL_DEV_NAME;
-        break;
-    case DRM_NODE_RENDER:
-        dev_name = DRM_RENDER_DEV_NAME;
-        break;
-    default:
-        return NULL;
-    };
-
     base = drmGetMinorBase(type);
     if (base < 0)
         return NULL;
@@ -2964,7 +3001,7 @@ static int drmParseSubsystemType(int maj
         return DRM_BUS_HOST1X;
 
     return -EINVAL;
-#elif defined(__OpenBSD__)
+#elif defined(__OpenBSD__) || defined(__FreeBSD__) || defined(__FreeBSD_kernel__) || defined(__DragonFly__)
     return DRM_BUS_PCI;
 #else
 #warning "Missing implementation of drmParseSubsystemType"
@@ -2972,7 +3009,8 @@ static int drmParseSubsystemType(int maj
 #endif
 }
 
-static int drmParsePciBusInfo(int maj, int min, drmPciBusInfoPtr info)
+static int drmParsePciBusInfo(const char *node, int node_type,
+                              int maj, int min, drmPciBusInfoPtr info)
 {
 #ifdef __linux__
     unsigned int domain, bus, dev, func;
@@ -3021,6 +3059,60 @@ static int drmParsePciBusInfo(int maj, i
     info->func = pinfo.func;
 
     return 0;
+#elif defined(__FreeBSD__) || defined(__FreeBSD_kernel__) || defined(__DragonFly__)
+    /*
+     * Only the primary nodes can be mapped to hw.dri.%i via major/minor
+     * Determine the primary node by offset and use its major/minor pair
+     */
+    if (node_type != DRM_NODE_PRIMARY) {
+        char name[DRM_NODE_NAME_MAX];
+        snprintf(name, sizeof(name), DRM_DEV_NAME, DRM_DIR_NAME,
+                 drmGetNodeNumber(node) - drmGetMinorBase(node_type));
+
+        stat_t sbuf;
+        if (stat(name, &sbuf))
+            return -errno;
+
+        maj = major(sbuf.st_rdev);
+        min = minor(sbuf.st_rdev);
+    }
+    /*
+     * Major/minor appear after the driver name in the hw.dri.%i.name node
+     * Find the node with matching major/minor pair and parse the bus ID,
+     * which may be after the name or may be alone in hw.dri.%i.busid
+     */
+    #define bus_fmt "pci:%04x:%02x:%02x.%u"
+    #define name_fmt "%*s %x " bus_fmt
+    for (int i = 0; i < DRM_MAX_MINOR; ++i) {
+        char name[16], value[256];
+        size_t length = sizeof(value);
+        snprintf(name, sizeof(name), "hw.dri.%i.name", i);
+        if (sysctlbyname(name, value, &length, NULL, 0))
+            continue;
+
+        value[length] = '\0';
+        unsigned int rdev = 0, domain = 0, bus = 0, slot = 0, func = 0;
+        int vals = sscanf(value, name_fmt, &rdev, &domain, &bus, &slot, &func);
+
+	if (vals >= 1 && rdev == makedev(maj,min)) {
+            if (vals < 5) {
+                /* busid not in the name, try busid */
+                length = sizeof(value);
+                snprintf(name, sizeof(name), "hw.dri.%i.busid", i);
+                if (sysctlbyname(name, value, &length, NULL, 0))
+                    break;
+                value[length] = '\0';
+                if (sscanf(value, bus_fmt, &domain, &bus, &slot, &func) != 4)
+                    break;
+            }
+            info->domain = domain;
+            info->bus = bus;
+            info->dev = slot;
+            info->func = func;
+            return 0;
+        }
+    }
+    return -ENODEV;
 #else
 #warning "Missing implementation of drmParsePciBusInfo"
     return -EINVAL;
@@ -3055,32 +3147,6 @@ int drmDevicesEqual(drmDevicePtr a, drmD
     return 0;
 }
 
-static int drmGetNodeType(const char *name)
-{
-    if (strncmp(name, DRM_PRIMARY_MINOR_NAME,
-        sizeof(DRM_PRIMARY_MINOR_NAME) - 1) == 0)
-        return DRM_NODE_PRIMARY;
-
-    if (strncmp(name, DRM_CONTROL_MINOR_NAME,
-        sizeof(DRM_CONTROL_MINOR_NAME ) - 1) == 0)
-        return DRM_NODE_CONTROL;
-
-    if (strncmp(name, DRM_RENDER_MINOR_NAME,
-        sizeof(DRM_RENDER_MINOR_NAME) - 1) == 0)
-        return DRM_NODE_RENDER;
-
-    return -EINVAL;
-}
-
-static int drmGetMaxNodeName(void)
-{
-    return sizeof(DRM_DIR_NAME) +
-           MAX3(sizeof(DRM_PRIMARY_MINOR_NAME),
-                sizeof(DRM_CONTROL_MINOR_NAME),
-                sizeof(DRM_RENDER_MINOR_NAME)) +
-           3 /* length of the node number */;
-}
-
 #ifdef __linux__
 static int parse_separate_sysfs_files(int maj, int min,
                                       drmPciDeviceInfoPtr device,
@@ -3150,6 +3216,7 @@ static int parse_config_sysfs_file(int m
 #endif
 
 static int drmParsePciDeviceInfo(int maj, int min,
+                                 drmPciBusInfoPtr info,
                                  drmPciDeviceInfoPtr device,
                                  uint32_t flags)
 {
@@ -3186,6 +3253,43 @@ static int drmParsePciDeviceInfo(int maj
     device->subdevice_id = pinfo.subdevice_id;
 
     return 0;
+#elif defined(__FreeBSD__) || defined(__FreeBSD_kernel__) || defined(__DragonFly__)
+    struct pci_conf_io pc;
+    struct pci_match_conf patterns[1];
+    struct pci_conf results[1];
+
+    int fd = open("/dev/pci", O_RDONLY, 0);
+    if (fd < 0)
+        return -errno;
+
+    bzero(&patterns, sizeof(patterns));
+    patterns[0].pc_sel.pc_domain = info->domain;
+    patterns[0].pc_sel.pc_bus = info->bus;
+    patterns[0].pc_sel.pc_dev = info->dev;
+    patterns[0].pc_sel.pc_func = info->func;
+    patterns[0].flags = PCI_GETCONF_MATCH_DOMAIN | PCI_GETCONF_MATCH_BUS
+                      | PCI_GETCONF_MATCH_DEV | PCI_GETCONF_MATCH_FUNC;
+    bzero(&pc, sizeof(struct pci_conf_io));
+    pc.num_patterns = 1;
+    pc.pat_buf_len = sizeof(patterns);
+    pc.patterns = patterns;
+    pc.match_buf_len = sizeof(results);
+    pc.matches = results;
+
+    if (ioctl(fd, PCIOCGETCONF, &pc) || pc.status == PCI_GETCONF_ERROR) {
+        int error = errno;
+        close(fd);
+        return -error;
+    }
+    close(fd);
+
+    device->vendor_id = results[0].pc_vendor;
+    device->device_id = results[0].pc_device;
+    device->subvendor_id = results[0].pc_subvendor;
+    device->subdevice_id = results[0].pc_subdevice;
+    device->revision_id = results[0].pc_revid;
+
+    return 0;
 #else
 #warning "Missing implementation of drmParsePciDeviceInfo"
     return -EINVAL;
@@ -3266,7 +3370,7 @@ static drmDevicePtr drmDeviceAlloc(unsig
     unsigned int i;
     char *ptr;
 
-    max_node_length = ALIGN(drmGetMaxNodeName(), sizeof(void *));
+    max_node_length = ALIGN(DRM_NODE_NAME_MAX, sizeof(void *));
     extra = DRM_NODE_MAX * (sizeof(void *) + max_node_length);
 
     size = sizeof(*device) + extra + bus_size + device_size;
@@ -3312,7 +3416,7 @@ static int drmProcessPciDevice(drmDevice
 
     dev->businfo.pci = (drmPciBusInfoPtr)addr;
 
-    ret = drmParsePciBusInfo(maj, min, dev->businfo.pci);
+    ret = drmParsePciBusInfo(node, node_type, maj, min, dev->businfo.pci);
     if (ret)
         goto free_device;
 
@@ -3321,7 +3425,7 @@ static int drmProcessPciDevice(drmDevice
         addr += sizeof(drmPciBusInfo);
         dev->deviceinfo.pci = (drmPciDeviceInfoPtr)addr;
 
-        ret = drmParsePciDeviceInfo(maj, min, dev->deviceinfo.pci, flags);
+        ret = drmParsePciDeviceInfo(maj, min, dev->businfo.pci, dev->deviceinfo.pci, flags);
         if (ret)
             goto free_device;
     }
@@ -3671,7 +3775,7 @@ static void drmFoldDuplicatedDevices(drm
                 local_devices[i]->available_nodes |= local_devices[j]->available_nodes;
                 node_type = log2(local_devices[j]->available_nodes);
                 memcpy(local_devices[i]->nodes[node_type],
-                       local_devices[j]->nodes[node_type], drmGetMaxNodeName());
+                       local_devices[j]->nodes[node_type], DRM_NODE_NAME_MAX);
                 drmFreeDevice(&local_devices[j]);
             }
         }
@@ -3689,7 +3793,7 @@ drm_device_validate_flags(uint32_t flags
  * Get information about the opened drm device
  *
  * \param fd file descriptor of the drm device
- * \param flags feature/behaviour bitmask
+ * \param flags feature/behavior bitmask
  * \param device the address of a drmDevicePtr where the information
  *               will be allocated in stored
  *
@@ -3707,8 +3811,8 @@ int drmGetDevice2(int fd, uint32_t flags
      * Avoid stat'ing all of /dev needlessly by implementing this custom path.
      */
     drmDevicePtr     d;
-    struct stat      sbuf;
-    char             node[PATH_MAX + 1];
+    stat_t           sbuf;
+    char             node[DRM_NODE_NAME_MAX];
     const char      *dev_name;
     int              node_type, subsystem_type;
     int              maj, min, n, ret, base;
@@ -3729,26 +3833,16 @@ int drmGetDevice2(int fd, uint32_t flags
     if (node_type == -1)
         return -ENODEV;
 
-    switch (node_type) {
-    case DRM_NODE_PRIMARY:
-        dev_name = DRM_DEV_NAME;
-        break;
-    case DRM_NODE_CONTROL:
-        dev_name = DRM_CONTROL_DEV_NAME;
-        break;
-    case DRM_NODE_RENDER:
-        dev_name = DRM_RENDER_DEV_NAME;
-        break;
-    default:
+    dev_name = drmGetDeviceName(node_type);
+    if (!dev_name)
         return -EINVAL;
-    };
 
     base = drmGetMinorBase(node_type);
     if (base < 0)
         return -EINVAL;
 
-    n = snprintf(node, PATH_MAX, dev_name, DRM_DIR_NAME, min - base);
-    if (n == -1 || n >= PATH_MAX)
+    n = snprintf(node, sizeof(node), dev_name, DRM_DIR_NAME, min - base);
+    if (n == -1 || n >= sizeof(node))
       return -errno;
     if (stat(node, &sbuf))
         return -EINVAL;
@@ -3769,8 +3863,8 @@ int drmGetDevice2(int fd, uint32_t flags
     drmDevicePtr d;
     DIR *sysdir;
     struct dirent *dent;
-    struct stat sbuf;
-    char node[PATH_MAX + 1];
+    stat_t sbuf;
+    char node[DRM_NODE_NAME_MAX];
     int node_type, subsystem_type;
     int maj, min;
     int ret, i, node_count;
@@ -3790,7 +3884,7 @@ int drmGetDevice2(int fd, uint32_t flags
     maj = major(sbuf.st_rdev);
     min = minor(sbuf.st_rdev);
 
-    if (maj != DRM_MAJOR || !S_ISCHR(sbuf.st_mode))
+    if ((DRM_MAJOR && maj != DRM_MAJOR) || !S_ISCHR(sbuf.st_mode))
         return -EINVAL;
 
     subsystem_type = drmParseSubsystemType(maj, min);
@@ -3811,14 +3905,14 @@ int drmGetDevice2(int fd, uint32_t flags
         if (node_type < 0)
             continue;
 
-        snprintf(node, PATH_MAX, "%s/%s", DRM_DIR_NAME, dent->d_name);
+        snprintf(node, sizeof(node), "%s/%s", DRM_DIR_NAME, dent->d_name);
         if (stat(node, &sbuf))
             continue;
 
         maj = major(sbuf.st_rdev);
         min = minor(sbuf.st_rdev);
 
-        if (maj != DRM_MAJOR || !S_ISCHR(sbuf.st_mode))
+        if ((DRM_MAJOR && maj != DRM_MAJOR) || !S_ISCHR(sbuf.st_mode))
             continue;
 
         if (drmParseSubsystemType(maj, min) != subsystem_type)
@@ -3916,7 +4010,7 @@ int drmGetDevice(int fd, drmDevicePtr *d
 /**
  * Get drm devices on the system
  *
- * \param flags feature/behaviour bitmask
+ * \param flags feature/behavior bitmask
  * \param devices the array of devices with drmDevicePtr elements
  *                can be NULL to get the device number first
  * \param max_devices the maximum number of devices for the array
@@ -3935,8 +4029,8 @@ int drmGetDevices2(uint32_t flags, drmDe
     drmDevicePtr device;
     DIR *sysdir;
     struct dirent *dent;
-    struct stat sbuf;
-    char node[PATH_MAX + 1];
+    stat_t sbuf;
+    char node[DRM_NODE_NAME_MAX];
     int node_type, subsystem_type;
     int maj, min;
     int ret, i, node_count, device_count;
@@ -3961,14 +4055,14 @@ int drmGetDevices2(uint32_t flags, drmDe
         if (node_type < 0)
             continue;
 
-        snprintf(node, PATH_MAX, "%s/%s", DRM_DIR_NAME, dent->d_name);
+        snprintf(node, sizeof(node), "%s/%s", DRM_DIR_NAME, dent->d_name);
         if (stat(node, &sbuf))
             continue;
 
         maj = major(sbuf.st_rdev);
         min = minor(sbuf.st_rdev);
 
-        if (maj != DRM_MAJOR || !S_ISCHR(sbuf.st_mode))
+        if ((DRM_MAJOR && maj != DRM_MAJOR) || !S_ISCHR(sbuf.st_mode))
             continue;
 
         subsystem_type = drmParseSubsystemType(maj, min);
@@ -4076,7 +4170,7 @@ int drmGetDevices(drmDevicePtr devices[]
 char *drmGetDeviceNameFromFd2(int fd)
 {
 #ifdef __linux__
-    struct stat sbuf;
+    stat_t sbuf;
     char path[PATH_MAX + 1], *value;
     unsigned int maj, min;
 
@@ -4099,9 +4193,26 @@ char *drmGetDeviceNameFromFd2(int fd)
     free(value);
 
     return strdup(path);
+#elif defined(__FreeBSD__) || defined(__FreeBSD_kernel__) || defined(__DragonFly__)
+    stat_t sbuf;
+    if (fstat(fd, &sbuf))
+        return NULL;
+
+    dev_t rdev = sbuf.st_rdev;
+    /* minor numbers don't depend on node name suffix, search for a match */
+    for (int i = 0; i < DRM_MAX_MINOR; ++i) {
+        char node[DRM_NODE_NAME_MAX];
+        for (int j = 0; j < DRM_NODE_MAX; ++j) {
+            snprintf(node, sizeof(node), drmGetDeviceName(j),
+                     DRM_DIR_NAME, drmGetMinorBase(j) + i);
+            if (stat(node, &sbuf) == 0 && sbuf.st_rdev == rdev)
+                return strdup(node);
+        }
+    }
+    return NULL;
 #else
-    struct stat      sbuf;
-    char             node[PATH_MAX + 1];
+    stat_t           sbuf;
+    char             node[DRM_NODE_NAME_MAX];
     const char      *dev_name;
     int              node_type;
     int              maj, min, n, base;
@@ -4119,26 +4230,16 @@ char *drmGetDeviceNameFromFd2(int fd)
     if (node_type == -1)
         return NULL;
 
-    switch (node_type) {
-    case DRM_NODE_PRIMARY:
-        dev_name = DRM_DEV_NAME;
-        break;
-    case DRM_NODE_CONTROL:
-        dev_name = DRM_CONTROL_DEV_NAME;
-        break;
-    case DRM_NODE_RENDER:
-        dev_name = DRM_RENDER_DEV_NAME;
-        break;
-    default:
+    dev_name = drmGetDeviceName(node_type);
+    if (!dev_name)
         return NULL;
-    };
 
     base = drmGetMinorBase(node_type);
     if (base < 0)
         return NULL;
 
-    n = snprintf(node, PATH_MAX, dev_name, DRM_DIR_NAME, min - base);
-    if (n == -1 || n >= PATH_MAX)
+    n = snprintf(node, sizeof(node), dev_name, DRM_DIR_NAME, min - base);
+    if (n == -1 || n >= sizeof(node))
       return NULL;
 
     return strdup(node);


[FILE:1334:patches/patch-xf86drm.h]
--- xf86drm.h.orig	2017-04-07 08:49:13 UTC
+++ xf86drm.h
@@ -78,17 +78,27 @@ extern "C" {
 
 #ifdef __OpenBSD__
 #define DRM_DIR_NAME  "/dev"
-#define DRM_DEV_NAME  "%s/drm%d"
-#define DRM_CONTROL_DEV_NAME  "%s/drmC%d"
-#define DRM_RENDER_DEV_NAME  "%s/drmR%d"
+#define DRM_PRIMARY_MINOR_NAME  "drm"
+#define DRM_CONTROL_MINOR_NAME  "drmC"
+#define DRM_RENDER_MINOR_NAME   "drmR"
 #else
 #define DRM_DIR_NAME  "/dev/dri"
-#define DRM_DEV_NAME  "%s/card%d"
-#define DRM_CONTROL_DEV_NAME  "%s/controlD%d"
-#define DRM_RENDER_DEV_NAME  "%s/renderD%d"
-#define DRM_PROC_NAME "/proc/dri/" /* For backward Linux compatibility */
+#define DRM_PRIMARY_MINOR_NAME  "card"
+#define DRM_CONTROL_MINOR_NAME  "controlD"
+#define DRM_RENDER_MINOR_NAME   "renderD"
 #endif
 
+#define DRM_DEV_NAME  "%s/" DRM_PRIMARY_MINOR_NAME "%d"
+#define DRM_CONTROL_DEV_NAME  "%s/" DRM_CONTROL_MINOR_NAME "%d"
+#define DRM_RENDER_DEV_NAME  "%s/" DRM_RENDER_MINOR_NAME "%d"
+
+#define DRM_NODE_NAME_MAX                   \
+    (sizeof(DRM_DIR_NAME) +                 \
+     MAX3(sizeof(DRM_PRIMARY_MINOR_NAME),   \
+         sizeof(DRM_CONTROL_MINOR_NAME),    \
+         sizeof(DRM_RENDER_MINOR_NAME))     \
+    + 3) /* length of the node number */
+
 #define DRM_ERR_NO_DEVICE  (-1001)
 #define DRM_ERR_NO_ACCESS  (-1002)
 #define DRM_ERR_NOT_ROOT   (-1003)


[FILE:3299:patches/patch-xf86drmMode.c]
--- xf86drmMode.c.orig	2017-04-07 08:49:13 UTC
+++ xf86drmMode.c
@@ -47,6 +47,7 @@
 #include <stdlib.h>
 #include <sys/ioctl.h>
 #ifdef HAVE_SYS_SYSCTL_H
+#include <sys/types.h>
 #include <sys/sysctl.h>
 #endif
 #include <stdio.h>
@@ -796,43 +797,60 @@ int drmCheckModesettingSupported(const c
 	closedir(sysdir);
 	if (found)
 		return 0;
-#elif defined (__FreeBSD__) || defined (__FreeBSD_kernel__)
-	char kbusid[1024], sbusid[1024];
-	char oid[128];
-	int domain, bus, dev, func;
-	int i, modesetting, ret;
-	size_t len;
+#elif defined (__FreeBSD__) || defined (__FreeBSD_kernel__) || defined (__DragonFly__)
+	#define bus_fmt "pci:%04x:%02x:%02x.%u"
+	#define name_fmt "%*s %*s " bus_fmt
+	unsigned int d1 = 0, b1 = 0, s1 = 0, f1 = 0;
+	if (sscanf(busid, bus_fmt, &d1, &b1, &s1, &f1) != 4)
+                return -EINVAL;
+	/*
+	 * hw.dri.%i.bus is not always present and hw.dri.%i.name does not
+	 * always contain the busid, so try both for best chance of success
+	 */
+	for (int i = 0; i < DRM_MAX_MINOR; ++i) {
+		char name[22], value[256];
+		size_t length = sizeof(value);
+		snprintf(name, sizeof(name), "hw.dri.%i.name", i);
+		if (sysctlbyname(name, value, &length, NULL, 0))
+			continue;
 
-	ret = sscanf(busid, "pci:%04x:%02x:%02x.%d", &domain, &bus, &dev,
-	    &func);
-	if (ret != 4)
-		return -EINVAL;
-	snprintf(kbusid, sizeof(kbusid), "pci:%04x:%02x:%02x.%d", domain, bus,
-	    dev, func);
+		value[length] = '\0';
+		unsigned int d2 = 0, b2 = 0, s2 = 0, f2 = 0;
+		switch (sscanf(value, name_fmt, &d2, &b2, &s2, &f2)) {
+		case 0: /* busid not in the name, try busid */
+			length = sizeof(value);
+			snprintf(name, sizeof(name), "hw.dri.%i.busid", i);
+			if (sysctlbyname(name, value, &length, NULL, 0))
+				continue;
 
-	/* How many GPUs do we expect in the machine ? */
-	for (i = 0; i < 16; i++) {
-		snprintf(oid, sizeof(oid), "hw.dri.%d.busid", i);
-		len = sizeof(sbusid);
-		ret = sysctlbyname(oid, sbusid, &len, NULL, 0);
-		if (ret == -1) {
-			if (errno == ENOENT)
+			value[length] = '\0';
+			if (sscanf(value, bus_fmt, &d2, &b2, &s2, &f2) != 4)
 				continue;
-			return -EINVAL;
+			/* fall through after parsing busid */
+
+		case 4: /* if we jumped here then busid was in the name */ 
+			if (d1 == d2 && b1 == b2 && s1 == s2 && f1 == f2) {
+			/*
+			 * Confirm the drm driver for this device supports KMS,
+			 * except on DragonFly where all the drm drivers do so
+			 * but only hw.dri.0.modesetting is present
+			 */ 
+			#ifndef __DragonFly__
+				int modesetting = 0;
+				length = sizeof(modesetting);
+				snprintf(name, sizeof(name), "hw.dri.%i.modesetting", i);
+				if (sysctlbyname(name, &modesetting, &length, NULL, 0)
+				 || length != sizeof(modesetting) || !modesetting)
+					return -ENOSYS;
+				else
+			#endif
+					return 0;
+			}
+		default:
+			break;
 		}
-		if (strcmp(sbusid, kbusid) != 0)
-			continue;
-		snprintf(oid, sizeof(oid), "hw.dri.%d.modesetting", i);
-		len = sizeof(modesetting);
-		ret = sysctlbyname(oid, &modesetting, &len, NULL, 0);
-		if (ret == -1 || len != sizeof(modesetting))
-			return -EINVAL;
-		return (modesetting ? 0 : -ENOSYS);
 	}
-#elif defined(__DragonFly__)
-	return 0;
-#endif
-#ifdef __OpenBSD__
+#elif defined(__OpenBSD__)
 	int	fd;
 	struct drm_mode_card_res res;
 	drmModeResPtr r = 0;


[FILE:728:freebsd/patch-xf86drm.c]
Error code 512 is being leaked from kernel space. While it should be
converted to either EINTR or EAGAIN in the kernel. Teach libdrm to do this
for now. Newer kernel modules will have this fixed included.

dragonfly fixed this issue in,
http://gitweb.dragonflybsd.org/dragonfly.git/commit/b922632f623ee2cc2c1346bb3a6894a7756676aa
which has been included since the 4.4 release.

--- xf86drm.c.orig	2017-01-30 13:59:15.919081000 +0100
+++ xf86drm.c
@@ -197,7 +197,7 @@ drmIoctl(int fd, unsigned long request, 
 
     do {
         ret = ioctl(fd, request, arg);
-    } while (ret == -1 && (errno == EINTR || errno == EAGAIN));
+    } while (ret == -1 && (errno == EINTR || errno == EAGAIN || errno == 512));
     return ret;
 }
 

