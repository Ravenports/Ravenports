# Buildsheet autogenerated by ravenadm tool -- Do not edit.

NAMEBASE=		libdrm
VERSION=		2.4.118
KEYWORDS=		graphics x11
VARIANTS=		standard
SDESC[standard]=	Direct Rendering Module services kernel interface
HOMEPAGE=		https://dri.freedesktop.org
CONTACT=		nobody

DOWNLOAD_GROUPS=	main
SITES[main]=		https://dri.freedesktop.org/libdrm/
DISTFILE[1]=		libdrm-2.4.118.tar.xz:main
DF_INDEX=		1
SPKGS[standard]=	complete
			primary
			man
			dev

OPTIONS_AVAILABLE=	ARM X86 NOUVEAU
OPTIONS_STANDARD=	ARM X86 NOUVEAU
OPT_ON[aarch64]=	ARM
OPT_ON[linux]=		NOUVEAU
OPT_ON[x86_64]=		X86
OPT_ON[i386]=		X86

BUILD_DEPENDS=		libxslt:primary:standard
			python-docutils:single:python_default

USES=			gmake pkgconfig solaris-funcs meson
GNOME_COMPONENTS=	libxml2
XORG_COMPONENTS=	pciaccess

LICENSE=		MIT:primary
LICENSE_FILE=		MIT:{{WRKDIR}}/LICENSE_MIT
LICENSE_AWK=		MIT:"_XF86DRM_H_"
LICENSE_SOURCE=		MIT:{{WRKSRC}}/xf86drm.h
LICENSE_SCHEME=		solo

FPC_EQUIVALENT=		graphics/libdrm
MESON_ARGS=		-Dman-pages=enabled
			-Dinstall-test-programs=true
			-Dcairo-tests=disabled
			-Dradeon=enabled
			-Damdgpu=enabled
SOL_FUNCTIONS=		getline:amdgpu/amdgpu_asic_id.c
			asprintf:xf86drm.c
			asprintf:tests/modetest/modetest.c
			strndup:tests/modetest/modetest.c

INSTALL_TARGET=		install-strip
INSTALL_REQ_TOOLCHAIN=	yes

VAR_OPSYS[sunos]=	LDFLAGS=-lrt
VAR_OPSYS[netbsd]=	LDFLAGS=-lpci

[X86].DESCRIPTION=			DRM Drivers for amd64 and i386 architectures
[X86].CONFIGURE_ARGS_OFF=		-Dintel=disabled
					-Dvmwgfx=disabled
[X86].CONFIGURE_ARGS_ON=		-Dintel=enabled
					-Dvmwgfx=enabled

[ARM].DESCRIPTION=			DRM Drivers for AARCH64 architecture
[ARM].CONFIGURE_ARGS_OFF=		-Detnaviv=disabled
					-Dexynos=disabled
					-Dfreedreno=disabled
					-Dfreedreno-kgsl=false
					-Domap=disabled
					-Dtegra=disabled
					-Dvc4=disabled
[ARM].CONFIGURE_ARGS_ON=		-Detnaviv=enabled
					-Dexynos=enabled
					-Dfreedreno=enabled
					-Domap=enabled
					-Dtegra=enabled
					-Dvc4=enabled

[NOUVEAU].DESCRIPTION=			Build x86 Nouveau driver
[NOUVEAU].CONFIGURE_ARGS_OFF=		-Dnouveau=disabled
[NOUVEAU].CONFIGURE_ARGS_ON=		-Dnouveau=enabled

[FILE:70:descriptions/desc.primary]
Userspace interface to kernel DRM (Direct Rendering Module) services.


[FILE:100:distinfo]
a777bd85f2b5fc9c57f886c82058300578317cafdbc77d0a769d7e9a9567ab88       479096 libdrm-2.4.118.tar.xz


[FILE:438:manifests/plist.primary]
%%ARM-ON%%lib/
 libdrm_freedreno.so.1
 libdrm_freedreno.so.1.0.0
%%X86-ON%%%%NOUVEAU-ON%%lib/
 libdrm_nouveau.so.2
 libdrm_nouveau.so.2.0.0
%%X86-ON%%bin/amdgpu_stress
%%X86-ON%%lib/
 libdrm_amdgpu.so.1
 libdrm_amdgpu.so.1.0.0
 libdrm_intel.so.1
 libdrm_intel.so.1.0.0
 libdrm_radeon.so.1
 libdrm_radeon.so.1.0.1
%%X86-ON%%share/libdrm/amdgpu.ids
bin/
 drmdevice
 modeprint
 modetest
 proptest
 vbltest
lib/
 libdrm.so.2
 libdrm.so.2.4.0


[FILE:139:manifests/plist.man]
share/man/man3/
 drmAvailable.3.gz
 drmHandleEvent.3.gz
 drmModeGetResources.3.gz
share/man/man7/
 drm-kms.7.gz
 drm-memory.7.gz
 drm.7.gz


[FILE:1209:manifests/plist.dev]
%%ARM-ON%%include/freedreno/
 freedreno_drmif.h
 freedreno_ringbuffer.h
%%ARM-ON%%include/libdrm/
 vc4_packet.h
 vc4_qpu_defines.h
%%ARM-ON%%lib/libdrm_freedreno.so
%%ARM-ON%%lib/pkgconfig/
 libdrm_freedreno.pc
 libdrm_vc4.pc
%%X86-ON%%%%NOUVEAU-ON%%include/libdrm/nouveau/nouveau.h
%%X86-ON%%%%NOUVEAU-ON%%include/libdrm/nouveau/nvif/
 cl0080.h
 cl9097.h
 class.h
 if0002.h
 if0003.h
 ioctl.h
 unpack.h
%%X86-ON%%%%NOUVEAU-ON%%lib/libdrm_nouveau.so
%%X86-ON%%%%NOUVEAU-ON%%lib/pkgconfig/libdrm_nouveau.pc
%%X86-ON%%include/libdrm/
 amdgpu.h
 amdgpu_drm.h
 intel_aub.h
 intel_bufmgr.h
 intel_debug.h
 r600_pci_ids.h
 radeon_bo.h
 radeon_bo_gem.h
 radeon_bo_int.h
 radeon_cs.h
 radeon_cs_gem.h
 radeon_cs_int.h
 radeon_surface.h
%%X86-ON%%lib/
 libdrm_amdgpu.so
 libdrm_intel.so
 libdrm_radeon.so
%%X86-ON%%lib/pkgconfig/
 libdrm_amdgpu.pc
 libdrm_intel.pc
 libdrm_radeon.pc
include/
 libsync.h
 xf86drm.h
 xf86drmMode.h
include/libdrm/
 drm.h
 drm_fourcc.h
 drm_mode.h
 drm_sarea.h
 i915_drm.h
 mach64_drm.h
 mga_drm.h
 msm_drm.h
 nouveau_drm.h
 qxl_drm.h
 r128_drm.h
 radeon_drm.h
 savage_drm.h
 sis_drm.h
 tegra_drm.h
 vc4_drm.h
 via_drm.h
 virtgpu_drm.h
 vmwgfx_drm.h
lib/libdrm.so
lib/pkgconfig/libdrm.pc


[FILE:425:patches/patch-amdgpu_amdgpu__cs.c]
$NetBSD: patch-amdgpu_amdgpu__cs.c,v 1.3 2022/03/13 15:20:01 tnn Exp $

libc-supplied compat alloca(3) should not be used

--- amdgpu/amdgpu_cs.c.orig	2023-11-20 13:03:51 UTC
+++ amdgpu/amdgpu_cs.c
@@ -28,9 +28,7 @@
 #include <pthread.h>
 #include <sched.h>
 #include <sys/ioctl.h>
-#if HAVE_ALLOCA_H
-# include <alloca.h>
-#endif
+#define alloca(size) __builtin_alloca(size)
 
 #include "xf86drm.h"
 #include "amdgpu_drm.h"


[FILE:834:patches/patch-amdgpu_amdgpu__device.c]
--- amdgpu/amdgpu_device.c.orig	2023-11-20 13:03:51 UTC
+++ amdgpu/amdgpu_device.c
@@ -177,7 +177,12 @@ drm_public int amdgpu_device_initialize(
 			return r;
 		}
 		if ((flag_auth) && (!flag_authexist)) {
+#ifdef F_DUPFD_CLOEXEC
 			dev->flink_fd = fcntl(fd, F_DUPFD_CLOEXEC, 0);
+#else
+			dev->flink_fd = fcntl(fd, F_DUPFD, 0);
+			fcntl(dev->flink_fd, F_SETFD, FD_CLOEXEC);
+#endif
 		}
 		*major_version = dev->major_version;
 		*minor_version = dev->minor_version;
@@ -211,7 +216,12 @@ drm_public int amdgpu_device_initialize(
 		goto cleanup;
 	}
 
+#ifdef F_DUPFD_CLOEXEC
 	dev->fd = fcntl(fd, F_DUPFD_CLOEXEC, 0);
+#else
+	dev->fd = fcntl(fd, F_DUPFD, 0);
+	fcntl(dev->fd, F_SETFD, FD_CLOEXEC);
+#endif
 	dev->flink_fd = dev->fd;
 	dev->major_version = version->version_major;
 	dev->minor_version = version->version_minor;


[FILE:283:patches/patch-include_drm_drm.h]
--- include/drm/drm.h.orig	2023-11-20 13:03:51 UTC
+++ include/drm/drm.h
@@ -843,7 +843,11 @@ struct drm_set_client_cap {
 };
 
 #define DRM_RDWR O_RDWR
+#ifdef __sun__
+#define DRM_CLOEXEC 0
+#else
 #define DRM_CLOEXEC O_CLOEXEC
+#endif
 struct drm_prime_handle {
 	__u32 handle;
 


[FILE:689:patches/patch-intel_intel__bufmgr__gem.c]
--- intel/intel_bufmgr_gem.c.orig	2023-11-20 13:03:51 UTC
+++ intel/intel_bufmgr_gem.c
@@ -966,6 +966,27 @@ drm_intel_gem_bo_alloc_userptr(drm_intel
 	return &bo_gem->bo;
 }
 
+#ifdef __sun__
+#define posix_memalign	illumos_memalign
+static int
+posix_memalign(void **memptr, size_t alignment, size_t size)
+{
+	void *ptr = NULL;
+	int error = 0;
+
+	if (alignment == 0 ||
+	    (alignment & (sizeof (void *) - 1)) != 0 ||
+	    (alignment & (alignment - 1)) != 0)
+		error = EINVAL;
+	else if (size != 0 &&
+	    (ptr = memalign(alignment, size)) == NULL)
+		error = ENOMEM;
+
+	*memptr = ptr;
+	return (error);
+}
+#endif
+
 static bool
 has_userptr(drm_intel_bufmgr_gem *bufmgr_gem)
 {


[FILE:379:patches/patch-intel_test__decode.c]
--- intel/test_decode.c.orig	2023-11-20 13:03:51 UTC
+++ intel/test_decode.c
@@ -28,7 +28,13 @@
 #include <fcntl.h>
 #include <sys/types.h>
 #include <sys/stat.h>
+#ifdef __sun__
+#define errx(exitcode, format, args...) \
+	{ fprintf(stderr, format "\n", ## args); \
+	  exit(exitcode); }
+#else
 #include <err.h>
+#endif
 
 #include "libdrm_macros.h"
 #include "intel_bufmgr.h"


[FILE:521:patches/patch-libsync.h]
define ETIME as ETIMEOUT same as done in mesa

--- libsync.h.orig	2023-11-20 13:03:51 UTC
+++ libsync.h
@@ -35,6 +35,9 @@
 #include <sys/ioctl.h>
 #include <sys/poll.h>
 #include <unistd.h>
+#ifndef ETIME
+#define ETIME ETIMEDOUT
+#endif
 
 #if defined(__cplusplus)
 extern "C" {
@@ -53,6 +56,9 @@ struct sync_merge_data {
 	uint32_t	flags;
 	uint32_t	pad;
 };
+#ifdef __sun__
+#include <sys/ioccom.h>
+#endif
 #define SYNC_IOC_MAGIC		'>'
 #define SYNC_IOC_MERGE		_IOWR(SYNC_IOC_MAGIC, 3, struct sync_merge_data)
 #endif


[FILE:267:patches/patch-tests_drmdevice.c]
--- tests/drmdevice.c.orig	2023-11-20 13:03:51 UTC
+++ tests/drmdevice.c
@@ -31,6 +31,9 @@
 #include <unistd.h>
 #include <xf86drm.h>
 
+#ifndef O_CLOEXEC
+#define O_CLOEXEC 0
+#endif
 
 static void
 print_device_info(drmDevicePtr device, int i, bool print_revision)


[FILE:354:patches/patch-tests_modetest_meson.build]
--- tests/modetest/meson.build.orig	2023-11-20 13:03:51 UTC
+++ tests/modetest/meson.build
@@ -25,6 +25,7 @@ modetest = executable(
   include_directories : [inc_root, inc_tests, inc_drm],
   dependencies : [dep_threads, dep_cairo],
   link_with : [libdrm, libutil],
+  link_args : ['-lpthread'],
   link_args: '-lm',
   install : with_install_tests,
 )


[FILE:358:patches/patch-tests_nouveau_meson.build]
--- tests/nouveau/meson.build.orig	2023-11-20 13:03:51 UTC
+++ tests/nouveau/meson.build
@@ -24,6 +24,7 @@ threaded = executable(
   dependencies : [dep_dl, dep_threads],
   include_directories : [inc_root, inc_drm, include_directories('../../nouveau')],
   link_with : [libdrm, libdrm_nouveau],
+  link_args : ['-lpthread'],
   c_args : libdrm_c_args,
 )
 


[FILE:387:patches/patch-tests_nouveau_threaded.c]
--- tests/nouveau/threaded.c.orig	2023-11-20 13:03:51 UTC
+++ tests/nouveau/threaded.c
@@ -36,7 +36,7 @@ static int failed;
 
 static int import_fd;
 
-#if defined(__GLIBC__) || defined(__FreeBSD__)
+#if defined(__GLIBC__) || defined(__FreeBSD__) || defined(__DragonFly__) || defined(__NetBSD__)
 int ioctl(int fd, unsigned long request, ...)
 #else
 int ioctl(int fd, int request, ...)


[FILE:7506:patches/patch-xf86drm.c]
--- xf86drm.c.orig	2023-11-20 13:03:51 UTC
+++ xf86drm.c
@@ -63,7 +63,17 @@
 #include <math.h>
 #include <inttypes.h>
 
-#if defined(__FreeBSD__)
+#ifndef O_CLOEXEC
+#define O_CLOEXEC 0
+#endif
+
+#if defined(__FreeBSD__) || defined(__FreeBSD_kernel__) || defined(__DragonFly__)
+#define FREEDFLY 1
+#else
+#define FREEDFLY 0
+#endif
+
+#if FREEDFLY
 #include <sys/param.h>
 #include <sys/pciio.h>
 #endif
@@ -86,7 +96,10 @@
 #endif
 
 #ifdef __NetBSD__
-#define DRM_MAJOR 34
+#define DRM_MAJOR 180
+#include <sys/param.h>
+#include <dev/pci/pcireg.h>
+#include <pci.h>
 #endif
 
 #ifdef __OpenBSD__
@@ -317,8 +330,10 @@ drmGetFormatModifierNameFromArm(uint64_t
     char *modifier_name = NULL;
     bool result = false;
 
+#ifndef __sun
     fp = open_memstream(&modifier_name, &size);
     if (!fp)
+#endif
         return NULL;
 
     switch (type) {
@@ -463,8 +478,10 @@ drmGetFormatModifierNameFromAmd(uint64_t
     tile_version = AMD_FMT_MOD_GET(TILE_VERSION, modifier);
     dcc = AMD_FMT_MOD_GET(DCC, modifier);
 
+#ifndef __sun
     fp = open_memstream(&mod_amd, &size);
     if (!fp)
+#endif
         return NULL;
 
     /* add tile  */
@@ -1033,7 +1050,7 @@ static int drmGetMinorBase(int type)
 
 static int drmGetMinorType(int major, int minor)
 {
-#ifdef __FreeBSD__
+#if FREEDFLY
     char name[SPECNAMELEN];
     int id;
 
@@ -3286,7 +3303,7 @@ drm_public int drmIsMaster(int fd)
 
 drm_public char *drmGetDeviceNameFromFd(int fd)
 {
-#ifdef __FreeBSD__
+#if FREEDFLY
     struct stat sbuf;
     int maj, min;
     int nodetype;
@@ -3333,7 +3350,7 @@ static bool drmNodeIsDRM(int maj, int mi
     snprintf(path, sizeof(path), "/sys/dev/char/%d:%d/device/drm",
              maj, min);
     return stat(path, &sbuf) == 0;
-#elif defined(__FreeBSD__)
+#elif FREEDFLY
     char name[SPECNAMELEN];
 
     if (!devname_r(makedev(maj, min), S_IFCHR, name, sizeof(name)))
@@ -3456,7 +3473,7 @@ static char *drmGetMinorNameForFD(int fd
 
     closedir(sysdir);
     return NULL;
-#elif defined(__FreeBSD__)
+#elif FREEDFLY
     struct stat sbuf;
     char dname[SPECNAMELEN];
     const char *mname;
@@ -3641,6 +3658,65 @@ static int drmParseSubsystemType(int maj
             return DRM_BUS_VIRTIO;
      }
     return subsystem_type;
+#elif defined(__NetBSD__)
+    int type, fd;
+    drmSetVersion sv;
+    char *buf;
+    unsigned domain, bus, dev;
+    int func;
+    int ret;
+
+    /* Get the type of device we're looking for to pick the right pathname.  */
+    type = drmGetMinorType(maj, min);
+    if (type == -1)
+	return -ENODEV;
+
+    /* Open the device.  Don't try to create it if it's not there.  */
+    fd = drmOpenMinor(min, 0, type);
+    if (fd < 0)
+	return -errno;
+
+    /*
+     * Set the interface version to 1.4 or 1.1, which has the effect of
+     * populating the bus id for us.
+     */
+    sv.drm_di_major = 1;
+    sv.drm_di_minor = 4;
+    sv.drm_dd_major = -1;
+    sv.drm_dd_minor = -1;
+    if (drmSetInterfaceVersion(fd, &sv)) {
+	sv.drm_di_major = 1;
+	sv.drm_di_minor = 1;
+	sv.drm_dd_major = -1;
+	sv.drm_dd_minor = -1;
+	if (drmSetInterfaceVersion(fd, &sv)) {
+	    /*
+	     * We're probably not the master.  Hope the master already
+	     * set the version to >=1.1 so that we can get the busid.
+	     */
+	}
+     }
+
+    /* Get the bus id.  */
+    buf = drmGetBusid(fd);
+
+    /* We're done with the device now.  */
+    (void)close(fd);
+
+    /* If there is no bus id, fail.  */
+    if (buf == NULL)
+	return -ENODEV;
+
+    /* Find a string we know about; otherwise -EINVAL.  */
+    ret = -EINVAL;
+    if (strncmp(buf, "pci:", 4) == 0)
+	ret = DRM_BUS_PCI;
+
+    /* We're done with the bus id.  */
+    free(buf);
+
+    /* Success or not, we're done.  */
+    return ret;
 #elif defined(__OpenBSD__) || defined(__DragonFly__) || defined(__FreeBSD__)
     return DRM_BUS_PCI;
 #else
@@ -3667,7 +3743,7 @@ get_pci_path(int maj, int min, char *pci
 }
 #endif
 
-#ifdef __FreeBSD__
+#if FREEDFLY
 static int get_sysctl_pci_bus_info(int maj, int min, drmPciBusInfoPtr info)
 {
     char dname[SPECNAMELEN];
@@ -3749,6 +3825,73 @@ static int drmParsePciBusInfo(int maj, i
     info->func = func;
 
     return 0;
+#elif defined(__NetBSD__)
+    int type, fd;
+    drmSetVersion sv;
+    char *buf;
+    unsigned domain, bus, dev;
+    int func;
+    int ret;
+
+    /* Get the type of device we're looking for to pick the right pathname.  */
+    type = drmGetMinorType(maj, min);
+    if (type == -1)
+	return -ENODEV;
+
+    /* Open the device.  Don't try to create it if it's not there.  */
+    fd = drmOpenMinor(min, 0, type);
+    if (fd < 0)
+	return -errno;
+
+    /*
+     * Set the interface version to 1.4 or 1.1, which has the effect of
+     * populating the bus id for us.
+     */
+    sv.drm_di_major = 1;
+    sv.drm_di_minor = 4;
+    sv.drm_dd_major = -1;
+    sv.drm_dd_minor = -1;
+    if (drmSetInterfaceVersion(fd, &sv)) {
+	sv.drm_di_major = 1;
+	sv.drm_di_minor = 1;
+	sv.drm_dd_major = -1;
+	sv.drm_dd_minor = -1;
+	if (drmSetInterfaceVersion(fd, &sv)) {
+            /*
+	     * We're probably not the master.  Hope the master already
+	     * set the version to >=1.1 so that we can get the busid.
+	     */
+	}
+    }
+
+    /* Get the bus id.  */
+    buf = drmGetBusid(fd);
+
+    /* We're done with the device now.  */
+    (void)close(fd);
+
+    /* If there is no bus id, fail.  */
+    if (buf == NULL)
+	return -ENODEV;
+
+    /* Parse the bus id.  */
+    ret = sscanf(buf, "pci:%04x:%02x:%02x.%d", &domain, &bus, &dev, &func);
+
+    /* We're done with the bus id.  */
+    free(buf);
+
+    /* If scanf didn't return 4 -- domain, bus, dev, func -- then fail.  */
+    if (ret != 4)
+	return -ENODEV;
+
+    /* Populate the results.  */
+    info->domain = domain;
+    info->bus = bus;
+    info->dev = dev;
+    info->func = func;
+
+    /* Success!  */
+    return 0;
 #elif defined(__OpenBSD__) || defined(__DragonFly__)
     struct drm_pciinfo pinfo;
     int fd, type;
@@ -3917,6 +4060,48 @@ static int drmParsePciDeviceInfo(int maj
         return parse_config_sysfs_file(maj, min, device);
 
     return 0;
+#elif defined(__NetBSD__)
+    drmPciBusInfo businfo;
+    char fname[PATH_MAX];
+    int pcifd;
+    pcireg_t id, class, subsys;
+    int ret;
+
+    /* Find where on the bus the device lives.  */
+    ret = drmParsePciBusInfo(maj, min, &businfo);
+    if (ret)
+	return ret;
+
+    /* Open the pciN device node to get at its config registers.  */
+    if (snprintf(fname, sizeof fname, "/dev/pci%u", businfo.domain)
+	>= sizeof fname)
+	return -ENODEV;
+    if ((pcifd = open(fname, O_RDONLY)) == -1)
+	return -errno;
+
+    ret = -1;
+    /* Read the id and class pci config registers.  */
+    if (pcibus_conf_read(pcifd, businfo.bus, businfo.dev, businfo.func,
+	    PCI_ID_REG, &id) == -1)
+	goto out;
+    if (pcibus_conf_read(pcifd, businfo.bus, businfo.dev, businfo.func,
+	    PCI_CLASS_REG, &class) == -1)
+	goto out;
+    if (pcibus_conf_read(pcifd, businfo.bus, businfo.dev, businfo.func,
+	    PCI_SUBSYS_ID_REG, &subsys) == -1)
+	goto out;
+
+    ret = 0;
+    device->vendor_id = PCI_VENDOR(id);
+    device->device_id = PCI_PRODUCT(id);
+    device->subvendor_id = PCI_SUBSYS_VENDOR(subsys);
+    device->subdevice_id = PCI_SUBSYS_ID(subsys);
+    device->revision_id = PCI_REVISION(class);
+out:
+    if (ret == -1)
+	ret = -errno;
+    close(pcifd);
+    return ret;
 #elif defined(__OpenBSD__) || defined(__DragonFly__)
     struct drm_pciinfo pinfo;
     int fd, type;


[FILE:397:patches/patch-xf86drm.h]
--- xf86drm.h.orig	2023-11-20 13:03:51 UTC
+++ xf86drm.h
@@ -59,6 +59,9 @@ extern "C" {
 #else /* One of the *BSDs */
 
 #include <sys/ioccom.h>
+#ifdef __sun__
+#define _IOC(inout,group,num,len)	(inout | ((len & IOCPARM_MASK) << 16) | ((group) << 8) | (num))
+#endif
 #define DRM_IOCTL_NR(n)         ((n) & 0xff)
 #define DRM_IOC_VOID            IOC_VOID
 #define DRM_IOC_READ            IOC_OUT


[FILE:635:patches/patch-xf86drmMode.c]
--- xf86drmMode.c.orig	2023-11-20 13:03:51 UTC
+++ xf86drmMode.c
@@ -39,9 +39,7 @@
 #include <stdlib.h>
 #include <sys/ioctl.h>
 #if HAVE_SYS_SYSCTL_H
-#ifdef __FreeBSD__
 #include <sys/types.h>
-#endif
 #include <sys/sysctl.h>
 #endif
 #include <stdio.h>
@@ -1129,7 +1127,7 @@ drm_public int drmModePageFlipTarget(int
 
 drm_public int drmModeSetPlane(int fd, uint32_t plane_id, uint32_t crtc_id,
 		    uint32_t fb_id, uint32_t flags,
-		    int32_t crtc_x, int32_t crtc_y,
+		    uint32_t crtc_x, int32_t crtc_y,
 		    uint32_t crtc_w, uint32_t crtc_h,
 		    uint32_t src_x, uint32_t src_y,
 		    uint32_t src_w, uint32_t src_h)


[FILE:505:patches/patch-xf86drmMode.h]
--- xf86drmMode.h.orig	2023-11-20 13:03:51 UTC
+++ xf86drmMode.h
@@ -436,7 +436,7 @@ extern drmModePlaneResPtr drmModeGetPlan
 extern drmModePlanePtr drmModeGetPlane(int fd, uint32_t plane_id);
 extern int drmModeSetPlane(int fd, uint32_t plane_id, uint32_t crtc_id,
 			   uint32_t fb_id, uint32_t flags,
-			   int32_t crtc_x, int32_t crtc_y,
+			   uint32_t crtc_x, int32_t crtc_y,
 			   uint32_t crtc_w, uint32_t crtc_h,
 			   uint32_t src_x, uint32_t src_y,
 			   uint32_t src_w, uint32_t src_h);

