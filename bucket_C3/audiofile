# Buildsheet autogenerated by ravenadm tool -- Do not edit.

NAMEBASE=		audiofile
VERSION=		0.3.6
KEYWORDS=		audio
VARIANTS=		std
SDESC[std]=		Library to handle various audio file formats
HOMEPAGE=		https://audiofile.68k.org/
CONTACT=		nobody

DOWNLOAD_GROUPS=	main
SITES[main]=		GNOME/audiofile/0.3
DISTFILE[1]=		audiofile-0.3.6.tar.xz:main
DF_INDEX=		1
SPKGS[std]=		set
			primary
			dev
			tools
			man

OPTIONS_AVAILABLE=	none
OPTIONS_STANDARD=	none

BUILD_DEPENDS=		flac:dev:std
BUILDRUN_DEPENDS=	flac:primary:std

USES=			cpe pkgconfig libtool c++:primary

LICENSE=		LGPL21+:primary
LICENSE_TERMS=		primary:{{WRKDIR}}/TERMS
LICENSE_FILE=		LGPL21+:{{WRKSRC}}/COPYING
LICENSE_SCHEME=		solo

FPC_EQUIVALENT=		audio/libaudiofile

MUST_CONFIGURE=		gnu

INSTALL_TARGET=		install-strip
SOVERSION=		1.0.0

post-extract:
	# extract license terms
	${AWK} '/Audio File Library itself/,EOF' ${WRKSRC}/README\
		> ${WRKDIR}/TERMS

[FILE:987:descriptions/desc.primary]
The Audio File Library is a C-based library for reading and writing audio
files in many common formats.

The Audio File Library provides a uniform API which abstracts away details
of file formats and data formats. The same calls for opening a file,
accessing and manipulating audio metadata (e.g. sample rate, sample format,
textual information, MIDI parameters), and reading and writing sample data
will work with any supported audio file format. The Audio File Library lets
you work with audio data in whatever format is most convenient for you.

Supported file formats:
- AIFF/AIFF-C (.aiff, .aifc)
- WAVE (.wav)
- NeXT .snd/Sun .au (.snd, .au)
- Berkeley/IRCAM/CARL Sound File (.sf)
- Audio Visual Research (.avr)
- Amiga IFF/8SVX (.iff)
- Sample Vision (.smp)
- Creative Voice File (.voc)
- NIST SPHERE (.wav)
- Core Audio Format (.caf)
- FLAC (.flac)

Supported compression formats:
- G.711 mu-law and A-law
- IMA ADPCM
- Microsoft ADPCM
- FLAC
- ALAC (Apple Lossless Audio Codec)


[FILE:42:descriptions/desc.tools]
This package contains audiofile programs.


[FILE:101:distinfo]
ea2449ad3f201ec590d811db9da6d02ffc5e87a677d06b92ab15363d8cb59782       530760 audiofile-0.3.6.tar.xz


[FILE:65:manifests/plist.primary]
lib/
 libaudiofile.so.%%SOMAJOR%%
 libaudiofile.so.%%SOVERSION%%


[FILE:109:manifests/plist.dev]
lib/pkgconfig/audiofile.pc
include/
 af_vfs.h
 audiofile.h
 aupvlist.h
lib/
 libaudiofile.a
 libaudiofile.so


[FILE:24:manifests/plist.tools]
bin/
 sfconvert
 sfinfo


[FILE:632:manifests/plist.man]
share/man/man1/
 sfconvert.1
 sfinfo.1
share/man/man3/
 afCloseFile.3
 afGetDataOffset.3
 afGetFrameCount.3
 afGetFrameSize.3
 afGetTrackBytes.3
 afInitAESChannelData.3
 afInitAESChannelDataTo.3
 afInitByteOrder.3
 afInitChannels.3
 afInitCompression.3
 afInitFileFormat.3
 afInitRate.3
 afInitSampleFormat.3
 afNewFileSetup.3
 afOpenFile.3
 afQuery.3
 afQueryDouble.3
 afQueryLong.3
 afQueryPointer.3
 afReadFrames.3
 afReadMisc.3
 afSeekFrame.3
 afSeekMisc.3
 afSetErrorHandler.3
 afSetVirtualByteOrder.3
 afSetVirtualChannels.3
 afSetVirtualPCMMapping.3
 afSetVirtualSampleFormat.3
 afTellFrame.3
 afWriteFrames.3
 afWriteMisc.3


[FILE:2907:patches/patch-01_gcc6]
Description: Fix FTBFS with GCC 6
Author: Michael Schwendt <mschwendt@fedoraproject.org>
Origin: vendor, https://github.com/mpruett/audiofile/pull/27
Bug-Debian: https://bugs.debian.org/812055
---
This patch header follows DEP-3: http://dep.debian.net/deps/dep3/

--- libaudiofile/modules/SimpleModule.h
+++ libaudiofile/modules/SimpleModule.h
@@ -123,7 +123,7 @@ struct signConverter
 	typedef typename IntTypes<Format>::UnsignedType UnsignedType;
 
 	static const int kScaleBits = (Format + 1) * CHAR_BIT - 1;
-	static const int kMinSignedValue = -1 << kScaleBits;
+	static const int kMinSignedValue = 0-(1U<<kScaleBits);
 
 	struct signedToUnsigned : public std::unary_function<SignedType, UnsignedType>
 	{
--- test/FloatToInt.cpp
+++ test/FloatToInt.cpp
@@ -115,7 +115,7 @@ TEST_F(FloatToIntTest, Int16)
 		EXPECT_EQ(readData[i], expectedData[i]);
 }
 
-static const int32_t kMinInt24 = -1<<23;
+static const int32_t kMinInt24 = 0-(1U<<23);
 static const int32_t kMaxInt24 = (1<<23) - 1;
 
 TEST_F(FloatToIntTest, Int24)
--- test/IntToFloat.cpp
+++ test/IntToFloat.cpp
@@ -117,7 +117,7 @@ TEST_F(IntToFloatTest, Int16)
 		EXPECT_EQ(readData[i], expectedData[i]);
 }
 
-static const int32_t kMinInt24 = -1<<23;
+static const int32_t kMinInt24 = 0-(1U<<23);
 static const int32_t kMaxInt24 = (1<<23) - 1;
 
 TEST_F(IntToFloatTest, Int24)
--- test/NeXT.cpp
+++ test/NeXT.cpp
@@ -37,13 +37,13 @@
 
 #include "TestUtilities.h"
 
-const char kDataUnspecifiedLength[] =
+const signed char kDataUnspecifiedLength[] =
 {
 	'.', 's', 'n', 'd',
 	0, 0, 0, 24, // offset of 24 bytes
-	0xff, 0xff, 0xff, 0xff, // unspecified length
+	-1, -1, -1, -1, // unspecified length
 	0, 0, 0, 3, // 16-bit linear
-	0, 0, 172, 68, // 44100 Hz
+	0, 0, -84, 68, // 44100 Hz (0xAC44)
 	0, 0, 0, 1, // 1 channel
 	0, 1,
 	0, 1,
@@ -57,13 +57,13 @@ const char kDataUnspecifiedLength[] =
 	0, 55
 };
 
-const char kDataTruncated[] =
+const signed char kDataTruncated[] =
 {
 	'.', 's', 'n', 'd',
 	0, 0, 0, 24, // offset of 24 bytes
 	0, 0, 0, 20, // length of 20 bytes
 	0, 0, 0, 3, // 16-bit linear
-	0, 0, 172, 68, // 44100 Hz
+	0, 0, -84, 68, // 44100 Hz (0xAC44)
 	0, 0, 0, 1, // 1 channel
 	0, 1,
 	0, 1,
@@ -152,13 +152,13 @@ TEST(NeXT, Truncated)
 	ASSERT_EQ(::unlink(testFileName.c_str()), 0);
 }
 
-const char kDataZeroChannels[] =
+const signed char kDataZeroChannels[] =
 {
 	'.', 's', 'n', 'd',
 	0, 0, 0, 24, // offset of 24 bytes
 	0, 0, 0, 2, // 2 bytes
 	0, 0, 0, 3, // 16-bit linear
-	0, 0, 172, 68, // 44100 Hz
+	0, 0, -84, 68, // 44100 Hz (0xAC44)
 	0, 0, 0, 0, // 0 channels
 	0, 1
 };
--- test/Sign.cpp
+++ test/Sign.cpp
@@ -116,7 +116,7 @@ TEST_F(SignConversionTest, Int16)
 		EXPECT_EQ(readData[i], expectedData[i]);
 }
 
-static const int32_t kMinInt24 = -1<<23;
+static const int32_t kMinInt24 = 0-(1U<<23);
 static const int32_t kMaxInt24 = (1<<23) - 1;
 static const uint32_t kMaxUInt24 = (1<<24) - 1;
 


[FILE:10170:patches/patch-02_hurd]
Description: Remove usage of PATH_MAX in tests to fix FTBFS on Hurd.
 jcowgill: Removed Changelog changes
Author: Pino Toscano <toscano.pino@tiscali.it>
Origin: backport, https://github.com/mpruett/audiofile/commit/34c261034f1193a783196618f0052112e00fbcfe
Bug: https://github.com/mpruett/audiofile/pull/17
Bug-Debian: https://bugs.debian.org/762595
---
This patch header follows DEP-3: http://dep.debian.net/deps/dep3/

--- test/TestUtilities.cpp
+++ test/TestUtilities.cpp
@@ -21,8 +21,8 @@
 #include "TestUtilities.h"
 
 #include <limits.h>
-#include <stdio.h>
 #include <stdlib.h>
+#include <string.h>
 #include <unistd.h>
 
 bool createTemporaryFile(const std::string &prefix, std::string *path)
@@ -35,12 +35,12 @@ bool createTemporaryFile(const std::stri
 	return true;
 }
 
-bool createTemporaryFile(const char *prefix, char *path)
+bool createTemporaryFile(const char *prefix, char **path)
 {
-	snprintf(path, PATH_MAX, "/tmp/%s-XXXXXX", prefix);
-	int fd = ::mkstemp(path);
-	if (fd < 0)
-		return false;
-	::close(fd);
-	return true;
+	*path = NULL;
+	std::string pathString;
+	bool result = createTemporaryFile(prefix, &pathString);
+	if (result)
+		*path = ::strdup(pathString.c_str());
+	return result;
 }
--- test/TestUtilities.h
+++ test/TestUtilities.h
@@ -53,7 +53,7 @@ extern "C" {
 
 #include <stdbool.h>
 
-bool createTemporaryFile(const char *prefix, char *path);
+bool createTemporaryFile(const char *prefix, char **path);
 
 #ifdef __cplusplus
 }
--- test/floatto24.c
+++ test/floatto24.c
@@ -86,8 +86,8 @@ int main (int argc, char **argv)
 	afInitChannels(setup, AF_DEFAULT_TRACK, 1);
 	afInitSampleFormat(setup, AF_DEFAULT_TRACK, AF_SAMPFMT_FLOAT, 32);
 
-	char testFileName[PATH_MAX];
-	if (!createTemporaryFile("floatto24", testFileName))
+	char *testFileName;
+	if (!createTemporaryFile("floatto24", &testFileName))
 	{
 		fprintf(stderr, "Could not create temporary file.\n");
 		exit(EXIT_FAILURE);
@@ -182,6 +182,7 @@ int main (int argc, char **argv)
 	}
 
 	unlink(testFileName);
+	free(testFileName);
 
 	exit(EXIT_SUCCESS);
 }
--- test/sixteen-to-eight.c
+++ test/sixteen-to-eight.c
@@ -57,8 +57,8 @@ int main (int argc, char **argv)
 	afInitSampleFormat(setup, AF_DEFAULT_TRACK, AF_SAMPFMT_UNSIGNED, 8);
 	afInitChannels(setup, AF_DEFAULT_TRACK, 1);
 
-	char testFileName[PATH_MAX];
-	if (!createTemporaryFile("sixteen-to-eight", testFileName))
+	char *testFileName;
+	if (!createTemporaryFile("sixteen-to-eight", &testFileName))
 	{
 		fprintf(stderr, "Could not create temporary file.\n");
 		exit(EXIT_FAILURE);
@@ -113,6 +113,7 @@ int main (int argc, char **argv)
 
 	afCloseFile(file);
 	unlink(testFileName);
+	free(testFileName);
 
 	exit(EXIT_SUCCESS);
 }
--- test/testchannelmatrix.c
+++ test/testchannelmatrix.c
@@ -39,7 +39,7 @@
 
 #include "TestUtilities.h"
 
-static char sTestFileName[PATH_MAX];
+static char *sTestFileName;
 
 const short samples[] = {300, -300, 515, -515, 2315, -2315, 9154, -9154};
 #define SAMPLE_COUNT (sizeof (samples) / sizeof (short))
@@ -47,7 +47,11 @@ const short samples[] = {300, -300, 515,
 
 void cleanup (void)
 {
-	unlink(sTestFileName);
+	if (sTestFileName)
+	{
+		unlink(sTestFileName);
+		free(sTestFileName);
+	}
 }
 
 void ensure (int condition, const char *message)
@@ -76,7 +80,7 @@ int main (void)
 	afInitFileFormat(setup, AF_FILE_AIFFC);
 
 	/* Write stereo data to test file. */
-	ensure(createTemporaryFile("testchannelmatrix", sTestFileName),
+	ensure(createTemporaryFile("testchannelmatrix", &sTestFileName),
 		"could not create temporary file");
 	file = afOpenFile(sTestFileName, "w", setup);
 	ensure(file != AF_NULL_FILEHANDLE, "could not open file for writing");
--- test/testdouble.c
+++ test/testdouble.c
@@ -38,7 +38,7 @@
 
 #include "TestUtilities.h"
 
-static char sTestFileName[PATH_MAX];
+static char *sTestFileName;
 
 const double samples[] =
 	{1.0, 0.6, -0.3, 0.95, 0.2, -0.6, 0.9, 0.4, -0.22, 0.125, 0.1, -0.4};
@@ -48,7 +48,11 @@ void testdouble (int fileFormat);
 
 void cleanup (void)
 {
-	unlink(sTestFileName);
+	if (sTestFileName)
+	{
+		unlink(sTestFileName);
+		free(sTestFileName);
+	}
 }
 
 void ensure (int condition, const char *message)
@@ -96,7 +100,7 @@ void testdouble (int fileFormat)
 	afInitSampleFormat(setup, AF_DEFAULT_TRACK, AF_SAMPFMT_DOUBLE, 64);
 	afInitChannels(setup, AF_DEFAULT_TRACK, 2);
 
-	ensure(createTemporaryFile("testdouble", sTestFileName),
+	ensure(createTemporaryFile("testdouble", &sTestFileName),
 		"could not create temporary file");
 	file = afOpenFile(sTestFileName, "w", setup);
 	ensure(file != AF_NULL_FILEHANDLE, "could not open file for writing");
--- test/testfloat.c
+++ test/testfloat.c
@@ -38,7 +38,7 @@
 
 #include "TestUtilities.h"
 
-static char sTestFileName[PATH_MAX];
+static char *sTestFileName;
 
 const float samples[] =
 	{1.0, 0.6, -0.3, 0.95, 0.2, -0.6, 0.9, 0.4, -0.22, 0.125, 0.1, -0.4};
@@ -48,7 +48,11 @@ void testfloat (int fileFormat);
 
 void cleanup (void)
 {
-	unlink(sTestFileName);
+	if (sTestFileName)
+	{
+		unlink(sTestFileName);
+		free(sTestFileName);
+	}
 }
 
 void ensure (int condition, const char *message)
@@ -96,7 +100,7 @@ void testfloat (int fileFormat)
 	afInitSampleFormat(setup, AF_DEFAULT_TRACK, AF_SAMPFMT_FLOAT, 32);
 	afInitChannels(setup, AF_DEFAULT_TRACK, 2);
 
-	ensure(createTemporaryFile("testfloat", sTestFileName),
+	ensure(createTemporaryFile("testfloat", &sTestFileName),
 		"could not create temporary file");
 	file = afOpenFile(sTestFileName, "w", setup);
 	ensure(file != AF_NULL_FILEHANDLE, "could not open file for writing");
--- test/testmarkers.c
+++ test/testmarkers.c
@@ -32,15 +32,19 @@
 
 #include "TestUtilities.h"
 
-static char sTestFileName[PATH_MAX];
+static char *sTestFileName;
 
 #define FRAME_COUNT 200
 
 void cleanup (void)
 {
+	if (sTestFileName)
+	{
 #ifndef DEBUG
-	unlink(sTestFileName);
+		unlink(sTestFileName);
 #endif
+		free(sTestFileName);
+	}
 }
 
 void ensure (int condition, const char *message)
@@ -127,7 +131,7 @@ int testmarkers (int fileformat)
 
 int main (void)
 {
-	ensure(createTemporaryFile("testmarkers", sTestFileName),
+	ensure(createTemporaryFile("testmarkers", &sTestFileName),
 		"could not create temporary file");
 
 	testmarkers(AF_FILE_AIFF);
--- test/twentyfour.c
+++ test/twentyfour.c
@@ -71,8 +71,8 @@ int main (int argc, char **argv)
 	afInitSampleFormat(setup, AF_DEFAULT_TRACK, AF_SAMPFMT_TWOSCOMP, 24);
 	afInitChannels(setup, AF_DEFAULT_TRACK, 1);
 
-	char testFileName[PATH_MAX];
-	if (!createTemporaryFile("twentyfour", testFileName))
+	char *testFileName;
+	if (!createTemporaryFile("twentyfour", &testFileName))
 	{
 		fprintf(stderr, "could not create temporary file\n");
 		exit(EXIT_FAILURE);
@@ -239,6 +239,7 @@ int main (int argc, char **argv)
 		exit(EXIT_FAILURE);
 	}
 	unlink(testFileName);
+	free(testFileName);
 
 	exit(EXIT_SUCCESS);
 }
--- test/twentyfour2.c
+++ test/twentyfour2.c
@@ -45,15 +45,19 @@
 
 #include "TestUtilities.h"
 
-static char sTestFileName[PATH_MAX];
+static char *sTestFileName;
 
 #define FRAME_COUNT 10000
 
 void cleanup (void)
 {
+	if (sTestFileName)
+	{
 #ifndef DEBUG
-	unlink(sTestFileName);
+		unlink(sTestFileName);
 #endif
+		free(sTestFileName);
+	}
 }
 
 void ensure (int condition, const char *message)
@@ -78,7 +82,7 @@ int main (void)
 	afInitChannels(setup, AF_DEFAULT_TRACK, 1);
 	afInitSampleFormat(setup, AF_DEFAULT_TRACK, AF_SAMPFMT_TWOSCOMP, 24);
 
-	ensure(createTemporaryFile("twentyfour2", sTestFileName),
+	ensure(createTemporaryFile("twentyfour2", &sTestFileName),
 		"could not create temporary file");
 	file = afOpenFile(sTestFileName, "w", setup);
 	ensure(file != NULL, "could not open test file for writing");
--- test/writealaw.c
+++ test/writealaw.c
@@ -53,7 +53,7 @@
 
 #include "TestUtilities.h"
 
-static char sTestFileName[PATH_MAX];
+static char *sTestFileName;
 
 #define FRAME_COUNT 16
 #define SAMPLE_COUNT FRAME_COUNT
@@ -62,9 +62,13 @@ void testalaw (int fileFormat);
 
 void cleanup (void)
 {
+	if (sTestFileName)
+	{
 #ifndef DEBUG
-	unlink(sTestFileName);
+		unlink(sTestFileName);
 #endif
+		free(sTestFileName);
+	}
 }
 
 void ensure (int condition, const char *message)
@@ -113,7 +117,7 @@ void testalaw (int fileFormat)
 	afInitFileFormat(setup, fileFormat);
 	afInitChannels(setup, AF_DEFAULT_TRACK, 1);
 
-	ensure(createTemporaryFile("writealaw", sTestFileName),
+	ensure(createTemporaryFile("writealaw", &sTestFileName),
 		"could not create temporary file");
 	file = afOpenFile(sTestFileName, "w", setup);
 	afFreeFileSetup(setup);
--- test/writeraw.c
+++ test/writeraw.c
@@ -44,13 +44,17 @@
 
 #include "TestUtilities.h"
 
-static char sTestFileName[PATH_MAX];
+static char *sTestFileName;
 
 void cleanup (void)
 {
+	if (sTestFileName)
+	{
 #ifndef DEBUG
-	unlink(sTestFileName);
+		unlink(sTestFileName);
 #endif
+		free(sTestFileName);
+	}
 }
 
 void ensure (int condition, const char *message)
@@ -84,7 +88,7 @@ int main (int argc, char **argv)
 	afInitChannels(setup, AF_DEFAULT_TRACK, 1);
 	afInitSampleFormat(setup, AF_DEFAULT_TRACK, AF_SAMPFMT_TWOSCOMP, 16);
 
-	ensure(createTemporaryFile("writeraw", sTestFileName),
+	ensure(createTemporaryFile("writeraw", &sTestFileName),
 		"could not create temporary file");
 	file = afOpenFile(sTestFileName, "w", setup);
 	ensure(file != AF_NULL_FILEHANDLE, "unable to open file for writing");
--- test/writeulaw.c
+++ test/writeulaw.c
@@ -53,7 +53,7 @@
 
 #include "TestUtilities.h"
 
-static char sTestFileName[PATH_MAX];
+static char *sTestFileName;
 
 #define FRAME_COUNT 16
 #define SAMPLE_COUNT FRAME_COUNT
@@ -62,9 +62,13 @@ void testulaw (int fileFormat);
 
 void cleanup (void)
 {
+	if (sTestFileName)
+	{
 #ifndef DEBUG
-	unlink(sTestFileName);
+		unlink(sTestFileName);
 #endif
+		free(sTestFileName);
+	}
 }
 
 void ensure (int condition, const char *message)
@@ -113,7 +117,7 @@ void testulaw (int fileFormat)
 	afInitFileFormat(setup, fileFormat);
 	afInitChannels(setup, AF_DEFAULT_TRACK, 1);
 
-	ensure(createTemporaryFile("writeulaw", sTestFileName),
+	ensure(createTemporaryFile("writeulaw", &sTestFileName),
 		"could not create temporary file");
 	file = afOpenFile(sTestFileName, "w", setup);
 	afFreeFileSetup(setup);


[FILE:4290:patches/patch-03_CVE-2015-7747]
Description: fix buffer overflow when changing both sample format and
 number of channels
Origin: https://github.com/mpruett/audiofile/pull/25
Bug-Ubuntu: https://bugs.launchpad.net/ubuntu/+source/audiofile/+bug/1502721
Bug-Debian: https://bugs.debian.org/801102

--- libaudiofile/modules/ModuleState.cpp
+++ libaudiofile/modules/ModuleState.cpp
@@ -402,7 +402,7 @@ status ModuleState::arrange(AFfilehandle
 		addModule(new Transform(outfc, in.pcm, out.pcm));
 
 	if (in.channelCount != out.channelCount)
-		addModule(new ApplyChannelMatrix(infc, isReading,
+		addModule(new ApplyChannelMatrix(outfc, isReading,
 			in.channelCount, out.channelCount,
 			in.pcm.minClip, in.pcm.maxClip,
 			track->channelMatrix));
--- test/Makefile.am
+++ test/Makefile.am
@@ -26,6 +26,7 @@ TESTS = \
 	VirtualFile \
 	floatto24 \
 	query2 \
+	sixteen-stereo-to-eight-mono \
 	sixteen-to-eight \
 	testchannelmatrix \
 	testdouble \
@@ -139,6 +140,7 @@ printmarkers_SOURCES = printmarkers.c
 printmarkers_LDADD = $(LIBAUDIOFILE) -lm
 
 sixteen_to_eight_SOURCES = sixteen-to-eight.c TestUtilities.cpp TestUtilities.h
+sixteen_stereo_to_eight_mono_SOURCES = sixteen-stereo-to-eight-mono.c TestUtilities.cpp TestUtilities.h
 
 testchannelmatrix_SOURCES = testchannelmatrix.c TestUtilities.cpp TestUtilities.h
 
--- /dev/null
+++ test/sixteen-stereo-to-eight-mono.c
@@ -0,0 +1,118 @@
+/*
+	Audio File Library
+
+	Copyright 2000, Silicon Graphics, Inc.
+
+	This program is free software; you can redistribute it and/or modify
+	it under the terms of the GNU General Public License as published by
+	the Free Software Foundation; either version 2 of the License, or
+	(at your option) any later version.
+
+	This program is distributed in the hope that it will be useful,
+	but WITHOUT ANY WARRANTY; without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+	GNU General Public License for more details.
+
+	You should have received a copy of the GNU General Public License along
+	with this program; if not, write to the Free Software Foundation, Inc.,
+	51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+*/
+
+/*
+	sixteen-stereo-to-eight-mono.c
+
+	This program tests the conversion from 2-channel 16-bit integers to
+	1-channel 8-bit	integers.
+*/
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include <stdint.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+#include <limits.h>
+
+#include <audiofile.h>
+
+#include "TestUtilities.h"
+
+int main (int argc, char **argv)
+{
+	AFfilehandle file;
+	AFfilesetup setup;
+	int16_t frames16[] = {14298, 392, 3923, -683, 958, -1921};
+	int8_t frames8[] = {28, 6, -2};
+	int i, frameCount = 3;
+	int8_t byte;
+	AFframecount result;
+
+	setup = afNewFileSetup();
+
+	afInitFileFormat(setup, AF_FILE_WAVE);
+
+	afInitSampleFormat(setup, AF_DEFAULT_TRACK, AF_SAMPFMT_TWOSCOMP, 16);
+	afInitChannels(setup, AF_DEFAULT_TRACK, 2);
+
+	char *testFileName;
+	if (!createTemporaryFile("sixteen-to-eight", &testFileName))
+	{
+		fprintf(stderr, "Could not create temporary file.\n");
+		exit(EXIT_FAILURE);
+	}
+
+	file = afOpenFile(testFileName, "w", setup);
+	if (file == AF_NULL_FILEHANDLE)
+	{
+		fprintf(stderr, "could not open file for writing\n");
+		exit(EXIT_FAILURE);
+	}
+
+	afFreeFileSetup(setup);
+
+	afWriteFrames(file, AF_DEFAULT_TRACK, frames16, frameCount);
+
+	afCloseFile(file);
+
+	file = afOpenFile(testFileName, "r", AF_NULL_FILESETUP);
+	if (file == AF_NULL_FILEHANDLE)
+	{
+		fprintf(stderr, "could not open file for reading\n");
+		exit(EXIT_FAILURE);
+	}
+
+	afSetVirtualSampleFormat(file, AF_DEFAULT_TRACK, AF_SAMPFMT_TWOSCOMP, 8);
+	afSetVirtualChannels(file, AF_DEFAULT_TRACK, 1);
+
+	for (i=0; i<frameCount; i++)
+	{
+		/* Read one frame. */
+		result = afReadFrames(file, AF_DEFAULT_TRACK, &byte, 1);
+
+		if (result != 1)
+			break;
+
+		/* Compare the byte read with its precalculated value. */
+		if (memcmp(&byte, &frames8[i], 1) != 0)
+		{
+			printf("error\n");
+			printf("expected %d, got %d\n", frames8[i], byte);
+			exit(EXIT_FAILURE);
+		}
+		else
+		{
+#ifdef DEBUG
+			printf("got what was expected: %d\n", byte);
+#endif
+		}
+	}
+
+	afCloseFile(file);
+	unlink(testFileName);
+	free(testFileName);
+
+	exit(EXIT_SUCCESS);
+}


[FILE:1119:patches/patch-04_clamp-index-values-to-fix-index-overflow-in-IMA.cpp]
From: Antonio Larrosa <larrosa@kde.org>
Date: Mon, 6 Mar 2017 18:02:31 +0100
Subject: clamp index values to fix index overflow in IMA.cpp

This fixes #33
(also reported at https://bugzilla.opensuse.org/show_bug.cgi?id=1026981
and https://blogs.gentoo.org/ago/2017/02/20/audiofile-global-buffer-overflow-in-decodesample-ima-cpp/)
---
 libaudiofile/modules/IMA.cpp | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

--- libaudiofile/modules/IMA.cpp
+++ libaudiofile/modules/IMA.cpp
@@ -169,7 +169,7 @@ int IMA::decodeBlockWAVE(const uint8_t *encoded, int16_t *decoded)
 		if (encoded[1] & 0x80)
 			m_adpcmState[c].previousValue -= 0x10000;
 
-		m_adpcmState[c].index = encoded[2];
+		m_adpcmState[c].index = clamp(encoded[2], 0, 88);
 
 		*decoded++ = m_adpcmState[c].previousValue;
 
@@ -210,7 +210,7 @@ int IMA::decodeBlockQT(const uint8_t *encoded, int16_t *decoded)
 			predictor -= 0x10000;
 
 		state.previousValue = clamp(predictor, MIN_INT16, MAX_INT16);
-		state.index = encoded[1] & 0x7f;
+		state.index = clamp(encoded[1] & 0x7f, 0, 88);
 		encoded += 2;
 
 		for (int n=0; n<m_framesPerPacket; n+=2)


[FILE:854:patches/patch-05_Always-check-the-number-of-coefficients]
From: Antonio Larrosa <larrosa@kde.org>
Date: Mon, 6 Mar 2017 12:51:22 +0100
Subject: Always check the number of coefficients

When building the library with NDEBUG, asserts are eliminated
so it's better to always check that the number of coefficients
is inside the array range.

This fixes the 00191-audiofile-indexoob issue in #41
---
 libaudiofile/WAVE.cpp | 6 ++++++
 1 file changed, 6 insertions(+)

--- libaudiofile/WAVE.cpp
+++ libaudiofile/WAVE.cpp
@@ -281,6 +281,12 @@ status WAVEFile::parseFormat(const Tag &id, uint32_t size)
 
 			/* numCoefficients should be at least 7. */
 			assert(numCoefficients >= 7 && numCoefficients <= 255);
+			if (numCoefficients < 7 || numCoefficients > 255)
+			{
+				_af_error(AF_BAD_HEADER,
+						"Bad number of coefficients");
+				return AF_FAIL;
+			}
 
 			m_msadpcmNumCoefficients = numCoefficients;
 


[FILE:3471:patches/patch-06_Check-for-multiplication-overflow-in-MSADPCM-decodeSam]
From: Antonio Larrosa <larrosa@kde.org>
Date: Mon, 6 Mar 2017 13:43:53 +0100
Subject: Check for multiplication overflow in MSADPCM decodeSample

Check for multiplication overflow (using __builtin_mul_overflow
if available) in MSADPCM.cpp decodeSample and return an empty
decoded block if an error occurs.

This fixes the 00193-audiofile-signintoverflow-MSADPCM case of #41
---
 libaudiofile/modules/BlockCodec.cpp |  5 ++--
 libaudiofile/modules/MSADPCM.cpp    | 47 +++++++++++++++++++++++++++++++++----
 2 files changed, 46 insertions(+), 6 deletions(-)

--- libaudiofile/modules/BlockCodec.cpp
+++ libaudiofile/modules/BlockCodec.cpp
@@ -52,8 +52,9 @@ void BlockCodec::runPull()
 	// Decompress into m_outChunk.
 	for (int i=0; i<blocksRead; i++)
 	{
-		decodeBlock(static_cast<const uint8_t *>(m_inChunk->buffer) + i * m_bytesPerPacket,
-			static_cast<int16_t *>(m_outChunk->buffer) + i * m_framesPerPacket * m_track->f.channelCount);
+		if (decodeBlock(static_cast<const uint8_t *>(m_inChunk->buffer) + i * m_bytesPerPacket,
+			static_cast<int16_t *>(m_outChunk->buffer) + i * m_framesPerPacket * m_track->f.channelCount)==0)
+			break;
 
 		framesRead += m_framesPerPacket;
 	}
--- libaudiofile/modules/MSADPCM.cpp
+++ libaudiofile/modules/MSADPCM.cpp
@@ -101,24 +101,60 @@ static const int16_t adaptationTable[] =
 	768, 614, 512, 409, 307, 230, 230, 230
 };
 
+int firstBitSet(int x)
+{
+        int position=0;
+        while (x!=0)
+        {
+                x>>=1;
+                ++position;
+        }
+        return position;
+}
+
+#ifndef __has_builtin
+#define __has_builtin(x) 0
+#endif
+
+int multiplyCheckOverflow(int a, int b, int *result)
+{
+#if (defined __GNUC__ && __GNUC__ >= 5) || ( __clang__ && __has_builtin(__builtin_mul_overflow))
+	return __builtin_mul_overflow(a, b, result);
+#else
+	if (firstBitSet(a)+firstBitSet(b)>31) // int is signed, so we can't use 32 bits
+		return true;
+	*result = a * b;
+	return false;
+#endif
+}
+
+
 // Compute a linear PCM value from the given differential coded value.
 static int16_t decodeSample(ms_adpcm_state &state,
-	uint8_t code, const int16_t *coefficient)
+	uint8_t code, const int16_t *coefficient, bool *ok=NULL)
 {
 	int linearSample = (state.sample1 * coefficient[0] +
 		state.sample2 * coefficient[1]) >> 8;
+	int delta;
 
 	linearSample += ((code & 0x08) ? (code - 0x10) : code) * state.delta;
 
 	linearSample = clamp(linearSample, MIN_INT16, MAX_INT16);
 
-	int delta = (state.delta * adaptationTable[code]) >> 8;
+	if (multiplyCheckOverflow(state.delta, adaptationTable[code], &delta))
+	{
+                if (ok) *ok=false;
+		_af_error(AF_BAD_COMPRESSION, "Error decoding sample");
+		return 0;
+	}
+	delta >>= 8;
 	if (delta < 16)
 		delta = 16;
 
 	state.delta = delta;
 	state.sample2 = state.sample1;
 	state.sample1 = linearSample;
+	if (ok) *ok=true;
 
 	return static_cast<int16_t>(linearSample);
 }
@@ -212,13 +248,16 @@ int MSADPCM::decodeBlock(const uint8_t *encoded, int16_t *decoded)
 	{
 		uint8_t code;
 		int16_t newSample;
+		bool ok;
 
 		code = *encoded >> 4;
-		newSample = decodeSample(*state[0], code, coefficient[0]);
+		newSample = decodeSample(*state[0], code, coefficient[0], &ok);
+		if (!ok) return 0;
 		*decoded++ = newSample;
 
 		code = *encoded & 0x0f;
-		newSample = decodeSample(*state[1], code, coefficient[1]);
+		newSample = decodeSample(*state[1], code, coefficient[1], &ok);
+		if (!ok) return 0;
 		*decoded++ = newSample;
 
 		encoded++;


[FILE:1880:patches/patch-07_Check-for-multiplication-overflow-in-sfconvert]
From: Antonio Larrosa <larrosa@kde.org>
Date: Mon, 6 Mar 2017 13:54:52 +0100
Subject: Check for multiplication overflow in sfconvert

Checks that a multiplication doesn't overflow when
calculating the buffer size, and if it overflows,
reduce the buffer size instead of failing.

This fixes the 00192-audiofile-signintoverflow-sfconvert case
in #41
---
 sfcommands/sfconvert.c | 34 ++++++++++++++++++++++++++++++++--
 1 file changed, 32 insertions(+), 2 deletions(-)

--- sfcommands/sfconvert.c
+++ sfcommands/sfconvert.c
@@ -45,6 +45,33 @@ void printusage (void);
 void usageerror (void);
 bool copyaudiodata (AFfilehandle infile, AFfilehandle outfile, int trackid);
 
+int firstBitSet(int x)
+{
+        int position=0;
+        while (x!=0)
+        {
+                x>>=1;
+                ++position;
+        }
+        return position;
+}
+
+#ifndef __has_builtin
+#define __has_builtin(x) 0
+#endif
+
+int multiplyCheckOverflow(int a, int b, int *result)
+{
+#if (defined __GNUC__ && __GNUC__ >= 5) || ( __clang__ && __has_builtin(__builtin_mul_overflow))
+	return __builtin_mul_overflow(a, b, result);
+#else
+	if (firstBitSet(a)+firstBitSet(b)>31) // int is signed, so we can't use 32 bits
+		return true;
+	*result = a * b;
+	return false;
+#endif
+}
+
 int main (int argc, char **argv)
 {
 	if (argc == 2)
@@ -323,8 +350,11 @@ bool copyaudiodata (AFfilehandle infile, AFfilehandle outfile, int trackid)
 {
 	int frameSize = afGetVirtualFrameSize(infile, trackid, 1);
 
-	const int kBufferFrameCount = 65536;
-	void *buffer = malloc(kBufferFrameCount * frameSize);
+	int kBufferFrameCount = 65536;
+	int bufferSize;
+	while (multiplyCheckOverflow(kBufferFrameCount, frameSize, &bufferSize))
+		kBufferFrameCount /= 2;
+	void *buffer = malloc(bufferSize);
 
 	AFframecount totalFrames = afGetFrameCount(infile, AF_DEFAULT_TRACK);
 	AFframecount totalFramesWritten = 0;


[FILE:1097:patches/patch-08_Fix-signature-of-multiplyCheckOverflow.-It-returns-a-b]
From: Antonio Larrosa <larrosa@kde.org>
Date: Fri, 10 Mar 2017 15:40:02 +0100
Subject: Fix signature of multiplyCheckOverflow. It returns a bool, not an int

---
 libaudiofile/modules/MSADPCM.cpp | 2 +-
 sfcommands/sfconvert.c           | 2 +-
 2 files changed, 2 insertions(+), 2 deletions(-)

--- libaudiofile/modules/MSADPCM.cpp
+++ libaudiofile/modules/MSADPCM.cpp
@@ -116,7 +116,7 @@ int firstBitSet(int x)
 #define __has_builtin(x) 0
 #endif
 
-int multiplyCheckOverflow(int a, int b, int *result)
+bool multiplyCheckOverflow(int a, int b, int *result)
 {
 #if (defined __GNUC__ && __GNUC__ >= 5) || ( __clang__ && __has_builtin(__builtin_mul_overflow))
 	return __builtin_mul_overflow(a, b, result);
--- sfcommands/sfconvert.c
+++ sfcommands/sfconvert.c
@@ -60,7 +60,7 @@ int firstBitSet(int x)
 #define __has_builtin(x) 0
 #endif
 
-int multiplyCheckOverflow(int a, int b, int *result)
+bool multiplyCheckOverflow(int a, int b, int *result)
 {
 #if (defined __GNUC__ && __GNUC__ >= 5) || ( __clang__ && __has_builtin(__builtin_mul_overflow))
 	return __builtin_mul_overflow(a, b, result);


[FILE:1179:patches/patch-09_Actually-fail-when-error-occurs-in-parseFormat]
From: Antonio Larrosa <larrosa@kde.org>
Date: Mon, 6 Mar 2017 18:59:26 +0100
Subject: Actually fail when error occurs in parseFormat

When there's an unsupported number of bits per sample or an invalid
number of samples per block, don't only print an error message using
the error handler, but actually stop parsing the file.

This fixes #35 (also reported at
https://bugzilla.opensuse.org/show_bug.cgi?id=1026983 and
https://blogs.gentoo.org/ago/2017/02/20/audiofile-heap-based-buffer-overflow-in-imadecodeblockwave-ima-cpp/
)
---
 libaudiofile/WAVE.cpp | 2 ++
 1 file changed, 2 insertions(+)

--- libaudiofile/WAVE.cpp
+++ libaudiofile/WAVE.cpp
@@ -332,6 +332,7 @@ status WAVEFile::parseFormat(const Tag &id, uint32_t size)
 			{
 				_af_error(AF_BAD_NOT_IMPLEMENTED,
 					"IMA ADPCM compression supports only 4 bits per sample");
+				return AF_FAIL;
 			}
 
 			int bytesPerBlock = (samplesPerBlock + 14) / 8 * 4 * channelCount;
@@ -339,6 +340,7 @@ status WAVEFile::parseFormat(const Tag &id, uint32_t size)
 			{
 				_af_error(AF_BAD_CODEC_CONFIG,
 					"Invalid samples per block for IMA ADPCM compression");
+				return AF_FAIL;
 			}
 
 			track->f.sampleWidth = 16;


[FILE:705:patches/patch-10_Check-for-division-by-zero-in-BlockCodec-runPull]
From: Antonio Larrosa <larrosa@kde.org>
Date: Thu, 9 Mar 2017 10:21:18 +0100
Subject: Check for division by zero in BlockCodec::runPull

---
 libaudiofile/modules/BlockCodec.cpp | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

--- libaudiofile/modules/BlockCodec.cpp
+++ libaudiofile/modules/BlockCodec.cpp
@@ -47,7 +47,7 @@ void BlockCodec::runPull()
 
 	// Read the compressed data.
 	ssize_t bytesRead = read(m_inChunk->buffer, m_bytesPerPacket * blockCount);
-	int blocksRead = bytesRead >= 0 ? bytesRead / m_bytesPerPacket : 0;
+	int blocksRead = (bytesRead >= 0 && m_bytesPerPacket > 0) ? bytesRead / m_bytesPerPacket : 0;
 
 	// Decompress into m_outChunk.
 	for (int i=0; i<blocksRead; i++)


[FILE:911:patches/patch-11_CVE-2018-13440]
From fde6d79fb8363c4a329a184ef0b107156602b225 Mon Sep 17 00:00:00 2001
From: Wim Taymans <wtaymans@redhat.com>
Date: Thu, 27 Sep 2018 10:48:45 +0200
Subject: [PATCH] ModuleState: handle compress/decompress init failure

When the unit initcompress or initdecompress function fails,
m_fileModule is NULL. Return AF_FAIL in that case instead of
causing NULL pointer dereferences later.

Fixes #49
---
 libaudiofile/modules/ModuleState.cpp | 3 +++
 1 file changed, 3 insertions(+)

--- libaudiofile/modules/ModuleState.cpp
+++ libaudiofile/modules/ModuleState.cpp
@@ -75,6 +75,9 @@ status ModuleState::initFileModule(AFfilehandle file, Track *track)
 		m_fileModule = unit->initcompress(track, file->m_fh, file->m_seekok,
 			file->m_fileFormat == AF_FILE_RAWDATA, &chunkFrames);
 
+	if (!m_fileModule)
+		return AF_FAIL;
+
 	if (unit->needsRebuffer)
 	{
 		assert(unit->nativeSampleFormat == AF_SAMPFMT_TWOSCOMP);


[FILE:720:patches/patch-12_CVE-2018-17095]
From 822b732fd31ffcb78f6920001e9b1fbd815fa712 Mon Sep 17 00:00:00 2001
From: Wim Taymans <wtaymans@redhat.com>
Date: Thu, 27 Sep 2018 12:11:12 +0200
Subject: [PATCH] SimpleModule: set output chunk framecount after pull

After pulling the data, set the output chunk to the amount of
frames we pulled so that the next module in the chain has the correct
frame count.

Fixes #50 and #51
---
 libaudiofile/modules/SimpleModule.cpp | 1 +
 1 file changed, 1 insertion(+)

--- libaudiofile/modules/SimpleModule.cpp
+++ libaudiofile/modules/SimpleModule.cpp
@@ -26,6 +26,7 @@
 void SimpleModule::runPull()
 {
 	pull(m_outChunk->frameCount);
+	m_outChunk->frameCount = m_inChunk->frameCount;
 	run(*m_inChunk, *m_outChunk);
 }
 


[FILE:2051:patches/patch-configure]
--- configure.orig	2013-03-07 07:27:14 UTC
+++ configure
@@ -5758,7 +5758,7 @@ darwin* | rhapsody*)
   lt_cv_deplibs_check_method=pass_all
   ;;
 
-freebsd* | dragonfly*)
+freebsd* | dragonfly*| midnight*)
   if echo __ELF__ | $CC -E - | $GREP __ELF__ > /dev/null; then
     case $host_cpu in
     i*86 )
@@ -9912,7 +9912,7 @@ fi
       ;;
 
     # FreeBSD 3 and greater uses gcc -shared to do shared libraries.
-    freebsd* | dragonfly*)
+    freebsd* | dragonfly* | midnight*)
       archive_cmds='$CC -shared $pic_flag -o $lib $libobjs $deplibs $compiler_flags'
       hardcode_libdir_flag_spec='-R$libdir'
       hardcode_direct=yes
@@ -10876,7 +10876,7 @@ dgux*)
   shlibpath_var=LD_LIBRARY_PATH
   ;;
 
-freebsd* | dragonfly*)
+freebsd* | dragonfly* | midnight*)
   # DragonFly does not have aout.  When/if they implement a new
   # versioning mechanism, adjust this.
   if test -x /usr/bin/objformat; then
@@ -12864,7 +12864,7 @@ fi
         archive_cmds_need_lc_CXX=no
         ;;
 
-      freebsd* | dragonfly*)
+      freebsd* | dragonfly* | midnight*)
         # FreeBSD 3 and later use GNU C++ and GNU ld with standard ELF
         # conventions
         ld_shlibs_CXX=yes
@@ -13851,7 +13851,7 @@ lt_prog_compiler_static_CXX=
 	    ;;
 	esac
 	;;
-      freebsd* | dragonfly*)
+      freebsd* | dragonfly* | midnight*)
 	# FreeBSD uses GNU C++
 	;;
       hpux9* | hpux10* | hpux11*)
@@ -14722,7 +14722,7 @@ dgux*)
   shlibpath_var=LD_LIBRARY_PATH
   ;;
 
-freebsd* | dragonfly*)
+freebsd* | dragonfly* | midnight*)
   # DragonFly does not have aout.  When/if they implement a new
   # versioning mechanism, adjust this.
   if test -x /usr/bin/objformat; then
@@ -15956,10 +15956,6 @@ platform=none
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking for platform specific tests to compile" >&5
 $as_echo_n "checking for platform specific tests to compile... " >&6; }
 case "$host_os" in
-  linux*)
-    TEST_BIN="linuxtest alsaplay"
-    platform=linux
-    ;;
   irix5* | irix6*)
     TEST_BIN="irixread irixtestloop"
     platform=irix

