# Buildsheet autogenerated by ravenadm tool -- Do not edit.

NAMEBASE=		bezitopo
VERSION=		0.1.4
KEYWORDS=		graphics
VARIANTS=		standard
SDESC[standard]=	Land surveying program based on Bezier splines
HOMEPAGE=		https://github.com/phma/bezitopo
CONTACT=		nobody

DOWNLOAD_GROUPS=	main
SITES[main]=		GITHUB/phma:bezitopo:0.1.4
DISTFILE[1]=		generated:main
DF_INDEX=		1
SPKGS[standard]=	single

OPTIONS_AVAILABLE=	none
OPTIONS_STANDARD=	none

BUILD_DEPENDS=		qt5-qttools:single:standard
			fftw:single:standard
BUILDRUN_DEPENDS=	qt5-qtbase:primary:standard

USES=			cmake

LICENSE=		GPLv3+:single
LICENSE_TERMS=		single:{{WRKDIR}}/TERMS
LICENSE_FILE=		GPLv3+:{{WRKSRC}}/COPYING
LICENSE_AWK=		TERMS:"BEZITOPO_H"
LICENSE_SOURCE=		TERMS:{{WRKSRC}}/bezitopo.h
LICENSE_SCHEME=		solo

SOVERSION=		0.1.4

CMAKE_ARGS=		-DQT_INCLUDE_DIR:PATH="{{PREFIX}}/include/qt5"
			-DQT_LIBRARY_DIR:PATH="{{PREFIX}}/lib/qt5"
			-DCMAKE_PREFIX_PATH:PATH="{{PREFIX}}/lib/qt5/cmake/"

post-install:
	${STRIP_CMD} ${STAGEDIR}${PREFIX}/bin/*
	# examples
	${MKDIR} ${STAGEDIR}${STD_EXAMPLESDIR}
	${INSTALL_DATA} ${WRKSRC}/topo0.asc ${STAGEDIR}${STD_EXAMPLESDIR}

post-patch-sunos:
	${REINPLACE_CMD} -e 's/isnan/bzisnan/ ; s/isfinite/bzisfinite/' \
		${WRKSRC}/xyz.h ${WRKSRC}/geoid.cpp ${WRKSRC}/geoid.h
	${REINPLACE_CMD} \
		-e '/xy/ s/isnan/bzisnan/' \
		-e '/xy/ s/isfinite/bzisfinite/' \
		${WRKSRC}/point.cpp
.for FF in bezier bezitest closure contour factordialog polyline ps \
	refinegeoid scalefactor
	${REINPLACE_CMD} -e 's|\.isnan|.bzisnan|g; s|\.isfinite|.bzisfinite|g'\
		${WRKSRC}/${FF}.cpp
.endfor

[FILE:255:descriptions/desc.single]
Bezitopo is a land surveying program using Bezier triangles. The sample
data file topo0.asc is a survey of Independence Park in Charlotte, North
Carolina.

Bezitopo is an interactive program. When you get the ? prompt, type
"help" for a list of commands.


[FILE:105:distinfo]
a2751d6016bb08cb838a09697c8546070ce0edaa3cbdab52c200c0d0ca2461d5       372705 phma-bezitopo-0.1.4.tar.gz


[FILE:842:manifests/plist.single]
bin/
 bezitopo
 convertgeoid
 viewtin
include/bezitopo.h
include/bezitopo/
 angle.h
 arc.h
 bezier.h
 bezier3d.h
 binio.h
 boundrect.h
 breakline.h
 circle.h
 cogo.h
 cogospiral.h
 color.h
 config.h
 contour.h
 csv.h
 document.h
 drawobj.h
 ellipsoid.h
 except.h
 geoid.h
 geoidboundary.h
 globals.h
 halton.h
 intloop.h
 latlong.h
 layer.h
 ldecimal.h
 leastsquares.h
 linetype.h
 manyarc.h
 manysum.h
 matrix.h
 measure.h
 minquad.h
 objlist.h
 penwidth.h
 pnezd.h
 point.h
 pointlist.h
 polyline.h
 projection.h
 ps.h
 qindex.h
 quaternion.h
 random.h
 relprime.h
 rootfind.h
 roscat.h
 segment.h
 spiral.h
 spolygon.h
 tin.h
 vball.h
 vcurve.h
 xyz.h
 zoom.h
lib/
 libbezitopo.a
 libbezitopo.so
 libbezitopo.so.%%SOVERSION%%
share/bezitopo/
 bezitopo_en.qm
 bezitopo_es.qm
 projections.txt
 transmer.dat
share/examples/bezitopo/topo0.asc


[FILE:1446:patches/patch-test.cpp]
--- test.cpp.orig	2018-12-19 05:21:41 UTC
+++ test.cpp
@@ -147,7 +147,8 @@ void aster(document &doc,int n)
 /* Fill points with asteraceous pattern. Pattern invented by H. Vogel in 1979
    and later by me, not knowing of Vogel. */
 {int i;
- double angle=(sqrt(5)-1)*M_PI;
+ double fred = 5;
+ double angle=(sqrt(fred)-1)*M_PI;
  xy pnt;
  for (i=0;i<n;i++)
      {pnt=xy(cos(angle*i)*sqrt(i+0.5),sin(angle*i)*sqrt(i+0.5));
@@ -159,7 +160,8 @@ void _ellipse(document &doc,int n,double
 /* Skewness is not eccentricity. When skewness=0.01, eccentricity=0.14072. */
 {
   int i;
-  double angle=(sqrt(5)-1)*M_PI;
+  double fred = 5;
+  double angle=(sqrt(fred)-1)*M_PI;
   xy pnt;
   for (i=0;i<n;i++)
   {
@@ -204,11 +206,12 @@ void straightrow(document &doc,int n)
 {
   int i;
   double angle;
+  double dn = n;
   xy pnt;
   for (i=0;i<n;i++)
   {
     angle=(2.0*i/(n-1)-1)*M_PI/6;
-    pnt=xy(0,sqrt(n)*tan(angle));
+    pnt=xy(0,sqrt(dn)*tan(angle));
     doc.pl[1].addpoint(i+1,point(pnt,testsurface(pnt),"test"));
   }
 }
@@ -217,10 +220,11 @@ void lozenge(document &doc,int n)
 // Add points on the short diagonal of a rhombus, then add the two other points.
 {
   xy pnt;
+  double dn = n;
   straightrow(doc,n);
-  pnt=xy(-sqrt(n),0);
+  pnt=xy(-sqrt(dn),0);
   doc.pl[1].addpoint(n+1,point(pnt,testsurface(pnt),"test"));
-  pnt=xy(sqrt(n),0);
+  pnt=xy(sqrt(dn),0);
   doc.pl[1].addpoint(n+2,point(pnt,testsurface(pnt),"test"));
 }
 

