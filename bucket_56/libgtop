# Buildsheet autogenerated by ravenadm tool -- Do not edit.

NAMEBASE=		libgtop
VERSION=		2.40.0
KEYWORDS=		devel
VARIANTS=		std
SDESC[std]=		GNOME library to collect system monitoring data
HOMEPAGE=		https://gitlab.gnome.org/GNOME/libgtop/
CONTACT=		Michael_Reim[kraileth@elderlinux.org]

DOWNLOAD_GROUPS=	main
SITES[main]=		https://download.gnome.org/sources/libgtop/2.40/
DISTFILE[1]=		libgtop-2.40.0.tar.xz:main
DIST_SUBDIR=		gnome2
DF_INDEX=		1
SPKGS[std]=		set
			primary
			nls
			docs

OPTIONS_AVAILABLE=	none
OPTIONS_STANDARD=	none

BROKEN[netbsd]=		Needs an absurd number of patches

BUILD_DEPENDS=		gtk-doc:single:std

USES=			gmake libtool pkgconfig perl
GNOME_COMPONENTS=	glib introspection
XORG_COMPONENTS=	xau

LICENSE=		GPLv2+:primary
LICENSE_TERMS=		primary:{{WRKDIR}}/TERMS
LICENSE_FILE=		GPLv2+:{{WRKSRC}}/COPYING
LICENSE_AWK=		TERMS:"ifndef __GLIBTOP_H__"
LICENSE_SOURCE=		TERMS:{{WRKSRC}}/glibtop.h
LICENSE_SCHEME=		solo

FPC_EQUIVALENT=		devel/libgtop

MUST_CONFIGURE=		gnu
CONFIGURE_ARGS=		--enable-introspection
			--enable-gtk-doc-html

INSTALL_TARGET=		install-strip
SOVERSION=		11.0.1

VAR_OPSYS[netbsd]=	CONFIGURE_ENV=fu_cv_sys_mounted_getmntinfo=yes

[FILE:73:descriptions/desc.primary]
LibGTop is a GNOME library that collects various system minitoring data.


[FILE:107:distinfo]
78f3274c0c79c434c03655c1b35edf7b95ec0421430897fb1345a98a265ed2d4       744316 gnome2/libgtop-2.40.0.tar.xz


[FILE:802:manifests/plist.primary]
bin/
 libgtop_daemon2
 libgtop_server2
include/libgtop-2.0/
 glibtop.h
 glibtop_machine.h
 glibtop_server.h
 glibtop_suid.h
 libgtopconfig.h
include/libgtop-2.0/glibtop/
 close.h
 command.h
 cpu.h
 fsusage.h
 global.h
 gnuserv.h
 loadavg.h
 mem.h
 mountlist.h
 msg_limits.h
 netlist.h
 netload.h
 open.h
 parameter.h
 ppp.h
 procaffinity.h
 procargs.h
 procio.h
 prockernel.h
 proclist.h
 procmap.h
 procmem.h
 procopenfiles.h
 procsegment.h
 procsignal.h
 procstate.h
 proctime.h
 procuid.h
 procwd.h
 sem_limits.h
 shm_limits.h
 signal.h
 swap.h
 sysdeps.h
 sysinfo.h
 union.h
 uptime.h
lib/
 libgtop-2.0.a
 libgtop-2.0.so
 libgtop-2.0.so.%%SOMAJOR%%
 libgtop-2.0.so.%%SOVERSION%%
lib/girepository-1.0/GTop-2.0.typelib
lib/pkgconfig/libgtop-2.0.pc
share/gir-1.0/GTop-2.0.gir
share/info/libgtop2.info


[FILE:3398:manifests/plist.nls]
share/locale/am/LC_MESSAGES/libgtop.mo
share/locale/ar/LC_MESSAGES/libgtop.mo
share/locale/as/LC_MESSAGES/libgtop.mo
share/locale/ast/LC_MESSAGES/libgtop.mo
share/locale/az/LC_MESSAGES/libgtop.mo
share/locale/be/LC_MESSAGES/libgtop.mo
share/locale/bg/LC_MESSAGES/libgtop.mo
share/locale/bn/LC_MESSAGES/libgtop.mo
share/locale/bn_IN/LC_MESSAGES/libgtop.mo
share/locale/bs/LC_MESSAGES/libgtop.mo
share/locale/ca/LC_MESSAGES/libgtop.mo
share/locale/ca@valencia/LC_MESSAGES/libgtop.mo
share/locale/cs/LC_MESSAGES/libgtop.mo
share/locale/cy/LC_MESSAGES/libgtop.mo
share/locale/da/LC_MESSAGES/libgtop.mo
share/locale/de/LC_MESSAGES/libgtop.mo
share/locale/dz/LC_MESSAGES/libgtop.mo
share/locale/el/LC_MESSAGES/libgtop.mo
share/locale/en@shaw/LC_MESSAGES/libgtop.mo
share/locale/en_CA/LC_MESSAGES/libgtop.mo
share/locale/en_GB/LC_MESSAGES/libgtop.mo
share/locale/eo/LC_MESSAGES/libgtop.mo
share/locale/es/LC_MESSAGES/libgtop.mo
share/locale/et/LC_MESSAGES/libgtop.mo
share/locale/eu/LC_MESSAGES/libgtop.mo
share/locale/fa/LC_MESSAGES/libgtop.mo
share/locale/fi/LC_MESSAGES/libgtop.mo
share/locale/fr/LC_MESSAGES/libgtop.mo
share/locale/fur/LC_MESSAGES/libgtop.mo
share/locale/ga/LC_MESSAGES/libgtop.mo
share/locale/gl/LC_MESSAGES/libgtop.mo
share/locale/gu/LC_MESSAGES/libgtop.mo
share/locale/he/LC_MESSAGES/libgtop.mo
share/locale/hi/LC_MESSAGES/libgtop.mo
share/locale/hr/LC_MESSAGES/libgtop.mo
share/locale/hu/LC_MESSAGES/libgtop.mo
share/locale/id/LC_MESSAGES/libgtop.mo
share/locale/it/LC_MESSAGES/libgtop.mo
share/locale/ja/LC_MESSAGES/libgtop.mo
share/locale/ka/LC_MESSAGES/libgtop.mo
share/locale/kn/LC_MESSAGES/libgtop.mo
share/locale/ko/LC_MESSAGES/libgtop.mo
share/locale/ku/LC_MESSAGES/libgtop.mo
share/locale/ky/LC_MESSAGES/libgtop.mo
share/locale/la/LC_MESSAGES/libgtop.mo
share/locale/lt/LC_MESSAGES/libgtop.mo
share/locale/lv/LC_MESSAGES/libgtop.mo
share/locale/mai/LC_MESSAGES/libgtop.mo
share/locale/mg/LC_MESSAGES/libgtop.mo
share/locale/mi/LC_MESSAGES/libgtop.mo
share/locale/mk/LC_MESSAGES/libgtop.mo
share/locale/ml/LC_MESSAGES/libgtop.mo
share/locale/mn/LC_MESSAGES/libgtop.mo
share/locale/mr/LC_MESSAGES/libgtop.mo
share/locale/ms/LC_MESSAGES/libgtop.mo
share/locale/nb/LC_MESSAGES/libgtop.mo
share/locale/ne/LC_MESSAGES/libgtop.mo
share/locale/nl/LC_MESSAGES/libgtop.mo
share/locale/nn/LC_MESSAGES/libgtop.mo
share/locale/oc/LC_MESSAGES/libgtop.mo
share/locale/or/LC_MESSAGES/libgtop.mo
share/locale/pa/LC_MESSAGES/libgtop.mo
share/locale/pl/LC_MESSAGES/libgtop.mo
share/locale/pt/LC_MESSAGES/libgtop.mo
share/locale/pt_BR/LC_MESSAGES/libgtop.mo
share/locale/ro/LC_MESSAGES/libgtop.mo
share/locale/ru/LC_MESSAGES/libgtop.mo
share/locale/rw/LC_MESSAGES/libgtop.mo
share/locale/sk/LC_MESSAGES/libgtop.mo
share/locale/sl/LC_MESSAGES/libgtop.mo
share/locale/sq/LC_MESSAGES/libgtop.mo
share/locale/sr/LC_MESSAGES/libgtop.mo
share/locale/sr@latin/LC_MESSAGES/libgtop.mo
share/locale/sv/LC_MESSAGES/libgtop.mo
share/locale/ta/LC_MESSAGES/libgtop.mo
share/locale/te/LC_MESSAGES/libgtop.mo
share/locale/tg/LC_MESSAGES/libgtop.mo
share/locale/th/LC_MESSAGES/libgtop.mo
share/locale/tr/LC_MESSAGES/libgtop.mo
share/locale/ug/LC_MESSAGES/libgtop.mo
share/locale/uk/LC_MESSAGES/libgtop.mo
share/locale/vi/LC_MESSAGES/libgtop.mo
share/locale/xh/LC_MESSAGES/libgtop.mo
share/locale/zh_CN/LC_MESSAGES/libgtop.mo
share/locale/zh_HK/LC_MESSAGES/libgtop.mo
share/locale/zh_TW/LC_MESSAGES/libgtop.mo


[FILE:1068:manifests/plist.docs]
share/gtk-doc/html/libgtop/
 home.png
 index.html
 left-insensitive.png
 left.png
 libgtop-Close.html
 libgtop-Command.html
 libgtop-GlibTop-Server.html
 libgtop-GlibTop.html
 libgtop-Net-List.html
 libgtop-Net-Load.html
 libgtop-PPP.html
 libgtop-Process-Arguments.html
 libgtop-Process-List.html
 libgtop-Process-Time.html
 libgtop-Shared-Memory-Limits.html
 libgtop-Uptime.html
 libgtop-cpu.html
 libgtop-fsusage.html
 libgtop-lib.html
 libgtop-loadavg.html
 libgtop-mem.html
 libgtop-mountlist.html
 libgtop-msg-limits.html
 libgtop-open.html
 libgtop-parameter.html
 libgtop-prockernel.html
 libgtop-procmap.html
 libgtop-procmem.html
 libgtop-procopenfiles.html
 libgtop-procsegment.html
 libgtop-procsignal.html
 libgtop-procstate.html
 libgtop-procuid.html
 libgtop-sem-limits.html
 libgtop-signal.html
 libgtop-swap.html
 libgtop-sysdeps.html
 libgtop-sysinfo.html
 libgtop-union.html
 libgtop-version.html
 libgtop-white-paper-overview.html
 libgtop-white-paper.html
 libgtop.devhelp2
 right-insensitive.png
 right.png
 style.css
 up-insensitive.png
 up.png


[FILE:299:patches/patch-config.h.in]
--- config.h.in.orig	2019-03-11 08:56:47 UTC
+++ config.h.in
@@ -119,6 +119,9 @@
 /* defined if you have linux/isdn.h */
 #undef HAVE_ISDN_H
 
+/* defined if you have kinfo_getfile in -lutil */
+#undef HAVE_KINFO_GETFILE
+
 /* Define to 1 if you have the `lchown' function. */
 #undef HAVE_LCHOWN
 


[FILE:4017:patches/patch-configure]
--- configure.orig	2019-03-11 08:56:47 UTC
+++ configure
@@ -7309,7 +7309,7 @@ darwin* | rhapsody*)
   lt_cv_deplibs_check_method=pass_all
   ;;
 
-freebsd* | dragonfly*)
+freebsd* | dragonfly* | midnightbsd*)
   if echo __ELF__ | $CC -E - | $GREP __ELF__ > /dev/null; then
     case $host_cpu in
     i*86 )
@@ -11573,7 +11573,7 @@ fi
       ;;
 
     # FreeBSD 3 and greater uses gcc -shared to do shared libraries.
-    freebsd* | dragonfly*)
+    freebsd* | dragonfly* | midnight*)
       archive_cmds='$CC -shared $pic_flag -o $lib $libobjs $deplibs $compiler_flags'
       hardcode_libdir_flag_spec='-R$libdir'
       hardcode_direct=yes
@@ -12618,7 +12618,7 @@ dgux*)
   shlibpath_var=LD_LIBRARY_PATH
   ;;
 
-freebsd* | dragonfly*)
+freebsd* | dragonfly* | midnight*)
   # DragonFly does not have aout.  When/if they implement a new
   # versioning mechanism, adjust this.
   if test -x /usr/bin/objformat; then
@@ -13955,7 +13955,7 @@ $as_echo_n "checking for libgtop sysdeps
 	  libgtop_sysdeps_private_fsusage=yes
 	  libgtop_postinstall='chgrp kmem $(bindir)/libgtop_server2 && chmod 2555 $(bindir)/libgtop_server2'
 	  ;;
-	freebsd*|kfreebsd*)
+	freebsd*|dragonfly*|kfreebsd*|midnight*)
 	  libgtop_sysdeps_dir=freebsd
 	  libgtop_need_server=yes
 	  libgtop_sysdeps_private_mountlist=yes
@@ -14020,7 +14020,7 @@ $as_echo "$libgtop_sysdeps_dir" >&6; }
 
 
 	case "$host_os" in
-	*bsd*)
+	*bsd*|dragonfly*)
 	  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for kvm_open in -lkvm" >&5
 $as_echo_n "checking for kvm_open in -lkvm... " >&6; }
 if ${ac_cv_lib_kvm_kvm_open+:} false; then :
@@ -14101,6 +14101,8 @@ $as_echo_n "checking for I4B... " >&6; }
 
 #if defined(__FreeBSD__) || defined(__NetBSD__) || defined(__FreeBSD_kernel__)
 #include <net/if_sppp.h>
+#elif defined(__DragonFly__)
+#include <net/sppp/if_sppp.h>
 #else
 #include <i4b/sppp/if_sppp.h>
 #endif
@@ -14147,6 +14149,8 @@ $as_echo_n "checking for I4B accounting.
 
 #if defined(__FreeBSD__) || defined(__NetBSD__) || defined(__FreeBSD_kernel__)
 #include <net/if_sppp.h>
+#elif defined(__DragonFly__)
+#include <net/sppp/if_sppp.h>
 #else
 #include <i4b/sppp/if_sppp.h>
 #endif
@@ -14462,6 +14466,57 @@ $as_echo "#define HAVE_IFADDRS_H 1" >>co
 
 fi
 
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for kinfo_getfile in -lutil" >&5
+$as_echo_n "checking for kinfo_getfile in -lutil... " >&6; }
+if ${ac_cv_lib_util_kinfo_getfile+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  ac_check_lib_save_LIBS=$LIBS
+LIBS="-lutil  $LIBS"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+char kinfo_getfile ();
+int
+main ()
+{
+return kinfo_getfile ();
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"; then :
+  ac_cv_lib_util_kinfo_getfile=yes
+else
+  ac_cv_lib_util_kinfo_getfile=no
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_util_kinfo_getfile" >&5
+$as_echo "$ac_cv_lib_util_kinfo_getfile" >&6; }
+if test "x$ac_cv_lib_util_kinfo_getfile" = xyes; then :
+  cat >>confdefs.h <<_ACEOF
+#define HAVE_LIBUTIL 1
+_ACEOF
+
+  LIBS="-lutil $LIBS"
+
+fi
+
+if test xac_cv_lib_kinfo_getfile_util = xyes ; then
+
+$as_echo "#define HAVE_KINFO_GETFILE 1" >>confdefs.h
+
+fi
+
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking for an ANSI C-conforming const" >&5
 $as_echo_n "checking for an ANSI C-conforming const... " >&6; }
 if ${ac_cv_c_const+:} false; then :
@@ -18806,7 +18861,7 @@ if test x$cross_compiling = xyes ; then
         sunos*)
           fu_cv_sys_stat_statfs4=yes
           ;;
-        freebsd*)
+        freebsd*|dragonfly*|midnight*)
           fu_cv_sys_stat_statfs2_bsize=yes
           ;;
         osf*)


[FILE:801:patches/patch-examples_mountlist.c]
Remove unreliable and non-portable way to demonstrate memory utilization
with sbrk(2).

https://bugs.freebsd.org/bugzilla/show_bug.cgi?id=221751

--- examples/mountlist.c.orig	2019-02-04 20:15:22 UTC
+++ examples/mountlist.c
@@ -71,16 +71,12 @@ main (int argc, char *argv [])
 
 	printf ("Host = '%s' - %u\n\n", buffer, port);
 
-	printf ("sbrk (0) = %p\n\n", sbrk (0));
-
 	for (c = 0; c < PROFILE_COUNT; c++) {
 		mount_entries = glibtop_get_mountlist (&mount_list, 1);
 
 		g_free (mount_entries);
 	}
 
-	printf ("sbrk (0) = %p\n\n", sbrk (0));
-
 	mount_entries = glibtop_get_mountlist (&mount_list, 1);
 
 	if (mount_entries == NULL)
@@ -108,8 +104,6 @@ main (int argc, char *argv [])
 
 	g_free (mount_entries);
 
-	printf ("\nsbrk (0) = %p\n\n", sbrk (0));
-
 	glibtop_close ();
 
 	exit (0);


[FILE:696:patches/patch-sysdeps_common_fsusage.c]
--- sysdeps/common/fsusage.c.orig	2019-02-04 20:15:22 UTC
+++ sysdeps/common/fsusage.c
@@ -140,7 +140,7 @@ _glibtop_get_fsusage_read_write(glibtop
 }
 
 
-#elif defined(__FreeBSD__)
+#elif defined(__FreeBSD__) || defined(__DragonFly__)
 void
 _glibtop_freebsd_get_fsusage_read_write(glibtop *server,
 					glibtop_fsusage *buf,
@@ -279,7 +279,7 @@ glibtop_get_fsusage_s (glibtop *server,
     return;
 
 #if (defined(sun) || defined(__sun)) && (defined(__SVR4) || defined(__svr4__)) \
-	|| defined(__FreeBSD__) || defined(__OpenBSD__)
+	|| defined(__FreeBSD__) || defined(__OpenBSD__) || defined(__DragonFly__)
   /* Solaris but not SunOS and FreeBSD */
   buf->block_size = fsd.f_frsize;
 #else


[FILE:1248:patches/patch-sysdeps_common_mountlist.c]
--- sysdeps/common/mountlist.c.orig	2019-02-04 20:15:22 UTC
+++ sysdeps/common/mountlist.c
@@ -106,7 +106,7 @@ static struct mount_entry *read_filesyst
 #endif
 
 
-#if defined (MOUNTED_GETMNTINFO) && !defined (__NetBSD__) && !defined (__OpenBSD__) && !defined(__FreeBSD__)
+#if defined (MOUNTED_GETMNTINFO) && !defined (__NetBSD__) && !defined (__OpenBSD__) && !defined(__FreeBSD__) && !defined(__DragonFly__)
 static const char *
 fstype_to_string (short t)
 {
@@ -298,7 +298,11 @@ read_filesystem_list (void)
 
 #ifdef MOUNTED_GETMNTINFO	/* 4.4BSD.  */
   {
+#if defined(STAT_STATVFS) && !defined(__DragonFly__)
+    struct statvfs *fsp;
+#else
     struct statfs *fsp;
+#endif
     int entries;
 
     entries = getmntinfo (&fsp, MNT_NOWAIT);
@@ -309,7 +313,7 @@ read_filesystem_list (void)
 	me = (struct mount_entry *) g_malloc (sizeof (struct mount_entry));
 	me->me_devname = g_strdup (fsp->f_mntfromname);
 	me->me_mountdir = g_strdup (fsp->f_mntonname);
-#if defined(__NetBSD__) || defined(__OpenBSD__) || defined(__FreeBSD__)
+#if defined(__NetBSD__) || defined(__OpenBSD__) || defined(__FreeBSD__) || defined(__DragonFly__)
 	me->me_type = g_strdup (fsp->f_fstypename);
 #else
 	me->me_type = g_strdup (fstype_to_string (fsp->f_type));


[FILE:304:patches/patch-sysdeps_freebsd_glibtop__machine.h]
--- sysdeps/freebsd/glibtop_machine.h.orig	2019-02-04 20:15:22 UTC
+++ sysdeps/freebsd/glibtop_machine.h
@@ -26,7 +26,9 @@
 #include <nlist.h>
 #include <limits.h>
 #include <kvm.h>
+#ifndef __DragonFly__
 #include <sys/dkstat.h>
+#endif
 #include <time.h>
 #include <sys/user.h>
 #include <sys/types.h>


[FILE:681:patches/patch-sysdeps_freebsd_netload.c]
DFLYGC 6.2

--- sysdeps/freebsd/netload.c.orig	2019-02-04 20:15:22 UTC
+++ sysdeps/freebsd/netload.c
@@ -108,7 +108,11 @@ glibtop_get_netload_p (glibtop *server,
                         memset(&ifmr, 0, sizeof(ifmr));
                         (void)strlcpy(ifmr.ifm_name, ifa->ifa_name,
                                 sizeof(ifmr.ifm_name));
+#ifndef SIOCGIFXMEDIA
+                        if (
+#else
                         if (ioctl(s, SIOCGIFXMEDIA, (caddr_t)&ifmr) < 0 &&
+#endif
                             ioctl(s, SIOCGIFMEDIA, (caddr_t)&ifmr) < 0) {
                                 glibtop_warn_io_r(server, "ioctl(SIOCGIFMEDIA)");
                         } else {


[FILE:458:patches/patch-sysdeps_freebsd_open.c]
--- sysdeps/freebsd/open.c.orig	2019-02-04 20:15:22 UTC
+++ sysdeps/freebsd/open.c
@@ -43,6 +43,12 @@ glibtop_open_s (glibtop *server, const c
 	server->real_ncpu = ncpus - 1;
 	server->ncpu = MIN(GLIBTOP_NCPU - 1, server->real_ncpu);
 
+#ifdef __DragonFly__
+	server->os_version_code = __DragonFly_version;
+#elif defined(__MidnightBSD__)
+	server->os_version_code = __MidnightBSD_version;
+#else
 	server->os_version_code = __FreeBSD_version;
+#endif
 
 }


[FILE:387:patches/patch-sysdeps_freebsd_procio.c]
--- sysdeps/freebsd/procio.c.orig	2019-02-04 20:15:22 UTC
+++ sysdeps/freebsd/procio.c
@@ -74,7 +74,9 @@ glibtop_get_proc_io_p (glibtop *server,
 
 	   FIXME: seems the blocksize is 1024 but ...
 	*/
+#ifndef __DragonFly__
 	buf->disk_rbytes = pinfo->ki_rusage.ru_inblock << 10;
 	buf->disk_wbytes = pinfo->ki_rusage.ru_oublock << 10;
 	buf->flags = _glibtop_sysdeps_proc_io;
+#endif
 }


[FILE:1217:patches/patch-sysdeps_freebsd_prockernel.c]
--- sysdeps/freebsd/prockernel.c.orig	2019-02-04 20:15:22 UTC
+++ sysdeps/freebsd/prockernel.c
@@ -89,9 +89,14 @@ glibtop_get_proc_kernel_p (glibtop *serv
 
 	glibtop_suid_leave (server);
 
+#ifdef __DragonFly__
+#define	PROC_WCHAN	kp_lwp.kl_wchan
+#define	PROC_WMESG	kp_lwp.kl_wmesg
+#else
 #define	PROC_WCHAN	ki_wchan
 #define	PROC_WMESG	ki_wmesg
 #define	PROC_WMESG	ki_wmesg
+#endif
 
 	buf->nwchan = (unsigned long) pinfo [0].PROC_WCHAN;
 
@@ -105,6 +110,11 @@ glibtop_get_proc_kernel_p (glibtop *serv
 		buf->wchan [0] = 0;
 	}
 
+#ifdef __DragonFly__
+	buf->k_flags = (unsigned long) pinfo [0].kp_flags;
+	buf->min_flt = (unsigned long) pinfo [0].kp_ru.ru_minflt;
+	buf->maj_flt = (unsigned long) pinfo [0].kp_ru.ru_majflt;
+#else
 	buf->k_flags = (unsigned long) pinfo [0].ki_flag;
 	buf->min_flt = (unsigned long) pinfo [0].ki_rusage.ru_minflt;
 	buf->maj_flt = (unsigned long) pinfo [0].ki_rusage.ru_majflt;
@@ -112,6 +122,7 @@ glibtop_get_proc_kernel_p (glibtop *serv
 	buf->cmin_flt = (unsigned long) buf->min_flt + pinfo [0].ki_rusage_ch.ru_minflt;
 	buf->cmaj_flt = (unsigned long) buf->maj_flt + pinfo [0].ki_rusage_ch.ru_majflt;
 #endif
+#endif
 
 	buf->flags |= _glibtop_sysdeps_proc_kernel_pstats;
 


[FILE:7435:patches/patch-sysdeps_freebsd_procmap.c]
--- sysdeps/freebsd/procmap.c.orig	2019-02-04 20:15:22 UTC
+++ sysdeps/freebsd/procmap.c
@@ -24,6 +24,7 @@
 #include <glibtop/error.h>
 #include <glibtop/procmap.h>
 
+#ifndef __DragonFly__ /* TODO */
 #include <glibtop_suid.h>
 
 #include <kvm.h>
@@ -34,12 +35,14 @@
 #include <vm/vm_map.h>
 #include <vm/vm.h>
 
+#include <stdbool.h>
+
 #define _KVM_VNODE
 #include <sys/vnode.h>
 #undef _KVM_VNODE
 
 #include <sys/conf.h>
-#if (__FreeBSD_version >= 800038) || (__FreeBSD_kernel_version >= 800038)
+#if defined(__MidnightBSD__) || (__FreeBSD_version >= 800038) || (__FreeBSD_kernel_version >= 800038)
 #define _WANT_FILE
 #include <sys/file.h>
 #undef _WANT_FILE
@@ -51,15 +54,16 @@
 #define _KERNEL
 #include <sys/mount.h>
 #include <ufs/ufs/quota.h>
-#include <ufs/ufs/inode.h>
+#include <ufs/ufs/extattr.h>
+#include <ufs/ufs/ufsmount.h>
 #include <fs/devfs/devfs.h>
-#if (__FreeBSD_version >= 600006) || defined(__FreeBSD_kernel__)
+#if defined(__MidnightBSD__) ||  (__FreeBSD_version >= 600006) || defined(__FreeBSD_kernel__)
 #include <fs/devfs/devfs_int.h>
 #endif
 #undef _KERNEL
+#include <ufs/ufs/inode.h>
 
-
-#if (__FreeBSD_version >= 1101001)
+#if defined(__MidnightBSD__) || (__FreeBSD_version >= 1101001)
 #define _KERNEL
 #include <ufs/ufs/extattr.h>
 #include <ufs/ufs/ufsmount.h>
@@ -79,7 +83,7 @@ static const unsigned long _glibtop_sysd
         (1L << GLIBTOP_MAP_ENTRY_OFFSET) + (1L << GLIBTOP_MAP_ENTRY_PERM) +
         (1L << GLIBTOP_MAP_ENTRY_INODE) + (1L << GLIBTOP_MAP_ENTRY_DEVICE);
 
-#if (__FreeBSD_version >= 600006) || defined(__FreeBSD_kernel__)
+#if defined(__MidnightBSD__) || (__FreeBSD_version >= 600006) || defined(__FreeBSD_kernel__)
 void _glibtop_sysdeps_freebsd_dev_inode (glibtop *server, struct vnode *vnode, struct vnode *vn, guint64 *inum, guint64 *dev);
 
 void
@@ -95,12 +99,14 @@ _glibtop_sysdeps_freebsd_dev_inode (glib
         struct cdev_priv priv;
 #if __FreeBSD_version < 800039
         struct cdev si;
+#else
+        struct ufsmount um;
 #endif
 
         *inum = 0;
         *dev = 0;
 
-        if (kvm_read (server->machine->kd, (gulong) &vnode->v_tag,
+        if (kvm_read (server->machine->kd, (gulong) &vnode->v_lock.lock_object.lo_name,
  	             (char *) &tagptr, sizeof (tagptr)) != sizeof (tagptr) ||
             kvm_read (server->machine->kd, (gulong) tagptr,
 		     (char *) tagstr, sizeof (tagstr)) != sizeof (tagstr))
@@ -120,7 +126,7 @@ _glibtop_sysdeps_freebsd_dev_inode (glib
                 return;
         }
 
-        if (kvm_read (server->machine->kd, (gulong) VTOI(vn), (char *) &inode,
+        if (kvm_read (server->machine->kd, (gulong) ((struct inode *)(vn)->v_data), (char *) &inode,
  	              sizeof (inode)) != sizeof (inode))
         {
                 glibtop_warn_io_r (server, "kvm_read (inode)");
@@ -175,7 +181,7 @@ _glibtop_sysdeps_freebsd_dev_inode (glib
                 *inum = inode.i_number;
 
 
-#if (__FreeBSD_version >= 1101001)
+#if defined(__MidnightBSD__) || (__FreeBSD_version >= 1101001)
 /*
   The ufs struct inode changed between 11.0 and 11.1.
 
@@ -201,7 +207,7 @@ _glibtop_sysdeps_freebsd_dev_inode (glib
 		*dev = priv.cdp_inode;
 
 #else /* older versions */
-#if (__FreeBSD_version >= 800039) || (__FreeBSD_kernel_version >= 800039)
+#if defined(__MidnightBSD__) || (__FreeBSD_version >= 800039) || (__FreeBSD_kernel_version >= 800039)
         if (kvm_read (server->machine->kd, (gulong) cdev2priv(inode.i_dev), (char *) &priv,
 		      sizeof (priv))
 #else
@@ -222,6 +228,9 @@ _glibtop_sysdeps_freebsd_dev_inode (glib
 	    } /* end-if IS_UFS */
 }
 #endif
+#else
+static const unsigned long _glibtop_sysdeps_proc_map = 0;
+#endif /* __DragonFly__ */
 
 /* Init function. */
 
@@ -231,20 +240,51 @@ _glibtop_init_proc_map_p (glibtop *serve
         server->sysdeps.proc_map = _glibtop_sysdeps_proc_map;
 }
 
+#ifndef __DragonFly__
+static int
+vm_map_reader(void *token, vm_map_entry_t addr, vm_map_entry_t dest)
+{
+	kvm_t *kd;
+
+	kd = (kvm_t *)token;
+	return (kvm_read (kd, (gulong) addr, dest, sizeof(*dest)) == sizeof(*dest));
+}
+
+#if !defined(__DragonFly__) && (defined(__MidnightBSD__) || (__FreeBSD_version < 1300062))
+typedef int vm_map_entry_reader(void *token, vm_map_entry_t addr,
+    vm_map_entry_t dest);
+
+static inline vm_map_entry_t
+vm_map_entry_read_succ(void *token, struct vm_map_entry *const clone,
+     vm_map_entry_reader reader)
+{
+	vm_map_entry_t next;
+
+	next = clone->next;
+	if (!reader (token, next, clone))
+		return (NULL);
+	return (next);
+}
+#endif
+#endif
+
 /* Provides detailed information about a process. */
 
 glibtop_map_entry *
 glibtop_get_proc_map_p (glibtop *server, glibtop_proc_map *buf,
                         pid_t pid)
 {
+#ifdef __DragonFly__
+	memset (buf, 0, sizeof (glibtop_proc_map));
+	return NULL;
+#else
         struct kinfo_proc *pinfo;
-        struct vm_map_entry entry, *first;
+        struct vm_map_entry entry;
         struct vmspace vmspace;
         struct vm_object object;
         GArray *maps;
         struct vnode vnode;
-        int count;
-        int update = 0;
+        int i, count;
 
         memset (buf, 0, sizeof (glibtop_proc_map));
 
@@ -273,16 +313,6 @@ glibtop_get_proc_map_p (glibtop *server,
                 return NULL;
         }
 
-        first = vmspace.vm_map.header.next;
-
-        if (kvm_read (server->machine->kd,
-                        (gulong) vmspace.vm_map.header.next,
-                        (char *) &entry, sizeof (entry)) != sizeof (entry)) {
-                glibtop_warn_io_r (server, "kvm_read (entry)");
-		glibtop_suid_leave (server);
-                return NULL;
-        }
-
         /* Walk through the `vm_map_entry' list ... */
 
         /* I tested this a few times with `mmap'; as soon as you write
@@ -292,21 +322,17 @@ glibtop_get_proc_map_p (glibtop *server,
         maps = g_array_sized_new(FALSE, FALSE, sizeof(glibtop_map_entry),
                                  vmspace.vm_map.nentries);
 
-        do {
+	entry = vmspace.vm_map.header;
+        for (i = 0; i < vmspace.vm_map.nentries; i++) {
                 glibtop_map_entry *mentry;
                 guint64 inum, dev;
                 guint len;
 
-                if (update) {
-                        if (kvm_read (server->machine->kd,
-                                        (gulong) entry.next,
-                                        (char *) &entry, sizeof (entry)) != sizeof (entry)) {
-                                glibtop_warn_io_r (server, "kvm_read (entry)");
-                                continue;
-                        }
-                } else {
-                        update = 1;
-                }
+		if (!vm_map_entry_read_succ(server->machine->kd, &entry, vm_map_reader)) {
+			glibtop_warn_io_r (server, "kvm_read (entry)");
+			glibtop_suid_leave (server);
+			return NULL;
+		}
 
                 if (entry.eflags & (MAP_ENTRY_IS_SUB_MAP))
                         continue;
@@ -377,7 +403,7 @@ glibtop_get_proc_map_p (glibtop *server,
                 if (entry.protection & VM_PROT_EXECUTE)
                         mentry->perm |= GLIBTOP_MAP_PERM_EXECUTE;
 
-        } while (entry.next != first);
+        }
 
         glibtop_suid_leave (server);
 
@@ -388,4 +414,5 @@ glibtop_get_proc_map_p (glibtop *server,
         buf->total  = (guint64) (buf->number * buf->size);
 
         return (glibtop_map_entry*) g_array_free(maps, FALSE);
+#endif
 }


[FILE:961:patches/patch-sysdeps_freebsd_procmem.c]
--- sysdeps/freebsd/procmem.c.orig	2019-02-04 20:15:22 UTC
+++ sysdeps/freebsd/procmem.c
@@ -34,8 +34,10 @@
 #include <vm/vm_map.h>
 
 #include <sys/vnode.h>
+#ifndef __DragonFly__
 #include <ufs/ufs/quota.h>
 #include <ufs/ufs/inode.h>
+#endif
 
 #include <sys/ucred.h>
 #include <sys/user.h>
@@ -92,12 +94,23 @@ glibtop_get_proc_mem_p (glibtop *server,
 
 #define        PROC_VMSPACE   ki_vmspace
 
+#ifdef __DragonFly__
+       buf->rss_rlim = pinfo [0].kp_vm_rssize;
+#else
        buf->rss_rlim = pinfo [0].ki_rssize;
+#endif
 
+#ifdef __DragonFly__
+       buf->vsize = buf->size = (guint64)
+	       pinfo [0].kp_vm_map_size;
+       buf->resident = buf->rss = (guint64)
+	       ps_pgtok (pinfo [0].kp_vm_rssize) * 1024;
+#else
        buf->vsize = buf->size = (guint64)
 	       pinfo [0].ki_size;
        buf->resident = buf->rss = (guint64)
 	       ps_pgtok (pinfo [0].ki_rssize) * 1024;
+#endif
 
        buf->flags |= _glibtop_sysdeps_proc_mem;
 


[FILE:2009:patches/patch-sysdeps_freebsd_procopenfiles.c]
--- sysdeps/freebsd/procopenfiles.c.orig	2019-02-04 20:15:22 UTC
+++ sysdeps/freebsd/procopenfiles.c
@@ -322,12 +322,21 @@ glibtop_get_proc_open_files_s (glibtop *
 				struct sockaddr_un *sun;
 
 				entry.type = GLIBTOP_FILE_TYPE_LOCALSOCKET;
+/* 64bit inodes */
+#if defined(__MidnightBSD__) || __FreeBSD_version >= 1200031
+				sun = (struct sockaddr_un *)&kif->kf_un.kf_sock.kf_sa_local;
+#else
 				sun = (struct sockaddr_un *)&kif->kf_sa_local;
+#endif
 
 				if (sun->sun_path[0]) {
 					char *addrstr;
 
+#if defined(__MidnightBSD__) || __FreeBSD_version >= 1200031
+					addrstr = addr_to_string(&kif->kf_un.kf_sock.kf_sa_local);
+#else
 					addrstr = addr_to_string(&kif->kf_sa_local);
+#endif
 					g_strlcpy(entry.info.localsock.name,
 						  addrstr,
 						  sizeof(entry.info.localsock.name));
@@ -335,7 +344,11 @@ glibtop_get_proc_open_files_s (glibtop *
 				} else {
 					char *addrstr;
 
+#if defined(__MidnightBSD__) || __FreeBSD_version >= 1200031
+					addrstr = addr_to_string(&kif->kf_un.kf_sock.kf_sa_peer);
+#else
 					addrstr = addr_to_string(&kif->kf_sa_peer);
+#endif
 					g_strlcpy(entry.info.localsock.name,
 						  addrstr,
 						  sizeof(entry.info.localsock.name));
@@ -349,12 +362,20 @@ glibtop_get_proc_open_files_s (glibtop *
 					entry.type = GLIBTOP_FILE_TYPE_INETSOCKET;
 				else
 					entry.type = GLIBTOP_FILE_TYPE_INET6SOCKET;
+#if defined(__MidnightBSD__) || __FreeBSD_version >= 1200031
+				addrstr = addr_to_string(&kif->kf_un.kf_sock.kf_sa_peer);
+#else
 				addrstr = addr_to_string(&kif->kf_sa_peer);
+#endif
 				g_strlcpy(entry.info.sock.dest_host,
 					  addrstr,
 					  sizeof(entry.info.sock.dest_host));
 				g_free(addrstr);
+#if defined(__MidnightBSD__) || __FreeBSD_version >= 1200031
+				entry.info.sock.dest_port = addr_to_port(&kif->kf_un.kf_sock.kf_sa_peer);
+#else
 				entry.info.sock.dest_port = addr_to_port(&kif->kf_sa_peer);
+#endif
 			}
 		} else if (kif->kf_type == KF_TYPE_PIPE) {
 			entry.type = GLIBTOP_FILE_TYPE_PIPE;


[FILE:460:patches/patch-sysdeps_freebsd_procsegment.c]
--- sysdeps/freebsd/procsegment.c.orig	2019-02-04 20:15:22 UTC
+++ sysdeps/freebsd/procsegment.c
@@ -67,8 +67,13 @@ glibtop_get_proc_segment_p (glibtop *ser
 		return;
 	}
 
+#ifdef __DragonFly__
+	buf->text_rss = pinfo[0].kp_vm_tsize * pagesize;
+	buf->data_rss = pinfo[0].kp_vm_dsize * pagesize;
+#else
 	buf->text_rss = pinfo[0].ki_tsize * pagesize;
 	buf->data_rss = pinfo[0].ki_dsize * pagesize;
+#endif
 
 	buf->flags = _glibtop_sysdeps_proc_segment;
 }


[FILE:574:patches/patch-sysdeps_freebsd_procsignal.c]
--- sysdeps/freebsd/procsignal.c.orig	2019-02-04 20:15:22 UTC
+++ sysdeps/freebsd/procsignal.c
@@ -64,10 +64,17 @@ glibtop_get_proc_signal_p (glibtop *serv
 		return;
 	}
 
+#ifdef __DragonFly__
+#define	PROC_SIGLIST	kp_siglist
+#define	PROC_SIGMASK	kp_lwp.kl_sigmask
+#define	PROC_SIGIGNORE	kp_sigignore
+#define	PROC_SIGCATCH	kp_sigcatch
+#else
 #define	PROC_SIGLIST	ki_siglist
 #define	PROC_SIGMASK	ki_sigmask
 #define	PROC_SIGIGNORE	ki_sigignore
 #define	PROC_SIGCATCH	ki_sigcatch
+#endif
 
 	/* signal: mask of pending signals.
 	 *         pinfo [0].kp_proc.p_siglist


[FILE:1227:patches/patch-sysdeps_freebsd_procstate.c]
--- sysdeps/freebsd/procstate.c.orig	2019-02-04 20:15:22 UTC
+++ sysdeps/freebsd/procstate.c
@@ -59,11 +59,46 @@ glibtop_get_proc_state_p (glibtop *serve
 		return;
 	}
 
+#ifdef __DragonFly__
+	buf->uid = pinfo[0].kp_ruid;
+	buf->gid = pinfo[0].kp_rgid;
+#else
 	buf->uid = pinfo[0].ki_ruid;
 	buf->gid = pinfo[0].ki_rgid;
+#endif
 
+#ifdef __DragonFly__
+	g_strlcpy (buf->cmd, pinfo[0].kp_comm, sizeof (buf->cmd));
+#else
 	g_strlcpy (buf->cmd, pinfo[0].ki_comm, sizeof (buf->cmd));
+#endif
 
+#ifdef __DragonFly__
+	switch (pinfo[0].kp_stat) {
+	case SACTIVE:
+		switch (pinfo[0].kp_lwp.kl_stat) {
+		case LSRUN:
+			buf->state = GLIBTOP_PROCESS_RUNNING;
+			break;
+		case LSSLEEP:
+			buf->state = GLIBTOP_PROCESS_INTERRUPTIBLE;
+			break;
+		case LSSTOP:
+			buf->state = GLIBTOP_PROCESS_STOPPED;
+			break;
+		default:
+			buf->state = 0;
+			break;
+		}
+	case SZOMB:
+		buf->state = GLIBTOP_PROCESS_ZOMBIE;
+		break;
+	case SIDL:
+	default:
+		buf->state = 0;
+	break;
+	}
+#else
 	switch (pinfo[0].ki_stat) {
 		case SRUN:
 			buf->state = GLIBTOP_PROCESS_RUNNING;
@@ -86,6 +121,7 @@ glibtop_get_proc_state_p (glibtop *serve
 			buf->state = 0;
 			break;
 	}
+#endif
 
 	buf->flags = _glibtop_sysdeps_proc_state;
 }


[FILE:1173:patches/patch-sysdeps_freebsd_proctime.c]
--- sysdeps/freebsd/proctime.c.orig	2019-02-04 20:15:22 UTC
+++ sysdeps/freebsd/proctime.c
@@ -92,8 +92,12 @@ glibtop_get_proc_time_p (glibtop *server
 	}
 
 	buf->frequency = (ci.stathz ? ci.stathz : ci.hz);
+#ifdef __DragonFly__
+	buf->rtime = 0; /* XXX TODO */
+#else
 	buf->rtime = pinfo [0].ki_runtime * buf->frequency / 1000000;
 	buf->flags = _glibtop_sysdeps_proc_time;
+#endif
 
 	/*
 	  All the following used to be 'if (pinfo [0].ki_flag & PS_INMEM)'
@@ -101,6 +105,13 @@ glibtop_get_proc_time_p (glibtop *server
 	  I have no idea what this PS_INMEM is, but it works perfectly
 	  without this check.
 	 */
+#ifdef __DragonFly__
+	buf->utime = 0;
+	buf->stime = 0;
+	buf->cutime = 0;
+	buf->cstime = 0;
+           buf->start_time = 0;
+#else
 	buf->utime = tv2sec_freq (pinfo [0].ki_rusage.ru_utime, buf->frequency);
 	buf->stime = tv2sec_freq (pinfo [0].ki_rusage.ru_stime, buf->frequency);
 	buf->cutime = tv2sec_freq (pinfo [0].ki_childtime, buf->frequency);
@@ -111,4 +122,5 @@ glibtop_get_proc_time_p (glibtop *server
 #endif
            buf->start_time = tv2sec (pinfo [0].ki_start);
            buf->flags |= _glibtop_sysdeps_proc_time_user;
+#endif
 }


[FILE:768:patches/patch-sysdeps_freebsd_procuid.c]
--- sysdeps/freebsd/procuid.c.orig	2019-02-04 20:15:22 UTC
+++ sysdeps/freebsd/procuid.c
@@ -62,6 +62,17 @@ glibtop_get_proc_uid_p (glibtop *server,
 		return;
 	}
 
+#ifdef __DragonFly__
+#define	PROC_RUID	kp_ruid
+#define	PROC_EUID	kp_uid
+#define	PROC_RGID	kp_rgid
+#define	PROC_SVGID	kp_svgid
+#define	PROC_PPID	kp_ppid
+#define	PROC_PGID	kp_pgid
+#define	PROC_TPGID	kp_tpgid
+#define	PROC_NICE	kp_nice
+#define	PROC_PRIORITY	kp_lwp.kl_tdprio
+#else
 #define	PROC_RUID	ki_ruid
 #define	PROC_EUID	ki_uid
 #define	PROC_RGID	ki_rgid
@@ -71,6 +82,7 @@ glibtop_get_proc_uid_p (glibtop *server,
 #define	PROC_TPGID	ki_tpgid
 #define	PROC_NICE	ki_nice
 #define	PROC_PRIORITY	ki_pri.pri_user
+#endif
 
 	buf->uid  = pinfo [0].PROC_RUID;
 	buf->euid = pinfo [0].PROC_EUID;


[FILE:233:dragonfly/patch-sysdeps_freebsd_mountlist.c]
--- sysdeps/freebsd/mountlist.c.orig	2019-02-04 20:15:22 UTC
+++ sysdeps/freebsd/mountlist.c
@@ -99,6 +99,7 @@ static gboolean ignore_mount_entry(const
 		"mfs",
 		"none",
 		"nfs",
+		"null",
 		"nullfs",
 		"nwfs",
 		"portalfs",


[FILE:1916:dragonfly/patch-sysdeps_freebsd_proclist.c]
--- sysdeps/freebsd/proclist.c.orig	2019-02-04 20:15:22 UTC
+++ sysdeps/freebsd/proclist.c
@@ -94,7 +94,7 @@ glibtop_get_proclist_p (glibtop *server,
 	for (i = 0; i < len; i++) {
 		pid_t pid;
 
-		pid = (pid_t) pinfo[i].ki_pid;
+		pid = (pid_t) pinfo[i].kp_pid;
 
 		/* If a process has many threads, kern.proc.all reports multiple
 		   times the same pid. So don't look twice at the same pid.
@@ -115,41 +115,41 @@ glibtop_get_proclist_p (glibtop *server,
 					continue;
 				break;
 			case GLIBTOP_KERN_PROC_UID:
-				if ((uid_t) arg != pinfo[i].ki_ruid)
+				if ((uid_t) arg != pinfo[i].kp_ruid)
 					continue;
 				break;
 			case GLIBTOP_KERN_PROC_PGRP:
-				if ((pid_t) arg != pinfo[i].ki_pgid)
+				if ((pid_t) arg != pinfo[i].kp_pgid)
 					continue;
 				break;
 			case GLIBTOP_KERN_PROC_SESSION:
-				if ((pid_t) arg != pinfo[i].ki_sid)
+				if ((pid_t) arg != pinfo[i].kp_sid)
 					continue;
 				break;
 			case GLIBTOP_KERN_PROC_TTY:
-				if ((dev_t) arg != pinfo[i].ki_tdev)
+				if ((dev_t) arg != pinfo[i].kp_tdev)
 					continue;
 				break;
 			case GLIBTOP_KERN_PROC_RUID:
-				if ((uid_t) arg != pinfo[i].ki_ruid)
+				if ((uid_t) arg != pinfo[i].kp_ruid)
 					continue;
 				break;
 			}
 
 		if (which & GLIBTOP_EXCLUDE_NOTTY)
-			if (pinfo[i].ki_tdev == (dev_t) -1) continue;
+			if (pinfo[i].kp_tdev == (dev_t) -1) continue;
 
 		if (which & GLIBTOP_EXCLUDE_IDLE) {
 			glibtop_get_proc_state_p (server, &procstate, pid);
 			if (procstate.flags & (1L << GLIBTOP_PROC_STATE_STATE))
 				if (procstate.state != GLIBTOP_PROCESS_RUNNING) continue;
 
-			if (pinfo[i].ki_ppid == 0 && !strcmp(pinfo[i].ki_comm, "idle"))
+			if (pinfo[i].kp_ppid == 0 && !strcmp(pinfo[i].kp_comm, "idle"))
 				continue;
 		}
 
 		if (which & GLIBTOP_EXCLUDE_SYSTEM)
-			if (pinfo[i].ki_ruid == (uid_t) 0) continue;
+			if (pinfo[i].kp_ruid == (uid_t) 0) continue;
 
 		g_array_append_val (pids, pid);
 	}

