# Buildsheet autogenerated by ravenadm tool -- Do not edit.

NAMEBASE=		python-async-timeout
VERSION=		5.0.1
KEYWORDS=		python
VARIANTS=		v12 v13
SDESC[v12]=		Asyncio-compatible timeout context manager (3.12)
SDESC[v13]=		Asyncio-compatible timeout context manager (3.13)
HOMEPAGE=		https://github.com/aio-libs/async-timeout
CONTACT=		Python_Automaton[python@ironwolf.systems]

DOWNLOAD_GROUPS=	main
SITES[main]=		PYPIWHL/fe/ba/e2081de779ca30d473f21f5b30e0e737c438205440784c7dfc81efc2b029
DISTFILE[1]=		async_timeout-5.0.1-py3-none-any.whl:main
DIST_SUBDIR=		python-src
DF_INDEX=		1
SPKGS[v12]=		single
SPKGS[v13]=		single

OPTIONS_AVAILABLE=	PY312 PY313
OPTIONS_STANDARD=	none
VOPTS[v12]=		PY312=ON PY313=OFF
VOPTS[v13]=		PY312=OFF PY313=ON

DISTNAME=		async_timeout-5.0.1.dist-info

GENERATED=		yes

[PY312].USES_ON=			python:v12,wheel

[PY313].USES_ON=			python:v13,wheel

[FILE:2981:descriptions/desc.single]
async-timeout
=============
    :alt: Chat on Gitter

asyncio-compatible timeout context manager.

DEPRECATED
----------

This library has effectively been upstreamed into Python 3.11+.

Therefore this library is considered deprecated and no longer actively
supported.

Version 5.0+ provides dual-mode when executed on Python 3.11+:
``asyncio_timeout.Timeout is fully compatible with asyncio.Timeout`` *and*
old
versions of the library.

Anyway, using upstream is highly recommended. asyncio_timeout exists only
for the
sake of backward compatibility, easy supporting both old and new Python by
the same
code, and easy misgration.

If rescheduling API is not important and only ``async with timeout(...):
...`` functionality is required,
a user could apply conditional import::

    if sys.version_info >= (3, 11):
        from asyncio import timeout, timeout_at
    else:
        from async_timeout import timeout, timeout_at

Usage example
-------------

The context manager is useful in cases when you want to apply timeout
logic around block of code or in cases when ``asyncio.wait_for()`` is
not suitable. Also it's much faster than ``asyncio.wait_for()
because timeout`` doesn't create a new task.

The ``timeout(delay, *, loop=None)`` call returns a context manager
that cancels a block on *timeout* expiring::

   from async_timeout import timeout
   async with timeout(1.5):
       await inner()

1. If ``inner() is executed faster than in 1.5`` seconds nothing
   happens.
2. Otherwise ``inner() is cancelled internally by sending
   asyncio.CancelledError into but asyncio.TimeoutError`` is
   raised outside of context manager scope.

*timeout* parameter could be None for skipping timeout functionality.

Alternatively, ``timeout_at(when)`` can be used for scheduling
at the absolute time::

   loop = asyncio.get_event_loop()
   now = loop.time()

   async with timeout_at(now + 1.5):
       await inner()

Please note: it is not POSIX time but a time with
undefined starting base, e.g. the time of the system power on.

Context manager has ``.expired()`` / ``.expired`` for check if timeout
happens
exactly in context manager::

   async with timeout(1.5) as cm:
       await inner()
   print(cm.expired())  # recommended api
   print(cm.expired)    # compatible api

The property is True if ``inner()`` execution is cancelled by
timeout context manager.

If ``inner() call explicitly raises TimeoutError cm.expired
is False``.

The scheduled deadline time is available as ``.when()`` / ``.deadline``::

   async with timeout(1.5) as cm:
       cm.when()    # recommended api
       cm.deadline  # compatible api

Not finished yet timeout can be rescheduled by ``shift()
or update()`` methods::

   async with timeout(1.5) as cm:
       # recommended api
       cm.reschedule(cm.when() + 1)  # add another second on waiting
       # compatible api
       cm.shift(1)  # add another second on waiting
       cm.update(loop.time() + 5)  # reschedule to now+5 seconds



[FILE:126:distinfo]
39e3809566ff85354557ec2398b55e096c8364bacac9405a7a1fa429e77fe76c         6233 python-src/async_timeout-5.0.1-py3-none-any.whl

