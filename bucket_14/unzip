# Buildsheet autogenerated by ravenadm tool -- Do not edit.

NAMEBASE=		unzip
VERSION=		6.0
KEYWORDS=		archivers
VARIANTS=		standard chinese korean russian
SDESC[russian]=		Russian extraction utility for .zip archives
SDESC[standard]=	Extraction utility for .zip format archives
SDESC[chinese]=		Chinese extraction utility for .zip archives
SDESC[korean]=		Korean extraction utility for .zip archives
HOMEPAGE=		http://infozip.sourceforge.net/UnZip.html
CONTACT=		nobody

DOWNLOAD_GROUPS=	main
SITES[main]=		SF/infozip/UnZip%206.x%20%28latest%29/UnZip%206.0/
DISTFILE[1]=		unzip60.tar.gz:main
DF_INDEX=		1
SPKGS[russian]=		core
SPKGS[standard]=	complete
			core
			docs
SPKGS[chinese]=		core
SPKGS[korean]=		core

OPTIONS_AVAILABLE=	LANG_CN LANG_KO LANG_RU ICONV
OPTIONS_STANDARD=	ICONV
VOPTS[russian]=		LANG_CN=OFF LANG_KO=OFF LANG_RU=ON ICONV=ON
VOPTS[chinese]=		LANG_CN=ON LANG_KO=OFF LANG_RU=OFF ICONV=ON
VOPTS[korean]=		LANG_CN=OFF LANG_KO=ON LANG_RU=OFF ICONV=ON

BUILD_DEPENDS=		bzip2:static:standard
			zlib:static:standard

USES=			cpe

DISTNAME=		unzip60

LICENSE=		CUSTOM1:core
LICENSE_NAME=		CUSTOM1:"Info-ZIP license"
LICENSE_FILE=		CUSTOM1:{{WRKSRC}}/LICENSE
LICENSE_SCHEME=		solo

CPE_VENDOR=		info-zip
FPC_EQUIVALENT=		archivers/unzip

INVALID_RPATH=		yes

BUILD_TARGET=		generic_zlib unzipsfx
MAKEFILE=		unix/Makefile
MAKE_ARGS=		LF2="{{STRIP}} {{LDFLAGS}}"
			CF="{{CPPFLAGS}} {{CFLAGS}}"
MAKE_ENV=		LOCAL_UNZIP="{{CFLAGS}} -DACORN_FTYPE_NFS -DWILD_STOP_AT_DIR -DUNICODE_SUPPORT -DUTF8_MAYBE_NATIVE -D_MBCS -DLARGE_FILE_SUPPORT"
			D_USE_BZ2=-DUSE_BZIP2
			L_BZ2={{LOCALBASE}}/lib/libbz2.a

CPPFLAGS=		-DUNIX
			-Dunix
			-DUSE_UNSHRINK
			-I.
VAR_OPSYS[freebsd]=	CPPFLAGS=-DBSD
VAR_OPSYS[sunos]=	CPPFLAGS=-DNO_LCHMOD
VAR_OPSYS[linux]=	CPPFLAGS=-DNO_LCHMOD
VAR_OPSYS[darwin]=	CPPFLAGS=-DBSD
VAR_OPSYS[netbsd]=	CPPFLAGS=-DBSD
VAR_OPSYS[openbsd]=	CPPFLAGS=-DBSD
			CPPFLAGS=-DNO_LCHMOD
VAR_OPSYS[dragonfly]=	CPPFLAGS=-DBSD

[LANG_KO].EXTRA_PATCHES_ON=		extra-ko-patch-fileio.c
					extra-ko-patch-unzip.c
					extra-ko-patch-unzip.h
[LANG_KO].KEYWORDS_ON=			korean

[LANG_RU].EXTRA_PATCHES_ON=		extra-ru-patch-ebcdic.h
[LANG_RU].KEYWORDS_ON=			russian

[LANG_CN].EXTRA_PATCHES_ON=		extra-zh-patch-fileio.c
[LANG_CN].KEYWORDS_ON=			chinese

[ICONV].CFLAGS_ON=			-DNATIVE
					-I{{ICONV_INCLUDE_PATH}}
[ICONV].EXTRA_PATCHES_ON=		extra-iconv-patch-unix_unix.c
					extra-iconv-patch-unix_unxcfg.h
					extra-iconv-patch-unzip.c
					extra-iconv-patch-unzpriv.h
					extra-iconv-patch-zipinfo.c
[ICONV].MAKE_ARGS_ON=			LFLAGS1="-L{{ICONV_LIBRARY_PATH}} {{ICONV_LIB}} -Wl,-rpath,{{ICONV_LIBRARY_PATH}}"
[ICONV].USES_ON=			iconv

post-install-LANG_CN-ON:
	${RM} -r ${STAGEDIR}${STD_DOCDIR}

post-install-LANG_RU-ON:
	${RM} -r ${STAGEDIR}${STD_DOCDIR}

do-install:
	${INSTALL_PROGRAM} ${WRKSRC}/unzip ${STAGEDIR}${PREFIX}/bin
	(cd ${WRKSRC} && \
		${INSTALL_PROGRAM} funzip unzipsfx ${STAGEDIR}${PREFIX}/bin)
	${LN} -sf unzip ${STAGEDIR}${PREFIX}/bin/zipinfo
	${INSTALL_SCRIPT} ${WRKSRC}/unix/zipgrep ${STAGEDIR}${PREFIX}/bin
	${INSTALL_MAN} ${WRKSRC}/man/unzip.1 ${STAGEDIR}${PREFIX}/share/man/man1
	(cd ${WRKSRC}/man && ${INSTALL_MAN} funzip.1 unzipsfx.1 zipgrep.1 \
		zipinfo.1 ${STAGEDIR}${PREFIX}/share/man/man1)
	@${MKDIR} ${STAGEDIR}${STD_DOCDIR}
	(cd ${WRKSRC} && ${INSTALL_DATA} README WHERE ${STAGEDIR}${STD_DOCDIR})

post-install-LANG_KO-ON:
	${RM} -r ${STAGEDIR}${STD_DOCDIR}

[FILE:1010:descriptions/desc.core.standard]
Unzip will list, test, or extract files from a ZIP archive, commonly
found on MS-DOS systems.  The default behavior (with no options) is to
extract into the current directory (and subdirectories below it) all
files from the specified ZIP archive. Unzip is compatible with
archives created by PKWARE's PKZIP, but in many cases the program
options or default behaviors differ.

Zipinfo lists technical information about files in a ZIP archive, most
commonly found on MS-DOS systems.  Such information includes file access
permissions, encryption status, type of compression, version and operating
system or file system of compressing program, and the like.

Funzip acts as a filter; that is, it assumes that a ZIP archive is
being piped into standard input, and it extracts the first member from
the archive to stdout.  If there is an argument, then the input comes
from the specified file instead of from stdin.

Unzipsfx may be used to create self-extracting ZIP archives from previously
created ZIP archives.


[FILE:1059:descriptions/desc.core.chinese]
Unzip will list, test, or extract files from a ZIP archive, commonly
found on MS-DOS systems.  The default behavior (with no options) is to
extract into the current directory (and subdirectories below it) all
files from the specified ZIP archive. Unzip is compatible with
archives created by PKWARE's PKZIP, but in many cases the program
options or default behaviors differ.

Zipinfo lists technical information about files in a ZIP archive, most
commonly found on MS-DOS systems.  Such information includes file access
permissions, encryption status, type of compression, version and operating
system or file system of compressing program, and the like.

Funzip acts as a filter; that is, it assumes that a ZIP archive is
being piped into standard input, and it extracts the first member from
the archive to stdout.  If there is an argument, then the input comes
from the specified file instead of from stdin.

Unzipsfx may be used to create self-extracting ZIP archives from previously
created ZIP archives.

This variant provides Chinese language support.


[FILE:1058:descriptions/desc.core.korean]
Unzip will list, test, or extract files from a ZIP archive, commonly
found on MS-DOS systems.  The default behavior (with no options) is to
extract into the current directory (and subdirectories below it) all
files from the specified ZIP archive. Unzip is compatible with
archives created by PKWARE's PKZIP, but in many cases the program
options or default behaviors differ.

Zipinfo lists technical information about files in a ZIP archive, most
commonly found on MS-DOS systems.  Such information includes file access
permissions, encryption status, type of compression, version and operating
system or file system of compressing program, and the like.

Funzip acts as a filter; that is, it assumes that a ZIP archive is
being piped into standard input, and it extracts the first member from
the archive to stdout.  If there is an argument, then the input comes
from the specified file instead of from stdin.

Unzipsfx may be used to create self-extracting ZIP archives from previously
created ZIP archives.

This variant provides Korean language support.


[FILE:1059:descriptions/desc.core.russian]
Unzip will list, test, or extract files from a ZIP archive, commonly
found on MS-DOS systems.  The default behavior (with no options) is to
extract into the current directory (and subdirectories below it) all
files from the specified ZIP archive. Unzip is compatible with
archives created by PKWARE's PKZIP, but in many cases the program
options or default behaviors differ.

Zipinfo lists technical information about files in a ZIP archive, most
commonly found on MS-DOS systems.  Such information includes file access
permissions, encryption status, type of compression, version and operating
system or file system of compressing program, and the like.

Funzip acts as a filter; that is, it assumes that a ZIP archive is
being piped into standard input, and it extracts the first member from
the archive to stdout.  If there is an argument, then the input comes
from the specified file instead of from stdin.

Unzipsfx may be used to create self-extracting ZIP archives from previously
created ZIP archives.

This variant provides Russian language support.


[FILE:93:distinfo]
036d96991646d0449ed0aa952e4fbe21b476ce994abc276e49d30e686708bd37      1376845 unzip60.tar.gz


[FILE:132:manifests/plist.core]
bin/
 funzip
 unzip
 unzipsfx
 zipgrep
 zipinfo
share/man/man1/
 funzip.1.gz
 unzip.1.gz
 unzipsfx.1.gz
 zipgrep.1.gz
 zipinfo.1.gz


[FILE:32:manifests/plist.docs]
share/doc/unzip/
 README
 WHERE


[FILE:644:patches/patch-consts.h]
--- consts.h.orig	2002-03-23 15:52:48 UTC
+++ consts.h
@@ -34,9 +34,9 @@ ZCONST char Far CentSigMsg[] =
   "error:  expected central file header signature not found (file #%lu).\n";
 ZCONST char Far SeekMsg[] =
   "error [%s]:  attempt to seek before beginning of zipfile\n%s";
-ZCONST char Far FilenameNotMatched[] = "caution: filename not matched:  %s\n";
+ZCONST char Far FilenameNotMatched[] = "caution: filename not matched:  %.512s\n";
 ZCONST char Far ExclFilenameNotMatched[] =
-  "caution: excluded filename not matched:  %s\n";
+  "caution: excluded filename not matched:  %.512s\n";
 
 #ifdef VMS
   ZCONST char Far ReportMsg[] = "\


[FILE:765:patches/patch-crypt.c]
--- crypt.c.orig	2007-01-05 15:47:36 UTC
+++ crypt.c
@@ -465,7 +465,17 @@ int decrypt(__G__ passwrd)
     GLOBAL(pInfo->encrypted) = FALSE;
     defer_leftover_input(__G);
     for (n = 0; n < RAND_HEAD_LEN; n++) {
-        b = NEXTBYTE;
+        /* 2012-11-23 SMS.  (OUSPG report.)
+         * Quit early if compressed size < HEAD_LEN.  The resulting
+         * error message ("unable to get password") could be improved,
+         * but it's better than trying to read nonexistent data, and
+         * then continuing with a negative G.csize.  (See
+         * fileio.c:readbyte()).
+         */
+        if ((b = NEXTBYTE) == (ush)EOF)
+        {
+            return PK_ERR;
+        }
         h[n] = (uch)b;
         Trace((stdout, " (%02x)", h[n]));
     }


[FILE:3573:patches/patch-extract.c]
--- extract.c.orig	2009-03-14 01:32:52 UTC
+++ extract.c
@@ -1,5 +1,5 @@
 /*
-  Copyright (c) 1990-2009 Info-ZIP.  All rights reserved.
+  Copyright (c) 1990-2014 Info-ZIP.  All rights reserved.
 
   See the accompanying file LICENSE, version 2009-Jan-02 or later
   (the contents of which are also included in unzip.h) for terms of use.
@@ -298,6 +298,8 @@ char ZCONST Far TruncNTSD[] =
 #ifndef SFX
    static ZCONST char Far InconsistEFlength[] = "bad extra-field entry:\n \
      EF block length (%u bytes) exceeds remaining EF data (%u bytes)\n";
+   static ZCONST char Far TooSmallEFlength[] = "bad extra-field entry:\n \
+     EF block length (%u bytes) invalid (< %d)\n";
    static ZCONST char Far InvalidComprDataEAs[] =
      " invalid compressed data for EAs\n";
 #  if (defined(WIN32) && defined(NTSD_EAS))
@@ -2023,7 +2025,8 @@ static int TestExtraField(__G__ ef, ef_l
         ebID = makeword(ef);
         ebLen = (unsigned)makeword(ef+EB_LEN);
 
-        if (ebLen > (ef_len - EB_HEADSIZE)) {
+        if (ebLen > (ef_len - EB_HEADSIZE))
+        {
            /* Discovered some extra field inconsistency! */
             if (uO.qflag)
                 Info(slide, 1, ((char *)slide, "%-22s ",
@@ -2032,6 +2035,16 @@ static int TestExtraField(__G__ ef, ef_l
               ebLen, (ef_len - EB_HEADSIZE)));
             return PK_ERR;
         }
+        else if (ebLen < EB_HEADSIZE)
+        {
+            /* Extra block length smaller than header length. */
+            if (uO.qflag)
+                Info(slide, 1, ((char *)slide, "%-22s ",
+                  FnFilter1(G.filename)));
+            Info(slide, 1, ((char *)slide, LoadFarString(TooSmallEFlength),
+              ebLen, EB_HEADSIZE));
+            return PK_ERR;
+        }
 
         switch (ebID) {
             case EF_OS2:
@@ -2217,14 +2230,28 @@ static int test_compr_eb(__G__ eb, eb_si
     ulg eb_ucsize;
     uch *eb_ucptr;
     int r;
+    ush method;
 
     if (compr_offset < 4)                /* field is not compressed: */
         return PK_OK;                    /* do nothing and signal OK */
 
+    /* Return no/bad-data error status if any problem is found:
+     *    1. eb_size is too small to hold the uncompressed size
+     *       (eb_ucsize).  (Else extract eb_ucsize.)
+     *    2. eb_ucsize is zero (invalid).  2014-12-04 SMS.
+     *    3. eb_ucsize is positive, but eb_size is too small to hold
+     *       the compressed data header.
+     */
     if ((eb_size < (EB_UCSIZE_P + 4)) ||
-        ((eb_ucsize = makelong(eb+(EB_HEADSIZE+EB_UCSIZE_P))) > 0L &&
-         eb_size <= (compr_offset + EB_CMPRHEADLEN)))
-        return IZ_EF_TRUNC;               /* no compressed data! */
+     ((eb_ucsize = makelong( eb+ (EB_HEADSIZE+ EB_UCSIZE_P))) == 0L) ||
+     ((eb_ucsize > 0L) && (eb_size <= (compr_offset + EB_CMPRHEADLEN))))
+        return IZ_EF_TRUNC;             /* no/bad compressed data! */
+
+    method = makeword(eb + (EB_HEADSIZE + compr_offset));
+    if ((method == STORED) && (eb_size - compr_offset != eb_ucsize))
+	return PK_ERR;			  /* compressed & uncompressed
+					   * should match in STORED
+					   * method */
 
     if (
 #ifdef INT_16BIT
@@ -2701,6 +2728,12 @@ __GDEF
     int repeated_buf_err;
     bz_stream bstrm;
 
+    if (G.incnt <= 0 && G.csize <= 0L) {
+        /* avoid an infinite loop */
+        Trace((stderr, "UZbunzip2() got empty input\n"));
+        return 2;
+    }
+
 #if (defined(DLL) && !defined(NO_SLIDE_REDIR))
     if (G.redirect_slide)
         wsize = G.redirect_size, redirSlide = G.redirect_buffer;


[FILE:1177:patches/patch-fileio.c]
$NetBSD: patch-fileio.c,v 1.1 2014/12/25 16:48:33 wiz Exp $

https://bugzilla.redhat.com/show_bug.cgi?id=CVE-2014-8141

--- fileio.c.orig	2009-04-20 00:03:44.000000000 +0000
+++ fileio.c
@@ -176,6 +176,8 @@ static ZCONST char Far FilenameTooLongTr
 #endif
 static ZCONST char Far ExtraFieldTooLong[] =
   "warning:  extra field too long (%d).  Ignoring...\n";
+static ZCONST char Far ExtraFieldCorrupt[] =
+  "warning:  extra field (type: 0x%04x) corrupt.  Continuing...\n";
 
 #ifdef WINDLL
    static ZCONST char Far DiskFullQuery[] =
@@ -2295,7 +2297,12 @@ int do_string(__G__ length, option)   /*
             if (readbuf(__G__ (char *)G.extra_field, length) == 0)
                 return PK_EOF;
             /* Looks like here is where extra fields are read */
-            getZip64Data(__G__ G.extra_field, length);
+            if (getZip64Data(__G__ G.extra_field, length) != PK_COOL)
+            {
+                Info(slide, 0x401, ((char *)slide,
+                 LoadFarString( ExtraFieldCorrupt), EF_PKSZ64));
+                error = PK_WARN;
+            }
 #ifdef UNICODE_SUPPORT
             G.unipath_filename = NULL;
             if (G.UzO.U_flag < 2) {


[FILE:890:patches/patch-inflate.c]
--- inflate.c.orig	2008-07-30 01:31:08 UTC
+++ inflate.c
@@ -473,7 +473,11 @@ int UZinflate(__G__ is_defl64)
                     retval = 2;
                 } else {
                     /* output write failure */
+#ifdef FUNZIP
+                    retval = PK_DISK;
+#else
                     retval = (G.disk_full != 0 ? PK_DISK : IZ_CTRLC);
+#endif
                 }
             } else {
                 Trace((stderr, "oops!  (inflateBack9() err = %d)\n", err));
@@ -538,7 +542,11 @@ int UZinflate(__G__ is_defl64)
                     retval = 2;
                 } else {
                     /* output write failure */
+#ifdef FUNZIP
+                    retval = PK_DISK;
+#else
                     retval = (G.disk_full != 0 ? PK_DISK : IZ_CTRLC);
+#endif
                 }
             } else {
                 Trace((stderr, "oops!  (inflateBack() err = %d)\n", err));


[FILE:1564:patches/patch-list.c]
$NetBSD: patch-list.c,v 1.2 2017/02/04 23:25:59 wiz Exp $

chunk 1:
Big-hammer fix for
http://seclists.org/oss-sec/2014/q4/497

chunk 2:
CVE-2014-9913 fix from
https://people.debian.org/~sanvila/unzip/cve-2014-9913/cve-2014-9913-unzip-buffer-overflow.txt
via
http://www.info-zip.org/phpBB3/viewtopic.php?f=7&t=529

--- list.c.orig	2009-02-08 17:11:34.000000000 +0000
+++ list.c
@@ -116,7 +116,7 @@ int list_files(__G)    /* return PK-type
     ulg acl_size, tot_aclsize=0L, tot_aclfiles=0L;
 #endif
     min_info info;
-    char methbuf[8];
+    char methbuf[80];
     static ZCONST char dtype[]="NXFS";  /* see zi_short() */
     static ZCONST char Far method[NUM_METHODS+1][8] =
         {"Stored", "Shrunk", "Reduce1", "Reduce2", "Reduce3", "Reduce4",
@@ -339,7 +339,14 @@ int list_files(__G)    /* return PK-type
                 G.crec.compression_method == ENHDEFLATED) {
                 methbuf[5] = dtype[(G.crec.general_purpose_bit_flag>>1) & 3];
             } else if (methnum >= NUM_METHODS) {
-                sprintf(&methbuf[4], "%03u", G.crec.compression_method);
+                /* Fix for CVE-2014-9913, similar to CVE-2016-9844.
+                 * Use the old decimal format only for values which fit.
+                 */
+                if (G.crec.compression_method <= 999) {
+                    sprintf( &methbuf[ 4], "%03u", G.crec.compression_method);
+                } else {
+                    sprintf( &methbuf[ 3], "%04X", G.crec.compression_method);
+                }
             }
 
 #if 0       /* GRR/Euro:  add this? */


[FILE:4618:patches/patch-process.c]
--- process.c.orig	2009-03-06 01:25:10 UTC
+++ process.c
@@ -1,5 +1,5 @@
 /*
-  Copyright (c) 1990-2009 Info-ZIP.  All rights reserved.
+  Copyright (c) 1990-2014 Info-ZIP.  All rights reserved.
 
   See the accompanying file LICENSE, version 2009-Jan-02 or later
   (the contents of which are also included in unzip.h) for terms of use.
@@ -101,10 +101,10 @@ static ZCONST char Far CannotAllocateBuf
    /* do_seekable() strings */
 # ifdef UNIX
    static ZCONST char Far CannotFindZipfileDirMsg[] =
-     "%s:  cannot find zipfile directory in one of %s or\n\
-        %s%s.zip, and cannot find %s, period.\n";
+     "%s:  cannot find zipfile directory in one of %.512s or\n\
+	%s%.512s.zip, and cannot find %.512s, period.\n";
    static ZCONST char Far CannotFindEitherZipfile[] =
-     "%s:  cannot find or open %s, %s.zip or %s.\n";
+     "%s:  cannot find or open %.512s, %.512s.zip or %.512s.\n";
 # else /* !UNIX */
    static ZCONST char Far CannotFindZipfileDirMsg[] =
      "%s:  cannot find zipfile directory in %s,\n\
@@ -1888,48 +1888,82 @@ int getZip64Data(__G__ ef_buf, ef_len)
     and a 4-byte version of disk start number.
     Sets both local header and central header fields.  Not terribly clever,
     but it means that this procedure is only called in one place.
+
+    2014-12-05 SMS.
+    Added checks to ensure that enough data are available before calling
+    makeint64() or makelong().  Replaced various sizeof() values with
+    simple ("4" or "8") constants.  (The Zip64 structures do not depend
+    on our variable sizes.)  Error handling is crude, but we should now
+    stay within the buffer.
   ---------------------------------------------------------------------------*/
 
+#define Z64FLGS 0xffff
+#define Z64FLGL 0xffffffff
+
     if (ef_len == 0 || ef_buf == NULL)
         return PK_COOL;
 
     Trace((stderr,"\ngetZip64Data: scanning extra field of length %u\n",
       ef_len));
 
-    while (ef_len >= EB_HEADSIZE) {
+    while (ef_len >= EB_HEADSIZE)
+    {
         eb_id = makeword(EB_ID + ef_buf);
         eb_len = makeword(EB_LEN + ef_buf);
 
-        if (eb_len > (ef_len - EB_HEADSIZE)) {
-            /* discovered some extra field inconsistency! */
+        if (eb_len > (ef_len - EB_HEADSIZE))
+        {
+            /* Extra block length exceeds remaining extra field length. */
             Trace((stderr,
               "getZip64Data: block length %u > rest ef_size %u\n", eb_len,
               ef_len - EB_HEADSIZE));
             break;
         }
-        if (eb_id == EF_PKSZ64) {
-
+        if (eb_id == EF_PKSZ64)
+        {
           int offset = EB_HEADSIZE;
 
-          if (G.crec.ucsize == 0xffffffff || G.lrec.ucsize == 0xffffffff){
-            G.lrec.ucsize = G.crec.ucsize = makeint64(offset + ef_buf);
-            offset += sizeof(G.crec.ucsize);
+          if ((G.crec.ucsize == Z64FLGL) || (G.lrec.ucsize == Z64FLGL))
+          {
+            if (offset+ 8 > ef_len)
+              return PK_ERR;
+
+            G.crec.ucsize = G.lrec.ucsize = makeint64(offset + ef_buf);
+            offset += 8;
           }
-          if (G.crec.csize == 0xffffffff || G.lrec.csize == 0xffffffff){
-            G.csize = G.lrec.csize = G.crec.csize = makeint64(offset + ef_buf);
-            offset += sizeof(G.crec.csize);
+
+          if ((G.crec.csize == Z64FLGL) || (G.lrec.csize == Z64FLGL))
+          {
+            if (offset+ 8 > ef_len)
+              return PK_ERR;
+
+            G.csize = G.crec.csize = G.lrec.csize = makeint64(offset + ef_buf);
+            offset += 8;
           }
-          if (G.crec.relative_offset_local_header == 0xffffffff){
+
+          if (G.crec.relative_offset_local_header == Z64FLGL)
+          {
+            if (offset+ 8 > ef_len)
+              return PK_ERR;
+
             G.crec.relative_offset_local_header = makeint64(offset + ef_buf);
-            offset += sizeof(G.crec.relative_offset_local_header);
+            offset += 8;
           }
-          if (G.crec.disk_number_start == 0xffff){
+
+          if (G.crec.disk_number_start == Z64FLGS)
+          {
+            if (offset+ 4 > ef_len)
+              return PK_ERR;
+
             G.crec.disk_number_start = (zuvl_t)makelong(offset + ef_buf);
-            offset += sizeof(G.crec.disk_number_start);
+            offset += 4;
           }
+#if 0
+          break;                /* Expect only one EF_PKSZ64 block. */
+#endif /* 0 */
         }
 
-        /* Skip this extra field block */
+        /* Skip this extra field block. */
         ef_buf += (eb_len + EB_HEADSIZE);
         ef_len -= (eb_len + EB_HEADSIZE);
     }


[FILE:796:patches/patch-unix_Makefile]
--- unix/Makefile.orig	2009-01-18 22:41:18 UTC
+++ unix/Makefile
@@ -42,12 +42,10 @@
 # such as -DDOSWILD).
 
 # UnZip flags
-CC = cc#	try using "gcc" target rather than changing this (CC and LD
 LD = $(CC)#	must match, else "unresolved symbol:  ___main" is possible)
 AS = as
 LOC = $(D_USE_BZ2) $(LOCAL_UNZIP)
 AF = $(LOC)
-CFLAGS = -O
 CF_NOOPT = -I. -I$(IZ_BZIP2) -DUNIX $(LOC)
 CF = $(CFLAGS) $(CF_NOOPT)
 LFLAGS1 =
@@ -651,7 +649,7 @@ vax:		unzips	# general-purpose VAX targe
 bsd:		_bsd	# generic BSD (BSD 4.2 & Ultrix handled in unzip.h)
 
 _bsd:		unix_make
-	$(MAKE) unzips CF="$(CF) -DBSD"
+	$(MAKE) unzips CF="$(CF) -DBSD -DUNIX"
 
 #----------------------------------------------------------------------------
 #  SysV group (for extern long timezone and ioctl.h instead of sgtty.h):


[FILE:451:patches/patch-unix_unix.c]
--- unix/unix.c.orig	2009-01-23 23:31:26 UTC
+++ unix/unix.c
@@ -610,7 +610,7 @@ int mapname(__G__ renamed)
                  * else allow 8-bit characters (e.g. UTF-8) in filenames:
                  */
                 if (uO.cflxflag ||
-                    (isprint(workch) || (128 <= workch && workch <= 254)))
+		    (isprint(workch) || (128 <= workch && workch <= 255)))
                     *pp++ = (char)workch;
         } /* end switch */
 


[FILE:726:patches/patch-unix_unxcfg.h]
$NetBSD: patch-unix_unxcfg.h,v 1.2 2014/05/03 11:24:19 ryoon Exp $

* Fix build on Debian GNU/kFreeBSD.
* Fix build under OpenBSD 5.5
  Patch from OpenBSD Ports
  "timeb was already well deprecated on 4.4BSD"

--- unix/unxcfg.h.orig	2009-04-16 18:36:12.000000000 +0000
+++ unix/unxcfg.h
@@ -52,6 +52,7 @@
 
 #include <sys/types.h>          /* off_t, time_t, dev_t, ... */
 #include <sys/stat.h>
+#include <unistd.h>
 
 #ifdef NO_OFF_T
   typedef long zoff_t;
@@ -111,7 +112,9 @@ typedef struct stat z_stat;
 
 #ifdef BSD
 #  include <sys/time.h>
-#  include <sys/timeb.h>
+#  ifndef BSD4_4
+#    include <sys/timeb.h>
+#  endif
 #  if (defined(_AIX) || defined(__GLIBC__) || defined(__GNU__))
 #    include <time.h>
 #  endif


[FILE:1102:patches/patch-zipinfo.c]
$NetBSD: patch-zipinfo.c,v 1.1 2017/02/04 23:25:59 wiz Exp $

Fix crash in zipinfo, CVE-2016-9844.
http://www.openwall.com/lists/oss-security/2016/12/05/19

--- zipinfo.c.orig	2009-02-08 17:04:30.000000000 +0000
+++ zipinfo.c
@@ -1921,7 +1921,18 @@ static int zi_short(__G)   /* return PK-
         ush  dnum=(ush)((G.crec.general_purpose_bit_flag>>1) & 3);
         methbuf[3] = dtype[dnum];
     } else if (methnum >= NUM_METHODS) {   /* unknown */
-        sprintf(&methbuf[1], "%03u", G.crec.compression_method);
+        /* 2016-12-05 SMS.
+         * https://launchpad.net/bugs/1643750
+         * Unexpectedly large compression methods overflow
+         * &methbuf[].  Use the old, three-digit decimal format
+         * for values which fit.  Otherwise, sacrifice the "u",
+         * and use four-digit hexadecimal.
+         */
+        if (G.crec.compression_method <= 999) {
+            sprintf( &methbuf[ 1], "%03u", G.crec.compression_method);
+        } else {
+            sprintf( &methbuf[ 0], "%04X", G.crec.compression_method);
+        }
     }
 
     for (k = 0;  k < 15;  ++k)


[FILE:2974:files/extra-iconv-patch-unix_unix.c]
--- unix/unix.c.orig	2015-02-17 15:18:36.176142072 -0800
+++ unix/unix.c	2015-02-17 15:18:56.289341100 -0800
@@ -30,6 +30,9 @@
 #define UNZIP_INTERNAL
 #include "unzip.h"
 
+#include <iconv.h>
+#include <langinfo.h>
+
 #ifdef SCO_XENIX
 #  define SYSNDIR
 #else  /* SCO Unix, AIX, DNIX, TI SysV, Coherent 4.x, ... */
@@ -1874,3 +1877,102 @@
     }
 }
 #endif /* QLZIP */
+
+
+typedef struct {
+    char *local_charset;
+    char *archive_charset;
+} CHARSET_MAP;
+
+/* A mapping of local <-> archive charsets used by default to convert filenames
+ * of DOS/Windows Zip archives. Currently very basic. */
+static CHARSET_MAP dos_charset_map[] = {
+    { "ANSI_X3.4-1968", "CP850" },
+    { "ISO-8859-1", "CP850" },
+    { "CP1252", "CP850" },
+    { "UTF-8", "CP866" },
+    { "KOI8-R", "CP866" },
+    { "KOI8-U", "CP866" },
+    { "ISO-8859-5", "CP866" }
+};
+
+char OEM_CP[MAX_CP_NAME] = "";
+char ISO_CP[MAX_CP_NAME] = "";
+
+/* Try to guess the default value of OEM_CP based on the current locale.
+ * ISO_CP is left alone for now. */
+void init_conversion_charsets()
+{
+    const char *local_charset;
+    int i;
+
+    /* Make a guess only if OEM_CP not already set. */ 
+    if(*OEM_CP == '\0') {
+    	local_charset = nl_langinfo(CODESET);
+    	for(i = 0; i < sizeof(dos_charset_map)/sizeof(CHARSET_MAP); i++)
+    		if(!strcasecmp(local_charset, dos_charset_map[i].local_charset)) {
+    			strncpy(OEM_CP, dos_charset_map[i].archive_charset,
+    					sizeof(OEM_CP));
+    			break;
+    		}
+    }
+}
+
+/* Convert a string from one encoding to the current locale using iconv().
+ * Be as non-intrusive as possible. If error is encountered during covertion
+ * just leave the string intact. */
+static void charset_to_intern(char *string, char *from_charset)
+{
+    iconv_t cd;
+    char *s,*d, *buf;
+    size_t slen, dlen, buflen;
+    const char *local_charset;
+
+    if(*from_charset == '\0')
+    	return;
+
+    buf = NULL;
+    local_charset = nl_langinfo(CODESET);
+
+    if((cd = iconv_open(local_charset, from_charset)) == (iconv_t)-1)
+        return;
+
+    slen = strlen(string);
+    s = string;
+
+    /*  Make sure OUTBUFSIZ + 1 never ends up smaller than FILNAMSIZ
+     *  as this function also gets called with G.outbuf in fileio.c
+     */
+    buflen = FILNAMSIZ;
+    if (OUTBUFSIZ + 1 < FILNAMSIZ)
+    {
+        buflen = OUTBUFSIZ + 1;
+    }
+
+    d = buf = malloc(buflen);
+    if(!d)
+    	goto cleanup;
+
+    bzero(buf,buflen);
+    dlen = buflen - 1;
+
+    if(iconv(cd, &s, &slen, &d, &dlen) == (size_t)-1)
+    	goto cleanup;
+    strncpy(string, buf, buflen);
+
+    cleanup:
+    free(buf);
+    iconv_close(cd);
+}
+
+/* Convert a string from OEM_CP to the current locale charset. */
+inline void oem_intern(char *string)
+{
+    charset_to_intern(string, OEM_CP);
+}
+
+/* Convert a string from ISO_CP to the current locale charset. */
+inline void iso_intern(char *string)
+{
+    charset_to_intern(string, ISO_CP);
+}


[FILE:810:files/extra-iconv-patch-unix_unxcfg.h]
--- unix/unxcfg.h.orig	2009-04-16 18:36:12 UTC
+++ unix/unxcfg.h
@@ -227,4 +227,30 @@ typedef struct stat z_stat;
 /* wild_dir, dirname, wildname, matchname[], dirnamelen, have_dirname, */
 /*    and notfirstcall are used by do_wild().                          */
 
+
+#define MAX_CP_NAME 25 
+   
+#ifdef SETLOCALE
+#  undef SETLOCALE
+#endif
+#define SETLOCALE(category, locale) setlocale(category, locale)
+#include <locale.h>
+   
+#ifdef _ISO_INTERN
+#  undef _ISO_INTERN
+#endif
+#define _ISO_INTERN(str1) iso_intern(str1)
+
+#ifdef _OEM_INTERN
+#  undef _OEM_INTERN
+#endif
+#ifndef IZ_OEM2ISO_ARRAY
+#  define IZ_OEM2ISO_ARRAY
+#endif
+#define _OEM_INTERN(str1) oem_intern(str1)
+
+void iso_intern(char *);
+void oem_intern(char *);
+void init_conversion_charsets(void);
+   
 #endif /* !__unxcfg_h */


[FILE:5938:files/extra-iconv-patch-unzip.c]
--- unzip.c.orig	2009-04-16 18:26:52 UTC
+++ unzip.c
@@ -327,11 +327,21 @@ static ZCONST char Far ZipInfoUsageLine2
   -2  just filenames but allow -h/-t/-z  -l  long Unix \"ls -l\" format\n\
                                          -v  verbose, multi-page format\n";
 
+#ifndef UNIX
 static ZCONST char Far ZipInfoUsageLine3[] = "miscellaneous options:\n\
   -h  print header line       -t  print totals for listed files or for all\n\
   -z  print zipfile comment   -T  print file times in sortable decimal format\
 \n  -C  be case-insensitive   %s\
   -x  exclude filenames that follow from listing\n";
+#else /* UNIX */
+static ZCONST char Far ZipInfoUsageLine3[] = "miscellaneous options:\n\
+  -h  print header line       -t  print totals for listed files or for all\n\
+  -z  print zipfile comment  %c-T%c print file times in sortable decimal format\
+\n %c-C%c be case-insensitive   %s\
+  -x  exclude filenames that follow from listing\n\
+  -O CHARSET  specify a character encoding for DOS, Windows and OS/2 archives\n\
+  -I CHARSET  specify a character encoding for UNIX and other archives\n";
+#endif /* !UNIX */
 #ifdef MORE
    static ZCONST char Far ZipInfoUsageLine4[] =
      "  -M  page output through built-in \"more\"\n";
@@ -665,6 +675,17 @@ modifiers:\n\
   -U  use escapes for all non-ASCII Unicode  -UU ignore any Unicode fields\n\
   -C  match filenames case-insensitively     -L  make (some) names \
 lowercase\n %-42s  -V  retain VMS version numbers\n%s";
+#elif (defined UNIX)
+static ZCONST char Far UnzipUsageLine4[] = "\
+modifiers:\n\
+  -n  never overwrite existing files         -q  quiet mode (-qq => quieter)\n\
+  -o  overwrite files WITHOUT prompting      -a  auto-convert any text files\n\
+  -j  junk paths (do not make directories)   -aa treat ALL files as text\n\
+  -U  use escapes for all non-ASCII Unicode  -UU ignore any Unicode fields\n\
+  -C  match filenames case-insensitively     -L  make (some) names \
+lowercase\n %-42s  -V  retain VMS version numbers\n%s\
+  -O CHARSET  specify a character encoding for DOS, Windows and OS/2 archives\n\
+  -I CHARSET  specify a character encoding for UNIX and other archives\n\n";
 #else /* !VMS */
 static ZCONST char Far UnzipUsageLine4[] = "\
 modifiers:\n\
@@ -803,6 +824,10 @@ int unzip(__G__ argc, argv)
 #endif /* UNICODE_SUPPORT */
 
 
+#ifdef UNIX
+    init_conversion_charsets();
+#endif
+
 #if (defined(__IBMC__) && defined(__DEBUG_ALLOC__))
     extern void DebugMalloc(void);
 
@@ -1336,6 +1361,11 @@ int uz_opts(__G__ pargc, pargv)
     argc = *pargc;
     argv = *pargv;
 
+#ifdef UNIX
+    extern char OEM_CP[MAX_CP_NAME];
+    extern char ISO_CP[MAX_CP_NAME];
+#endif
+    
     while (++argv, (--argc > 0 && *argv != NULL && **argv == '-')) {
         s = *argv + 1;
         while ((c = *s++) != 0) {    /* "!= 0":  prevent Turbo C warning */
@@ -1517,6 +1547,35 @@ int uz_opts(__G__ pargc, pargv)
                     }
                     break;
 #endif  /* MACOS */
+#ifdef UNIX
+    			case ('I'):
+                    if (negative) {
+                        Info(slide, 0x401, ((char *)slide,
+                          "error:  encodings can't be negated"));
+                        return(PK_PARAM);
+    				} else {
+    					if(*s) { /* Handle the -Icharset case */
+    						/* Assume that charsets can't start with a dash to spot arguments misuse */
+    						if(*s == '-') { 
+    	                        Info(slide, 0x401, ((char *)slide,
+        		                  "error:  a valid character encoding should follow the -I argument"));
+    	                        return(PK_PARAM); 
+    						}
+    						strncpy(ISO_CP, s, sizeof(ISO_CP));
+    					} else { /* -I charset */
+    						++argv;
+    						if(!(--argc > 0 && *argv != NULL && **argv != '-')) {
+    	                        Info(slide, 0x401, ((char *)slide,
+        		                  "error:  a valid character encoding should follow the -I argument"));
+    	                        return(PK_PARAM); 
+    						}
+    						s = *argv;
+    						strncpy(ISO_CP, s, sizeof(ISO_CP));
+    					}
+    					while(*(++s)); /* No params straight after charset name */
+    				}
+    				break;
+#endif /* ?UNIX */
                 case ('j'):    /* junk pathnames/directory structure */
                     if (negative)
                         uO.jflag = FALSE, negative = 0;
@@ -1592,6 +1651,35 @@ int uz_opts(__G__ pargc, pargv)
                     } else
                         ++uO.overwrite_all;
                     break;
+#ifdef UNIX
+    			case ('O'):
+                    if (negative) {
+                        Info(slide, 0x401, ((char *)slide,
+                          "error:  encodings can't be negated"));
+                        return(PK_PARAM);
+    				} else {
+    					if(*s) { /* Handle the -Ocharset case */
+    						/* Assume that charsets can't start with a dash to spot arguments misuse */
+    						if(*s == '-') { 
+    	                        Info(slide, 0x401, ((char *)slide,
+        		                  "error:  a valid character encoding should follow the -I argument"));
+    	                        return(PK_PARAM); 
+    						}
+    						strncpy(OEM_CP, s, sizeof(OEM_CP));
+    					} else { /* -O charset */
+    						++argv;
+    						if(!(--argc > 0 && *argv != NULL && **argv != '-')) {
+    	                        Info(slide, 0x401, ((char *)slide,
+        		                  "error:  a valid character encoding should follow the -O argument"));
+    	                        return(PK_PARAM); 
+    						}
+    						s = *argv;
+    						strncpy(OEM_CP, s, sizeof(OEM_CP));
+    					}
+    					while(*(++s)); /* No params straight after charset name */
+    				}
+    				break;
+#endif /* ?UNIX */
                 case ('p'):    /* pipes:  extract to stdout, no messages */
                     if (negative) {
                         uO.cflag = FALSE;


[FILE:479:files/extra-iconv-patch-unzpriv.h]
--- unzpriv.h.orig	2009-04-19 23:59:26 UTC
+++ unzpriv.h
@@ -3008,7 +3008,7 @@ char    *GetLoadPath     OF((__GPRO));  
          !(((islochdr) || (isuxatt)) && \
            ((hostver) == 25 || (hostver) == 26 || (hostver) == 40))) || \
         (hostnum) == FS_HPFS_ || \
-        ((hostnum) == FS_NTFS_ && (hostver) == 50)) { \
+        ((hostnum) == FS_NTFS_ /* && (hostver) == 50 */ )) { \
         _OEM_INTERN((string)); \
     } else { \
         _ISO_INTERN((string)); \


[FILE:3468:files/extra-iconv-patch-zipinfo.c]
--- zipinfo.c.orig	2009-02-08 17:04:30 UTC
+++ zipinfo.c
@@ -457,6 +457,10 @@ int zi_opts(__G__ pargc, pargv)
     int    tflag_slm=TRUE, tflag_2v=FALSE;
     int    explicit_h=FALSE, explicit_t=FALSE;
 
+#ifdef UNIX
+    extern char OEM_CP[MAX_CP_NAME];
+    extern char ISO_CP[MAX_CP_NAME];
+#endif
 
 #ifdef MACOS
     uO.lflag = LFLAG;         /* reset default on each call */
@@ -501,6 +505,35 @@ int zi_opts(__G__ pargc, pargv)
                             uO.lflag = 0;
                     }
                     break;
+#ifdef UNIX
+    			case ('I'):
+                    if (negative) {
+                        Info(slide, 0x401, ((char *)slide,
+                          "error:  encodings can't be negated"));
+                        return(PK_PARAM);
+    				} else {
+    					if(*s) { /* Handle the -Icharset case */
+    						/* Assume that charsets can't start with a dash to spot arguments misuse */
+    						if(*s == '-') { 
+    	                        Info(slide, 0x401, ((char *)slide,
+        		                  "error:  a valid character encoding should follow the -I argument"));
+    	                        return(PK_PARAM); 
+    						}
+    						strncpy(ISO_CP, s, sizeof(ISO_CP));
+    					} else { /* -I charset */
+    						++argv;
+    						if(!(--argc > 0 && *argv != NULL && **argv != '-')) {
+    	                        Info(slide, 0x401, ((char *)slide,
+        		                  "error:  a valid character encoding should follow the -I argument"));
+    	                        return(PK_PARAM); 
+    						}
+    						s = *argv;
+    						strncpy(ISO_CP, s, sizeof(ISO_CP));
+    					}
+    					while(*(++s)); /* No params straight after charset name */
+    				}
+    				break;
+#endif /* ?UNIX */
                 case 'l':      /* longer form of "ls -l" type listing */
                     if (negative)
                         uO.lflag = -2, negative = 0;
@@ -521,6 +554,35 @@ int zi_opts(__G__ pargc, pargv)
                         G.M_flag = TRUE;
                     break;
 #endif
+#ifdef UNIX
+    			case ('O'):
+                    if (negative) {
+                        Info(slide, 0x401, ((char *)slide,
+                          "error:  encodings can't be negated"));
+                        return(PK_PARAM);
+    				} else {
+    					if(*s) { /* Handle the -Ocharset case */
+    						/* Assume that charsets can't start with a dash to spot arguments misuse */
+    						if(*s == '-') { 
+    	                        Info(slide, 0x401, ((char *)slide,
+        		                  "error:  a valid character encoding should follow the -I argument"));
+    	                        return(PK_PARAM); 
+    						}
+    						strncpy(OEM_CP, s, sizeof(OEM_CP));
+    					} else { /* -O charset */
+    						++argv;
+    						if(!(--argc > 0 && *argv != NULL && **argv != '-')) {
+    	                        Info(slide, 0x401, ((char *)slide,
+        		                  "error:  a valid character encoding should follow the -O argument"));
+    	                        return(PK_PARAM); 
+    						}
+    						s = *argv;
+    						strncpy(OEM_CP, s, sizeof(OEM_CP));
+    					}
+    					while(*(++s)); /* No params straight after charset name */
+    				}
+    				break;
+#endif /* ?UNIX */
                 case 's':      /* default:  shorter "ls -l" type listing */
                     if (negative)
                         uO.lflag = -2, negative = 0;


[FILE:684:files/extra-ko-patch-fileio.c]
--- fileio.c.orig	2009-04-20 00:03:44 UTC
+++ fileio.c
@@ -2240,8 +2240,9 @@ int do_string(__G__ length, option)   /*
 
         /* translate the Zip entry filename coded in host-dependent "extended
            ASCII" into the compiler's (system's) internal text code page */
-        Ext_ASCII_TO_Native(G.filename, G.pInfo->hostnum, G.pInfo->hostver,
-                            G.pInfo->HasUxAtt, (option == DS_FN_L));
+	if (!uO.dotflag)
+	    Ext_ASCII_TO_Native(G.filename, G.pInfo->hostnum, G.pInfo->hostver,
+				G.pInfo->HasUxAtt, (option == DS_FN_L));
 
         if (G.pInfo->lcflag)      /* replace with lowercase filename */
             STRLOWER(G.filename, G.filename);


[FILE:1038:files/extra-ko-patch-unzip.c]
--- unzip.c.orig	2009-04-16 18:26:52 UTC
+++ unzip.c
@@ -664,7 +664,8 @@ modifiers:\n\
   -j  junk paths (do not make directories)   -aa treat ALL files as text\n\
   -U  use escapes for all non-ASCII Unicode  -UU ignore any Unicode fields\n\
   -C  match filenames case-insensitively     -L  make (some) names \
-lowercase\n %-42s  -V  retain VMS version numbers\n%s";
+lowercase\n %-42s  -V  retain VMS version numbers\n\
+                                             -.  don't translate filenames\n%s";
 #else /* !VMS */
 static ZCONST char Far UnzipUsageLine4[] = "\
 modifiers:\n\
@@ -1829,6 +1830,12 @@ int uz_opts(__G__ pargc, pargv)
                         ++uO.cflxflag;
                     break;
 #endif /* UNIX */
+                case ('.'):
+                    if (negative)
+                        uO.dotflag = FALSE, negative = 0;
+                    else
+                        uO.dotflag = TRUE;
+                    break;
                 default:
                     error = TRUE;
                     break;


[FILE:305:files/extra-ko-patch-unzip.h]
--- unzip.h.orig	2009-02-15 18:12:54 UTC
+++ unzip.h
@@ -559,6 +559,7 @@ typedef struct _UzpOpts {
 #ifdef UNIX
     int cflxflag;       /* -^: allow control chars in extracted filenames */
 #endif
+    int dotflag;	/* -.: don't translate filenames to local charset */
 #endif /* !FUNZIP */
 } UzpOpts;
 


[FILE:4614:files/extra-ru-patch-ebcdic.h]
--- ebcdic.h.orig	2008-03-21 12:04:22 UTC
+++ ebcdic.h
@@ -237,43 +237,43 @@ ZCONST uch ascii[] = {
 
 #ifdef IZ_ISO2OEM_ARRAY
 ZCONST uch Far iso2oem_850[] = {
-    0x3F, 0x3F, 0x27, 0x9F, 0x22, 0x2E, 0xC5, 0xCE,  /* 80 - 87 */
-    0x5E, 0x25, 0x53, 0x3C, 0x4F, 0x3F, 0x3F, 0x3F,  /* 88 - 8F */
-    0x3F, 0x27, 0x27, 0x22, 0x22, 0x07, 0x2D, 0x2D,  /* 90 - 97 */
-    0x7E, 0x54, 0x73, 0x3E, 0x6F, 0x3F, 0x3F, 0x59,  /* 98 - 9F */
-    0xFF, 0xAD, 0xBD, 0x9C, 0xCF, 0xBE, 0xDD, 0xF5,  /* A0 - A7 */
-    0xF9, 0xB8, 0xA6, 0xAE, 0xAA, 0xF0, 0xA9, 0xEE,  /* A8 - AF */
-    0xF8, 0xF1, 0xFD, 0xFC, 0xEF, 0xE6, 0xF4, 0xFA,  /* B0 - B7 */
-    0xF7, 0xFB, 0xA7, 0xAF, 0xAC, 0xAB, 0xF3, 0xA8,  /* B8 - BF */
-    0xB7, 0xB5, 0xB6, 0xC7, 0x8E, 0x8F, 0x92, 0x80,  /* C0 - C7 */
-    0xD4, 0x90, 0xD2, 0xD3, 0xDE, 0xD6, 0xD7, 0xD8,  /* C8 - CF */
-    0xD1, 0xA5, 0xE3, 0xE0, 0xE2, 0xE5, 0x99, 0x9E,  /* D0 - D7 */
-    0x9D, 0xEB, 0xE9, 0xEA, 0x9A, 0xED, 0xE8, 0xE1,  /* D8 - DF */
-    0x85, 0xA0, 0x83, 0xC6, 0x84, 0x86, 0x91, 0x87,  /* E0 - E7 */
-    0x8A, 0x82, 0x88, 0x89, 0x8D, 0xA1, 0x8C, 0x8B,  /* E8 - EF */
-    0xD0, 0xA4, 0x95, 0xA2, 0x93, 0xE4, 0x94, 0xF6,  /* F0 - F7 */
-    0x9B, 0x97, 0xA3, 0x96, 0x81, 0xEC, 0xE7, 0x98   /* F8 - FF */
+   0xC4, 0xB3, 0xDA, 0xBF, 0xC0, 0xD9, 0xC3, 0xB4,  /* 80 - 87 */
+   0xC2, 0xC1, 0xC5, 0xDF, 0xDC, 0xDB, 0xDD, 0xDE,  /* 88 - 8F */
+   0xB0, 0xB1, 0xB2, 0x40, 0xFE, 0xF9, 0xFB, 0x40,  /* 90 - 97 */
+   0x66, 0x02, 0xFF, 0x0D, 0xF8, 0x02, 0xFA, 0x0D,  /* 98 - 9F */
+   0xCD, 0xBA, 0xD5, 0xF1, 0xD6, 0xC9, 0xB8, 0xB7,  /* A0 - A7 */
+   0xBB, 0xD4, 0xD3, 0xC8, 0xBE, 0xBD, 0xBC, 0xC6,  /* A8 - AF */
+   0xC7, 0xCC, 0xB5, 0xF0, 0xB6, 0xB9, 0xD1, 0xD2,  /* B0 - B7 */
+   0xCB, 0xCF, 0xD0, 0xCA, 0xD8, 0xD7, 0xCE, 0xBF,  /* B8 - BF */
+   0xEE, 0xA0, 0xA1, 0xE6, 0xA4, 0xA5, 0xE4, 0xA3,  /* C0 - C7 */
+   0xE5, 0xA8, 0xA9, 0xAA, 0xAB, 0xAC, 0xAD, 0xAE,  /* C8 - CF */
+   0xAF, 0xEF, 0xE0, 0xE1, 0xE2, 0xE3, 0xA6, 0xA2,  /* D0 - D7 */
+   0xEC, 0xEB, 0xA7, 0xE8, 0xED, 0xE9, 0xE7, 0xEA,  /* D8 - DF */
+   0x9E, 0x80, 0x81, 0x96, 0x84, 0x85, 0x94, 0x83,  /* E0 - E7 */
+   0x95, 0x88, 0x89, 0x8A, 0x8B, 0x8C, 0x8D, 0x8E,  /* E8 - EF */
+   0x8F, 0x9F, 0x90, 0x91, 0x92, 0x93, 0x86, 0x82,  /* F0 - F7 */
+   0x9C, 0x9B, 0x87, 0x98, 0x9D, 0x99, 0x97, 0x9A,  /* F8 - FF */
 };
 #endif /* IZ_ISO2OEM_ARRAY */
 
 #ifdef IZ_OEM2ISO_ARRAY
 ZCONST uch Far oem2iso_850[] = {
-    0xC7, 0xFC, 0xE9, 0xE2, 0xE4, 0xE0, 0xE5, 0xE7,  /* 80 - 87 */
-    0xEA, 0xEB, 0xE8, 0xEF, 0xEE, 0xEC, 0xC4, 0xC5,  /* 88 - 8F */
-    0xC9, 0xE6, 0xC6, 0xF4, 0xF6, 0xF2, 0xFB, 0xF9,  /* 90 - 97 */
-    0xFF, 0xD6, 0xDC, 0xF8, 0xA3, 0xD8, 0xD7, 0x83,  /* 98 - 9F */
-    0xE1, 0xED, 0xF3, 0xFA, 0xF1, 0xD1, 0xAA, 0xBA,  /* A0 - A7 */
-    0xBF, 0xAE, 0xAC, 0xBD, 0xBC, 0xA1, 0xAB, 0xBB,  /* A8 - AF */
-    0xA6, 0xA6, 0xA6, 0xA6, 0xA6, 0xC1, 0xC2, 0xC0,  /* B0 - B7 */
-    0xA9, 0xA6, 0xA6, 0x2B, 0x2B, 0xA2, 0xA5, 0x2B,  /* B8 - BF */
-    0x2B, 0x2D, 0x2D, 0x2B, 0x2D, 0x2B, 0xE3, 0xC3,  /* C0 - C7 */
-    0x2B, 0x2B, 0x2D, 0x2D, 0xA6, 0x2D, 0x2B, 0xA4,  /* C8 - CF */
-    0xF0, 0xD0, 0xCA, 0xCB, 0xC8, 0x69, 0xCD, 0xCE,  /* D0 - D7 */
-    0xCF, 0x2B, 0x2B, 0xA6, 0x5F, 0xA6, 0xCC, 0xAF,  /* D8 - DF */
-    0xD3, 0xDF, 0xD4, 0xD2, 0xF5, 0xD5, 0xB5, 0xFE,  /* E0 - E7 */
-    0xDE, 0xDA, 0xDB, 0xD9, 0xFD, 0xDD, 0xAF, 0xB4,  /* E8 - EF */
-    0xAD, 0xB1, 0x3D, 0xBE, 0xB6, 0xA7, 0xF7, 0xB8,  /* F0 - F7 */
-    0xB0, 0xA8, 0xB7, 0xB9, 0xB3, 0xB2, 0xA6, 0xA0   /* F8 - FF */
+   0xE1, 0xE2, 0xF7, 0xE7, 0xE4, 0xE5, 0xF6, 0xFA,  /* 80 - 87 */
+   0xE9, 0xEA, 0xEB, 0xEC, 0xED, 0xEE, 0xEF, 0xF0,  /* 88 - 8F */
+   0xF2, 0xF3, 0xF4, 0xF5, 0xE6, 0xE8, 0xE3, 0xFE,  /* 90 - 97 */
+   0xFB, 0xFD, 0xFF, 0xF9, 0xF8, 0xFC, 0xE0, 0xF1,  /* 98 - 9F */
+   0xC1, 0xC2, 0xD7, 0xC7, 0xC4, 0xC5, 0xD6, 0xDA,  /* A0 - A7 */
+   0xC9, 0xCA, 0xCB, 0xCC, 0xCD, 0xCE, 0xCF, 0xD0,  /* A8 - AF */
+   0x90, 0x91, 0x92, 0x81, 0x87, 0xB2, 0xB4, 0xA7,  /* B0 - B7 */
+   0xA6, 0xB5, 0xA1, 0xA8, 0xAE, 0xAD, 0xAC, 0x83,  /* B8 - BF */
+   0x84, 0x89, 0x88, 0x86, 0x80, 0x8A, 0xAF, 0xB0,  /* C0 - C7 */
+   0xAB, 0xA5, 0xBB, 0xB8, 0xB1, 0xA0, 0xBE, 0xB9,  /* C8 - CF */
+   0xBA, 0xB6, 0xB7, 0xAA, 0xA9, 0xA2, 0xA4, 0xBD,  /* D0 - D7 */
+   0xBC, 0x85, 0x82, 0x8D, 0x8C, 0x8E, 0x8F, 0x8B,  /* D8 - DF */
+   0xD2, 0xD3, 0xD4, 0xD5, 0xC6, 0xC8, 0xC3, 0xDE,  /* E0 - E7 */
+   0xDB, 0xDD, 0xDF, 0xD9, 0xD8, 0xDC, 0xC0, 0xD1,  /* E8 - EF */
+   0xB3, 0xA3, 0x90, 0x91, 0x92, 0x93, 0x86, 0x82,  /* F0 - F7 */
+   0x9C, 0x95, 0x9E, 0x96, 0x9D, 0x99, 0x94, 0x9A,  /* F8 - FF */
 };
 #endif /* IZ_OEM2ISO_ARRAY */
 


[FILE:604:files/extra-zh-patch-fileio.c]
--- fileio.c.orig	2009-04-20 00:03:44 UTC
+++ fileio.c
@@ -2240,8 +2240,11 @@ int do_string(__G__ length, option)   /*
 
         /* translate the Zip entry filename coded in host-dependent "extended
            ASCII" into the compiler's (system's) internal text code page */
+#if 0
+/* cnoize is lazy to read it carefully */
         Ext_ASCII_TO_Native(G.filename, G.pInfo->hostnum, G.pInfo->hostver,
                             G.pInfo->HasUxAtt, (option == DS_FN_L));
+#endif
 
         if (G.pInfo->lcflag)      /* replace with lowercase filename */
             STRLOWER(G.filename, G.filename);

