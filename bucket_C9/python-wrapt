# Buildsheet autogenerated by ravenadm tool -- Do not edit.

NAMEBASE=		python-wrapt
VERSION=		2.1.1
KEYWORDS=		python
VARIANTS=		v13 v14
SDESC[v13]=		Decorators, wrappers and monkey patching (3.13)
SDESC[v14]=		Decorators, wrappers and monkey patching (3.14)
HOMEPAGE=		https://github.com/GrahamDumpleton/wrapt
CONTACT=		Python_Automaton[python@ironwolf.systems]

DOWNLOAD_GROUPS=	main
SITES[main]=		PYPIWHL/c4/da/5a086bf4c22a41995312db104ec2ffeee2cf6accca9faaee5315c790377d
DISTFILE[1]=		wrapt-2.1.1-py3-none-any.whl:main
DIST_SUBDIR=		python-src
DF_INDEX=		1
SPKGS[v13]=		single
SPKGS[v14]=		single

OPTIONS_AVAILABLE=	PY313 PY314
OPTIONS_STANDARD=	none
VOPTS[v13]=		PY313=ON PY314=OFF
VOPTS[v14]=		PY313=OFF PY314=ON

DISTNAME=		wrapt-2.1.1.dist-info

GENERATED=		yes

[PY313].USES_ON=			python:v13,wheel

[PY314].USES_ON=			python:v14,wheel

[FILE:2631:descriptions/desc.single]
wrapt
=====

|PyPI| |Documentation|

A Python module for decorators, wrappers and monkey patching.

Overview
--------

The **wrapt** module provides a transparent object proxy for Python, which
can be used as the basis for the construction of function wrappers and
decorator functions.

The **wrapt** module focuses very much on correctness. It goes way beyond
existing mechanisms such as ``functools.wraps()`` to ensure that decorators
preserve introspectability, signatures, type checking abilities etc. The
decorators that can be constructed using this module will work in far more
scenarios than typical decorators and provide more predictable and
consistent behaviour.

To ensure that the overhead is as minimal as possible, a C extension module
is used for performance critical components. An automatic fallback to a
pure Python implementation is also provided where a target system does not
have a compiler to allow the C extension to be compiled.

Key Features
------------

* **Universal decorators** that work with functions, methods, classmethods,
staticmethods, and classes
* **Transparent object proxies** for advanced wrapping scenarios  
* **Monkey patching utilities** for safe runtime modifications
* **C extension** for optimal performance with Python fallback
* **Comprehensive introspection preservation** (signatures, annotations,
etc.)
* **Thread-safe decorator implementations**

Installation
------------

Install from PyPI using pip::

    pip install wrapt

Supported Python Versions
--------------------------

* Python 3.9+
* CPython and PyPy implementations

Documentation
-------------

For comprehensive documentation, examples, and advanced usage patterns,
visit:

* https://wrapt.readthedocs.io/

Quick Start
-----------

To implement your decorator you need to first define a wrapper function.
This will be called each time a decorated function is called. The wrapper
function needs to take four positional arguments:

* wrapped - The wrapped function which in turns needs to be called by your
wrapper function.
* instance - The object to which the wrapped function was bound when it was
called.
* args - The list of positional arguments supplied when the decorated
function was called.
* kwargs - The dictionary of keyword arguments supplied when the decorated
function was called.

The wrapper function would do whatever it needs to, but would usually in
turn call the wrapped function that is passed in via the wrapped
argument.

The decorator ``@wrapt.decorator`` then needs to be applied to the wrapper
function to convert it into a decorator which can in turn be applied to
other functions.


[FILE:118:distinfo]
3b0f4629eb954394a3d7c7a1c8cca25f0b07cefe6aa8545e862e9778152de5b7        43886 python-src/wrapt-2.1.1-py3-none-any.whl

