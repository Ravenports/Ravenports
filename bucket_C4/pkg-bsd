# Buildsheet autogenerated by ravenadm tool -- Do not edit.

NAMEBASE=		pkg-bsd
VERSION=		1.10.1
REVISION=		6
KEYWORDS=		raven
VARIANTS=		standard
SDESC[standard]=	BSD binary package manager
HOMEPAGE=		https://github.com/freebsd/pkg/blob/master/README.md
CONTACT=		nobody

DOWNLOAD_GROUPS=	main
SITES[main]=		http://files.etoilebsd.net/pkg/
			http://mirror.shatow.net/freebsd/pkg/
DISTFILE[1]=		pkg-1.10.1.tar.xz:main
DF_INDEX=		1
SPKGS[standard]=	complete
			shared
			static

OPTIONS_AVAILABLE=	none
OPTIONS_STANDARD=	none

BUILD_DEPENDS=		libarchive-devel:static:standard
			zlib:static:standard
			bzip2:static:standard
BUILDRUN_DEPENDS=	libarchive-devel:shared:standard
BR_DEPS[linux]=		libbsd:single:standard

USES=			libtool

DISTNAME=		pkg-1.10.1

LICENSE=		BSD2CLAUSE:shared
LICENSE_SCHEME=		solo
LICENSE_FILE=		BSD2CLAUSE:{{WRKSRC}}/COPYING

FPC_EQUIVALENT=		ports-mgmt/pkg

MUST_CONFIGURE=		gnu
CONFIGURE_ARGS=		--disable-maintainer-mode
			--mandir={{MANPREFIX}}/man
CONFIGURE_ENV=		LIBS="-lpthread -lzstd"

SINGLE_JOB=		yes

INSTALL_TARGET=		install-strip

CFLAGS=			-Wno-error

post-patch:
	${REINPLACE_CMD} -e '/mandir = / s|/man|/share/man|' \
		${WRKSRC}/docs/Makefile.in
	${REINPLACE_CMD}\
		-e '/libpkg_static_la_CFLAGS =/ s/$$/ -DSKIP_PLUGINS/' \
		-e 's/larchive/larchive-devel -lzstd/' \
		${WRKSRC}/libpkg/Makefile.in
	${REINPLACE_CMD} -e 's/larchive/larchive-devel -lzstd/' \
		${WRKSRC}/src/Makefile.in
	${REINPLACE_CMD} -e "s/' archive/' archive-devel/" \
		${WRKSRC}/configure

post-patch-linux:
	${REINPLACE_CMD} -e '/libpkg_la_LDFLAGS =/ s/= /= -ldl /' \
		${WRKSRC}/libpkg/Makefile.in
	${REINPLACE_CMD} -e '/OS_STATIC/ s/false/true/' \
		-e '/OS_LIBS=/ s/-ldl //' \
		${WRKSRC}/configure

post-install:
	${RM} ${STAGEDIR}${PREFIX}/sbin/pkg2ng
	${MV} ${STAGEDIR}${PREFIX}/lib/libpkg_static.a \
		${STAGEDIR}${PREFIX}/lib/libpkg.a
	${INSTALL_SCRIPT} ${WRKSRC}/scripts/periodic/411.pkg-backup \
		${WRKSRC}/scripts/periodic/490.status-pkg-changes \
		${STAGEDIR}${PREFIX}/etc/periodic/daily/
	${INSTALL_SCRIPT} ${WRKSRC}/scripts/periodic/460.pkg-checksum \
		${WRKSRC}/scripts/periodic/410.pkg-audit \
		${STAGEDIR}${PREFIX}/etc/periodic/security/
	${INSTALL_SCRIPT} ${WRKSRC}/scripts/periodic/400.status-pkg \
		${STAGEDIR}${PREFIX}/etc/periodic/weekly/
	${MKDIR} ${STAGEDIR}${PREFIX}/etc/pkg/repos

post-patch-freebsd:
	${REINPLACE_CMD} -e '/#include <sys\/elf_common.h>/d' \
		${WRKSRC}/libpkg/pkg_elf.c

[FILE:290:descriptions/desc.shared]
The pkg program is the package management tool used natively on FreeBSD and
DragonFly, and has also been successfully demonstrated on NetBSD, OpenBSD
and Darwin.

It is one of the package managers available for the manipulation of both
locally-built and remotely available binary packages.


[FILE:362:descriptions/desc.static]
The pkg program is the package management tool used natively on FreeBSD and
DragonFly, and has also been successfully demonstrated on NetBSD, OpenBSD
and Darwin.

It is one of the package managers available for the manipulation of both
locally-built and remotely available binary packages.

This package contains just the statically-linked version (pkg-static).


[FILE:96:distinfo]
6cf178ce356588cddcba60a2c53ef18f5aac2c87628e3d3924a54743573aee4d      2169816 pkg-1.10.1.tar.xz


[FILE:1058:manifests/plist.shared]
etc/bash_completion.d/_pkg.bash
etc/periodic/daily/
 411.pkg-backup
 490.status-pkg-changes
etc/periodic/security/
 410.pkg-audit
 460.pkg-checksum
etc/periodic/weekly/400.status-pkg
@sample etc/pkg.conf.sample
include/pkg.h
lib/
 libpkg.a
 libpkg.so
 libpkg.so.4
 libpkg.so.4.0.0
libdata/pkgconfig/pkg.pc
share/man/man3/
 pkg_printf.3.gz
 pkg_repos.3.gz
share/man/man5/
 pkg-repository.5.gz
 pkg.conf.5.gz
share/man/man8/
 pkg-add.8.gz
 pkg-alias.8.gz
 pkg-annotate.8.gz
 pkg-audit.8.gz
 pkg-autoremove.8.gz
 pkg-backup.8.gz
 pkg-check.8.gz
 pkg-clean.8.gz
 pkg-config.8.gz
 pkg-convert.8.gz
 pkg-create.8.gz
 pkg-delete.8.gz
 pkg-fetch.8.gz
 pkg-info.8.gz
 pkg-install.8.gz
 pkg-lock.8.gz
 pkg-query.8.gz
 pkg-register.8.gz
 pkg-remove.8.gz
 pkg-repo.8.gz
 pkg-rquery.8.gz
 pkg-search.8.gz
 pkg-set.8.gz
 pkg-shell.8.gz
 pkg-shlib.8.gz
 pkg-ssh.8.gz
 pkg-static.8.gz
 pkg-stats.8.gz
 pkg-unlock.8.gz
 pkg-update.8.gz
 pkg-updating.8.gz
 pkg-upgrade.8.gz
 pkg-version.8.gz
 pkg-which.8.gz
 pkg.8.gz
sbin/pkg
share/zsh/site-functions/_pkg
@dir etc/pkg/repos


[FILE:16:manifests/plist.static]
sbin/pkg-static


[FILE:1473:patches/patch-163d922]
From 163d922772bed016de01570c71e4902ee5f75e41 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Fran=C3=A7ois=20Tigeot?= <ftigeot@wolfpond.org>
Date: Fri, 26 May 2017 10:22:11 +0200
Subject: [PATCH] pkg_elf.c: Only FreeBSD uses FreeBSD binaries

* Only compile a check preventing non-FreeBSD binaries from being
  recognized as valid shared libraries on FreeBSD systems

* This code was preventing shlibs_provided and shlibs_required entries
  from being put in newly created packages on non-FreeBSD systems

* This commit should fix issue #1578
---
 libpkg/pkg_elf.c | 4 ++++
 1 file changed, 4 insertions(+)

diff --git libpkg/pkg_elf.c b/libpkg/pkg_elf.c
index 4cda48801..c3aca4e1f 100644
--- libpkg/pkg_elf.c
+++ libpkg/pkg_elf.c
@@ -216,6 +216,7 @@ shlib_valid_abi(const char *fpath, GElf_Ehdr *hdr, const char *abi)
 	return (true);
 }
 
+#ifdef __FreeBSD__
 static bool
 is_old_freebsd_armheader(const GElf_Ehdr *e)
 {
@@ -234,6 +235,7 @@ is_old_freebsd_armheader(const GElf_Ehdr *e)
 	}
 	return (false);
 }
+#endif
 
 static int
 analyse_elf(struct pkg *pkg, const char *fpath)
@@ -347,11 +349,13 @@ analyse_elf(struct pkg *pkg, const char *fpath)
 		goto cleanup; /* Invalid ABI */
 	}
 
+#ifdef __FreeBSD__
 	if (elfhdr.e_ident[EI_OSABI] != ELFOSABI_FREEBSD &&
 	    !is_old_freebsd_armheader(&elfhdr)) {
 		ret = EPKG_END;
 		goto cleanup;
 	}
+#endif
 
 	if ((data = elf_getdata(dynamic, NULL)) == NULL) {
 		ret = EPKG_END; /* Some error occurred, ignore this file */


[FILE:3078:patches/patch-7eaa671]
From 7eaa671e88a0636eacffb60db2944a75e3532284 Mon Sep 17 00:00:00 2001
From: jrmarino <draco@marino.st>
Date: Wed, 17 May 2017 22:23:51 -0500
Subject: [PATCH] Another follow-up for issue #1431

The initial problem started with commit 4d53b1 which added the
AT_SYMLINK_NOFOLLOW flag to fchmodat function.  On Linux, the flag is
recognized but not implemented.  Setting the flag on Linux causes
ENOTSUP to return in every case, which issue #1431 reported.

The solution to add a second "fallback" attempt by calling fchmodat was
accepted, but I think it was not tested on a port that contained
symbolic links in the packing list.  It doesn't work for symbolic links.
fchmodat will follow the link and fail with ENOENT (file not found).
From my limited research, it's not possible to change file modes on
symbolic links on Linux -- not until AT_SYMLINK_NOFOLLOW is implemented.
Note that lchmod is not an option because it has not been implemented
on Linux, nor is it part of the POSIX standard.

Thus this modification which is only seen by platforms that don't
support AT_SYMLINK_NOFOLLOW (which excludes FreeBSD, DragonFly and
NetBSD but includes Linux) now skips symbolic links as the attempt to
change file mode is impossible and fatal.  This is okay because the
permissions of symlinks have never been evaluated; they are taken from
the target of the link.  Thus changing permissions of symlinks is
cosmetic and the impact of not modifying them is nil in all cases.
---
 libpkg/pkg_add.c | 22 +++++++++++++++++++---
 1 file changed, 19 insertions(+), 3 deletions(-)

diff --git libpkg/pkg_add.c b/libpkg/pkg_add.c
index 7c8f9b2fe..a2cb5733f 100644
--- libpkg/pkg_add.c
+++ libpkg/pkg_add.c
@@ -228,6 +228,7 @@ set_attrs(int fd, char *path, mode_t perm, uid_t uid, gid_t gid,
 {
 
 	struct timeval tv[2];
+	struct stat st;
 	int fdcwd;
 #ifdef HAVE_UTIMENSAT
 	struct timespec times[2];
@@ -285,9 +286,24 @@ set_attrs(int fd, char *path, mode_t perm, uid_t uid, gid_t gid,
 	/* zfs drops the setuid on fchownat */
 	if (fchmodat(fd, RELATIVE_PATH(path), perm, AT_SYMLINK_NOFOLLOW) == -1) {
 		if (errno == ENOTSUP) {
-			if (fchmodat(fd, RELATIVE_PATH(path), perm, 0) == -1) {
-				pkg_fatal_errno("Fail to chmod(fallback) %s",
-				    path);
+			/* 
+			 * Executing fchmodat on a symbolic link results in
+			 * ENOENT (file not found) on platforms that do not
+			 * support AT_SYMLINK_NOFOLLOW. The file mode of
+			 * symlinks cannot be modified via file descriptor
+			 * reference on these systems. The lchmod function is
+			 * also not an option because it is not a posix
+			 * standard, nor is implemented everywhere. Since
+			 * symlink permissions have never been evaluated and
+			 * thus cosmetic, just skip them on these systems.
+			 */
+			if (fstatat(fd, RELATIVE_PATH(path), &st, AT_SYMLINK_NOFOLLOW) == -1) {
+				pkg_fatal_errno("Fail to get file status %s", path);
+			}
+			if (!S_ISLNK(st.st_mode)) {
+				if (fchmodat(fd, RELATIVE_PATH(path), perm, 0) == -1) {
+					pkg_fatal_errno("Fail to chmod(fallback) %s", path);
+				}
 			}
 		}
 		else {


[FILE:6089:patches/patch-b7d9905]
From b7d990572ae72577abc6760800f4b10744756179 Mon Sep 17 00:00:00 2001
From: jrmarino <draco@marino.st>
Date: Fri, 26 May 2017 14:10:40 -0500
Subject: [PATCH] Fix ELF note parsing and recognize NT_GNU_ABI_TAG

The logic on the ELF note parsing was incorrect.  It happens to work
on *BSD, but the issue shows on other platforms (e.g. Linux ABI gets
set to "GNU:0").

The first mistake is assuming the note always has a namespace and that
this namespace equals the standard name of the operating system.  In
fact, having a namespace is not even required as there are default
definitions for tags: NT_VERSION (=1) and NT_ARCH (=2).

The BSDs (at least FreeBSD, DragonFly, and NetBSD) define their
own namespace (aka "Owner" on readelf" and the NT_VERSION tag, which
is a single word.  Pkg currently assumes the namespace is equal to
the osname and assumes there's a NT_VERSION note defined.  For
correctness, pkg must check that the namespace length is either zero
or equal to an operating system name before assume a n_type value of
1 is equivalent to an NT_VERSION note.

A very popular namespace is "GNU".  The tag values of "GNU" overlap
with with all other namespaces; for example NT_GNU_ABI_TAG is
value 1 (same as NT_VERSION) and  NT_GNU_ABI_TAG is value 2 (same as
the default NT_ARCH).  Thus the namespace has to be checked when
examining n_type of ELF notes.

The second issue is a lack of support for NT_GNU_ABI_TAG.  Linux
does not use NT_VERSION note, the only one pkg supports.  The ELF
note parsing code then mistakenly converts the note namespace "GNU"
into the osname, thus resulting in "GNU:0:..." ABI for Linux.

This code implements NT_GNU_ABI_TAG along side NT_VERSION.  As a
result, this is the output on x86_64 Linux:

ABI = "Linux:2.6.32:amd64";
ALTABI = "linux:2.6.32:x86:64";

This is the correct value in the case of Linux.  The glibc was
compiled with Linux kernel headers from version 2.6.32 and all
later kernels should be binary-compatible with it.

It has been verified that FreeBSD and DragonFly still function as
before with this patch.
---
 libpkg/pkg_elf.c            | 70 +++++++++++++++++++++++++++++++++++++++------
 libpkg/private/elf_tables.h |  1 +
 2 files changed, 63 insertions(+), 8 deletions(-)

diff --git libpkg/pkg_elf.c libpkg/pkg_elf.c
index c3aca4e1f..707a4e0a4 100644
--- libpkg/pkg_elf.c
+++ libpkg/pkg_elf.c
@@ -710,12 +710,17 @@ pkg_get_myarch_elfparse(char *dest, size_t sz)
 	Elf_Note note;
 	Elf_Scn *scn = NULL;
 	int fd;
+	int version_style = 1;
 	char *src = NULL;
 	char *osname;
 	uint32_t version = 0;
 	int ret = EPKG_OK;
 	const char *arch, *abi, *endian_corres_str, *wordsize_corres_str, *fpu;
 	const char *path;
+	char invalid_osname[] = "Unknown";
+	char *note_os[6] = {"Linux", "GNU", "Solaris", "FreeBSD", "NetBSD", "Syllable"};
+	char *(*pnote_os)[6] = &note_os;
+	uint32_t gnu_abi_tag[4];
 
 	path = getenv("ABI_FILE");
 	if (path == NULL)
@@ -768,8 +773,21 @@ pkg_get_myarch_elfparse(char *dest, size_t sz)
 	while ((uintptr_t)src < ((uintptr_t)data->d_buf + data->d_size)) {
 		memcpy(&note, src, sizeof(Elf_Note));
 		src += sizeof(Elf_Note);
-		if (note.n_type == NT_VERSION)
-			break;
+		if ((strncmp ((const char *) src, "FreeBSD", note.n_namesz) == 0) ||
+		    (strncmp ((const char *) src, "DragonFly", note.n_namesz) == 0) ||
+ 		    (strncmp ((const char *) src, "NetBSD", note.n_namesz) == 0) ||
+		    (note.n_namesz == 0)) {
+			if (note.n_type == NT_VERSION) {
+				version_style = 1;
+				break;
+			}
+		}
+		if (strncmp ((const char *) src, "GNU", note.n_namesz) == 0) {
+			if (note.n_type == NT_GNU_ABI_TAG) {
+				version_style = 2;
+				break;
+			}
+		}
 		src += roundup2(note.n_namesz + note.n_descsz, 4);
 	}
 	if ((uintptr_t)src >= ((uintptr_t)data->d_buf + data->d_size)) {
@@ -777,17 +795,52 @@ pkg_get_myarch_elfparse(char *dest, size_t sz)
 		pkg_emit_error("failed to find the version elf note");
 		goto cleanup;
 	}
-	osname = src;
-	src += roundup2(note.n_namesz, 4);
-	if (elfhdr.e_ident[EI_DATA] == ELFDATA2MSB)
-		version = be32dec(src);
-	else
-		version = le32dec(src);
+	if (version_style == 2) {
+		/*
+		 * NT_GNU_ABI_TAG
+		 * Operating system (OS) ABI information.  The
+		 * desc field contains 4 words:
+		 * word 0: OS descriptor (ELF_NOTE_OS_LINUX, ELF_NOTE_OS_GNU, etc)
+		 * word 1: major version of the ABI
+		 * word 2: minor version of the ABI
+		 * word 3: subminor version of the ABI
+		 */
+		src += roundup2(note.n_namesz, 4);
+		if (elfhdr.e_ident[EI_DATA] == ELFDATA2MSB) {
+			for (int wdndx = 0; wdndx < 4; wdndx++) {
+				gnu_abi_tag[wdndx] = be32dec(src);
+				src += 4;
+			}
+		} else {
+			for (int wdndx = 0; wdndx < 4; wdndx++) {
+				gnu_abi_tag[wdndx] = le32dec(src);
+				src += 4;
+			}
+		}
+		if (gnu_abi_tag[0] < 6)
+			osname = (*pnote_os)[gnu_abi_tag[0]];
+		else
+			osname = invalid_osname;
+	} else {
+		if (note.n_namesz == 0)
+			osname = invalid_osname;
+		else
+			osname = src;
+		src += roundup2(note.n_namesz, 4);
+		if (elfhdr.e_ident[EI_DATA] == ELFDATA2MSB)
+			version = be32dec(src);
+		else
+			version = le32dec(src);
+	}
 
 	wordsize_corres_str = elf_corres_to_string(wordsize_corres,
 	    (int)elfhdr.e_ident[EI_CLASS]);
 
 	arch = elf_corres_to_string(mach_corres, (int) elfhdr.e_machine);
+if (version_style == 2) {
+	snprintf(dest, sz, "%s:%d.%d.%d", osname, gnu_abi_tag[1],
+		 gnu_abi_tag[2], gnu_abi_tag[3]);
+} else {
 #if defined(__DragonFly__)
 	snprintf(dest, sz, "%s:%d.%d",
 	    osname, version / 100000, (((version / 100 % 1000)+1)/2)*2);
@@ -796,6 +849,7 @@ pkg_get_myarch_elfparse(char *dest, size_t sz)
 #else
 	snprintf(dest, sz, "%s:%d", osname, version / 100000);
 #endif
+}
 
 	switch (elfhdr.e_machine) {
 	case EM_ARM:
diff --git libpkg/private/elf_tables.h libpkg/private/elf_tables.h
index 7ff4c7e9c..98210d5bd 100644
--- libpkg/private/elf_tables.h
+++ libpkg/private/elf_tables.h
@@ -73,6 +73,7 @@ static const struct _elf_corres os_corres[] = {
 
 #define NT_VERSION	1
 #define NT_ARCH	2
+#define NT_GNU_ABI_TAG	1
 
 /* All possibilities on FreeBSD as of 5/26/2014 */
 struct arch_trans {


[FILE:1551:patches/patch-c05884d]
From c05884d9fd45e06aa5305eb1ffb7ad074e36228e Mon Sep 17 00:00:00 2001
From: jrmarino <draco@marino.st>
Date: Wed, 17 May 2017 10:41:22 -0500
Subject: [PATCH] Fix drop_privileges() on Linux

As setuid will set the effective user ID as well as the real user ID, it
is redundant to have to calls to set these IDs.  In the case of Linux,
it is illegal.  Once the effective ID is changed from "root" to
"nobody", pkg(8) no longer has the privilege to run setuid, resulting in
an "Operation not permitted" error when "sudo pkg" is executed.

Similarly, setegid is unnecessary when followed by setgid, but that is
legal.  Remove both redundant steps to fix operation on the Linux
platform and fix a spelling error while here.
---
 src/utils.c | 7 ++-----
 1 file changed, 2 insertions(+), 5 deletions(-)

diff --git src/utils.c b/src/utils.c
index 6e7cb0460..ab4780690 100644
--- src/utils.c
+++ src/utils.c
@@ -1027,14 +1027,11 @@ drop_privileges(void)
 	if (geteuid() == 0) {
 		nobody = getpwnam("nobody");
 		if (nobody == NULL)
-			err(EXIT_FAILURE, "Unable to drop priviledges");
+			err(EXIT_FAILURE, "Unable to drop privileges");
 		setgroups(1, &nobody->pw_gid);
-		if (setegid(nobody->pw_gid) == -1)
-			err(EXIT_FAILURE, "Unable to setegid");
+		/* setgid also sets egid and setuid also sets euid */
 		if (setgid(nobody->pw_gid) == -1)
 			err(EXIT_FAILURE, "Unable to setgid");
-		if (seteuid(nobody->pw_uid) == -1)
-			err(EXIT_FAILURE, "Unable to seteuid");
 		if (setuid(nobody->pw_uid) == -1)
 			err(EXIT_FAILURE, "Unable to setuid");
 	}


[FILE:326:patches/patch-compat_bsd__compat.h]
--- compat/bsd_compat.h.orig	2017-05-16 10:02:56.425060136 -0500
+++ compat/bsd_compat.h	2017-05-16 10:11:34.539069691 -0500
@@ -37,6 +37,10 @@
  #endif
 #endif
 
+#ifndef	__DECONST
+#define	__DECONST(type, var)	((type)(uintptr_t)(const void *)(var))
+#endif
+
 #ifdef HAVE_BSD_SYS_CDEFS_H
 #include <bsd/sys/cdefs.h>
 #endif


[FILE:436:patches/patch-libpkg_pkg__config.c]
--- libpkg/pkg_config.c.orig	2017-03-09 12:57:56 UTC
+++ libpkg/pkg_config.c
@@ -497,6 +497,9 @@ pkg_config_dump(void)
 static void
 disable_plugins_if_static(void)
 {
+#ifdef SKIP_PLUGINS
+	ucl_object_replace_key(config, ucl_object_frombool(false), "PKG_ENABLE_PLUGINS", 18, false);
+#else
 	void *dlh;
 
 	dlh = dlopen(0, RTLD_NOW);
@@ -507,6 +510,7 @@ disable_plugins_if_static(void)
 	else
 		dlclose(dlh);
 
+#endif
 	return;
 }
 


[FILE:942:patches/patch-libpkg_plugins.c]
--- libpkg/plugins.c.orig	2017-03-09 12:57:56 UTC
+++ libpkg/plugins.c
@@ -70,7 +70,11 @@ static int pkg_plugin_hook_exec(struct p
 void *
 pkg_plugin_func(struct pkg_plugin *p, const char *func)
 {
+#ifdef SKIP_PLUGINS
+	return NULL;
+#else
 	return (dlsym(p->lh, func));
+#endif
 }
 
 static int
@@ -265,6 +269,7 @@ pkg_plugins(struct pkg_plugin **plugin)
 int
 pkg_plugins_init(void)
 {
+#ifndef SKIP_PLUGINS
 	struct pkg_plugin *p = NULL;
 	char pluginfile[MAXPATHLEN];
 	const ucl_object_t *obj, *cur;
@@ -315,6 +320,7 @@ pkg_plugins_init(void)
 			free(p);
 		}
 	}
+#endif
 
 	return (EPKG_OK);
 }
@@ -377,6 +383,7 @@ pkg_plugin_parse(struct pkg_plugin *p)
 void
 pkg_plugins_shutdown(void)
 {
+#ifndef SKIP_PLUGINS
 	struct pkg_plugin *p = NULL;
 	int (*shutdown_func)(struct pkg_plugin *p);
 
@@ -394,6 +401,7 @@ pkg_plugins_shutdown(void)
 	 * Deallocate memory used by the plugins
 	 */
 	pkg_plugin_free();
+#endif
 
 	return;
 }


[FILE:8022:patches/patch-use-zstd-format]
Note: These packages were generated on master and have been modified
to apply to release 10.1.

From 695f07277e132e73db985352e2d2e759344c6923 Mon Sep 17 00:00:00 2001
From: jrmarino <draco@marino.st>
Date: Tue, 22 Aug 2017 09:44:52 -0500
Subject: [PATCH] Implement zstandard format

The extension of zstd-compressed packages will be ".tzst" (equivalent of
".tar.zst")
---
 docs/pkg-create.8          |  2 +-
 libpkg/packing.c           | 10 ++++++++++
 libpkg/pkg.h.in            |  2 +-
 libpkg/pkg_jobs.c          |  3 ++-
 libpkg/pkg_repo_meta.c     |  2 +-
 scripts/completion/_pkg.in |  2 +-
 src/create.c               |  9 +++++++--
 7 files changed, 23 insertions(+), 7 deletions(-)

diff --git docs/pkg-create.8 docs/pkg-create.8
index 0d10aac25..fc79d8473 100644
--- docs/pkg-create.8
+++ docs/pkg-create.8
@@ -148,7 +148,7 @@ Set
 .Ar format
 as the package output format.
 It can be one of
-.Ar txz , tbz , tgz
+.Ar tzst , txz , tbz , tgz
 or
 .Ar tar
 which are currently the only supported formats.
diff --git libpkg/packing.c libpkg/packing.c
index b1570b377..c82f41c0b 100644
--- libpkg/packing.c
+++ libpkg/packing.c
@@ -313,6 +313,11 @@ packing_set_format(struct archive *a, pkg_formats format)
 	const char *notsupp_fmt = "%s is not supported, trying %s";
 
 	switch (format) {
+	case TZS:
+		if (archive_write_add_filter_zstd(a) == ARCHIVE_OK)
+			return ("tzst");
+		else
+			pkg_emit_error(notsupp_fmt, "zstd", "xz");
 	case TXZ:
 		if (archive_write_add_filter_xz(a) == ARCHIVE_OK)
 			return ("txz");
@@ -340,6 +345,8 @@ packing_format_from_string(const char *str)
 {
 	if (str == NULL)
 		return TXZ;
+	if (strcmp(str, "tzst") == 0)
+		return TZS;
 	if (strcmp(str, "txz") == 0)
 		return TXZ;
 	if (strcmp(str, "tbz") == 0)
@@ -358,6 +365,9 @@ packing_format_to_string(pkg_formats format)
 	const char *res = NULL;
 
 	switch (format) {
+	case TZS:
+		res = "tzst";
+		break;
 	case TXZ:
 		res = "txz";
 		break;
diff --git libpkg/pkg.h.in libpkg/pkg.h.in
index 4944b587d..a60f0b745 100644
--- libpkg/pkg.h.in
+++ libpkg/pkg.h.in
@@ -1111,7 +1111,7 @@ void pkg_solve_problem_free(struct pkg_solve_problem *problem);
 /**
  * Archive formats options.
  */
-typedef enum pkg_formats { TAR, TGZ, TBZ, TXZ } pkg_formats;
+typedef enum pkg_formats { TAR, TGZ, TBZ, TXZ, TZS } pkg_formats;
 
 /**
  * Create package from an installed & registered package
diff --git libpkg/pkg_jobs.c libpkg/pkg_jobs.c
index 4b7ee7c23..2034b5d83 100644
--- libpkg/pkg_jobs.c
+++ libpkg/pkg_jobs.c
@@ -192,7 +192,8 @@ pkg_jobs_maybe_match_file(struct job_pattern *jp, const char *pattern)
 		 * Compare suffix with .txz or .tbz
 		 */
 		dot_pos ++;
-		if (strcmp(dot_pos, "txz") == 0 ||
+		if (strcmp(dot_pos, "tzst") == 0 ||
+			strcmp(dot_pos, "txz") == 0 ||
 			strcmp(dot_pos, "tbz") == 0 ||
 			strcmp(dot_pos, "tgz") == 0 ||
 			strcmp(dot_pos, "tar") == 0) {
diff --git libpkg/pkg_repo_meta.c libpkg/pkg_repo_meta.c
index a29ab50b6..ea264a4e0 100644
--- libpkg/pkg_repo_meta.c
+++ libpkg/pkg_repo_meta.c
@@ -97,7 +97,7 @@ pkg_repo_meta_open_schema_v1()
 			"version = {type = integer};\n"
 			"maintainer = {type = string};\n"
 			"source = {type = string};\n"
-			"packing_format = {enum = [txz, tbz, tgz, tar]};\n"
+			"packing_format = {enum = [tzst, txz, tbz, tgz, tar]};\n"
 			"digest_format = {enum = [sha256_base32, sha256_hex, blake2_base32, blake2s_base32]};\n"
 			"digests = {type = string};\n"
 			"manifests = {type = string};\n"
diff --git scripts/completion/_pkg.in scripts/completion/_pkg.in
index 3913de3f7..814c971e9 100644
--- scripts/completion/_pkg.in
+++ scripts/completion/_pkg.in
@@ -243,7 +243,7 @@ _pkg() {
 				'(-q --quiet)'{-q,--quiet}'[force quiet output]' \
 				'(-v --verbose)'{-v,--verbose}'[be verbose]' \
 				'(-n --no-clobber)'{-n,--no-clobber}'[no not overwrite existing packages]' \
-				'(-f --format)'{-f,--format}'[format]:format:((tar tgz tbz txz))' \
+				'(-f --format)'{-f,--format}'[format]:format:((tar tgz tbz txz tzst))' \
 				'(-o --out-dir)'{-o,--out-dir}'[output directory]:outdir:_files -/' \
 				'(-r --root-dir)'{-r,--root-dir}'[specify root directory]:rootdir:_files -/' \
 				- '(manifest)' \
diff --git src/create.c src/create.c
index be76973a9..8aa90cc15 100644
--- src/create.c
+++ src/create.c
@@ -104,6 +104,9 @@ pkg_create_matches(int argc, char **argv, match_t match, pkg_formats fmt,
 	}
 
 	switch (fmt) {
+	case TZS:
+		format = "tzst";
+		break;
 	case TXZ:
 		format = "txz";
 		break;
@@ -185,7 +188,7 @@ pkg_create_matches(int argc, char **argv, match_t match, pkg_formats fmt,
  * -m: path to dir where to find the metadata
  * -q: quiet mode
  * -M: manifest file
- * -f <format>: format could be txz, tgz, tbz or tar
+ * -f <format>: format could be tzst, txz, tgz, tbz or tar
  * -o: output directory where to create packages by default ./ is used
  */
 
@@ -293,7 +296,9 @@ exec_create(int argc, char **argv)
 	} else {
 		if (format[0] == '.')
 			++format;
-		if (strcmp(format, "txz") == 0)
+		if (strcmp(format, "tzst") == 0)
+			fmt = TZS;
+		else if (strcmp(format, "txz") == 0)
 			fmt = TXZ;
 		else if (strcmp(format, "tbz") == 0)
 			fmt = TBZ;
From 11c83126107b97dbb458021ac46676dbda64886c Mon Sep 17 00:00:00 2001
From: John Marino <draco@marino.st>
Date: Fri, 6 Oct 2017 08:45:12 -0500
Subject: [PATCH] Switch repo command over to zstd format

The repo command is hard-coded for the txz format (really??).
Which, in effect, means other package formats are usable.
Switch this over to a hardcoded tzst format.  The true fix is have
a package format switch for repo command.
---
 libpkg/pkg_repo.c        |  2 +-
 libpkg/pkg_repo_create.c | 10 +++++-----
 libpkg/pkg_repo_meta.c   |  2 +-
 3 files changed, 7 insertions(+), 7 deletions(-)

--- libpkg/pkg_repo.c.orig	2017-03-26 21:07:41 UTC
+++ libpkg/pkg_repo.c
@@ -835,7 +835,7 @@ pkg_repo_fetch_meta(struct pkg_repo *rep
 
 	dbdir = pkg_object_string(pkg_config_get("PKG_DBDIR"));
 
-	fd = pkg_repo_fetch_remote_tmp(repo, "meta", "txz", t, &rc);
+	fd = pkg_repo_fetch_remote_tmp(repo, "meta", "tzst", t, &rc);
 	if (fd == -1)
 		return (rc);
 
diff --git a/libpkg/pkg_repo_create.c b/libpkg/pkg_repo_create.c
index 7f8797462..a3fa5885b 100644
--- libpkg/pkg_repo_create.c
+++ libpkg/pkg_repo_create.c
@@ -1013,7 +1013,7 @@ pkg_finish_repo(const char *output_dir, pkg_password_cb *password_cb,
 #endif
 
 	/* Now we need to set the equal mtime for all archives in the repo */
-	snprintf(repo_archive, sizeof(repo_archive), "%s/%s.txz",
+	snprintf(repo_archive, sizeof(repo_archive), "%s/%s.tzst",
 	    output_dir, repo_meta_file);
 	if (stat(repo_archive, &st) == 0) {
 		struct timeval ftimes[2] = {
@@ -1026,20 +1026,20 @@ pkg_finish_repo(const char *output_dir, pkg_password_cb *password_cb,
 			.tv_usec = 0
 			}
 		};
-		snprintf(repo_archive, sizeof(repo_archive), "%s/%s.txz",
+		snprintf(repo_archive, sizeof(repo_archive), "%s/%s.tzst",
 		    output_dir, meta->manifests_archive);
 		utimes(repo_archive, ftimes);
-		snprintf(repo_archive, sizeof(repo_archive), "%s/%s.txz",
+		snprintf(repo_archive, sizeof(repo_archive), "%s/%s.tzst",
 		    output_dir, meta->digests_archive);
 		utimes(repo_archive, ftimes);
 		if (filelist) {
 			snprintf(repo_archive, sizeof(repo_archive),
-			    "%s/%s.txz", output_dir, meta->filesite_archive);
+			    "%s/%s.tzst", output_dir, meta->filesite_archive);
 			utimes(repo_archive, ftimes);
 		}
 		if (!legacy) {
 			snprintf(repo_archive, sizeof(repo_archive),
-				"%s/%s.txz", output_dir, repo_meta_file);
+				"%s/%s.tzst", output_dir, repo_meta_file);
 			utimes(repo_archive, ftimes);
 		}
 	}
diff --git a/libpkg/pkg_repo_meta.c b/libpkg/pkg_repo_meta.c
index ea264a4e0..4440dc110 100644
--- libpkg/pkg_repo_meta.c
+++ libpkg/pkg_repo_meta.c
@@ -36,7 +36,7 @@ static void
 pkg_repo_meta_set_default(struct pkg_repo_meta *meta)
 {
 	meta->digest_format = PKG_HASH_TYPE_SHA256_BASE32;
-	meta->packing_format = TXZ;
+	meta->packing_format = TZS;
 
 	/* Not use conflicts for now */
 	meta->conflicts = NULL;


[FILE:491:linux/patch-libpkg_elfhints.c]
--- libpkg/elfhints.c.orig	2017-03-09 12:57:56 UTC
+++ libpkg/elfhints.c
@@ -305,6 +305,11 @@ shlib_list_from_elf_hints(const char *hi
 #if defined __FreeBSD__ || defined __DragonFly__
 	read_elf_hints(hintsfile, 1);
 #endif
+#if defined __linux__
+	add_dir ("fake-elf-hints-1", "/lib/x86_64-linux-gnu", 1);
+	add_dir ("fake-elf-hints-2", "/usr/lib/x86_64-linux-gnu", 1);
+	add_dir ("fake-elf-hints-3", "/lib64", 1);
+#endif
 
 	return (scan_dirs_for_shlibs(&shlibs, ndirs, dirs, true));
 }


[FILE:906:linux/patch-src_Makefile.in]
--- src/Makefile.in.orig	2017-05-16 18:01:51 UTC
+++ src/Makefile.in
@@ -710,9 +710,18 @@ pkg$(EXEEXT): $(pkg_OBJECTS) $(pkg_DEPEN
 	@rm -f pkg$(EXEEXT)
 	$(AM_V_CCLD)$(pkg_LINK) $(pkg_OBJECTS) $(pkg_LDADD) $(LIBS)
 
-pkg-static$(EXEEXT): $(pkg_static_OBJECTS) $(pkg_static_DEPENDENCIES) $(EXTRA_pkg_static_DEPENDENCIES) 
+pkg-static: $(pkg_OBJECTS) $(pkg_DEPENDENCIES) $(EXTRA_pkg_DEPENDENCIES) 
 	@rm -f pkg-static$(EXEEXT)
-	$(AM_V_CCLD)$(pkg_static_LINK) $(pkg_static_OBJECTS) $(pkg_static_LDADD) $(LIBS)
+	$(CCLD) $(pkg_CFLAGS) $(CFLAGS) $(AM_LDFLAGS) $(LDFLAGS) -o ${.TARGET} \
+	$(pkg_OBJECTS) -pthread \
+	../libpkg/.libs/libpkg_static.a \
+	../external/.libs/libelf_static.a \
+	../compat/.libs/libbsd_compat.a \
+	-Wl,-Bstatic \
+	-lutil -lssl -lcrypto -lbsd -lresolv -larchive -lz -lbz2 -llzma \
+	-Wl,-Bdynamic \
+	-lm \
+	-Wl,-rpath -Wl,/raven/lib
 
 mostlyclean-compile:
 	-rm -f *.$(OBJEXT)

