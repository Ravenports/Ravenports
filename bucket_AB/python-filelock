# Buildsheet autogenerated by ravenadm tool -- Do not edit.

NAMEBASE=		python-filelock
VERSION=		3.1.0
KEYWORDS=		python
VARIANTS=		py38 py39
SDESC[py38]=		Platform independent file lock (PY38)
SDESC[py39]=		Platform independent file lock (PY39)
HOMEPAGE=		https://github.com/tox-dev/py-filelock
CONTACT=		Python_Automaton[python@ironwolf.systems]

DOWNLOAD_GROUPS=	main
SITES[main]=		PYPIWHL/e0/a5/23349971aaf2bb56cf0bb084e51b4020098e53465c97eeb730e2e2a1da13
DISTFILE[1]=		filelock-3.1.0-py2.py3-none-any.whl:main
DF_INDEX=		1
SPKGS[py38]=		single
SPKGS[py39]=		single

OPTIONS_AVAILABLE=	PY38 PY39
OPTIONS_STANDARD=	none
VOPTS[py38]=		PY38=ON PY39=OFF
VOPTS[py39]=		PY38=OFF PY39=ON

DISTNAME=		filelock-3.1.0.dist-info

GENERATED=		yes

[PY38].USES_ON=				python:py38,wheel

[PY39].USES_ON=				python:py39,wheel

[FILE:2193:descriptions/desc.single]
# py-filelock

[PyPI]
[Supported Python
versions]
[Documentation
status]
[![Code style:
black]](https://github.com/psf/black)
[Downloads]
[check]

This package contains a single module, which implements a platform
independent
file lock in Python, which provides a simple way of inter-process
communication:

```Python
from src.filelock import Timeout, FileLock

lock = FileLock("high_ground.txt.lock")
with lock:
    open("high_ground.txt", "a").write("You were the chosen one.")
```

**Don't use** a *FileLock* to lock the file you want to write to, instead
create
a separate *.lock* file as shown above.

![animated example]

## Similar libraries

Perhaps you are looking for something like

*   https://pypi.python.org/pypi/pid/2.1.1
*   https://docs.python.org/3.6/library/msvcrt.html#msvcrt.locking
*   or https://docs.python.org/3/library/fcntl.html#fcntl.flock

## Installation

*py-filelock* is available via PyPi:

```
$ pip3 install filelock
```

## Documentation

The documentation for the API is available on
[readthedocs.org].

### Examples

A *FileLock* is used to indicate another process of your application that a
resource or working
directory is currently used. To do so, create a *FileLock* first:

```Python
from src.filelock import Timeout, FileLock

file_path = "high_ground.txt"
lock_path = "high_ground.txt.lock"

lock = FileLock(lock_path, timeout=1)
```

The lock object supports multiple ways for acquiring the lock, including
the
ones used to acquire standard Python thread locks:

```Python
with lock:
    open(file_path, "a").write("Hello there!")

lock.acquire()
try:
    open(file_path, "a").write("General Kenobi!")
finally:
    lock.release()
```

The *acquire()* method accepts also a *timeout* parameter. If the lock
cannot be
acquired within *timeout* seconds, a *Timeout* exception is raised:

```Python
try:
    with lock.acquire(timeout=10):
        open(file_path, "a").write("I have a bad feeling about this.")
except Timeout:
    print("Another instance of this application currently holds the lock.")
```

The lock objects are recursive locks, which means that once acquired, they
will
not block on successive lock requests:

```Python
def cite1():


[FILE:114:distinfo]
d9e9c7d8191e915339843c81c90d3e44f7c84e5fb03bdc6b1b4d019025cf953b         8394 filelock-3.1.0-py2.py3-none-any.whl

