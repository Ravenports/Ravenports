# Buildsheet autogenerated by ravenadm tool -- Do not edit.

NAMEBASE=		python-pathspec
VERSION=		0.9.0
KEYWORDS=		python
VARIANTS=		py39 py310
SDESC[py310]=		Library for git file pattern matching (3.10)
SDESC[py39]=		Library for git file pattern matching (3.9)
HOMEPAGE=		https://github.com/cpburnz/python-path-specification
CONTACT=		Python_Automaton[python@ironwolf.systems]

DOWNLOAD_GROUPS=	main
SITES[main]=		PYPIWHL/42/ba/a9d64c7bcbc7e3e8e5f93a52721b377e994c22d16196e2b0f1236774353a
DISTFILE[1]=		pathspec-0.9.0-py2.py3-none-any.whl:main
DF_INDEX=		1
SPKGS[py310]=		single
SPKGS[py39]=		single

OPTIONS_AVAILABLE=	PY39 PY310
OPTIONS_STANDARD=	none
VOPTS[py310]=		PY39=OFF PY310=ON
VOPTS[py39]=		PY39=ON PY310=OFF

DISTNAME=		pathspec-0.9.0.dist-info

GENERATED=		yes

[PY39].USES_ON=				python:py39,wheel

[PY310].USES_ON=			python:py310,wheel

[FILE:3059:descriptions/desc.single]

*pathspec*: Path Specification
==============================

*pathspec* is a utility library for pattern matching of file paths. So
far this only includes Git's wildmatch pattern matching which itself is
derived from Rsync's wildmatch. Git uses wildmatch for its `gitignore`_
files.

.. _`gitignore`: http://git-scm.com/docs/gitignore

Tutorial
--------

Say you have a "Projects" directory and you want to back it up, but only
certain files, and ignore others depending on certain conditions::

	>>> import pathspec
	>>> # The gitignore-style patterns for files to select, but we're
including
	>>> # instead of ignoring.
	>>> spec = """
	...
	... # This is a comment because the line begins with a hash: "#"
	...
	... # Include several project directories (and all descendants) relative
to
	... # the current directory. To reference a directory you must end with a
	... # slash: "/"
	... /project-a/
	... /project-b/
	... /project-c/
	...
	... # Patterns can be negated by prefixing with exclamation mark: "!"
	...
	... # Ignore temporary files beginning or ending with "~" and ending with
	... # ".swp".
	... !~*
	... !*~
	... !*.swp
	...
	... # These are python projects so ignore compiled python files from
	... # testing.
	... !*.pyc
	...
	... # Ignore the build directories but only directly under the project
	... # directories.
	... !/*/build/
	...
	... """

We want to use the GitWildMatchPattern class to compile our patterns. The
PathSpec class provides an interface around pattern implementations::

	>>> spec =
pathspec.PathSpec.from_lines(pathspec.patterns.GitWildMatchPattern,
spec.splitlines())

That may be a mouthful but it allows for additional patterns to be
implemented
in the future without them having to deal with anything but matching the
paths
sent to them. GitWildMatchPattern is the implementation of the actual
pattern which internally gets converted into a regular expression.
PathSpec is a simple wrapper around a list of compiled patterns.

To make things simpler, we can use the registered name for a pattern class
instead of always having to provide a reference to the class itself. The
GitWildMatchPattern class is registered as **gitwildmatch**::

	>>> spec = pathspec.PathSpec.from_lines('gitwildmatch', spec.splitlines())

If we wanted to manually compile the patterns we can just do the
following::

	>>> patterns = map(pathspec.patterns.GitWildMatchPattern,
spec.splitlines())
	>>> spec = PathSpec(patterns)

``PathSpec.from_lines()`` is simply a class method which does just that.

If you want to load the patterns from file, you can pass the file instance
directly as well::

	>>> with open('patterns.list', 'r') as fh:
	>>>     spec = pathspec.PathSpec.from_lines('gitwildmatch', fh)

You can perform matching on a whole directory tree with::

	>>> matches = spec.match_tree('path/to/directory')

Or you can perform matching on a specific set of file paths with::

	>>> matches = spec.match_files(file_paths)

Or check to see if an individual file matches::

	>>> is_matched = spec.match_file(file_path)

License


[FILE:114:distinfo]
7d15c4ddb0b5c802d161efc417ec1a2558ea2653c2e8ad9c19098201dc1c993a        31165 pathspec-0.9.0-py2.py3-none-any.whl

