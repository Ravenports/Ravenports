# Buildsheet autogenerated by ravenadm tool -- Do not edit.

NAMEBASE=		python-pathspec
VERSION=		0.10.3
KEYWORDS=		python
VARIANTS=		py310 py311
SDESC[py310]=		Library for git file pattern matching (3.10)
SDESC[py311]=		Library for git file pattern matching (3.11)
HOMEPAGE=		https://github.com/cpburnz/python-pathspec
CONTACT=		Python_Automaton[python@ironwolf.systems]

DOWNLOAD_GROUPS=	main
SITES[main]=		PYPIWHL/3c/29/c07c3a976dbe37c56e381e058c11e8738cb3a0416fc842a310461f8bb695
DISTFILE[1]=		pathspec-0.10.3-py3-none-any.whl:main
DF_INDEX=		1
SPKGS[py310]=		single
SPKGS[py311]=		single

OPTIONS_AVAILABLE=	PY310 PY311
OPTIONS_STANDARD=	none
VOPTS[py310]=		PY310=ON PY311=OFF
VOPTS[py311]=		PY310=OFF PY311=ON

DISTNAME=		pathspec-0.10.3.dist-info

GENERATED=		yes

[PY310].USES_ON=			python:py310,wheel

[PY311].USES_ON=			python:py311,wheel

[FILE:3027:descriptions/desc.single]

PathSpec
========

*pathspec* is a utility library for pattern matching of file paths. So
far this only includes Git's wildmatch pattern matching which itself is
derived from Rsync's wildmatch. Git uses wildmatch for its `gitignore`_
files.

.. _`gitignore`: http://git-scm.com/docs/gitignore

Tutorial
--------

Say you have a "Projects" directory and you want to back it up, but only
certain files, and ignore others depending on certain conditions::

	>>> import pathspec
	>>> # The gitignore-style patterns for files to select, but we're
including
	>>> # instead of ignoring.
	>>> spec_text = """
	...
	... # This is a comment because the line begins with a hash: "#"
	...
	... # Include several project directories (and all descendants) relative
to
	... # the current directory. To reference a directory you must end with a
	... # slash: "/"
	... /project-a/
	... /project-b/
	... /project-c/
	...
	... # Patterns can be negated by prefixing with exclamation mark: "!"
	...
	... # Ignore temporary files beginning or ending with "~" and ending with
	... # ".swp".
	... !~*
	... !*~
	... !*.swp
	...
	... # These are python projects so ignore compiled python files from
	... # testing.
	... !*.pyc
	...
	... # Ignore the build directories but only directly under the project
	... # directories.
	... !/*/build/
	...
	... """

We want to use the GitWildMatchPattern class to compile our patterns. The
PathSpec class provides an interface around pattern implementations::

	>>> spec =
pathspec.PathSpec.from_lines(pathspec.patterns.GitWildMatchPattern,
spec_text.splitlines())

That may be a mouthful but it allows for additional patterns to be
implemented
in the future without them having to deal with anything but matching the
paths
sent to them. GitWildMatchPattern is the implementation of the actual
pattern which internally gets converted into a regular expression. PathSpec
is a simple wrapper around a list of compiled patterns.

To make things simpler, we can use the registered name for a pattern class
instead of always having to provide a reference to the class itself. The
GitWildMatchPattern class is registered as **gitwildmatch**::

	>>> spec = pathspec.PathSpec.from_lines('gitwildmatch',
spec_text.splitlines())

If we wanted to manually compile the patterns we can just do the
following::

	>>> patterns = map(pathspec.patterns.GitWildMatchPattern,
spec_text.splitlines())
	>>> spec = PathSpec(patterns)

``PathSpec.from_lines()`` is simply a class method which does just that.

If you want to load the patterns from file, you can pass the file instance
directly as well::

	>>> with open('patterns.list', 'r') as fh:
	>>>     spec = pathspec.PathSpec.from_lines('gitwildmatch', fh)

You can perform matching on a whole directory tree with::

	>>> matches = spec.match_tree('path/to/directory')

Or you can perform matching on a specific set of file paths with::

	>>> matches = spec.match_files(file_paths)

Or check to see if an individual file matches::

	>>> is_matched = spec.match_file(file_path)



[FILE:111:distinfo]
3c95343af8b756205e2aba76e843ba9520a24dd84f68c22b9f93251507509dd6        29165 pathspec-0.10.3-py3-none-any.whl

