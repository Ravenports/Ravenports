# Buildsheet autogenerated by ravenadm tool -- Do not edit.

NAMEBASE=		smartmontools
VERSION=		7.2
KEYWORDS=		sysutils
VARIANTS=		standard
SDESC[standard]=	S.M.A.R.T. disk monitoring tools and daemon
HOMEPAGE=		https://www.smartmontools.org
CONTACT=		Michael_Reim[kraileth@elderlinux.org]

DOWNLOAD_GROUPS=	main
SITES[main]=		SF/smartmontools/smartmontools/7.2
DISTFILE[1]=		smartmontools-7.2.tar.gz:main
DF_INDEX=		1
SPKGS[standard]=	complete
			primary
			docs

OPTIONS_AVAILABLE=	none
OPTIONS_STANDARD=	none

USES=			c++:primary gmake shebangfix

LICENSE=		GPLv2+:primary
LICENSE_TERMS=		primary:{{WRKDIR}}/TERMS
LICENSE_FILE=		GPLv2+:{{WRKSRC}}/COPYING
LICENSE_AWK=		TERMS:"^$$"
LICENSE_SOURCE=		TERMS:{{WRKSRC}}/utility.h
LICENSE_SCHEME=		solo

FPC_EQUIVALENT=		sysutils/smartmontools
SHEBANG_FILES=		examplescripts/Example5

MUST_CONFIGURE=		gnu
CONFIGURE_ARGS=		--enable-sample
			--with-initscriptdir={{PREFIX}}/etc/rc.d
			--with-nvme-devicescan=yes

[FILE:342:descriptions/desc.primary]
Smartmontools provides two programs, smartctl and the smartd daemon. They are used to control and monitor storage devices using the S.M.A.R.T (Self-Monitoring, Analysis and Reporting Technology) system supported by most modern ATA/SATA, SCSI/SAS and NVMe disks. It is commonly used to provide early warnings before your storage devices fail.


[FILE:103:distinfo]
5cd98a27e6393168bc6aaea070d9e1cd551b0f898c52f66b2ff2e5d274118cd6       992256 smartmontools-7.2.tar.gz


[FILE:272:manifests/plist.primary]
etc/
 smartd.conf.sample
 smartd_warning.sh
etc/rc.d/smartd.sample
sbin/
 smartctl
 smartd
 update-smart-drivedb
share/man/man5/smartd.conf.5.gz
share/man/man8/
 smartctl.8.gz
 smartd.8.gz
 update-smart-drivedb.8.gz
share/smartmontools/drivedb.h
@dir etc/smartd_warning.d


[FILE:243:manifests/plist.docs]
share/doc/smartmontools/
 AUTHORS
 COPYING
 ChangeLog
 ChangeLog-6.0-7.0
 INSTALL
 NEWS
 README
 TODO
 smartd.conf
share/doc/smartmontools/examplescripts/
 Example1
 Example2
 Example3
 Example4
 Example5
 Example6
 Example7
 Example8
 README


[FILE:359:patches/patch-cciss.cpp]
--- cciss.cpp.orig	2019-11-22 19:57:04 UTC
+++ cciss.cpp
@@ -28,7 +28,7 @@
 #  ifndef be32toh
 #    define be32toh __be32_to_cpu
 #  endif
-#elif defined(__FreeBSD__) || defined(__FreeBSD_kernel__)
+#elif defined(__FreeBSD__) || defined(__FreeBSD_kernel__) || defined(__DragonFly__)
 #  include <sys/endian.h>
 #  include CISS_LOCATION
 #  define _HAVE_CCISS


[FILE:563:patches/patch-dev__areca.h]
--- dev_areca.h.orig	2020-10-06 15:31:47 UTC
+++ dev_areca.h
@@ -51,7 +51,7 @@ ARCMSR_CMD_TOTAL
 #define ARCMSR_IOCTL_CLEAR_RQBUFFER          (ARECA_SATA_RAID | FUNCTION_CLEAR_RQBUFFER)
 #define ARCMSR_IOCTL_CLEAR_WQBUFFER          (ARECA_SATA_RAID | FUNCTION_CLEAR_WQBUFFER)
 #define ARCMSR_IOCTL_RETURN_CODE_3F          (ARECA_SATA_RAID | FUNCTION_RETURN_CODE_3F)
-#elif defined(__FreeBSD__) || defined(__FreeBSD_kernel__)
+#elif defined(__FreeBSD__) || defined(__FreeBSD_kernel__) || defined(__DragonFly__)
 #include <sys/ioctl.h> // _IOWR
 
 /*FunctionCode*/


[FILE:1961:patches/patch-os__freebsd.cpp]
--- os_freebsd.cpp.orig	2020-12-12 21:36:48 UTC
+++ os_freebsd.cpp
@@ -17,11 +17,13 @@
 #include <err.h>
 #include <errno.h>
 #include <camlib.h>
-#include <cam/scsi/scsi_message.h>
-#include <cam/scsi/scsi_pass.h>
 #if defined(__DragonFly__)
+#include <bus/cam/scsi/scsi_message.h>
+#include <bus/cam/scsi/scsi_pass.h>
 #include <sys/nata.h>
 #else
+#include <cam/scsi/scsi_message.h>
+#include <cam/scsi/scsi_pass.h>
 #include <sys/ata.h>
 #endif
 #include <sys/stat.h>
@@ -54,12 +56,15 @@
 #define FREEBSDVER __FreeBSD_kernel_version
 #endif
 
-#if (FREEBSDVER >= 800000)
+#ifdef __DragonFly__
+#define  DFU4B 1
+#include <libusb20_desc.h>
+#include <libusb20.h>
+#include <bus/u4b/usb.h>
+#include <bus/u4b/usbhid.h>
+#elif (FREEBSDVER >= 800000)
 #include <libusb20_desc.h>
 #include <libusb20.h>
-#elif defined(__DragonFly__)
-#include <bus/usb/usb.h>
-#include <bus/usb/usbhid.h>
 #else
 #include <dev/usb/usb.h>
 #include <dev/usb/usbhid.h>
@@ -1390,6 +1395,14 @@ smart_device * freebsd_scsi_device::auto
   if (len < 36)
     return this;
 
+#ifdef __DragonFly__
+  if (m_camdev == NULL) {
+      close();
+      set_err(EINVAL, "m_camdev not set");
+      return this;
+  }
+#endif
+
   // Use INQUIRY to detect type
 
   // 3ware ?
@@ -1800,7 +1813,7 @@ bool freebsd_smart_interface::get_nvme_d
   return true;
 }
 
-#if (FREEBSDVER < 800000) // without this build fail on FreeBSD 8
+#if (FREEBSDVER < 800000) && !defined(DFU4B)
 static char done[USB_MAX_DEVICES];
 
 static int usbdevinfo(int f, int a, int rec, int busno, unsigned short & vendor_id,
@@ -1856,7 +1869,7 @@ static int usbdevinfo(int f, int a, int
 static int usbdevlist(int busno,unsigned short & vendor_id,
   unsigned short & product_id, unsigned short & version)
 {
-#if (FREEBSDVER >= 800000) // libusb2 interface
+#if (FREEBSDVER >= 800000) || defined(DFU4B) // libusb2 interface
   struct libusb20_device *pdev = NULL;
   struct libusb20_backend *pbe;
   uint32_t matches = 0;

