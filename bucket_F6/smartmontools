# Buildsheet autogenerated by ravenadm tool -- Do not edit.

NAMEBASE=		smartmontools
VERSION=		7.0
KEYWORDS=		sysutils
VARIANTS=		standard
SDESC[standard]=	S.M.A.R.T. disk monitoring tools and daemon
HOMEPAGE=		https://www.smartmontools.org
CONTACT=		Michael_Reim[kraileth@elderlinux.org]

DOWNLOAD_GROUPS=	main
SITES[main]=		SF/smartmontools/smartmontools/7.0
DISTFILE[1]=		smartmontools-7.0.tar.gz:main
DF_INDEX=		1
SPKGS[standard]=	single

OPTIONS_AVAILABLE=	none
OPTIONS_STANDARD=	none

USES=			c++:single gmake shebangfix

LICENSE=		GPLv2+:single
LICENSE_TERMS=		single:{{WRKDIR}}/TERMS
LICENSE_FILE=		GPLv2+:{{WRKSRC}}/COPYING
LICENSE_AWK=		TERMS:"^$$"
LICENSE_SOURCE=		TERMS:{{WRKSRC}}/utility.h
LICENSE_SCHEME=		solo

FPC_EQUIVALENT=		sysutils/smartmontools
SHEBANG_FILES=		examplescripts/Example5

MUST_CONFIGURE=		gnu
CONFIGURE_ARGS=		--enable-sample
			--with-initscriptdir={{PREFIX}}/etc/rc.d
			--with-nvme-devicescan=yes

[FILE:342:descriptions/desc.single]
Smartmontools provides two programs, smartctl and the smartd daemon. They are used to control and monitor storage devices using the S.M.A.R.T (Self-Monitoring, Analysis and Reporting Technology) system supported by most modern ATA/SATA, SCSI/SAS and NVMe disks. It is commonly used to provide early warnings before your storage devices fail.


[FILE:103:distinfo]
e5e1ac2786bc87fdbd6f92d0ee751b799fbb3e1a09c0a6a379f9eb64b3e8f61c       944925 smartmontools-7.0.tar.gz


[FILE:495:manifests/plist.single]
etc/
 smartd.conf.sample
 smartd_warning.sh
etc/rc.d/smartd.sample
sbin/
 smartctl
 smartd
 update-smart-drivedb
share/doc/smartmontools/
 AUTHORS
 COPYING
 ChangeLog
 ChangeLog-5.0-6.0
 INSTALL
 NEWS
 README
 TODO
 smartd.conf
share/doc/smartmontools/examplescripts/
 Example1
 Example2
 Example3
 Example4
 Example5
 Example6
 README
share/man/man5/smartd.conf.5.gz
share/man/man8/
 smartctl.8.gz
 smartd.8.gz
 update-smart-drivedb.8.gz
share/smartmontools/drivedb.h
@dir etc/smartd_warning.d


[FILE:554:patches/patch-configure]
--- configure.orig	2018-12-30 14:49:08 UTC
+++ configure
@@ -6891,7 +6891,7 @@ case "${host}" in
   *-*-freebsd*|*-*-dragonfly*|*-*-kfreebsd*-gnu*)
     os_deps='os_freebsd.o cciss.o dev_areca.o'
     os_libs='-lcam -lsbuf'
-    os_dltools='curl wget lynx fetch svn'
+    os_dltools='fetch curl wget lynx svn'
     { $as_echo "$as_me:${as_lineno-$LINENO}: checking for libusb20_dev_get_device_desc in -lusb" >&5
 $as_echo_n "checking for libusb20_dev_get_device_desc in -lusb... " >&6; }
 if ${ac_cv_lib_usb_libusb20_dev_get_device_desc+:} false; then :


[FILE:1590:patches/patch-os__freebsd.cpp]
Index: os_freebsd.cpp
===================================================================
--- os_freebsd.cpp.orig	2018-12-05 18:30:46 UTC
+++ os_freebsd.cpp
@@ -9,6 +9,7 @@
  */
 
 #include <sys/param.h>
+#include <sys/endian.h>
 #include <stdio.h>
 #include <sys/types.h>
 #include <dirent.h>
@@ -522,29 +523,29 @@ bool freebsd_nvme_device::nvme_pass_through(const nvme
   pt.cmd.opc = in.opcode;
 #endif
   pt.cmd.opc = in.opcode;
-  pt.cmd.nsid = in.nsid;
+  pt.cmd.nsid = htole32(in.nsid);
   pt.buf = in.buffer;
   pt.len = in.size;
-  pt.cmd.cdw10 = in.cdw10;
-  pt.cmd.cdw11 = in.cdw11;
-  pt.cmd.cdw12 = in.cdw12;
-  pt.cmd.cdw13 = in.cdw13;
-  pt.cmd.cdw14 = in.cdw14;
-  pt.cmd.cdw15 = in.cdw15;
+  pt.cmd.cdw10 = htole32(in.cdw10);
+  pt.cmd.cdw11 = htole32(in.cdw11);
+  pt.cmd.cdw12 = htole32(in.cdw12);
+  pt.cmd.cdw13 = htole32(in.cdw13);
+  pt.cmd.cdw14 = htole32(in.cdw14);
+  pt.cmd.cdw15 = htole32(in.cdw15);
   pt.is_read = 1; // should we use in.direction()?
   
   int status = ioctl(get_fd(), NVME_PASSTHROUGH_CMD, &pt);
 
   if (status < 0)
     return set_err(errno, "NVME_PASSTHROUGH_CMD: %s", strerror(errno));
-
+#if __FreeBSD_version >= 1200058
+  nvme_completion_swapbytes(&pt.cpl);
+#endif
   cp_p = &pt.cpl;
   out.result=cp_p->cdw0; // Command specific result (DW0)
 
   if (nvme_completion_is_error(cp_p)) {  /* ignore DNR and More bits */
-    uint16_t nvme_status = ((cp_p->status.sct << 8) | cp_p->status.sc) & 0x3ff;
-
-    return set_nvme_err(out, nvme_status);
+    return set_nvme_err(out, nvme_completion_is_error(&pt.cpl));
   }
 
   return true;

