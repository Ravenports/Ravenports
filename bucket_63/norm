# Buildsheet autogenerated by ravenadm tool -- Do not edit.

NAMEBASE=		norm
VERSION=		1.5.9
KEYWORDS=		net
VARIANTS=		standard
SDESC[standard]=	NACK-Oriented Reliable Multicast (NORM)
HOMEPAGE=		https://www.nrl.navy.mil/itd/ncs/products/norm
CONTACT=		nobody

DOWNLOAD_GROUPS=	main protolib
SITES[main]=		GITHUB/USNavalResearchLaboratory:norm:v1.5.9
SITES[protolib]=	GITHUB/USNavalResearchLaboratory:protolib:702e909:protolib
DISTFILE[1]=		generated:main
DISTFILE[2]=		generated:protolib
DF_INDEX=		1 2
SPKGS[standard]=	single

OPTIONS_AVAILABLE=	none
OPTIONS_STANDARD=	none

USES=			cmake c++:single dos2unix
GNOME_COMPONENTS=	libxml2

LICENSE=		CUSTOM1:single
LICENSE_NAME=		CUSTOM1:"NORM source code license"
LICENSE_FILE=		CUSTOM1:{{WRKSRC}}/LICENSE.TXT
LICENSE_SCHEME=		solo

CMAKE_ARGS=		-DBUILD_SHARED_LIBS:BOOL=ON

post-extract-sunos:
	${CP} ${FILESDIR}/getifaddrs.cpp ${WRKSRC}/protolib/src/unix/
	${CP} ${FILESDIR}/ifaddrs.h ${WRKSRC}/protolib/include/

[FILE:1185:descriptions/desc.single]
This a port of NACK-Oriented Reliable Multicast (N.O.R.M.), as specified 
in RFC5740.

The NORM protocol is designed to provide end-to-end reliable transport of 
bulk data objects or streams over generic IP multicast routing and 
forwarding services. NORM uses a selective, negative acknowledgement 
(NACK) mechanism for transport reliability and offers additional protocol 
mechanisms to conduct reliable multicast sessions with limited "a priori" 
coordination among senders and receivers. A congestion control scheme is 
specified to allow the NORM protocol fairly share available network 
bandwidth with other transport protocols such as Transmission Control 
Protocol (TCP). It is capable of operating with both reciprocal multicast 
routing among senders and receivers and with asymmetric connectivity 
(possibly a unicast return path) from the senders to receivers. The 
protocol offers a number of features to allow different types of 
applications or possibly other higher level transport protocols to utilize 
its service in different ways. The protocol leverages the use of FEC-based 
repair and other IETF reliable multicast transport (RMT) building blocks 
in its design.


[FILE:250:distinfo]
9f1fece22d861aebd79b89ff8b45f623471c40177a24cc0d5f81cb719c8c6ffe      1658306 USNavalResearchLaboratory-norm-1.5.9.tar.gz
9dd572238c231edbab2b2ab78d6938396ddcf3354655ae0a81e51fef662947eb      1284131 USNavalResearchLaboratory-protolib-702e909.tar.gz


[FILE:155:manifests/plist.single]
include/normApi.h
lib/
 libnorm.so
 libprotokit.a
lib/cmake/norm/
 normConfig.cmake
 normConfigVersion.cmake
 normTargets-release.cmake
 normTargets.cmake


[FILE:341:patches/patch-protolib_CMakeLists.txt]
--- protolib/CMakeLists.txt.orig	2021-02-01 04:02:34 UTC
+++ protolib/CMakeLists.txt
@@ -20,6 +20,8 @@ include(CheckTypeSize)
 include(CheckIncludeFiles)
 include(CheckLibraryExists)
 
+list(APPEND PLATFORM_FLAGS -fPIC)
+
 check_include_files( pcap.h HAVE_PCAP_H)
 if(HAVE_PCAP_H)
 	#list(APPEND PLATFORM_SOURCE_FILES ${COMMON}/pcapCap.cpp)


[FILE:720:patches/patch-protolib_include_protoSocket.h]
--- protolib/include/protoSocket.h.orig	2021-01-17 15:48:09 UTC
+++ protolib/include/protoSocket.h
@@ -106,7 +106,7 @@ class ProtoSocket : public ProtoNotify
 // On Mac OSX, only version 10.7 and later support IGMPv3 
 // and the "MCAST_JOIN_GROUP" macro definition is a "tell" for this
 // (we _reallly_ need to go to a more sophisticated build system!)
-#if (!defined(WIN32) && !defined(ANDROID) && (!defined(MACOSX))) || (defined(MACOSX) && defined(MCAST_JOIN_GROUP))
+#if (!defined(WIN32) && !defined(ANDROID) && !defined(__DragonFly__) &&(!defined(MACOSX))) || (defined(MACOSX) && defined(MCAST_JOIN_GROUP)) 
 #define _PROTOSOCKET_IGMPV3_SSM
 #endif // !WIN32 && !ANDROID && (!MACOSX || MCAST_JOIN_GROUP)
         


[FILE:7148:files/getifaddrs.cpp]
/*
 * CDDL HEADER START
 *
 * The contents of this file are subject to the terms of the
 * Common Development and Distribution License (the "License").
 * You may not use this file except in compliance with the License.
 *
 * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
 * or http://www.opensolaris.org/os/licensing.
 * See the License for the specific language governing permissions
 * and limitations under the License.
 *
 * When distributing Covered Code, include this CDDL HEADER in each
 * file and include the License file at usr/src/OPENSOLARIS.LICENSE.
 * If applicable, add the following below this CDDL HEADER, with the
 * fields enclosed by brackets "[]" replaced with your own identifying
 * information: Portions Copyright [yyyy] [name of copyright owner]
 *
 * CDDL HEADER END
 */

/*
 * Copyright (c) 2010, Oracle and/or its affiliates. All rights reserved.
 */

#include <netdb.h>

#include <netinet/in.h>
#include <sys/socket.h>
#include <string.h>
#include <stdio.h>
#include <errno.h>
#include <sys/sockio.h>
#include <sys/types.h>
#include <stdlib.h>
#include <unistd.h>
#include <net/if.h>
#include <ifaddrs.h>

/* Normally this is defined in <net/if.h> but was new for Solaris 11 */
#ifndef LIFC_ENABLED
#define LIFC_ENABLED    0x20
#endif

int getallifaddrs(sa_family_t af, struct ifaddrs **ifap, int64_t flags);
int getallifs(int s, sa_family_t af, struct lifreq **lifr, int *numifs,
    int64_t lifc_flags);

/*
 * Create a linked list of `struct ifaddrs_rsys' structures, one for each
 * address that is UP. If successful, store the list in *ifap and
 * return 0.  On errors, return -1 and set `errno'.
 *
 * The storage returned in *ifap is allocated dynamically and can
 * only be properly freed by passing it to `freeifaddrs'.
 */
int
getifaddrs(struct ifaddrs **ifap)
{
	int		err;
	char		*cp;
	struct ifaddrs  *curr;

	if (ifap == NULL) {
		errno = EINVAL;
		return (-1);
	}
	*ifap = NULL;
	err = getallifaddrs(AF_UNSPEC, ifap, LIFC_ENABLED);
	if (err == 0) {
		for (curr = *ifap; curr != NULL; curr = curr->ifa_next) {
			if ((cp = strchr(curr->ifa_name, ':')) != NULL)
				*cp = '\0';
		}
	}
	return (err);
}

void
freeifaddrs(struct ifaddrs *ifa)
{
	struct ifaddrs *curr;

	while (ifa != NULL) {
		curr = ifa;
		ifa = ifa->ifa_next;
		free(curr->ifa_name);
		free(curr->ifa_addr);
		free(curr->ifa_netmask);
		free(curr->ifa_dstaddr);
		free(curr);
	}
}

/*
 * Returns all addresses configured on the system. If flags contain
 * LIFC_ENABLED, only the addresses that are UP are returned.
 * Address list that is returned by this function must be freed
 * using freeifaddrs().
 */
int
getallifaddrs(sa_family_t af, struct ifaddrs **ifap, int64_t flags)
{
	struct lifreq *buf = NULL;
	struct lifreq *lifrp;
	struct lifreq lifrl;
	int ret;
	int s, n, numifs;
	struct ifaddrs *curr, *prev;
	sa_family_t lifr_af;
	int sock4;
	int sock6;
	int err;

	if ((sock4 = socket(AF_INET, SOCK_DGRAM, 0)) < 0)
		return (-1);
	if ((sock6 = socket(AF_INET6, SOCK_DGRAM, 0)) < 0) {
		err = errno;
		close(sock4);
		errno = err;
		return (-1);
	}

retry:
	/* Get all interfaces from SIOCGLIFCONF */
	ret = getallifs(sock4, af, &buf, &numifs, (flags & ~LIFC_ENABLED));
	if (ret != 0)
		goto fail;

	/*
	 * Loop through the interfaces obtained from SIOCGLIFCOMF
	 * and retrieve the addresses, netmask and flags.
	 */
	prev = NULL;
	lifrp = buf;
	*ifap = NULL;
	for (n = 0; n < numifs; n++, lifrp++) {

		/* Prepare for the ioctl call */
		(void) strncpy(lifrl.lifr_name, lifrp->lifr_name,
		    sizeof (lifrl.lifr_name));
		lifr_af = lifrp->lifr_addr.ss_family;
		if (af != AF_UNSPEC && lifr_af != af)
			continue;

		s = (lifr_af == AF_INET ? sock4 : sock6);

		if (ioctl(s, SIOCGLIFFLAGS, (caddr_t)&lifrl) < 0)
			goto fail;
		if ((flags & LIFC_ENABLED) && !(lifrl.lifr_flags & IFF_UP))
			continue;

		/*
		 * Allocate the current list node. Each node contains data
		 * for one ifaddrs structure.
		 */
		curr = (struct ifaddrs *) calloc(1, sizeof (struct ifaddrs));
		if (curr == NULL)
			goto fail;

		if (prev != NULL) {
			prev->ifa_next = curr;
		} else {
			/* First node in the linked list */
			*ifap = curr;
		}
		prev = curr;

		curr->ifa_flags = lifrl.lifr_flags;
		if ((curr->ifa_name = strdup(lifrp->lifr_name)) == NULL)
			goto fail;

		curr->ifa_addr = (struct sockaddr *) malloc(sizeof (struct sockaddr_storage));
		if (curr->ifa_addr == NULL)
			goto fail;
		(void) memcpy(curr->ifa_addr, &lifrp->lifr_addr,
		    sizeof (struct sockaddr_storage));

		/* Get the netmask */
		if (ioctl(s, SIOCGLIFNETMASK, (caddr_t)&lifrl) < 0)
			goto fail;
		curr->ifa_netmask = (struct sockaddr *) malloc(sizeof (struct sockaddr_storage));
		if (curr->ifa_netmask == NULL)
			goto fail;
		(void) memcpy(curr->ifa_netmask, &lifrl.lifr_addr,
		    sizeof (struct sockaddr_storage));

		/* Get the destination for a pt-pt interface */
		if (curr->ifa_flags & IFF_POINTOPOINT) {
			if (ioctl(s, SIOCGLIFDSTADDR, (caddr_t)&lifrl) < 0)
				goto fail;
			curr->ifa_dstaddr = (struct sockaddr *) malloc(
			    sizeof (struct sockaddr_storage));
			if (curr->ifa_dstaddr == NULL)
				goto fail;
			(void) memcpy(curr->ifa_dstaddr, &lifrl.lifr_addr,
			    sizeof (struct sockaddr_storage));
		} else if (curr->ifa_flags & IFF_BROADCAST) {
			if (ioctl(s, SIOCGLIFBRDADDR, (caddr_t)&lifrl) < 0)
				goto fail;
			curr->ifa_broadaddr = (struct sockaddr *) malloc(
			    sizeof (struct sockaddr_storage));
			if (curr->ifa_broadaddr == NULL)
				goto fail;
			(void) memcpy(curr->ifa_broadaddr, &lifrl.lifr_addr,
			    sizeof (struct sockaddr_storage));
		}

	}
	free(buf);
	close(sock4);
	close(sock6);
	return (0);
fail:
	err = errno;
	free(buf);
	freeifaddrs(*ifap);
	*ifap = NULL;
	if (err == ENXIO)
		goto retry;
	close(sock4);
	close(sock6);
	errno = err;
	return (-1);
}

/*
 * Do a SIOCGLIFCONF and store all the interfaces in `buf'.
 */
int
getallifs(int s, sa_family_t af, struct lifreq **lifr, int *numifs,
    int64_t lifc_flags)
{
	struct lifnum lifn;
	struct lifconf lifc;
	size_t bufsize;
	char *tmp;
	caddr_t *buf = (caddr_t *)lifr;

	lifn.lifn_family = af;
	lifn.lifn_flags = lifc_flags;

	*buf = NULL;
retry:
	if (ioctl(s, SIOCGLIFNUM, &lifn) < 0)
		goto fail;

	/*
	 * When calculating the buffer size needed, add a small number
	 * of interfaces to those we counted.  We do this to capture
	 * the interface status of potential interfaces which may have
	 * been plumbed between the SIOCGLIFNUM and the SIOCGLIFCONF.
	 */
	bufsize = (lifn.lifn_count + 4) * sizeof (struct lifreq);

	if ((tmp = (char *) realloc(*buf, bufsize)) == NULL)
		goto fail;

	*buf = tmp;
	lifc.lifc_family = af;
	lifc.lifc_flags = lifc_flags;
	lifc.lifc_len = bufsize;
	lifc.lifc_buf = *buf;
	if (ioctl(s, SIOCGLIFCONF, (char *)&lifc) < 0)
		goto fail;

	*numifs = lifc.lifc_len / sizeof (struct lifreq);
	if (*numifs >= (lifn.lifn_count + 4)) {
		/*
		 * If every entry was filled, there are probably
		 * more interfaces than (lifn.lifn_count + 4).
		 * Redo the ioctls SIOCGLIFNUM and SIOCGLIFCONF to
		 * get all the interfaces.
		 */
		goto retry;
	}
	return (0);
fail:
	free(*buf);
	*buf = NULL;
	return (-1);
}


[FILE:2466:files/ifaddrs.h]
/*
 * CDDL HEADER START
 *
 * The contents of this file are subject to the terms of the
 * Common Development and Distribution License (the "License").
 * You may not use this file except in compliance with the License.
 *
 * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
 * or http://www.opensolaris.org/os/licensing.
 * See the License for the specific language governing permissions
 * and limitations under the License.
 *
 * When distributing Covered Code, include this CDDL HEADER in each
 * file and include the License file at usr/src/OPENSOLARIS.LICENSE.
 * If applicable, add the following below this CDDL HEADER, with the
 * fields enclosed by brackets "[]" replaced with your own identifying
 * information: Portions Copyright [yyyy] [name of copyright owner]
 *
 * CDDL HEADER END
 */
/*
 * Copyright (c) 2010, Oracle and/or its affiliates. All rights reserved.
 */
#ifndef _IFADDRS_H
#define	_IFADDRS_H

#ifdef	__cplusplus
extern "C" {
#endif

#include <sys/types.h>

/*
 * The `getifaddrs' function generates a linked list of these structures.
 * Each element of the list describes one network interface.
 */
struct ifaddrs {
	struct ifaddrs	*ifa_next;	/* Pointer to the next structure. */
	char		*ifa_name;	/* Name of this network interface. */
	uint64_t	ifa_flags;	/* Flags as from SIOCGLIFFLAGS ioctl. */
	struct sockaddr	*ifa_addr;	/* Network address of this interface. */
	struct sockaddr	*ifa_netmask;	/* Netmask of this interface. */
	union {
		/*
		 * At most one of the following two is valid.  If the
		 * IFF_BROADCAST bit is set in `ifa_flags', then
		 * `ifa_broadaddr' is valid.  If the IFF_POINTOPOINT bit is
		 * set, then `ifa_dstaddr' is valid. It is never the case that
		 * both these bits are set at once.
		 */
		struct sockaddr	*ifu_broadaddr;
		struct sockaddr	*ifu_dstaddr;
	} ifa_ifu;
	void		*ifa_data; /* Address-specific data (may be unused). */
};

/*
 * Create a linked list of `struct ifaddrs' structures, one for each
 * network interface on the host machine.  If successful, store the
 * list in *ifap and return 0.  On errors, return -1 and set `errno'.
 *
 * The storage returned in *ifap is allocated dynamically and can
 * only be properly freed by passing it to `freeifaddrs'.
 */
extern int getifaddrs(struct ifaddrs **);

/* Reclaim the storage allocated by a previous `getifaddrs' call. */
extern void freeifaddrs(struct ifaddrs *);


#ifdef	__cplusplus
}
#endif

#endif	/* _IFADDRS_H */


[FILE:2358:sunos/patch-protolib_include_protoPktIP.h]
--- protolib/include/protoPktIP.h.orig	2021-02-01 04:25:51 UTC
+++ protolib/include/protoPktIP.h
@@ -69,7 +69,7 @@ class ProtoPktIP : public ProtoPkt
             RTG      =  43,  // IPv6 routing header
             FRAG     =  44,  // IPv6 fragment header
             GRE      =  47,  // Generic Router Encapsulation
-            ESP      =  50,  // Encapsulation security payload header
+            ESPXX      =  50,  // Encapsulation security payload header
             AUTH     =  51,  // authentication/ESP header  
             MOBILE   =  55,  // IP Moobility (Min Encap)                
             ICMPv6   =  58,  // ICMP for IPv6 
@@ -140,7 +140,7 @@ class ProtoPktIPv4 : public ProtoPktIP
                 {
                     EOOL   =      0, // End of Options List    [RFC791,JBP]                            
                     NOP    =      1, // No Operation           [RFC791,JBP]                            
-                    SEC    =    130, // Security                  [RFC1108]                            
+                    SECXX  =    130, // Security                  [RFC1108]                            
                     LSR    =    131, // Loose Source Route     [RFC791,JBP]                            
                     TS     =     68, // Time Stamp             [RFC791,JBP]                            
                     ESEC   =    133, // Extended Security         [RFC1108]                            
@@ -155,7 +155,7 @@ class ProtoPktIPv4 : public ProtoPktIP
                     VISA   =    142, // Expermental Access Control [Estrin]                            
                     ENCODE =     15, // ???                      [VerSteeg]                            
                     IMITD  =    144, // IMI Traffic Descriptor        [Lee]                            
-                    EIP    =    145, // Extended Internet Protocol[RFC1385]                            
+                    EIPXX  =    145, // Extended Internet Protocol[RFC1385]                            
                     TR     =     82, // Traceroute        [RFC1393]                                    
                     ADDEXT =    147, // Address Extension    [Ullmann IPv7]                            
                     RTRALT =    148, // Router Alert              [RFC2113]                            


[FILE:334:sunos/patch-protolib_src_common_protoAddress.cpp]
--- protolib/src/common/protoAddress.cpp.orig	2018-07-20 21:58:26 UTC
+++ protolib/src/common/protoAddress.cpp
@@ -552,6 +552,9 @@ bool ProtoAddress::SetSockAddr(const str
     }
 }  // end ProtoAddress:SetAddress()
 
+#undef _SOCKLEN_T
+#undef _SOCKLEN_T_DECLARED
+
 /**
 *
 * @brief Initializes the address from the buffer contents


[FILE:842:sunos/patch-protolib_src_common_protoPktIP.cpp]
--- protolib/src/common/protoPktIP.cpp.orig	2018-07-20 22:06:04 UTC
+++ protolib/src/common/protoPktIP.cpp
@@ -339,7 +339,7 @@ int ProtoPktIPv4::Option::GetLengthByTyp
         case EOOL:
         case NOP:
             return 1;
-        case SEC:
+        case SECXX:
             return 11;
         case SID:
         case MTUP:
@@ -354,7 +354,7 @@ int ProtoPktIPv4::Option::GetLengthByTyp
         case TS:
         case TR:
         case SDB:
-        case EIP:
+        case EIPXX:
         case CIPSO:
             return LENGTH_VARIABLE; // indicates variable length
         // unsupported options 
@@ -371,7 +371,7 @@ bool ProtoPktIPv4::Option::IsMutable(Typ
         // Immutable options
         case EOOL:
         case NOP:
-        case SEC:
+        case SECXX:
         case ESEC:
         case CIPSO:
         case RTRALT:

