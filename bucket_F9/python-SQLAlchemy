# Buildsheet autogenerated by ravenadm tool -- Do not edit.

NAMEBASE=		python-SQLAlchemy
VERSION=		2.0.39
KEYWORDS=		python
VARIANTS=		v12 v13
SDESC[v12]=		Database Abstraction Library (3.12)
SDESC[v13]=		Database Abstraction Library (3.13)
HOMEPAGE=		https://www.sqlalchemy.org
CONTACT=		Python_Automaton[python@ironwolf.systems]

DOWNLOAD_GROUPS=	main
SITES[main]=		PYPIWHL/7b/0f/d69904cb7d17e65c65713303a244ec91fd3c96677baf1d6331457fd47e16
DISTFILE[1]=		sqlalchemy-2.0.39-py3-none-any.whl:main
DIST_SUBDIR=		python-src
DF_INDEX=		1
SPKGS[v12]=		single
SPKGS[v13]=		single

OPTIONS_AVAILABLE=	PY312 PY313
OPTIONS_STANDARD=	none
VOPTS[v12]=		PY312=ON PY313=OFF
VOPTS[v13]=		PY312=OFF PY313=ON

USES=			cpe

DISTNAME=		sqlalchemy-2.0.39.dist-info

CPE_PRODUCT=		sqlalchemy
CPE_VENDOR=		sqlalchemy
GENERATED=		yes

[PY312].RUN_DEPENDS_ON=			python-typing-extensions:single:v12
[PY312].USES_ON=			python:v12,wheel

[PY313].RUN_DEPENDS_ON=			python-typing-extensions:single:v13
[PY313].USES_ON=			python:v13,wheel

[FILE:3699:descriptions/desc.single]
SQLAlchemy
==========

|PyPI| |Python| |Downloads|

    :alt: PyPI

    :alt: PyPI - Python Version

    :alt: PyPI - Downloads

The Python SQL Toolkit and Object Relational Mapper

Introduction
-------------

SQLAlchemy is the Python SQL toolkit and Object Relational Mapper
that gives application developers the full power and
flexibility of SQL. SQLAlchemy provides a full suite
of well known enterprise-level persistence patterns,
designed for efficient and high-performing database
access, adapted into a simple and Pythonic domain
language.

Major SQLAlchemy features include:

* An industrial strength ORM, built
  from the core on the identity map, unit of work,
  and data mapper patterns.   These patterns
  allow transparent persistence of objects
  using a declarative configuration system.
  Domain models
  can be constructed and manipulated naturally,
  and changes are synchronized with the
  current transaction automatically.
* A relationally-oriented query system, exposing
  the full range of SQL's capabilities
  explicitly, including joins, subqueries,
  correlation, and most everything else,
  in terms of the object model.
  Writing queries with the ORM uses the same
  techniques of relational composition you use
  when writing SQL.  While you can drop into
  literal SQL at any time, it's virtually never
  needed.
* A comprehensive and flexible system
  of eager loading for related collections and objects.
  Collections are cached within a session,
  and can be loaded on individual access, all
  at once using joins, or by query per collection
  across the full result set.
* A Core SQL construction system and DBAPI
  interaction layer.  The SQLAlchemy Core is
  separate from the ORM and is a full database
  abstraction layer in its own right, and includes
  an extensible Python-based SQL expression
  language, schema metadata, connection pooling,
  type coercion, and custom types.
* All primary and foreign key constraints are
  assumed to be composite and natural.  Surrogate
  integer primary keys are of course still the
  norm, but SQLAlchemy never assumes or hardcodes
  to this model.
* Database introspection and generation.  Database
  schemas can be "reflected" in one step into
  Python structures representing database metadata;
  those same structures can then generate
  CREATE statements right back out - all within
  the Core, independent of the ORM.

SQLAlchemy's philosophy:

* SQL databases behave less and less like object
  collections the more size and performance start to
  matter; object collections behave less and less like
  tables and rows the more abstraction starts to matter.
  SQLAlchemy aims to accommodate both of these
  principles.
* An ORM doesn't need to hide the "R".   A relational
  database provides rich, set-based functionality
  that should be fully exposed.   SQLAlchemy's
  ORM provides an open-ended set of patterns
  that allow a developer to construct a custom
  mediation layer between a domain model and
  a relational schema, turning the so-called
  "object relational impedance" issue into
  a distant memory.
* The developer, in all cases, makes all decisions
  regarding the design, structure, and naming conventions
  of both the object model as well as the relational
  schema.   SQLAlchemy only provides the means
  to automate the execution of these decisions.
* With SQLAlchemy, there's no such thing as
  "the ORM generated a bad query" - you
  retain full control over the structure of
  queries, including how joins are organized,
  how subqueries and correlation is used, what
  columns are requested.  Everything SQLAlchemy
  does is ultimately the result of a developer-initiated 
  decision.


[FILE:124:distinfo]
a1c6b0a5e3e326a466d809b651c63f278b1256146a377a528b6938a279da334f      1898621 python-src/sqlalchemy-2.0.39-py3-none-any.whl

