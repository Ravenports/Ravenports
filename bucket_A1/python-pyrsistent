# Buildsheet autogenerated by ravenadm tool -- Do not edit.

NAMEBASE=		python-pyrsistent
VERSION=		0.20.0
KEYWORDS=		python
VARIANTS=		v12 v13
SDESC[v12]=		Persistent, Immutable data structures (3.12)
SDESC[v13]=		Persistent, Immutable data structures (3.13)
HOMEPAGE=		https://github.com/tobgu/pyrsistent/
CONTACT=		Python_Automaton[python@ironwolf.systems]

DOWNLOAD_GROUPS=	main
SITES[main]=		PYPIWHL/23/88/0acd180010aaed4987c85700b7cc17f9505f3edb4e5873e4dc67f613e338
DISTFILE[1]=		pyrsistent-0.20.0-py3-none-any.whl:main
DIST_SUBDIR=		python-src
DF_INDEX=		1
SPKGS[v12]=		single
SPKGS[v13]=		single

OPTIONS_AVAILABLE=	PY312 PY313
OPTIONS_STANDARD=	none
VOPTS[v12]=		PY312=ON PY313=OFF
VOPTS[v13]=		PY312=OFF PY313=ON

DISTNAME=		pyrsistent-0.20.0.dist-info

GENERATED=		yes

[PY312].USES_ON=			python:v12,wheel

[PY313].USES_ON=			python:v13,wheel

[FILE:3797:descriptions/desc.single]
Pyrsistent
==========

.. _Pyrthon: https://www.github.com/tobgu/pyrthon
.. _Pyrsistent_extras: https://github.com/mingmingrr/pyrsistent-extras

Pyrsistent is a number of persistent collections (by some referred to as
functional data structures). Persistent in
the sense that they are immutable.

All methods on a data structure that would normally mutate it instead
return a new copy of the structure containing the
requested updates. The original structure is left untouched.

This will simplify the reasoning about what a program does since no hidden
side effects ever can take place to these
data structures. You can rest assured that the object you hold a reference
to will remain the same throughout its
lifetime and need not worry that somewhere five stack levels below you in
the darkest corner of your application
someone has decided to remove that element that you expected to be there.

Pyrsistent is influenced by persistent data structures such as those found
in the standard library of Clojure. The
data structures are designed to share common elements through path copying.
It aims at taking these concepts and make them as pythonic as possible so
that they can be easily integrated into any python
program without hassle.

If you want use literal syntax to define them in your code rather
than function calls check out Pyrthon_. Be aware, that one is experimental,
unmaintained and alpha software. 

If you cannot find the persistent data structure you're looking for here
you may want to take a look at
Pyrsistent_extras_ which is maintained by @mingmingrr. If you still don't
find what you're looking for please
open an issue for discussion. If we agree that functionality is missing you
may want to go ahead and create
a Pull Request implement the missing functionality.

Examples
--------
.. _Sequence: collections_
.. _Hashable: collections_
.. _Mapping: collections_
.. _Mappings: collections_
.. _Set: collections_
.. _collections: https://docs.python.org/3/library/collections.abc.html
.. _documentation: http://pyrsistent.readthedocs.org/

The collection types and key features currently implemented are:

* PVector_, similar to a python list
* PMap_, similar to dict
* PSet_, similar to set
* PRecord_, a PMap on steroids with fixed fields, optional type and
invariant checking and much more
* PClass_, a Python class fixed fields, optional type and invariant
checking and much more
* `Checked collections`_, PVector, PMap and PSet with optional type and
invariance checks and more
* PBag, similar to collections.Counter
* PList, a classic singly linked list
* PDeque, similar to collections.deque
* Immutable object type (immutable) built on the named tuple
* freeze_ and thaw_ functions to convert between pythons standard
collections and pyrsistent collections.
* Flexible transformations_ of arbitrarily complex structures built from
PMaps and PVectors.

Below are examples of common usage patterns for some of the structures and
features. More information and
full documentation for all data structures is available in the
documentation_.

.. _PVector:

PVector
~~~~~~~
With full support for the Sequence_ protocol PVector is meant as a drop in
replacement to the built in list from a readers
point of view. Write operations of course differ since no in place mutation
is done but naming should be in line
with corresponding operations on the built in list.

Support for the Hashable_ protocol also means that it can be used as key in
Mappings_.

Appends are amortized O(1). Random access and insert is log32(n) where n is
the size of the vector.

.. code:: python

    >>> from pyrsistent import v, pvector

    # No mutation of vectors once created, instead they
    # are "evolved" leaving the original untouched
    >>> v1 = v(1, 2, 3)
    >>> v2 = v1.append(4)


[FILE:124:distinfo]
c55acc4733aad6560a7f5f818466631f07efc001fd023f34a6c203f8b6df0f0b        58106 python-src/pyrsistent-0.20.0-py3-none-any.whl

