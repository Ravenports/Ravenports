# Buildsheet autogenerated by ravenadm tool -- Do not edit.

NAMEBASE=		python-pyrsistent
VERSION=		0.19.2
KEYWORDS=		python
VARIANTS=		py310 py311
SDESC[py310]=		Persistent, Immutable data structures (3.10)
SDESC[py311]=		Persistent, Immutable data structures (3.11)
HOMEPAGE=		https://github.com/tobgu/pyrsistent/
CONTACT=		Python_Automaton[python@ironwolf.systems]

DOWNLOAD_GROUPS=	main
SITES[main]=		PYPIWHL/54/d3/986fcfeaf62047840c571a857fb8f3ad1e9622081d5e7d0ee5e3451ca2e7
DISTFILE[1]=		pyrsistent-0.19.2-py3-none-any.whl:main
DF_INDEX=		1
SPKGS[py310]=		single
SPKGS[py311]=		single

OPTIONS_AVAILABLE=	PY310 PY311
OPTIONS_STANDARD=	none
VOPTS[py310]=		PY310=ON PY311=OFF
VOPTS[py311]=		PY310=OFF PY311=ON

DISTNAME=		pyrsistent-0.19.2.dist-info

GENERATED=		yes

[PY310].USES_ON=			python:py310,wheel

[PY311].USES_ON=			python:py311,wheel

[FILE:3519:descriptions/desc.single]
Pyrsistent
==========

.. _Pyrthon: https://www.github.com/tobgu/pyrthon/

Pyrsistent is a number of persistent collections (by some referred to as
functional data structures). Persistent in
the sense that they are immutable.

All methods on a data structure that would normally mutate it instead
return a new copy of the structure containing the
requested updates. The original structure is left untouched.

This will simplify the reasoning about what a program does since no hidden
side effects ever can take place to these
data structures. You can rest assured that the object you hold a reference
to will remain the same throughout its
lifetime and need not worry that somewhere five stack levels below you in
the darkest corner of your application
someone has decided to remove that element that you expected to be there.

Pyrsistent is influenced by persistent data structures such as those found
in the standard library of Clojure. The
data structures are designed to share common elements through path copying.
It aims at taking these concepts and make them as pythonic as possible so
that they can be easily integrated into any python
program without hassle.

If you want use literal syntax to define them in your code rather
than function calls check out Pyrthon_. Be aware, that one is experimental,
unmaintained and alpha software. 

Examples
--------
.. _Sequence: collections_
.. _Hashable: collections_
.. _Mapping: collections_
.. _Mappings: collections_
.. _Set: collections_
.. _collections: https://docs.python.org/3/library/collections.abc.html
.. _documentation: http://pyrsistent.readthedocs.org/

The collection types and key features currently implemented are:

* PVector_, similar to a python list
* PMap_, similar to dict
* PSet_, similar to set
* PRecord_, a PMap on steroids with fixed fields, optional type and
invariant checking and much more
* PClass_, a Python class fixed fields, optional type and invariant
checking and much more
* `Checked collections`_, PVector, PMap and PSet with optional type and
invariance checks and more
* PBag, similar to collections.Counter
* PList, a classic singly linked list
* PDeque, similar to collections.deque
* Immutable object type (immutable) built on the named tuple
* freeze_ and thaw_ functions to convert between pythons standard
collections and pyrsistent collections.
* Flexible transformations_ of arbitrarily complex structures built from
PMaps and PVectors.

Below are examples of common usage patterns for some of the structures and
features. More information and
full documentation for all data structures is available in the
documentation_.

.. _PVector:

PVector
~~~~~~~
With full support for the Sequence_ protocol PVector is meant as a drop in
replacement to the built in list from a readers
point of view. Write operations of course differ since no in place mutation
is done but naming should be in line
with corresponding operations on the built in list.

Support for the Hashable_ protocol also means that it can be used as key in
Mappings_.

Appends are amortized O(1). Random access and insert is log32(n) where n is
the size of the vector.

.. code:: python

    >>> from pyrsistent import v, pvector

    # No mutation of vectors once created, instead they
    # are "evolved" leaving the original untouched
    >>> v1 = v(1, 2, 3)
    >>> v2 = v1.append(4)
    >>> v3 = v2.set(1, 5)
    >>> v1
    pvector([1, 2, 3])
    >>> v2
    pvector([1, 2, 3, 4])
    >>> v3
    pvector([1, 5, 3, 4])

    # Random access and slicing


[FILE:113:distinfo]
ea6b79a02a28550c98b6ca9c35b9f492beaa54d7c5c9e9949555893c8a9234d0        57455 pyrsistent-0.19.2-py3-none-any.whl

