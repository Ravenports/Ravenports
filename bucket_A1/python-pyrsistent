# Buildsheet autogenerated by ravenadm tool -- Do not edit.

NAMEBASE=		python-pyrsistent
VERSION=		0.17.3
KEYWORDS=		python
VARIANTS=		py38 py39
SDESC[py38]=		Persistent, Immutable data structures (PY38)
SDESC[py39]=		Persistent, Immutable data structures (PY39)
HOMEPAGE=		https://github.com/tobgu/pyrsistent/
CONTACT=		Python_Automaton[python@ironwolf.systems]

DOWNLOAD_GROUPS=	main
SITES[main]=		PYPI/p/pyrsistent
DISTFILE[1]=		pyrsistent-0.17.3.tar.gz:main
DF_INDEX=		1
SPKGS[py38]=		single
SPKGS[py39]=		single

OPTIONS_AVAILABLE=	PY38 PY39
OPTIONS_STANDARD=	none
VOPTS[py38]=		PY38=ON PY39=OFF
VOPTS[py39]=		PY38=OFF PY39=ON

DISTNAME=		pyrsistent-0.17.3

GENERATED=		yes

[PY38].USES_ON=				python:py38

[PY39].USES_ON=				python:py39

[FILE:3496:descriptions/desc.single]
Pyrsistent
==========

.. _Pyrthon: https://www.github.com/tobgu/pyrthon/

Pyrsistent is a number of persistent collections (by some referred to as
functional data structures). Persistent in
the sense that they are immutable.

All methods on a data structure that would normally mutate it instead
return a new copy of the structure containing the
requested updates. The original structure is left untouched.

This will simplify the reasoning about what a program does since no hidden
side effects ever can take place to these
data structures. You can rest assured that the object you hold a reference
to will remain the same throughout its
lifetime and need not worry that somewhere five stack levels below you in
the darkest corner of your application
someone has decided to remove that element that you expected to be there.

Pyrsistent is influenced by persistent data structures such as those found
in the standard library of Clojure. The
data structures are designed to share common elements through path copying.
It aims at taking these concepts and make them as pythonic as possible so
that they can be easily integrated into any python
program without hassle.

If you want to go all in on persistent data structures and use literal
syntax to define them in your code rather
than function calls check out Pyrthon_.

Examples
--------
.. _Sequence: collections_
.. _Hashable: collections_
.. _Mapping: collections_
.. _Mappings: collections_
.. _Set: collections_
.. _collections: https://docs.python.org/3/library/collections.abc.html
.. _documentation: http://pyrsistent.readthedocs.org/

The collection types and key features currently implemented are:

* PVector_, similar to a python list
* PMap_, similar to dict
* PSet_, similar to set
* PRecord_, a PMap on steroids with fixed fields, optional type and
invariant checking and much more
* PClass_, a Python class fixed fields, optional type and invariant
checking and much more
* `Checked collections`_, PVector, PMap and PSet with optional type and
invariance checks and more
* PBag, similar to collections.Counter
* PList, a classic singly linked list
* PDeque, similar to collections.deque
* Immutable object type (immutable) built on the named tuple
* freeze_ and thaw_ functions to convert between pythons standard
collections and pyrsistent collections.
* Flexible transformations_ of arbitrarily complex structures built from
PMaps and PVectors.

Below are examples of common usage patterns for some of the structures and
features. More information and
full documentation for all data structures is available in the
documentation_.

.. _PVector:

PVector
~~~~~~~
With full support for the Sequence_ protocol PVector is meant as a drop in
replacement to the built in list from a readers
point of view. Write operations of course differ since no in place mutation
is done but naming should be in line
with corresponding operations on the built in list.

Support for the Hashable_ protocol also means that it can be used as key in
Mappings_.

Appends are amortized O(1). Random access and insert is log32(n) where n is
the size of the vector.

.. code:: python

    >>> from pyrsistent import v, pvector

    # No mutation of vectors once created, instead they
    # are "evolved" leaving the original untouched
    >>> v1 = v(1, 2, 3)
    >>> v2 = v1.append(4)
    >>> v3 = v2.set(1, 5)
    >>> v1
    pvector([1, 2, 3])
    >>> v2
    pvector([1, 2, 3, 4])
    >>> v3
    pvector([1, 5, 3, 4])

    # Random access and slicing


[FILE:103:distinfo]
2e636185d9eb976a18a8a8e96efce62f2905fea90041958d8cc2a189756ebf3e       106911 pyrsistent-0.17.3.tar.gz

