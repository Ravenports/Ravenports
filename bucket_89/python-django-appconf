# Buildsheet autogenerated by ravenadm tool -- Do not edit.

NAMEBASE=		python-django-appconf
VERSION=		1.0.6
KEYWORDS=		python
VARIANTS=		v12 v13
SDESC[v12]=		Django configure defaults helper class (3.12)
SDESC[v13]=		Django configure defaults helper class (3.13)
HOMEPAGE=		https://django-appconf.readthedocs.io/
CONTACT=		Python_Automaton[python@ironwolf.systems]

DOWNLOAD_GROUPS=	main
SITES[main]=		PYPIWHL/c0/98/1cb3d9e8b1c6d0a74539b998474796fc5c0c0888b6201e5c95ba2f7a0677
DISTFILE[1]=		django_appconf-1.0.6-py3-none-any.whl:main
DF_INDEX=		1
SPKGS[v12]=		single
SPKGS[v13]=		single

OPTIONS_AVAILABLE=	PY312 PY313
OPTIONS_STANDARD=	none
VOPTS[v12]=		PY312=ON PY313=OFF
VOPTS[v13]=		PY312=OFF PY313=ON

DISTNAME=		django_appconf-1.0.6.dist-info

GENERATED=		yes

[PY312].RUN_DEPENDS_ON=			python-Django:single:v12
[PY312].USES_ON=			python:v12,wheel

[PY313].RUN_DEPENDS_ON=			python-Django:single:v13
[PY313].USES_ON=			python:v13,wheel

[FILE:2975:descriptions/desc.single]
django-appconf
==============

A helper class for handling configuration defaults of packaged Django
apps gracefully.

.. note::

    This app precedes Django's own AppConfig_ classes that act as
    "objects [to] store metadata for an application" inside Django's
    app loading mechanism. In other words, they solve a related but
    different use case than django-appconf and can't easily be used
    as a replacement. The similarity in name is purely coincidental.

.. _AppConfig:
https://docs.djangoproject.com/en/stable/ref/applications/#django.apps.AppConfig

Overview
--------

Say you have an app called myapp with a few defaults, which you want
to refer to in the app's code without repeating yourself all the time.
appconf provides a simple class to implement those defaults. Simply add
something like the following code somewhere in your app files:

.. code-block:: python

    from appconf import AppConf

    class MyAppConf(AppConf):
        SETTING_1 = "one"
        SETTING_2 = (
            "two",
        )

.. note::

    AppConf classes depend on being imported during startup of the Django
    process. Even though there are multiple modules loaded automatically,
    only the models modules (usually the ``models.py`` file of your
    app) are guaranteed to be loaded at startup. Therefore it's recommended
    to put your AppConf subclass(es) there, too.

The settings are initialized with the capitalized app label of where the
setting is located at. E.g. if your ``models.py with the AppConf class
is in the myapp`` package, the prefix of the settings will be MYAPP.

You can override the default prefix by specifying a prefix attribute of
an inner Meta class:

.. code-block:: python

    from appconf import AppConf

    class AcmeAppConf(AppConf):
        SETTING_1 = "one"
        SETTING_2 = (
            "two",
        )

        class Meta:
            prefix = 'acme'

The MyAppConf class will automatically look at Django's global settings
to determine if you've overridden it. For example, adding this to your
site's
``settings.py would override SETTING_1 of the above MyAppConf``:

.. code-block:: python

    ACME_SETTING_1 = "uno"
    
Since django-appconf completes Django's global settings with its default
values 
(like "one" above), the standard ``python manage.py diffsettings`` will
show 
these defaults automatically.

In case you want to use a different settings object instead of the default
``'django.conf.settings'``, set the holder attribute of the inner
Meta class to a dotted import path:

.. code-block:: python

    from appconf import AppConf

    class MyAppConf(AppConf):
        SETTING_1 = "one"
        SETTING_2 = (
            "two",
        )

        class Meta:
            prefix = 'acme'
            holder = 'acme.conf.settings'

If you ship an AppConf class with your reusable Django app, it's
recommended to put it in a ``conf.py file of your app package and
import django.conf.settings`` in it, too:



[FILE:116:distinfo]
c3ae442fba1ff7ec830412c5184b17169a7a1e71cf0864a4c3f93cf4c98a1993         6424 django_appconf-1.0.6-py3-none-any.whl

