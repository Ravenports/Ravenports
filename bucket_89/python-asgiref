# Buildsheet autogenerated by ravenadm tool -- Do not edit.

NAMEBASE=		python-asgiref
VERSION=		3.3.1
KEYWORDS=		python
VARIANTS=		py38 py39
SDESC[py38]=		ASGI specs, helper code, and adapters (PY38)
SDESC[py39]=		ASGI specs, helper code, and adapters (PY39)
HOMEPAGE=		https://github.com/django/asgiref/
CONTACT=		Python_Automaton[python@ironwolf.systems]

DOWNLOAD_GROUPS=	main
SITES[main]=		PYPIWHL/89/49/5531992efc62f9c6d08a7199dc31176c8c60f7b2548c6ef245f96f29d0d9
DISTFILE[1]=		asgiref-3.3.1-py3-none-any.whl:main
DF_INDEX=		1
SPKGS[py38]=		single
SPKGS[py39]=		single

OPTIONS_AVAILABLE=	PY38 PY39
OPTIONS_STANDARD=	none
VOPTS[py38]=		PY38=ON PY39=OFF
VOPTS[py39]=		PY38=OFF PY39=ON

DISTNAME=		asgiref-3.3.1.dist-info

GENERATED=		yes

[PY38].USES_ON=				python:py38,wheel

[PY39].USES_ON=				python:py39,wheel

[FILE:3473:descriptions/desc.single]
asgiref
=======

ASGI is a standard for Python asynchronous web apps and servers to
communicate
with each other, and positioned as an asynchronous successor to WSGI. You
can
read more at https://asgi.readthedocs.io/en/latest/

This package includes ASGI base libraries, such as:

* Sync-to-async and async-to-sync function wrappers, ``asgiref.sync``
* Server base classes, ``asgiref.server``
* A WSGI-to-ASGI adapter, in ``asgiref.wsgi``

Function wrappers
-----------------

These allow you to wrap or decorate async or sync functions to call them
from
the other style (so you can call async functions from a synchronous thread,
or vice-versa).

In particular:

* AsyncToSync lets a synchronous subthread stop and wait while the async
  function is called on the main thread's event loop, and then control is
  returned to the thread when the async function is finished.

* SyncToAsync lets async code call a synchronous function, which is run in
  a threadpool and control returned to the async coroutine when the
synchronous
  function completes.

The idea is to make it easier to call synchronous APIs from async code and
asynchronous APIs from synchronous code so it's easier to transition code
from
one style to the other. In the case of Channels, we wrap the (synchronous)
Django view system with SyncToAsync to allow it to run inside the
(asynchronous)
ASGI server.

Note that exactly what threads things run in is very specific, and aimed to
keep maximum compatibility with old synchronous code. See
"Synchronous code & Threads" below for a full explanation. By default,
sync_to_async will run all synchronous code in the program in the same
thread for safety reasons; you can disable this for more performance with
``@sync_to_async(thread_sensitive=False)``, but make sure that your code
does
not rely on anything bound to threads (like database connections) when you
do.

Threadlocal replacement
-----------------------

This is a drop-in replacement for ``threading.local`` that works with both
threads and asyncio Tasks. Even better, it will proxy values through from a
task-local context to a thread-local context when you use sync_to_async
to run things in a threadpool, and vice-versa for async_to_sync.

If you instead want true thread- and task-safety, you can set
thread_critical on the Local object to ensure this instead.

Server base classes
-------------------

Includes a StatelessServer class which provides all the hard work of
writing a stateless server (as in, does not handle direct incoming sockets
but instead consumes external streams or sockets to work out what is
happening).

An example of such a server would be a chatbot server that connects out to
a central chat server and provides a "connection scope" per user chatting
to
it. There's only one actual connection, but the server has to separate
things
into several scopes for easier writing of the code.

You can see an example of this being used in [frequensgi].

WSGI-to-ASGI adapter
--------------------

Allows you to wrap a WSGI application so it appears as a valid ASGI
application.

Simply wrap it around your WSGI application like so::

    asgi_application = WsgiToAsgi(wsgi_application)

The WSGI application will be run in a synchronous threadpool, and the
wrapped
ASGI application will be one that accepts http class messages.

Please note that not all extended features of WSGI may be supported (such
as
file handles for incoming POST bodies).

Dependencies
------------


[FILE:109:distinfo]
5ee950735509d04eb673bd7f7120f8fa1c9e2df495394992c73234d526907e17        19983 asgiref-3.3.1-py3-none-any.whl

