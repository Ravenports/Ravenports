# Buildsheet autogenerated by ravenadm tool -- Do not edit.

NAMEBASE=		qemu
VERSION=		5.1.0
KEYWORDS=		emulators
VARIANTS=		standard
SDESC[standard]=	Fast CPU emulator and virtualizer for x86 platform
HOMEPAGE=		https://www.qemu.org/
CONTACT=		nobody

DOWNLOAD_GROUPS=	main
SITES[main]=		https://download.qemu.org/
DISTFILE[1]=		qemu-5.1.0.tar.xz:main
DF_INDEX=		1
SPKGS[standard]=	complete
			primary
			docs
			nls

OPTIONS_AVAILABLE=	none
OPTIONS_STANDARD=	none

BUILD_DEPENDS=		texi2html:primary:standard
			python-Sphinx:single:python_default
BUILDRUN_DEPENDS=	nettle:primary:standard
			fontconfig:primary:standard
			freetype:primary:standard
			gnutls:primary:standard
			cyrus-sasl:primary:standard
			curl:primary:standard
			vde2:single:standard
			libepoxy:single:standard

USES=			cpe gmake pkgconfig bison perl:build python:build
			jpeg png mesa gettext-runtime gettext-tools ncurses
			makeinfo
GNOME_COMPONENTS=	gdkpixbuf gtk2 vte
SDL_COMPONENTS=		sdl2
XORG_COMPONENTS=	x11 xext

LICENSE=		GPLv2:primary
LICENSE_TERMS=		primary:{{WRKSRC}}/LICENSE
LICENSE_FILE=		GPLv2:{{WRKSRC}}/COPYING
LICENSE_SCHEME=		solo

FPC_EQUIVALENT=		emulators/qemu

MUST_CONFIGURE=		yes
CONFIGURE_ARGS=		--disable-usb-redir
			--disable-stack-protector
			--disable-kvm
			--disable-xen
			--disable-vde
			--enable-pcap
			--enable-docs
			--enable-debug
			--enable-debug-info
			--prefix={{PREFIX}}
			--cc={{CC}}
			--python={{PYTHON_CMD}}
			--localstatedir=/var
			--extra-cflags="-I{{WRKSRC}} -I{{LOCALBASE}}/include -DPREFIX=\\\"\"{{PREFIX}}\\\"\""
			--extra-ldflags="-L/usr/lib -L{{LOCALBASE}}/lib"

MAKE_ENV=		BSD_MAKE="{{MAKE}}"
			V=1

INSTALL_REQ_TOOLCHAIN=	yes
PLIST_SUB=		JQUERY=3.5.1

VAR_OPSYS[freebsd]=	CONFIGURE_ARGS=--enable-netmap
			CONFIGURE_ARGS=--disable-linux-user
			CONFIGURE_ARGS=--disable-linux-aio
VAR_OPSYS[linux]=	CONFIGURE_ARGS=--disable-netmap
VAR_OPSYS[dragonfly]=	CONFIGURE_ARGS=--disable-netmap
			CONFIGURE_ARGS=--disable-linux-user
			CONFIGURE_ARGS=--disable-linux-aio

post-patch:
	${REINPLACE_CMD} -e '/LIBS/s|-lprocstat|-lprocstat -lelf|' \
		 -e '/libusb/s/ --atleast-version=1\.0\.[0-9]*//' \
		${WRKSRC}/configure
	${REINPLACE_CMD} -E \
		-e "s|^(CFLAGS=).*|\1${CFLAGS} -fno-strict-aliasing|" \
		-e "s|^(LDFLAGS=).*|\1${LDFLAGS}|" \
		${WRKSRC}/Makefile.target
	${REINPLACE_CMD} -E \
		-e "s|^(CFLAGS=).*|\1${CFLAGS} -fno-strict-aliasing -I.|" \
		-e "s|^(LDFLAGS=).*|\1${LDFLAGS}|" \
		${WRKSRC}/Makefile
	${REINPLACE_CMD} -E \
		-e "1s|^(#! )/usr/bin/perl|\1${PERL}|" \
		${WRKSRC}/scripts/texi2pod.pl
	# GNS3 (promiscuous multicast)
	${REINPLACE_CMD} -e 's|(buf\[0\] & 1) && (rctl & E1000_RCTL_MPE)|buf[0] \& 1|' \
		${WRKSRC}/hw/net/e1000.c
	# broken build for optionrom
	${REINPLACE_CMD} -e '/roms="optionrom"/d' ${WRKSRC}/configure
	# silence some include warnings
	${MKDIR} ${WRKSRC}/bsd-user/dragonfly

pre-install:
	# for some reason file is considered out-of-date
	${TOUCH} ${WRKSRC}/config-host.mak

post-patch-dragonfly:
	${REINPLACE_CMD} -e '/libs_qga=..glib_libs/ s|glib_libs|glib_libs -lintl|' \
		${WRKSRC}/configure

post-install:
	${INSTALL_SCRIPT} ${FILESDIR}/qemu-ifup.sample \
		${STAGEDIR}${PREFIX}/etc
	${INSTALL_SCRIPT} ${FILESDIR}/qemu-ifdown.sample \
		${STAGEDIR}${PREFIX}/etc
	${STRIP_CMD} ${STAGEDIR}${PREFIX}/bin/qemu-*
	(cd ${WRKSRC} && ${COPYTREE_SHARE} docs ${STAGEDIR}${STD_DOCDIR}/)
	# remove empty directories
	${RM} -r ${STAGEDIR}/var

post-patch-freebsd:
	${REINPLACE_CMD} -e '/libs_qga=..glib_libs/ s|glib_libs|glib_libs -lintl|' \
		${WRKSRC}/configure

[FILE:782:descriptions/desc.primary]
QEMU is a fast processor emulator using dynamic translation to achieve
good emulation speed.  QEMU has two operating modes:

 * Full system emulation. In this mode, QEMU emulates a full system (for
   example a PC), including a processor and various peripherials.  It can
   be used to launch different Operating Systems without rebooting the PC
   or to debug system code.
 * User mode emulation (Linux host only). In this mode, QEMU can launch
   Linux processes compiled for one CPU on another CPU. It can be used to
   launch the Wine Windows API emulator or to ease cross-compilation and
   cross-debugging.

As QEMU requires no host kernel patches to run, it is safe and easy to use.

See also the preconfigured system images on http://oszoo.org/
Many live cd isos also work.


[FILE:96:distinfo]
c9174eb5933d9eb5e61f541cd6d1184cd3118dfe4c5c4955bc1bdc4d390fa4e5     62911540 qemu-5.1.0.tar.xz


[FILE:3510:manifests/plist.primary]
@sample etc/qemu-ifdown.sample
@sample etc/qemu-ifup.sample
%%ONLY-LINUX%%bin/
 ivshmem-client
 ivshmem-server
 qemu-aarch64
 qemu-aarch64_be
 qemu-alpha
 qemu-arm
 qemu-armeb
 qemu-cris
 qemu-hppa
 qemu-m68k
 qemu-microblaze
 qemu-microblazeel
 qemu-mips
 qemu-mips64
 qemu-mips64el
 qemu-mipsel
 qemu-mipsn32
 qemu-mipsn32el
 qemu-nios2
 qemu-or1k
 qemu-ppc
 qemu-ppc64
 qemu-ppc64abi32
 qemu-ppc64le
 qemu-pr-helper
 qemu-riscv32
 qemu-riscv64
 qemu-s390x
 qemu-sh4
 qemu-sh4eb
 qemu-sparc32plus
 qemu-tilegx
 qemu-xtensa
 qemu-xtensaeb
%%ONLY-LINUX%%libexec/qemu-bridge-helper
bin/
 elf2dmp
 qemu-edid
 qemu-ga
 qemu-i386
 qemu-img
 qemu-io
 qemu-nbd
 qemu-sparc
 qemu-sparc64
 qemu-storage-daemon
 qemu-system-aarch64
 qemu-system-alpha
 qemu-system-arm
 qemu-system-avr
 qemu-system-cris
 qemu-system-hppa
 qemu-system-i386
 qemu-system-lm32
 qemu-system-m68k
 qemu-system-microblaze
 qemu-system-microblazeel
 qemu-system-mips
 qemu-system-mips64
 qemu-system-mips64el
 qemu-system-mipsel
 qemu-system-moxie
 qemu-system-nios2
 qemu-system-or1k
 qemu-system-ppc
 qemu-system-ppc64
 qemu-system-riscv32
 qemu-system-riscv64
 qemu-system-rx
 qemu-system-s390x
 qemu-system-sh4
 qemu-system-sh4eb
 qemu-system-sparc
 qemu-system-sparc64
 qemu-system-tricore
 qemu-system-unicore32
 qemu-system-x86_64
 qemu-system-xtensa
 qemu-system-xtensaeb
 qemu-x86_64
share/applications/qemu.desktop
share/icons/hicolor/128x128/apps/qemu.png
share/icons/hicolor/16x16/apps/qemu.png
share/icons/hicolor/24x24/apps/qemu.png
share/icons/hicolor/256x256/apps/qemu.png
share/icons/hicolor/32x32/apps/
 qemu.bmp
 qemu.png
share/icons/hicolor/48x48/apps/qemu.png
share/icons/hicolor/512x512/apps/qemu.png
share/icons/hicolor/64x64/apps/qemu.png
share/icons/hicolor/scalable/apps/qemu.svg
share/man/man1/
 qemu-img.1.gz
 qemu.1.gz
share/man/man7/
 qemu-block-drivers.7.gz
 qemu-cpu-models.7.gz
 qemu-ga-ref.7.gz
 qemu-qmp-ref.7.gz
share/man/man8/
 qemu-ga.8.gz
 qemu-nbd.8.gz
share/qemu/
 QEMU,cgthree.bin
 QEMU,tcx.bin
 bamboo.dtb
 bios-256k.bin
 bios-microvm.bin
 bios.bin
 canyonlands.dtb
 edk2-aarch64-code.fd
 edk2-arm-code.fd
 edk2-arm-vars.fd
 edk2-i386-code.fd
 edk2-i386-secure-code.fd
 edk2-i386-vars.fd
 edk2-licenses.txt
 edk2-x86_64-code.fd
 edk2-x86_64-secure-code.fd
 efi-e1000.rom
 efi-e1000e.rom
 efi-eepro100.rom
 efi-ne2k_pci.rom
 efi-pcnet.rom
 efi-rtl8139.rom
 efi-virtio.rom
 efi-vmxnet3.rom
 hppa-firmware.img
 kvmvapic.bin
 linuxboot.bin
 linuxboot_dma.bin
 multiboot.bin
 openbios-ppc
 openbios-sparc32
 openbios-sparc64
 opensbi-riscv32-sifive_u-fw_jump.bin
 opensbi-riscv32-virt-fw_jump.bin
 opensbi-riscv64-sifive_u-fw_jump.bin
 opensbi-riscv64-virt-fw_jump.bin
 palcode-clipper
 petalogix-ml605.dtb
 petalogix-s3adsp1800.dtb
 pvh.bin
 pxe-e1000.rom
 pxe-eepro100.rom
 pxe-ne2k_pci.rom
 pxe-pcnet.rom
 pxe-rtl8139.rom
 pxe-virtio.rom
 qemu-nsis.bmp
 qemu_vga.ndrv
 s390-ccw.img
 s390-netboot.img
 sgabios.bin
 skiboot.lid
 slof.bin
 trace-events-all
 u-boot-sam460-20100605.bin
 u-boot.e500
 vgabios-ati.bin
 vgabios-bochs-display.bin
 vgabios-cirrus.bin
 vgabios-qxl.bin
 vgabios-ramfb.bin
 vgabios-stdvga.bin
 vgabios-virtio.bin
 vgabios-vmware.bin
 vgabios.bin
share/qemu/firmware/
 50-edk2-i386-secure.json
 50-edk2-x86_64-secure.json
 60-edk2-aarch64.json
 60-edk2-arm.json
 60-edk2-i386.json
 60-edk2-x86_64.json
share/qemu/keymaps/
 ar
 bepo
 cz
 da
 de
 de-ch
 en-gb
 en-us
 es
 et
 fi
 fo
 fr
 fr-be
 fr-ca
 fr-ch
 hr
 hu
 is
 it
 ja
 lt
 lv
 mk
 nl
 no
 pl
 pt
 pt-br
 ru
 sl
 sv
 th
 tr


[FILE:11393:manifests/plist.docs]
share/doc/qemu/index.html
share/doc/qemu/docs/
 COLO-FT.txt
 amd-memory-encryption.txt
 barrier.txt
 block-replication.txt
 bootindex.txt
 can.txt
 ccid.txt
 colo-proxy.txt
 conf.py
 cpu-hotplug.rst
 defs.rst.inc
 generic-loader.txt
 hyperv.txt
 igd-assign.txt
 image-fuzzer.txt
 index.html.in
 index.rst
 memory-hotplug.txt
 microvm.rst
 multi-thread-compression.txt
 multiseat.txt
 nvdimm.txt
 pci_expander_bridge.txt
 pcie.txt
 pcie_pci_bridge.txt
 pr-manager.rst
 pvrdma.txt
 qcow2-cache.txt
 qdev-device-use.txt
 qemu-option-trace.rst.inc
 qemu_logo.pdf
 qemupciserial.inf
 rdma.txt
 replay.txt
 spice-port-fqdn.txt
 throttle.txt
 usb-storage.txt
 usb2.txt
 version.texi
 virtio-balloon-stats.txt
 virtio-net-failover.rst
 virtio-pmem.rst
 xbzrle.txt
 xen-save-devices-state.txt
share/doc/qemu/docs/built/index.html
share/doc/qemu/docs/built/devel/
 .buildinfo
 atomics.html
 bitops.html
 clocks.html
 decodetree.html
 genindex.html
 index.html
 kconfig.html
 loads-stores.html
 memory.html
 migration.html
 multi-thread-tcg.html
 objects.inv
 reset.html
 s390-dasd-ipl.html
 search.html
 searchindex.js
 secure-coding-practices.html
 stable-process.html
 tcg-icount.html
 tcg-plugins.html
 tcg.html
 testing.html
share/doc/qemu/docs/built/devel/_static/
 alabaster.css
 basic.css
 custom.css
 doctools.js
 documentation_options.js
 file.png
 jquery-%%JQUERY%%.js
 jquery.js
 language_data.js
 minus.png
 plus.png
 pygments.css
 searchtools.js
 underscore-1.3.1.js
 underscore.js
share/doc/qemu/docs/built/interop/
 .buildinfo
 bitmaps.html
 dbus-vmstate.html
 dbus.html
 genindex.html
 index.html
 live-block-operations.html
 objects.inv
 pr-helper.html
 qemu-ga.8
 qemu-ga.html
 search.html
 searchindex.js
 vhost-user-gpu.html
 vhost-user.html
 vhost-vdpa.html
share/doc/qemu/docs/built/interop/_static/
 alabaster.css
 basic.css
 custom.css
 doctools.js
 documentation_options.js
 file.png
 jquery-%%JQUERY%%.js
 jquery.js
 language_data.js
 minus.png
 plus.png
 pygments.css
 searchtools.js
 underscore-1.3.1.js
 underscore.js
share/doc/qemu/docs/built/specs/
 .buildinfo
 acpi_hest_ghes.html
 acpi_hw_reduced_hotplug.html
 genindex.html
 index.html
 objects.inv
 ppc-spapr-xive.html
 ppc-xive.html
 search.html
 searchindex.js
 tpm.html
share/doc/qemu/docs/built/specs/_static/
 alabaster.css
 basic.css
 custom.css
 doctools.js
 documentation_options.js
 file.png
 jquery-%%JQUERY%%.js
 jquery.js
 language_data.js
 minus.png
 plus.png
 pygments.css
 searchtools.js
 underscore-1.3.1.js
 underscore.js
share/doc/qemu/docs/built/system/
 .buildinfo
 build-platforms.html
 deprecated.html
 gdb.html
 genindex.html
 images.html
 index.html
 invocation.html
 ivshmem.html
 keys.html
 license.html
 linuxboot.html
 managed-startup.html
 monitor.html
 mux-chardev.html
 net.html
 objects.inv
 qemu-block-drivers.7
 qemu-block-drivers.html
 qemu-cpu-models.7
 qemu-cpu-models.html
 qemu-manpage.html
 qemu.1
 quickstart.html
 search.html
 searchindex.js
 security.html
 target-arm.html
 target-avr.html
 target-i386.html
 target-m68k.html
 target-mips.html
 target-ppc.html
 target-rx.html
 target-s390x.html
 target-sparc.html
 target-sparc64.html
 target-xtensa.html
 targets.html
 tls.html
 usb.html
 vnc-security.html
share/doc/qemu/docs/built/system/_static/
 alabaster.css
 basic.css
 custom.css
 doctools.js
 documentation_options.js
 file.png
 jquery-%%JQUERY%%.js
 jquery.js
 language_data.js
 minus.png
 plus.png
 pygments.css
 searchtools.js
 underscore-1.3.1.js
 underscore.js
share/doc/qemu/docs/built/system/arm/
 aspeed.html
 collie.html
 cpu-features.html
 digic.html
 gumstix.html
 integratorcp.html
 mps2.html
 musca.html
 musicpal.html
 nseries.html
 orangepi.html
 palm.html
 realview.html
 stellaris.html
 sx1.html
 versatile.html
 vexpress.html
 virt.html
 xscale.html
share/doc/qemu/docs/built/system/s390x/
 3270.html
 css.html
 protvirt.html
 vfio-ap.html
 vfio-ccw.html
share/doc/qemu/docs/built/tools/
 .buildinfo
 genindex.html
 index.html
 objects.inv
 qemu-img.1
 qemu-img.html
 qemu-nbd.8
 qemu-nbd.html
 qemu-trace-stap.1
 qemu-trace-stap.html
 search.html
 searchindex.js
 virtfs-proxy-helper.1
 virtfs-proxy-helper.html
 virtiofsd.1
 virtiofsd.html
share/doc/qemu/docs/built/tools/_static/
 alabaster.css
 basic.css
 custom.css
 doctools.js
 documentation_options.js
 file.png
 jquery-%%JQUERY%%.js
 jquery.js
 language_data.js
 minus.png
 plus.png
 pygments.css
 searchtools.js
 underscore-1.3.1.js
 underscore.js
share/doc/qemu/docs/built/user/
 .buildinfo
 genindex.html
 index.html
 main.html
 objects.inv
 search.html
 searchindex.js
share/doc/qemu/docs/built/user/_static/
 alabaster.css
 basic.css
 custom.css
 doctools.js
 documentation_options.js
 file.png
 jquery-%%JQUERY%%.js
 jquery.js
 language_data.js
 minus.png
 plus.png
 pygments.css
 searchtools.js
 underscore-1.3.1.js
 underscore.js
share/doc/qemu/docs/config/
 ich9-ehci-uhci.cfg
 mach-virt-graphical.cfg
 mach-virt-serial.cfg
 q35-emulated.cfg
 q35-virtio-graphical.cfg
 q35-virtio-serial.cfg
share/doc/qemu/docs/devel/
 atomics.rst
 bitops.rst
 blkdebug.txt
 blkverify.txt
 build-system.txt
 clocks.rst
 conf.py
 decodetree.rst
 fuzzing.txt
 index.rst
 kconfig.rst
 loads-stores.rst
 lockcnt.txt
 memory.rst
 migration.rst
 multi-thread-tcg.rst
 multiple-iothreads.txt
 qapi-code-gen.txt
 rcu.txt
 replay.txt
 reset.rst
 s390-dasd-ipl.rst
 secure-coding-practices.rst
 stable-process.rst
 tcg-icount.rst
 tcg-plugins.rst
 tcg.rst
 testing.rst
 tracing.txt
 virtio-migration.txt
 writing-qmp-commands.txt
share/doc/qemu/docs/interop/
 bitmaps.rst
 conf.py
 dbus-vmstate.rst
 dbus.rst
 firmware.json
 index.rst
 live-block-operations.rst
 nbd.txt
 parallels.txt
 pr-helper.rst
 prl-xml.txt
 qcow2.txt
 qed_spec.txt
 qemu-ga-qapi.texi
 qemu-ga-ref.7
 qemu-ga-ref.7.pod
 qemu-ga-ref.html
 qemu-ga-ref.texi
 qemu-ga-ref.txt
 qemu-ga.rst
 qemu-qmp-qapi.texi
 qemu-qmp-ref.7
 qemu-qmp-ref.7.pod
 qemu-qmp-ref.html
 qemu-qmp-ref.texi
 qemu-qmp-ref.txt
 qmp-intro.txt
 qmp-spec.txt
 vhost-user-gpu.rst
 vhost-user.json
 vhost-user.rst
 vhost-vdpa.rst
 vnc-ledstate-Pseudo-encoding.txt
share/doc/qemu/docs/specs/
 acpi_cpu_hotplug.txt
 acpi_hest_ghes.rst
 acpi_hw_reduced_hotplug.rst
 acpi_mem_hotplug.txt
 acpi_nvdimm.txt
 acpi_pci_hotplug.txt
 conf.py
 edu.txt
 fw_cfg.txt
 index.rst
 ivshmem-spec.txt
 pci-ids.txt
 pci-serial.txt
 pci-testdev.txt
 ppc-spapr-hcalls.txt
 ppc-spapr-hotplug.txt
 ppc-spapr-uv-hcalls.txt
 ppc-spapr-xive.rst
 ppc-xive.rst
 pvpanic.txt
 rocker.txt
 standard-vga.txt
 tpm.rst
 vmcoreinfo.txt
 vmgenid.txt
 vmw_pvscsi-spec.txt
share/doc/qemu/docs/sphinx/
 hxtool.py
 kerneldoc.py
 kernellog.py
 qmp_lexer.py
share/doc/qemu/docs/sphinx/__pycache__/
 hxtool.cpython-38.pyc
 kerneldoc.cpython-38.pyc
 kernellog.cpython-38.pyc
 qmp_lexer.cpython-%%PYTHON_SUFFIX%%.pyc
share/doc/qemu/docs/spin/
 aio_notify.promela
 aio_notify_accept.promela
 aio_notify_bug.promela
 tcg-exclusive.promela
 win32-qemu-event.promela
share/doc/qemu/docs/system/
 build-platforms.rst
 conf.py
 cpu-models-mips.rst.inc
 cpu-models-x86.rst.inc
 deprecated.rst
 device-url-syntax.rst.inc
 gdb.rst
 images.rst
 index.rst
 invocation.rst
 ivshmem.rst
 keys.rst
 keys.rst.inc
 license.rst
 linuxboot.rst
 managed-startup.rst
 monitor.rst
 mux-chardev.rst
 mux-chardev.rst.inc
 net.rst
 qemu-block-drivers.rst
 qemu-block-drivers.rst.inc
 qemu-cpu-models.rst
 qemu-manpage.rst
 quickstart.rst
 security.rst
 target-arm.rst
 target-avr.rst
 target-i386-desc.rst.inc
 target-i386.rst
 target-m68k.rst
 target-mips.rst
 target-ppc.rst
 target-rx.rst
 target-s390x.rst
 target-sparc.rst
 target-sparc64.rst
 target-xtensa.rst
 targets.rst
 tls.rst
 usb.rst
 vnc-security.rst
share/doc/qemu/docs/system/arm/
 aspeed.rst
 collie.rst
 cpu-features.rst
 digic.rst
 gumstix.rst
 integratorcp.rst
 mps2.rst
 musca.rst
 musicpal.rst
 nseries.rst
 orangepi.rst
 palm.rst
 realview.rst
 stellaris.rst
 sx1.rst
 versatile.rst
 vexpress.rst
 virt.rst
 xscale.rst
share/doc/qemu/docs/system/s390x/
 3270.rst
 css.rst
 protvirt.rst
 vfio-ap.rst
 vfio-ccw.rst
share/doc/qemu/docs/tools/
 conf.py
 index.rst
 qemu-img.rst
 qemu-nbd.rst
 qemu-trace-stap.rst
 virtfs-proxy-helper.rst
 virtiofsd.rst
share/doc/qemu/docs/user/
 conf.py
 index.rst
 main.rst
share/doc/qemu/interop/
 .buildinfo
 bitmaps.html
 dbus-vmstate.html
 dbus.html
 genindex.html
 index.html
 live-block-operations.html
 objects.inv
 pr-helper.html
 qemu-ga-ref.html
 qemu-ga-ref.txt
 qemu-ga.html
 qemu-qmp-ref.html
 qemu-qmp-ref.txt
 search.html
 searchindex.js
 vhost-user-gpu.html
 vhost-user.html
 vhost-vdpa.html
share/doc/qemu/interop/_static/
 alabaster.css
 basic.css
 custom.css
 doctools.js
 documentation_options.js
 file.png
 jquery-%%JQUERY%%.js
 jquery.js
 language_data.js
 minus.png
 plus.png
 pygments.css
 searchtools.js
 underscore-1.3.1.js
 underscore.js
share/doc/qemu/specs/
 .buildinfo
 acpi_hest_ghes.html
 acpi_hw_reduced_hotplug.html
 genindex.html
 index.html
 objects.inv
 ppc-spapr-xive.html
 ppc-xive.html
 search.html
 searchindex.js
 tpm.html
share/doc/qemu/specs/_static/
 alabaster.css
 basic.css
 custom.css
 doctools.js
 documentation_options.js
 file.png
 jquery-%%JQUERY%%.js
 jquery.js
 language_data.js
 minus.png
 plus.png
 pygments.css
 searchtools.js
 underscore-1.3.1.js
 underscore.js
share/doc/qemu/system/
 .buildinfo
 build-platforms.html
 deprecated.html
 gdb.html
 genindex.html
 images.html
 index.html
 invocation.html
 ivshmem.html
 keys.html
 license.html
 linuxboot.html
 managed-startup.html
 monitor.html
 mux-chardev.html
 net.html
 objects.inv
 qemu-block-drivers.html
 qemu-cpu-models.html
 qemu-manpage.html
 quickstart.html
 search.html
 searchindex.js
 security.html
 target-arm.html
 target-avr.html
 target-i386.html
 target-m68k.html
 target-mips.html
 target-ppc.html
 target-rx.html
 target-s390x.html
 target-sparc.html
 target-sparc64.html
 target-xtensa.html
 targets.html
 tls.html
 usb.html
 vnc-security.html
share/doc/qemu/system/_static/
 alabaster.css
 basic.css
 custom.css
 doctools.js
 documentation_options.js
 file.png
 jquery-%%JQUERY%%.js
 jquery.js
 language_data.js
 minus.png
 plus.png
 pygments.css
 searchtools.js
 underscore-1.3.1.js
 underscore.js
share/doc/qemu/system/arm/
 aspeed.html
 collie.html
 cpu-features.html
 digic.html
 gumstix.html
 integratorcp.html
 mps2.html
 musca.html
 musicpal.html
 nseries.html
 orangepi.html
 palm.html
 realview.html
 stellaris.html
 sx1.html
 versatile.html
 vexpress.html
 virt.html
 xscale.html
share/doc/qemu/system/s390x/
 3270.html
 css.html
 protvirt.html
 vfio-ap.html
 vfio-ccw.html
share/doc/qemu/tools/
 .buildinfo
 genindex.html
 index.html
 objects.inv
 qemu-img.html
 qemu-nbd.html
 qemu-trace-stap.html
 search.html
 searchindex.js
 virtfs-proxy-helper.html
 virtiofsd.html
share/doc/qemu/tools/_static/
 alabaster.css
 basic.css
 custom.css
 doctools.js
 documentation_options.js
 file.png
 jquery-%%JQUERY%%.js
 jquery.js
 language_data.js
 minus.png
 plus.png
 pygments.css
 searchtools.js
 underscore-1.3.1.js
 underscore.js
share/doc/qemu/user/
 .buildinfo
 genindex.html
 index.html
 main.html
 objects.inv
 search.html
 searchindex.js
share/doc/qemu/user/_static/
 alabaster.css
 basic.css
 custom.css
 doctools.js
 documentation_options.js
 file.png
 jquery-%%JQUERY%%.js
 jquery.js
 language_data.js
 minus.png
 plus.png
 pygments.css
 searchtools.js
 underscore-1.3.1.js
 underscore.js


[FILE:297:manifests/plist.nls]
share/locale/bg/LC_MESSAGES/qemu.mo
share/locale/de_DE/LC_MESSAGES/qemu.mo
share/locale/fr_FR/LC_MESSAGES/qemu.mo
share/locale/hu/LC_MESSAGES/qemu.mo
share/locale/it/LC_MESSAGES/qemu.mo
share/locale/sv/LC_MESSAGES/qemu.mo
share/locale/tr/LC_MESSAGES/qemu.mo
share/locale/zh_CN/LC_MESSAGES/qemu.mo


[FILE:3366:patches/patch-configure]
--- configure.orig	2020-08-11 19:17:15 UTC
+++ configure
@@ -501,6 +501,9 @@ numa=""
 tcmalloc="no"
 jemalloc="no"
 replication="yes"
+pcap="no"
+pcap_create="no"
+bpf="no"
 bochs="yes"
 cloop="yes"
 dmg="yes"
@@ -1191,6 +1194,10 @@ for opt do
   ;;
   --enable-vnc-png) vnc_png="yes"
   ;;
+  --enable-pcap) pcap="yes"
+  ;;
+  --disable-pcap) pcap="no"
+  ;;
   --disable-slirp) slirp="no"
   ;;
   --enable-slirp=git) slirp="git"
@@ -3246,6 +3253,14 @@ if check_include "sys/signal.h" ; then
 fi
 
 ##########################################
+# getifaddrs (for tests/test-io-channel-socket )
+
+have_ifaddrs_h=yes
+if ! check_include "ifaddrs.h" ; then
+  have_ifaddrs_h=no
+fi
+
+##########################################
 # VTE probe
 
 if test "$vte" != "no"; then
@@ -5252,7 +5267,7 @@ fi
 
 # check for libusb
 if test "$libusb" != "no" ; then
-    if $pkg_config --atleast-version=1.0.13 libusb-1.0; then
+    if $pkg_config libusb-1.0; then
         libusb="yes"
         libusb_cflags=$($pkg_config --cflags libusb-1.0)
         libusb_libs=$($pkg_config --libs libusb-1.0)
@@ -6514,6 +6529,50 @@ EOF
     fi
 fi
 
+##########################################
+# pcap probe
+
+if test "$pcap" = "yes" -a "$pcap" != "no"; then
+  cat > $TMPC << EOF
+#include <pcap.h>
+int main(void) { return (pcap_lib_version() == (char *)0 ? 1 : 0); }
+EOF
+  if test "$mingw32" = "no" ; then
+    libpcap=-lpcap
+  else
+    libpcap=-lwpcap
+  fi
+  if compile_prog "" "$libpcap" ; then
+    :
+  else
+    echo
+    echo "Error: Could not find pcap"
+    echo "Make sure to have the pcap libs and headers installed."
+    echo
+    exit 1
+  fi
+  cat > $TMPC << EOF
+#include <pcap.h>
+int main(void)
+{
+  char errbuf[PCAP_ERRBUF_SIZE];
+  return (pcap_create("foo", errbuf) == (pcap_t *)0 ? 1 : 0);
+}
+EOF
+  if compile_prog "" "$libpcap" ; then
+    pcap_create="yes"
+  fi
+  cat > $TMPC << EOF
+#define PCAP_DONT_INCLUDE_PCAP_BPF_H
+#include <pcap.h>
+#include <net/bpf.h>
+int main(void) { return (BPF_MAJOR_VERSION); }
+EOF
+  if compile_prog ; then
+    bpf="yes"
+  fi
+  libs_softmmu="$libpcap $libs_softmmu"
+fi # test "$pcap"
 
 ##########################################
 # End of CC checks
@@ -6910,6 +6969,7 @@ echo "Audio drivers     $audio_drv_list"
 echo "Block whitelist (rw) $block_drv_rw_whitelist"
 echo "Block whitelist (ro) $block_drv_ro_whitelist"
 echo "VirtFS support    $virtfs"
+echo "pcap support      $pcap"
 echo "Multipath support $mpath"
 echo "VNC support       $vnc"
 if test "$vnc" = "yes" ; then
@@ -7153,6 +7213,15 @@ fi
 if test "$want_tools" = "yes" ; then
   echo "CONFIG_TOOLS=y" >> $config_host_mak
 fi
+if test "$pcap" = "yes" ; then
+  echo "CONFIG_PCAP=y" >> $config_host_mak
+  if test "$pcap_create" = "yes" ; then
+    echo "CONFIG_PCAP_CREATE=y" >> $config_host_mak
+  fi
+  if test "$bpf" = "yes" ; then
+    echo "CONFIG_BPF=y" >> $config_host_mak
+  fi
+fi
 if test "$slirp" != "no"; then
   echo "CONFIG_SLIRP=y" >> $config_host_mak
   echo "CONFIG_SMBD_COMMAND=\"$smbd\"" >> $config_host_mak
@@ -7420,6 +7489,9 @@ fi
 if test "$have_fsxattr" = "yes" ; then
     echo "HAVE_FSXATTR=y" >> $config_host_mak
 fi
+if test "$have_ifaddrs_h" = "yes" ; then
+    echo "HAVE_IFADDRS_H=y" >> $config_host_mak
+fi
 if test "$have_copy_file_range" = "yes" ; then
     echo "HAVE_COPY_FILE_RANGE=y" >> $config_host_mak
 fi


[FILE:365:patches/patch-disas_libvixl_vixl_a64_disasm-a64.cc]
--- disas/libvixl/vixl/a64/disasm-a64.cc.orig	2020-08-11 19:17:14 UTC
+++ disas/libvixl/vixl/a64/disasm-a64.cc
@@ -2693,7 +2693,7 @@ void Disassembler::AppendPCRelativeOffse
   if (offset < 0) {
     abs_offset = -abs_offset;
   }
-  AppendToOutput("#%c0x%" PRIx64, sign, abs_offset);
+  AppendToOutput("#%c0x%" PRIx64, sign, offset < 0 ? -offset : offset);
 }
 
 


[FILE:582:patches/patch-include_net_net.h]
--- include/net/net.h.orig	2020-08-11 19:17:15 UTC
+++ include/net/net.h
@@ -209,8 +209,8 @@ void netdev_add(QemuOpts *opts, Error **
 int net_hub_id_for_client(NetClientState *nc, int *id);
 NetClientState *net_hub_port_find(int hub_id);
 
-#define DEFAULT_NETWORK_SCRIPT "/etc/qemu-ifup"
-#define DEFAULT_NETWORK_DOWN_SCRIPT "/etc/qemu-ifdown"
+#define DEFAULT_NETWORK_SCRIPT PREFIX "/etc/qemu-ifup"
+#define DEFAULT_NETWORK_DOWN_SCRIPT PREFIX "/etc/qemu-ifdown"
 #define DEFAULT_BRIDGE_HELPER CONFIG_QEMU_HELPERDIR "/qemu-bridge-helper"
 #define DEFAULT_BRIDGE_INTERFACE "br0"
 


[FILE:563:patches/patch-net_clients.h]
--- net/clients.h.orig	2020-08-11 19:17:15 UTC
+++ net/clients.h
@@ -61,6 +61,12 @@ int net_init_netmap(const Netdev *netdev
 int net_init_vhost_user(const Netdev *netdev, const char *name,
                         NetClientState *peer, Error **errp);
 
+#ifdef CONFIG_PCAP
+int net_init_pcap(const Netdev *netdev, const char *name,
+                    NetClientState *peer, Error **errp);
+#endif
+
+
 int net_init_vhost_vdpa(const Netdev *netdev, const char *name,
                         NetClientState *peer, Error **errp);
 #endif /* QEMU_NET_CLIENTS_H */


[FILE:6930:patches/patch-net_net.c]
--- net/net.c.orig	2020-08-11 19:17:15 UTC
+++ net/net.c
@@ -55,6 +55,11 @@
 #include "net/filter.h"
 #include "qapi/string-output-visitor.h"
 
+#include <sys/ioctl.h>
+#if defined(__FreeBSD__) || defined(__DragonFly__)
+#include <net/if.h>
+#endif
+
 /* Net bridge is currently not supported for W32. */
 #if !defined(_WIN32)
 # define CONFIG_NET_BRIDGE
@@ -942,7 +947,225 @@ static int net_init_nic(const Netdev *ne
     return idx;
 }
 
+#if defined(CONFIG_PCAP)
+#if defined(CONFIG_BPF)
+#define PCAP_DONT_INCLUDE_PCAP_BPF_H
+#include <net/bpf.h>
+#endif
+#include <pcap.h>
+
+struct PCAPState {
+    NetClientState     nc;
+    pcap_t            *handle;
+    int                max_eth_frame_size;
+};
+
+static ssize_t pcap_receive(NetClientState *nc, const uint8_t *buf, size_t size)
+{
+    struct PCAPState *s = DO_UPCAST(struct PCAPState, nc, nc);
+
+    return pcap_inject(s->handle, (u_char*)buf, size);
+}
+
+static void pcap_callback(u_char *user, struct pcap_pkthdr *phdr, u_char *pdata
+		)
+{
+    NetClientState *nc = (NetClientState *)user;
+
+    int len = phdr->len;
+#if defined(__FreeBSD__) || defined(__DragonFly__)
+    struct PCAPState *s = DO_UPCAST(struct PCAPState, nc, nc);
+    int max_eth_frame_size = s->max_eth_frame_size;
+
+    if (len > max_eth_frame_size) {
+        fprintf(stderr,
+            "pcap_send: packet size > %d (%d), truncating\n",
+            max_eth_frame_size, len);
+        len = max_eth_frame_size;
+    }
+#endif
+    qemu_send_packet(nc, pdata, len);
+}
+
+static void pcap_send(void *opaque)
+{
+    struct PCAPState *s = (struct PCAPState *)opaque;
+
+    for (;;) {
+        if (pcap_dispatch(s->handle, 0, (pcap_handler)&pcap_callback, (u_char *)&s->nc) >= 0)
+            break;
+    }
+}
+
+static void pcap_cleanup(NetClientState *nc)
+{
+    struct PCAPState *s = DO_UPCAST(struct PCAPState, nc, nc);
+
+    qemu_purge_queued_packets(nc);
+    pcap_close(s->handle);
+}
+
+static NetClientInfo net_pcap_info = {
+    .type = NET_CLIENT_DRIVER_PCAP,
+    .size = sizeof(struct PCAPState),
+    .receive = pcap_receive,
+//    .receive_raw = pcap_receive_raw,
+//    .receive_iov = pcap_receive_iov,
+//    .poll = pcap_poll,
+    .cleanup = pcap_cleanup,
+};
+/*
+ * ... -net pcap,ifname="..."
+ */
+
+int net_init_pcap(const Netdev *netdev,
+    const char *name, NetClientState *peer, Error **errp)
+{
+    const NetdevPcapOptions *pcap_opts;
+    NetClientState *nc;
+    struct PCAPState *s;
+    const char *ifname;
+    char errbuf[PCAP_ERRBUF_SIZE];
+#if defined(_WIN32)
+    HANDLE h;
+#endif
+    int i;
+
+    assert(netdev->type == NET_CLIENT_DRIVER_PCAP);
+    pcap_opts = &netdev->u.pcap;
+    if (!pcap_opts->has_ifname)
+        return -1;
+
+    ifname = pcap_opts->ifname;
+
+    /* create the object */
+    nc = qemu_new_net_client(&net_pcap_info, peer, "pcap", ifname);
+    s = DO_UPCAST(struct PCAPState, nc, nc);
+
+    if (ifname == NULL && (ifname = pcap_lookupdev(errbuf)) == NULL) {
+        fprintf(stderr, "qemu: pcap_create: %s\n", errbuf);
+        goto fail;
+    }
+ 
+#if defined(__FreeBSD__) || defined(__DragonFly__)
+    /*
+     * We want to avoid passing oversize packets to the guest, which
+     * at least on FreeBSD can happen if the host interface uses tso
+     * (seen with an em(4) in this case) - so find out the host
+    * interface's mtu and assume the guest is configured the same.
+     */
+    s->max_eth_frame_size = 1514;
+    i = socket(AF_INET, SOCK_DGRAM, 0);
+    if (i >= 0) {
+        struct ifreq ifr;
+
+        (void) memset(&ifr, 0, sizeof(ifr));
+        strncpy(ifr.ifr_name, ifname, sizeof(ifr.ifr_name));
+        if (ioctl(i, SIOCGIFMTU, &ifr) != -1)
+            s->max_eth_frame_size = ifr.ifr_mtu + 14;
+        close(i);
+    }
+#endif
+
+#if defined(CONFIG_PCAP_CREATE) || defined(_WIN32)
+    /*
+     * Create pcap handle for the device, set promiscuous mode and activate.
+     */
+    s->handle = (void *)pcap_create(ifname, errbuf);
+    if (!s->handle) {
+        fprintf(stderr, "qemu: pcap_create: %s\n", errbuf);
+        goto fail;
+    }
+    if (pcap_set_promisc(s->handle, 1) != 0) {
+        pcap_perror(s->handle, (char *)"qemu: pcap_set_promisc:");
+        goto fail;
+    }
+   if (pcap_activate(s->handle) != 0) {
+        pcap_perror(s->handle, (char *)"qemu: pcap_activate:");
+        goto fail;
+    }
+#else
+    /* Attempt to connect device. */
+    s->handle = (void *)pcap_open_live(ifname, 65535, 1, 0, errbuf);
+    if (!s->handle) {
+        fprintf(stderr, "qemu: pcap_open_live: %s\n", errbuf);
+        goto fail;
+    }
+#endif
+
+    /* Set non-blocking mode. */
+    if (pcap_setnonblock(s->handle, 1, errbuf) < 0) {
+        fprintf(stderr, "qemu: pcap_setnonblock: %s\n", errbuf);
+        goto fail;
+    }
+
+#if defined(_WIN32)
+    /*
+     * Tell the kernel that the packet has to be seen immediately.
+     */
+    if (pcap_setmintocopy(s->handle, 0) < 0) {
+        fprintf(stderr, "qemu: pcap failed to set immediate mode\n");
+        goto fail;
+    }
+#else /* !_WIN32 */
+#if defined(CONFIG_BPF)
+#if defined(BIOCIMMEDIATE)
+    /*
+     * Tell the kernel that the packet has to be seen immediately.
+     */
+    {
+        unsigned int one = 1;
+        if (ioctl(pcap_fileno(s->handle), BIOCIMMEDIATE, &one) < 0) {
+            fprintf(stderr, "qemu: pcap failed to set immediate mode\n");
+            goto fail;
+        }
+    }
+#endif /* BIOCIMMEDIATE */
+#if defined(BIOCFEEDBACK)
+    /*
+     * Tell the kernel that the sent packet has to be fed back.
+     * This is necessary to connect host and guest.
+     */
+    {
+        unsigned int one = 1;
+        if (ioctl(pcap_fileno(s->handle), BIOCFEEDBACK, &one) < 0) {
+            fprintf(stderr, "qemu: pcap failed to set feedback mode\n");
+            goto fail;
+        }
+    }
+#endif /* BIOCFEEDBACK */
+#endif /* CONFIG_BPF */
+#endif /* _WIN32 */
+
+    snprintf(s->nc.info_str, sizeof(s->nc.info_str), "pcap redirector");
+
+#if defined(_WIN32)
+    if ((h = pcap_getevent(s->handle)) == NULL) {
+        fprintf(stderr, "qemu: pcap_getevent failed\n");
+        goto fail;
+    }
+    qemu_add_wait_object(h, pcap_send, s);
+#else /* !_WIN32 */
+    if ((i = pcap_get_selectable_fd(s->handle)) < 0) {
+        fprintf(stderr, "qemu: pcap_get_selectable_fd failed\n");
+        goto fail;
+    }
+    qemu_set_fd_handler(i, pcap_send, NULL, s);
+#endif /* _WIN32 */
+
+    return 0;
+
+fail:
+    if (s) {
+        if (s->handle)
+            pcap_close(s->handle);
+    }
+
+    return -1;
+}
 
+#endif
+ 
 static int (* const net_client_init_fun[NET_CLIENT_DRIVER__MAX])(
     const Netdev *netdev,
     const char *name,
@@ -972,6 +1195,9 @@ static int (* const net_client_init_fun[
 #ifdef CONFIG_L2TPV3
         [NET_CLIENT_DRIVER_L2TPV3]    = net_init_l2tpv3,
 #endif
+#ifdef CONFIG_PCAP
+	[NET_CLIENT_DRIVER_PCAP]      = net_init_pcap,
+#endif
 };
 
 


[FILE:423:patches/patch-net_tap-bsd.c]
--- net/tap-bsd.c.orig	2020-08-11 19:17:15 UTC
+++ net/tap-bsd.c
@@ -31,9 +31,16 @@
 
 #if defined(__NetBSD__) || defined(__FreeBSD__)
 #include <sys/ioctl.h>
+#include <sys/socket.h>
 #include <net/if.h>
 #include <net/if_tap.h>
 #endif
+#if defined(__DragonFly)
+#include <sys/ioctl.h>
+#include <sys/socket.h>
+#include <net/if.h>
+#include <net/tap/if_tap.h>
+#endif
 
 #if defined(__OpenBSD__)
 #include <sys/param.h>


[FILE:1028:patches/patch-qapi_net.json]
--- qapi/net.json.orig	2020-08-11 19:17:15 UTC
+++ qapi/net.json
@@ -374,6 +374,19 @@
     '*helper': 'str' } }
 
 ##
+# @NetdevPcapOptions:
+#
+# Use ifname as a source to capture
+#
+# @ifname: #required to determine which interface to capture
+#
+# Since: 1.2
+##
+{ 'struct': 'NetdevPcapOptions',
+  'data': {
+    '*ifname':     'str' } }
+
+##
 # @NetdevHubPortOptions:
 #
 # Connect two or more net clients through a software hub.
@@ -461,7 +474,7 @@
 ##
 { 'enum': 'NetClientDriver',
   'data': [ 'none', 'nic', 'user', 'tap', 'l2tpv3', 'socket', 'vde',
-            'bridge', 'hubport', 'netmap', 'vhost-user', 'vhost-vdpa' ] }
+            'bridge', 'hubport', 'netmap', 'vhost-user', 'vhost-vdpa', 'pcap' ] }
 
 ##
 # @Netdev:
@@ -484,6 +497,7 @@
     'user':     'NetdevUserOptions',
     'tap':      'NetdevTapOptions',
     'l2tpv3':   'NetdevL2TPv3Options',
+    'pcap':     'NetdevPcapOptions',
     'socket':   'NetdevSocketOptions',
     'vde':      'NetdevVdeOptions',
     'bridge':   'NetdevBridgeOptions',


[FILE:7685:files/pkg-message-single]
FreeBSD host notes
==================

- Needs to set net.link.tap.user_open sysctl in order to use /dev/tap*
  networking as non-root.  Don't forget to adjust device node permissions in
  /etc/devfs.rules.

- slirp (usermode networking) is fixed now in cvs, on FreeSBIE 1.0 guests you
  still have to manually do: echo nameserver 10.0.2.3 >/etc/resolv.conf but
  i've been told that that's normal.  (fixed on FreeSBIE 1.1.) And you have
  to wait a bit for dhclient to do its thing; traffic to address 10.0.2.2 is
  routed to 127.1 on the host.

- Expect timer problems when guest kernel HZ is > hosts, for example time
  sleep 1 takes 49 seconds and booting sleeps for minutes at the acd0 probe
  with a FreeSBIE 1.0 guest, thats because its kernel is built with HZ=5000,
  and FreeBSD's default is 100...  (no longer a problem with FreeSBIE 1.1.)
  The linux 2.6 kernel uses 1000 by default btw.  (changed to 250 later, and
  recent linux kernels now no longer have a fixed HZ, aka `tickless
  kernel'...)  Enabling /dev/rtc doesn't seem to help either (not included
  since it needs a patch to emulators/rtc.)

- Update: the above problem has gotten worse with FreeBSD guests
  somewhere before 8.0, mainly since the kernel now usually wants
  double or even quadruple number of timer irqs compared to HZ if
  it detects an apic (and at least early versions of FreeBSD 8 had
  a bug that essentially halved qemu's clock rate too); the only
  reason you usually don't see symptoms of this with FreeBSD 8
  guests is they automatically reduce their HZ to 100 when running
  in a VM while the default for the host kernel is still HZ=1000.
  Workaround: you can disable the apic clock in the guest by setting

    hint.apic.0.clock="0"

  in loader.conf(5) (or manually at the loader prompt), if that
  doesn't work the only things you can do is either reduce the
  guest's HZ to, say, 100 by setting e.g.

    kern.hz="100"

  from the loader as above (which usually is a good idea in a VM
  anyway and FreeBSD 8 now does by itself as mentioned), or otherwise
  increase the host's HZ to 2000 or even 4000 from the loader in
  the same way.

- The -smb option (smb-export local dir to guest using the default
  slirp networking) needs the samba port/package installed
  in addition to qemu. (SAMBA knob.)

- If you want to use usb devices connected to the host in the guest
  yot need either recent 10-current (not tested yet much) or you can
  use usbredir over the network (see below); also unless you are
  running qemu as root you then need to fix permissions for /dev/ugen*
  device nodes: if you are on 5.x or later (devfs) put a rule in
  /etc/devfs.rules, activate it in /etc/rc.conf and run /etc/rc.d/devfs
  restart.  Example devfs.rules:

    [ugen_ruleset=20]
    add path 'ugen*' mode 660 group operator

  corresponding rc.conf line:

    devfs_system_ruleset="ugen_ruleset"

- If you want to test the new (in 0.15.0) usb network redirection (USBREDIR
  option) see this thread by Hans de Goede <hdegoede <at> redhat.com>:

    http://thread.gmane.org/gmane.comp.emulators.qemu/110176/focus=110183

  Quote:

  Example usage:

  1) Start usbredirserver for a usb device:
  sudo usbredirserver 045e:0772
  2) Start qemu with usb2 support + a chardev talking to usbredirserver +
     a usb-redir device using this chardev:
  qemu -usb \
    -readconfig docs/ich9-ehci-uhci.cfg \
    -chardev socket,id=usbredirchardev,host=localhost,port=4000 \
    -device usb-redir,chardev=usbredirchardev,id=usbredirdev ...

  [you would replace docs/ich9-ehci-uhci.cfg with e.g.
  /raven/share/doc/qemu/docs/ich9-ehci-uhci.cfg, but turns out
  ehci was broken for me here with FreeBSD guests and the previous
  qemu version at least, I got:

    FETCHENTRY: entry at 22C5484 is of type 2 which is not supported yet processing error - resetting ehci HC
    Assertion failed: (0), function ehci_advance_state, file /data/ports/emulators/qemu-devel/work/qemu-0.15.0/hw/usb-ehci.c, line 2045.

  The new qemu version works better tho.]

- Still usb: since the hub is no longer attached to the uchi controller and
  the wakeup mechanism, resume interrupt is not implemented yet linux guests
  will suspend the bus, i.e. they wont see devices usb_add'ed after its
  (linux') uhci module got loaded.  Workaround: either add devices before
  linux loads the module or rmmod and modprobe it afterwards.  [Not sure
  if this still applies to the new libusb host code used on recent
  10-current.]

- If you build qemu wihout SDL and then get crashes running it try passing it
  -nographic.  This should probably be default in that case...

- qemu's network boot roms (-boot n) have a bug when bootfiles sizes are a
  multiple of blksize, if this affects you (like with FreeBSD's /boot/pxeboot)
  you can do like

    cp /boot/pxeboot pxeboot-qemu && chmod +w pxeboot-qemu && echo >>pxeboot-qemu

  and then use pxeboot-qemu.  Actually you need recent btx code
  (from after 7.0 was released) because of the real mode boot
  problem, so use at least pxeboot from there.  And I just did that
  for the pxeboot extracted out of

    ftp://ftp.freebsd.org/pub/FreeBSD/snapshots/200805/7.0-STABLE-200805-i386-bootonly.iso

  and placed it here:

    http://people.freebsd.org/~nox/qemu/pxeboot-qemu

- If you use slirp (usernet, the default) and want to mount nfs into the guest
  and you are not running qemu as root, then mountd(8) on the exporting box
  needs to be run with -n in order to accept requests from ports >= 1024.

- (not FreeBSD-specific:) There have been reports of qcow2 corruption with (at
  least) win2k guests on recent kvm (which uses similar qcow2 code than qemu
  now, see this thread:

    http://lists.gnu.org/archive/html/qemu-devel/2009-02/msg00713.html -

  the consensus on that thread seems to be that qcow(2) code has always been
  experimental and you should use raw images if you want reliability; raw is
  also usually faster.)  You should be able to migrate existing images to raw
  using qemu-img(1)'s convert function; raw doesn't support advanced features
  like snapshots tho.  [a few important qcow2 bugfixed have been committed in
  the meantime so this _might_ be less of an issue now; and meanwhile there
  also is the new qed format - I don't know how stable that one is.]

- (also not FreeBSD-specific:)  It is recommended to pass raw images using the
  new -drive syntax, specifying format=raw explicitly in order to avoid
  malicious guests being able to exploit the format autodetection thats
  otherwise getting used.  (Not that you should run malicious guests anyway,
  but this eleminates at least a known attack vector.)

- qemu now has improved physical cdrom support, but still there is at
  least one known problem: you need to have the guest eject the disc if you
  want to change it/take it out, or otherwise the guest may continue using
  state (like size) of the old disc.  (You can also do like `change ide1-cd0
  /dev/acd0' in the monitor after taking out the disc if a guest cannot eject
  it itself.)

- The default configuration location (qemu-ifup script etc.) has been changed
  from /etc to PREFIX/etc (usually /raven/etc).  Move your files accordingly.

- The pcap code (-net nic... -net pcap,ifname=...) should work properly now,
  with only one exception:  Advanced features like TSO used on the host
  interface can cause oversize packets which now do get truncated to avoid
  confusing/panicing guests but of course still will cause retransmissions.
  So if you see slow throughput and `pcap_send: packet size > ..., truncating'
  messages on qemu's tty try disabling TSO etc on the host interface at least
  while using pcap.


[FILE:20:files/qemu-ifdown.sample]
#!/bin/sh
exec true


[FILE:20:files/qemu-ifup.sample]
#!/bin/sh
exec true


[FILE:66:files/special.mk]
.if "${ARCH_STANDARD}" == "x86_64"
MAKE_ARGS+=	ARCH=x86_64
.endif


[FILE:436:dragonfly/patch-disas_libvixl_vixl_utils.h]
--- disas/libvixl/vixl/utils.h.orig	2020-08-11 19:17:14 UTC
+++ disas/libvixl/vixl/utils.h
@@ -42,6 +42,13 @@ namespace vixl {
 #define PRINTF_CHECK(format_index, varargs_index)
 #endif
 
+#ifndef INT64_C
+#define INT32_C(c) c
+#define INT64_C(c) (c ## LL)
+#define UINT32_C(c) (c ## U)
+#define UINT64_C(c) (c ## ULL)
+#endif
+
 // Check number width.
 inline bool is_intn(unsigned n, int64_t x) {
   VIXL_ASSERT((0 < n) && (n < 64));


[FILE:323:dragonfly/patch-hw-ppc_newworld.c]
--- hw/ppc/mac_newworld.c.orig	2020-08-11 19:17:15 UTC
+++ hw/ppc/mac_newworld.c
@@ -74,6 +74,11 @@
 #include "hw/sysbus.h"
 #include "trace.h"
 
+/* FreeBSD headers define this */
+#ifdef round_page
+#undef round_page
+#endif
+
 #define MAX_IDE_BUS 2
 #define CFG_ADDR 0xf0000510
 #define TBFREQ (100UL * 1000UL * 1000UL)


[FILE:334:dragonfly/patch-hw_ppc_mac__oldworld.c]
--- hw/ppc/mac_oldworld.c.orig	2020-08-11 19:17:15 UTC
+++ hw/ppc/mac_oldworld.c
@@ -60,6 +60,11 @@
 
 #define GRACKLE_BASE 0xfec00000
 
+/* FreeBSD headers define this */
+#ifdef round_page
+#undef round_page
+#endif
+
 static void fw_cfg_boot_set(void *opaque, const char *boot_device,
                             Error **errp)
 {


[FILE:906:dragonfly/patch-util_coroutine-ucontext.c]
--- util/coroutine-ucontext.c.orig	2020-08-11 19:17:15 UTC
+++ util/coroutine-ucontext.c
@@ -221,7 +221,15 @@ Coroutine *qemu_coroutine_new(void)
                 2, arg.i[0], arg.i[1]);
 
     /* swapcontext() in, siglongjmp() back out */
-    if (!sigsetjmp(old_env, 0)) {
+    /* Save signal mask in this sigsetjmp, because makecontext on DragonFly
+     * leaves all signals blocked when entering the new context with
+     * swapcontext.
+     * Workaround this, by just having the signal mask restored by the
+     * siglongjmp that brings us back from qemu_coroutine_new().
+     * XXX Remove this workaround when the makecontext behaviour is fixed
+     *     on DragonFly.
+     */
+    if (!sigsetjmp(old_env, 1)) {
         start_switch_fiber_asan(COROUTINE_YIELD, &fake_stack_save, co->stack,
                                 co->stack_size);
         start_switch_fiber_tsan(&fake_stack_save,

