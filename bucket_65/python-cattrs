# Buildsheet autogenerated by ravenadm tool -- Do not edit.

NAMEBASE=		python-cattrs
VERSION=		23.2.0
KEYWORDS=		python
VARIANTS=		v11 v12
SDESC[v11]=		Composable complex class support for attrs (3.11)
SDESC[v12]=		Composable complex class support for attrs (3.12)
HOMEPAGE=		https://catt.rs
CONTACT=		Python_Automaton[python@ironwolf.systems]

DOWNLOAD_GROUPS=	main
SITES[main]=		PYPIWHL/19/29/f0b58e2dcdb2c2186a790410fabb66e3a0a70e0bea53b11bfa6ce7dca46c
DISTFILE[1]=		cattrs-23.2.0-py3-none-any.whl:main
DF_INDEX=		1
SPKGS[v11]=		single
SPKGS[v12]=		single

OPTIONS_AVAILABLE=	PY311 PY312
OPTIONS_STANDARD=	none
VOPTS[v11]=		PY311=ON PY312=OFF
VOPTS[v12]=		PY311=OFF PY312=ON

DISTNAME=		cattrs-23.2.0.dist-info

GENERATED=		yes

[PY311].RUN_DEPENDS_ON=			python-attrs:single:v11
[PY311].USES_ON=			python:v11,wheel

[PY312].RUN_DEPENDS_ON=			python-attrs:single:v12
[PY312].USES_ON=			python:v12,wheel

[FILE:2726:descriptions/desc.single]
# cattrs

[image]
[image]
[image]
[image]
[image]
[image]

---

**cattrs** is an open source Python library for structuring and
unstructuring
data. _cattrs_ works best with _attrs_ classes, dataclasses and the usual
Python collections, but other kinds of classes are supported by manually
registering converters.

Python has a rich set of powerful, easy to use, built-in data types like
dictionaries, lists and tuples. These data types are also the lingua franca
of most data serialization libraries, for formats like json, msgpack, cbor,
yaml or toml.

Data types like this, and mappings like `dict` s in particular, represent
unstructured data. Your data is, in all likelihood, structured: not all
combinations of field names or values are valid inputs to your programs. In
Python, structured data is better represented with classes and
enumerations.
_attrs_ is an excellent library for declaratively describing the structure
of
your data, and validating it.

When you're handed unstructured data (by your network, file system,
database...),
_cattrs_ helps to convert this data into structured data. When you have to
convert your structured data into data types other libraries can handle,
_cattrs_ turns your classes and enumerations into dictionaries, integers
and
strings.

Here's a simple taste. The list containing a float, an int and a string
gets converted into a tuple of three ints.

```python
>>> import cattrs

>>> cattrs.structure([1.0, 2, "3"], tuple[int, int, int])
(1, 2, 3)
```

_cattrs_ works well with _attrs_ classes out of the box.

```python
>>> from attrs import frozen
>>> import cattrs

>>> @frozen  # It works with non-frozen classes too.
... class C:
...     a: int
...     b: str

>>> instance = C(1, 'a')
>>> cattrs.unstructure(instance)
{'a': 1, 'b': 'a'}
>>> cattrs.structure({'a': 1, 'b': 'a'}, C)
C(a=1, b='a')
```

Here's a much more complex example, involving `attrs` classes with type
metadata.

```python
>>> from enum import unique, Enum
>>> from typing import Optional, Sequence, Union
>>> from cattrs import structure, unstructure
>>> from attrs import define, field

>>> @unique
... class CatBreed(Enum):
...     SIAMESE = "siamese"
...     MAINE_COON = "maine_coon"
...     SACRED_BIRMAN = "birman"

>>> @define
... class Cat:
...     breed: CatBreed
...     names: Sequence[str]

>>> @define
... class DogMicrochip:
...     chip_id = field()  # Type annotations are optional, but recommended
...     time_chipped: float = field()

>>> @define
... class Dog:
...     cuteness: int
...     chip: Optional[DogMicrochip] = None

>>> p = unstructure([Dog(cuteness=1, chip=DogMicrochip(chip_id=1,
time_chipped=10.0)),
...                  Cat(breed=CatBreed.MAINE_COON, names=('Fluffly',


[FILE:109:distinfo]
9783f5afefc889b680a83b7afc88c53388ae89d05d4c199b35869beac1f77832        57457 cattrs-23.2.0-py3-none-any.whl

