# Buildsheet autogenerated by ravenadm tool -- Do not edit.

NAMEBASE=		python-cattrs
VERSION=		1.0.0
KEYWORDS=		python
VARIANTS=		py38 py37
SDESC[py37]=		Composable complex class support for attrs (PY37)
SDESC[py38]=		Composable complex class support for attrs (PY38)
HOMEPAGE=		https://github.com/Tinche/cattrs
CONTACT=		Python_Automaton[python@ironwolf.systems]

DOWNLOAD_GROUPS=	main
SITES[main]=		PYPI/c/cattrs
DISTFILE[1]=		cattrs-1.0.0.tar.gz:main
DF_INDEX=		1
SPKGS[py37]=		single
SPKGS[py38]=		single

OPTIONS_AVAILABLE=	PY38 PY37
OPTIONS_STANDARD=	none
VOPTS[py37]=		PY38=OFF PY37=ON
VOPTS[py38]=		PY38=ON PY37=OFF

DISTNAME=		cattrs-1.0.0

GENERATED=		yes

[PY37].BUILDRUN_DEPENDS_ON=		python-attrs:single:py37
[PY37].USES_ON=				python:py37

[PY38].BUILDRUN_DEPENDS_ON=		python-attrs:single:py38
[PY38].USES_ON=				python:py38

[FILE:3074:descriptions/desc.single]
======
cattrs
======

        :alt: Documentation Status

        :alt: Supported Python versions

----

cattrs is an open source Python library for structuring and unstructuring
data. cattrs works best with attrs classes and the usual Python
collections, but other kinds of classes are supported by manually
registering
converters.

Python has a rich set of powerful, easy to use, built-in data types like
dictionaries, lists and tuples. These data types are also the lingua franca
of most data serialization libraries, for formats like json, msgpack, yaml
or
toml.

Data types like this, and mappings like dict s in particular, represent
unstructured data. Your data is, in all likelihood, structured: not all
combinations of field names are values are valid inputs to your programs.
In
Python, structured data is better represented with classes and
enumerations.
attrs is an excellent library for declaratively describing the structure of
your data, and validating it.

When you're handed unstructured data (by your network, file system,
database...),
cattrs helps to convert this data into structured data. When you have to
convert your structured data into data types other libraries can handle,
cattrs turns your classes and enumerations into dictionaries, integers and
strings.

Here's a simple taste. The list containing a float, an int and a string
gets converted into a tuple of three ints.

    >>> import cattr
    >>> from typing import Tuple
    >>>
    >>> cattr.structure([1.0, 2, "3"], Tuple[int, int, int])
    (1, 2, 3)

cattrs works well with attrs classes out of the box.

    >>> import attr, cattr
    >>>
    >>> @attr.s(slots=True, frozen=True)  # It works with normal classes
too.
    ... class C:
    ...     a = attr.ib()
    ...     b = attr.ib()
    ...
    >>> instance = C(1, 'a')
    >>> cattr.unstructure(instance)
    {'a': 1, 'b': 'a'}
    >>> cattr.structure({'a': 1, 'b': 'a'}, C)
    C(a=1, b='a')

Here's a much more complex example, involving attrs classes with type
metadata.

    >>> from enum import unique, Enum
    >>> from typing import List, Optional, Sequence, Union
    >>> from cattr import structure, unstructure
    >>> import attr
    >>>
    >>> @unique
    ... class CatBreed(Enum):
    ...     SIAMESE = "siamese"
    ...     MAINE_COON = "maine_coon"
    ...     SACRED_BIRMAN = "birman"
    ...
    >>> @attr.s
    ... class Cat:
    ...     breed: CatBreed = attr.ib()
    ...     names: Sequence[str] = attr.ib()
    ...
    >>> @attr.s
    ... class DogMicrochip:
    ...     chip_id = attr.ib()
    ...     time_chipped: float = attr.ib()
    ...
    >>> @attr.s
    ... class Dog:
    ...     cuteness: int = attr.ib()
    ...     chip: Optional[DogMicrochip] = attr.ib()
    ...
    >>> p = unstructure([Dog(cuteness=1, chip=DogMicrochip(chip_id=1,
time_chipped=10.0)),
    ...                  Cat(breed=CatBreed.MAINE_COON, names=('Fluffly',
'Fluffer'))])
    ...
    >>> print(p)
    [{'cuteness': 1, 'chip': {'chip_id': 1, 'time_chipped': 10.0}},
{'breed': 'maine_coon', 'names': ('Fluffly', 'Fluffer')}]


[FILE:98:distinfo]
b7ab5cf8ad127c42eefd01410c1c6e28569a45a255ea80ed968511873c433c7a        32506 cattrs-1.0.0.tar.gz

