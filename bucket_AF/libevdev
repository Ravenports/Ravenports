# Buildsheet autogenerated by ravenadm tool -- Do not edit.

NAMEBASE=		libevdev
VERSION=		1.13.2
KEYWORDS=		devel
VARIANTS=		standard
SDESC[standard]=	Wrapper library for evdev devices
HOMEPAGE=		https://www.freedesktop.org/wiki/Software/libevdev/
CONTACT=		nobody

DOWNLOAD_GROUPS=	main
SITES[main]=		https://www.freedesktop.org/software/libevdev/
DISTFILE[1]=		libevdev-1.13.2.tar.xz:main
DF_INDEX=		1
SPKGS[standard]=	complete
			primary
			tools
			dev
			man

OPTIONS_AVAILABLE=	none
OPTIONS_STANDARD=	none

BUILD_DEPENDS=		evdev-proto:single:standard

USES=			meson pkgconfig python:build

LICENSE=		MIT:primary
LICENSE_FILE=		MIT:{{WRKSRC}}/COPYING
LICENSE_SCHEME=		solo

FPC_EQUIVALENT=		devel/libevdev
MESON_ARGS=		-Ddocumentation=disabled
			-Dtests=disabled

SOVERSION=		2.3.0

CFLAGS=			-Wno-incompatible-pointer-types
			-Wno-unused-function
			-Wno-format-truncation

pre-configure:
	${CP} ${LOCALBASE}/include/linux/*.h ${WRKSRC}/include/linux/

post-extract:
	(cd ${WRKSRC}/include && ${MV} linux stock)
	${MKDIR} ${WRKSRC}/include/linux

[FILE:328:descriptions/desc.primary]
libevdev is a wrapper library for evdev devices. It moves the common
tasks when dealing with evdev devices into a library and provides a
library interface to the callers, thus avoiding erroneous ioctls, etc.

The eventual goal is that libevdev wraps all ioctls available to evdev
devices, thus making direct access unnecessary.


[FILE:47:descriptions/desc.tools]
This package contains tools based on libevdev.


[FILE:101:distinfo]
3eca86a6ce55b81d5bce910637fc451c8bbe373b1f9698f375c7f1ad0de3ac48       460456 libevdev-1.13.2.tar.xz


[FILE:57:manifests/plist.primary]
lib/
 libevdev.so.%%SOMAJOR%%
 libevdev.so.%%SOVERSION%%


[FILE:68:manifests/plist.tools]
bin/
 libevdev-tweak-device
 mouse-dpi-tool
 touchpad-edge-detector


[FILE:104:manifests/plist.dev]
include/libevdev-1.0/libevdev/
 libevdev-uinput.h
 libevdev.h
lib/libevdev.so
lib/pkgconfig/libevdev.pc


[FILE:123:manifests/plist.man]
share/man/man1/
 libevdev-tweak-device.1.gz
 mouse-dpi-tool.1.gz
 touchpad-edge-detector.1.gz
share/man/man3/libevdev.3.gz


[FILE:572:patches/patch-meson.build]
--- meson.build.orig	2023-05-05 01:30:18 UTC
+++ meson.build
@@ -40,8 +40,8 @@ pkgconfig = import('pkgconfig')
 dep_lm = cc.find_library('m')
 dep_rt = cc.find_library('rt')
 
-input_h = dir_root / 'include' / 'linux' / host_machine.system() / 'input.h'
-input_event_codes_h = dir_root / 'include' / 'linux' / host_machine.system() / 'input-event-codes.h'
+input_h = dir_root / 'include' / 'linux' / 'input.h'
+input_event_codes_h = dir_root / 'include' / 'linux' / 'input-event-codes.h'
 
 # event-names.h
 make_event_names = find_program('libevdev/make-event-names.py')


[FILE:2605:patches/patch-tools_mouse-dpi-tool.c]
--- tools/mouse-dpi-tool.c.orig	2023-05-05 01:30:18 UTC
+++ tools/mouse-dpi-tool.c
@@ -5,6 +5,11 @@
 
 #include "config.h"
 
+#if defined(__DragonFly__)
+#include <sys/types.h>
+#include <sys/event.h>
+#include <sys/time.h>
+#endif
 #include <errno.h>
 #include <fcntl.h>
 #include <libgen.h>
@@ -130,6 +135,88 @@ signal_handler(__attribute__((__unused__
 	signalled++;
 }
 
+#if defined(__DragonFly__)
+static int
+mainloop(struct libevdev *dev, struct dimensions *dim) {
+	int kq, nev;
+	struct kevent change[2];
+	struct kevent events[2];
+	int libevdev_fd;
+	struct sigaction sa;
+
+	memset(&sa, 0, sizeof(struct sigaction));
+	sa.sa_handler = SIG_IGN;
+	sigaction(SIGINT, &sa, NULL);
+
+	kq = kqueue();
+	if (kq == -1) {
+		fprintf(stderr, "Error initializing kqueue: %s\n",
+		        strerror(errno));
+		return (EXIT_FAILURE);
+	}
+
+	libevdev_fd = libevdev_get_fd(dev);
+	EV_SET(&change[0], libevdev_fd, EVFILT_READ, EV_ADD | EV_ENABLE, 0, 0,
+	       NULL);
+	EV_SET(&change[1], SIGINT, EVFILT_SIGNAL, EV_ADD | EV_ENABLE, 0, 0,
+	       NULL);
+
+	if (kevent(kq, change, 2, NULL, 0, NULL) == -1) {
+		fprintf(stderr, "Error adding events: %s\n", strerror(errno));
+		close(kq);
+		return (EXIT_FAILURE);
+	}
+
+	for (;;) {
+		struct input_event ev;
+		int rc;
+
+		nev = kevent(kq, NULL, 0, events, 2, NULL);
+
+		if (nev == 0) {
+			break;
+		} else if (nev == -1) {
+			if (errno == EINTR) {
+				continue;
+			} else {
+				fprintf(stderr, "Error from kqueue: %s\n",
+				    strerror(errno));
+				return (EXIT_FAILURE);
+			}
+		} else if (nev > 0) {
+			for (int i = 0; i < nev; i++) {
+				if ((events[i].filter == EVFILT_SIGNAL) &&
+				    (events[i].data > 0)) {
+				    goto out;
+				}
+			}
+		}
+
+		/* now let's find read events */
+		if (nev > 0) {
+			for (int i = 0; i < nev; i++) {
+				if (events[i].filter == EVFILT_READ) {
+					do {
+						rc = libevdev_next_event(dev, LIBEVDEV_READ_FLAG_NORMAL, &ev);
+						if (rc == LIBEVDEV_READ_STATUS_SYNC) {
+							fprintf(stderr, "Error: cannot keep up\n");
+							return 1;
+						} else if (rc != -EAGAIN && rc < 0) {
+							fprintf(stderr, "Error: %s\n", strerror(-rc));
+							return 1;
+						} else if (rc == LIBEVDEV_READ_STATUS_SUCCESS) {
+							handle_event(dim, &ev);
+						}
+					} while (rc != -EAGAIN);
+				}
+			}
+		}
+	}
+
+out:
+	return 0;
+}
+#else  /* Linux */
 static int
 mainloop(struct libevdev *dev, struct measurements *m) {
 	struct pollfd fds;
@@ -165,6 +252,7 @@ mainloop(struct libevdev *dev, struct me
 
 	return 0;
 }
+#endif
 
 static inline double
 mean_frequency(struct measurements *m)


[FILE:2641:patches/patch-tools_touchpad-edge-detector.c]
--- tools/touchpad-edge-detector.c.orig	2023-05-05 01:30:18 UTC
+++ tools/touchpad-edge-detector.c
@@ -5,6 +5,11 @@
 
 #include "config.h"
 
+#if defined(__DragonFly__)
+#include <sys/types.h>
+#include <sys/event.h>
+#include <sys/time.h>
+#endif
 #include <errno.h>
 #include <fcntl.h>
 #include <libgen.h>
@@ -93,6 +98,88 @@ signal_handler(__attribute__((__unused__
 	signalled++;
 }
 
+#if defined(__DragonFly__)
+static int
+mainloop(struct libevdev *dev, struct dimensions *dim) {
+	int kq, nev;
+	struct kevent change[2];
+	struct kevent events[2];
+	int libevdev_fd;
+	struct sigaction sa;
+
+	memset(&sa, 0, sizeof(struct sigaction));
+	sa.sa_handler = SIG_IGN;
+	sigaction(SIGINT, &sa, NULL);
+
+	kq = kqueue();
+	if (kq == -1) {
+		fprintf(stderr, "Error initializing kqueue: %s\n",
+		        strerror(errno));
+		return (EXIT_FAILURE);
+	}
+
+	libevdev_fd = libevdev_get_fd(dev);
+	EV_SET(&change[0], libevdev_fd, EVFILT_READ, EV_ADD | EV_ENABLE, 0, 0,
+	       NULL);
+	EV_SET(&change[1], SIGINT, EVFILT_SIGNAL, EV_ADD | EV_ENABLE, 0, 0,
+	       NULL);
+
+	if (kevent(kq, change, 2, NULL, 0, NULL) == -1) {
+		fprintf(stderr, "Error adding events: %s\n", strerror(errno));
+		close(kq);
+		return (EXIT_FAILURE);
+	}
+
+	for (;;) {
+		struct input_event ev;
+		int rc;
+
+		nev = kevent(kq, NULL, 0, events, 2, NULL);
+
+		if (nev == 0) {
+			break;
+		} else if (nev == -1) {
+			if (errno == EINTR) {
+				continue;
+			} else {
+				fprintf(stderr, "Error from kqueue: %s\n",
+				    strerror(errno));
+				return (EXIT_FAILURE);
+			}
+		} else if (nev > 0) {
+			for (int i = 0; i < nev; i++) {
+				if ((events[i].filter == EVFILT_SIGNAL) &&
+				    (events[i].data > 0)) {
+				    goto out;
+				}
+			}
+		}
+
+		/* now let's find read events */
+		if (nev > 0) {
+			for (int i = 0; i < nev; i++) {
+				if (events[i].filter == EVFILT_READ) {
+					do {
+						rc = libevdev_next_event(dev, LIBEVDEV_READ_FLAG_NORMAL, &ev);
+						if (rc == LIBEVDEV_READ_STATUS_SYNC) {
+							fprintf(stderr, "Error: cannot keep up\n");
+							return 1;
+						} else if (rc != -EAGAIN && rc < 0) {
+							fprintf(stderr, "Error: %s\n", strerror(-rc));
+							return 1;
+						} else if (rc == LIBEVDEV_READ_STATUS_SUCCESS) {
+							handle_event(dim, &ev);
+						}
+					} while (rc != -EAGAIN);
+				}
+			}
+		}
+	}
+
+out:
+	return 0;
+}
+#else  /* Linux */
 static int
 mainloop(struct libevdev *dev, struct dimensions *dim) {
 	struct pollfd fds;
@@ -129,6 +216,7 @@ mainloop(struct libevdev *dev, struct di
 
 	return 0;
 }
+#endif
 
 static inline void
 pid_vid_matchstr(struct libevdev *dev, char *match, size_t sz)

