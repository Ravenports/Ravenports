# Buildsheet autogenerated by ravenadm tool -- Do not edit.

NAMEBASE=		zig
VERSION=		0.15.2
REVISION=		1
KEYWORDS=		devel lang
VARIANTS=		std
SDESC[std]=		Programming language
HOMEPAGE=		https://ziglang.org/
CONTACT=		Tse_[tse@tse.gratis]

DOWNLOAD_GROUPS=	main
SITES[main]=		GITHUB/ziglang:zig:0.15.2
DISTFILE[1]=		generated:main
DF_INDEX=		1
SPKGS[std]=		single

OPTIONS_AVAILABLE=	none
OPTIONS_STANDARD=	none

BROKEN[dragonfly]=	Stage 1 binary started crashing
BROKEN[midnightbsd]=	error: UnknownOperatingSystem
ONLY_FOR_OPSYS=		freebsd dragonfly netbsd linux midnightbsd

BUILD_DEPENDS=		clang20:compiler:std
			lld20:dev:std
			lld20:primary:std
			llvm20:tools:std
			llvm20:dev:std
BUILDRUN_DEPENDS=	clang20:dynlibs:std

USES=			cmake ncurses execinfo zlib
GNOME_COMPONENTS=	libxml2

LICENSE=		MIT:single
LICENSE_FILE=		MIT:{{WRKSRC}}/LICENSE
LICENSE_SCHEME=		solo

FPC_EQUIVALENT=		lang/zig

INSTALL_REQ_TOOLCHAIN=	yes

VAR_OPSYS[midnightbsd]=	MAKEFILE_LINE=CONFIGURE_TARGET=x86_64-raven-freebsd12.3

post-install:
	${STRIP_CMD} ${STAGEDIR}${PREFIX}/bin/zig
	# remove empty directories
	${FIND} ${STAGEDIR}${PREFIX}/lib -type d -empty -delete
	# remove licenses out of place
	${RM} ${STAGEDIR}${PREFIX}/lib/zig/*/LICENSE.TXT
	${RM} ${STAGEDIR}${PREFIX}/lib/zig/libc/glibc/LICENSES
	# automatic plist for much of the manifest (influenced by clang)
	@(cd ${STAGEDIR}${PREFIX} && ${FIND} \
		lib/zig/compiler_rt \
		lib/zig/include \
		lib/zig/libc \
		lib/zig/libcxx \
		lib/zig/libcxxabi \
		lib/zig/std \
		lib/zig/libtsan \
		lib/zig/libunwind \
	\( -type f -o -type l \) 2>/dev/null | ${SORT}) \
	>> ${WRKDIR}/.manifest.single.mktmp

pre-configure:
	${REINPLACE_CMD} \
		-e 's|@GCC_TARGET_LIBDIR@|${LOCALBASE}/toolchain/ravensys-gcc/lib/gcc/${CONFIGURE_TARGET}/14.2.0|' \
		${WRKSRC}/lib/std/zig/LibCInstallation.zig
	${REINPLACE_CMD} \
		-e 's|@GCC_TARGET_LIBDIR@|${LOCALBASE}/toolchain/ravensys-gcc/lib/gcc/${CONFIGURE_TARGET}/14.2.0|' \
		-e 's|@GCC_LIBDIR@|${LOCALBASE}/toolchain/ravensys-gcc/${ASLIB}|' \
		-e 's|@LOCALBASE@|${LOCALBASE}|' \
		${WRKSRC}/build.zig
	${REINPLACE_CMD} -e 's|/usr/local|${PREFIX}|g' \
		${WRKSRC}/cmake/Findclang.cmake \
		${WRKSRC}/cmake/Findllvm.cmake \
		${WRKSRC}/cmake/Findlld.cmake
	${FIND} ${WRKSRC} -name "*.orig" -delete

[FILE:94:descriptions/desc.single]
General purpose programming language designed for robustness, optimality, and maintainability


[FILE:104:distinfo]
ebe6eb7006f6bbb72e54bd25d0675f2794084909d63a95aa315f2dcf2af5fd99     32724425 ziglang-zig-0.15.2.tar.gz


[FILE:2244:manifests/plist.single]
@comment lib/zig autolist: compiler_rt, include, libc, libcxx, libcxxabi, std, libtsan, libunwind
bin/zig
lib/zig/
 c.zig
 compiler_rt.zig
 fuzzer.zig
 ubsan_rt.zig
 zig.h
lib/zig/build-web/
 fuzz.zig
 index.html
 main.js
 main.zig
 style.css
 time_report.css
 time_report.zig
lib/zig/c/
 common.zig
 inttypes.zig
 stdlib.zig
 string.zig
 strings.zig
lib/zig/compiler/
 aro_translate_c.zig
 build_runner.zig
 libc.zig
 objcopy.zig
 reduce.zig
 std-docs.zig
 test_runner.zig
lib/zig/compiler/aro/
 aro.zig
 backend.zig
lib/zig/compiler/aro/aro/
 Attribute.zig
 Builtins.zig
 CodeGen.zig
 Compilation.zig
 Diagnostics.zig
 Driver.zig
 Hideset.zig
 InitList.zig
 LangOpts.zig
 Parser.zig
 Pragma.zig
 Preprocessor.zig
 Source.zig
 StringInterner.zig
 SymbolStack.zig
 Tokenizer.zig
 Toolchain.zig
 Tree.zig
 Type.zig
 Value.zig
 annex_g.zig
 char_info.zig
 features.zig
 record_layout.zig
 target.zig
 text_literal.zig
 tracy.zig
lib/zig/compiler/aro/aro/Attribute/names.zig
lib/zig/compiler/aro/aro/Builtins/
 Builtin.zig
 Properties.zig
 TypeDescription.zig
 eval.zig
lib/zig/compiler/aro/aro/Diagnostics/messages.zig
lib/zig/compiler/aro/aro/Driver/
 Distro.zig
 Filesystem.zig
 GCCDetector.zig
 GCCVersion.zig
 Multilib.zig
lib/zig/compiler/aro/aro/Tree/number_affixes.zig
lib/zig/compiler/aro/aro/char_info/identifier_tables.zig
lib/zig/compiler/aro/aro/pragmas/
 gcc.zig
 message.zig
 once.zig
 pack.zig
lib/zig/compiler/aro/aro/toolchains/Linux.zig
lib/zig/compiler/aro/backend/
 Interner.zig
 Ir.zig
 Object.zig
lib/zig/compiler/aro/backend/Ir/x86/Renderer.zig
lib/zig/compiler/aro/backend/Object/Elf.zig
lib/zig/compiler/aro_translate_c/ast.zig
lib/zig/compiler/reduce/Walk.zig
lib/zig/compiler/resinator/
 ani.zig
 ast.zig
 bmp.zig
 cli.zig
 code_pages.zig
 comments.zig
 compile.zig
 cvtres.zig
 disjoint_code_page.zig
 errors.zig
 ico.zig
 lang.zig
 lex.zig
 literals.zig
 main.zig
 parse.zig
 preprocess.zig
 rc.zig
 res.zig
 source_mapping.zig
 utils.zig
 windows1252.zig
lib/zig/docs/
 index.html
 main.js
lib/zig/docs/wasm/
 Decl.zig
 Walk.zig
 html_render.zig
 main.zig
 markdown.zig
lib/zig/docs/wasm/markdown/
 Document.zig
 Parser.zig
 renderer.zig
lib/zig/init/
 build.zig
 build.zig.zon
lib/zig/init/src/
 main.zig
 root.zig


[FILE:2110:patches/patch-build.zig]
--- build.zig.orig	2025-08-19 23:20:53 UTC
+++ build.zig
@@ -814,6 +814,7 @@ fn addCmakeCfgOptionsToExe(
                     else => |e| return e,
                 };
                 mod.linkSystemLibrary("unwind", .{});
+                exe.addRPath(.{ .cwd_relative = "@GCC_LIBDIR@" });
             },
             .ios, .macos, .watchos, .tvos, .visionos => {
                 mod.link_libcpp = true;
@@ -821,20 +822,10 @@ fn addCmakeCfgOptionsToExe(
             .windows => {
                 if (target.abi != .msvc) mod.link_libcpp = true;
             },
-            .freebsd => {
-                try addCxxKnownPath(b, cfg, exe, b.fmt("libc++.{s}", .{lib_suffix}), null, need_cpp_includes);
-                if (static) try addCxxKnownPath(b, cfg, exe, b.fmt("libgcc_eh.{s}", .{lib_suffix}), null, need_cpp_includes);
-            },
-            .openbsd => {
-                // - llvm requires libexecinfo which has conflicting symbols with libc++abi
-                // - only an issue with .a linking
-                // - workaround is to link c++abi dynamically
-                try addCxxKnownPath(b, cfg, exe, b.fmt("libc++.{s}", .{target.dynamicLibSuffix()[1..]}), null, need_cpp_includes);
-                try addCxxKnownPath(b, cfg, exe, b.fmt("libc++abi.{s}", .{target.dynamicLibSuffix()[1..]}), null, need_cpp_includes);
-            },
-            .netbsd, .dragonfly => {
-                try addCxxKnownPath(b, cfg, exe, b.fmt("libstdc++.{s}", .{lib_suffix}), null, need_cpp_includes);
-                if (static) try addCxxKnownPath(b, cfg, exe, b.fmt("libgcc_eh.{s}", .{lib_suffix}), null, need_cpp_includes);
+            .netbsd, .dragonfly, .freebsd => {
+                exe.addObjectFile(.{ .cwd_relative = "@GCC_LIBDIR@/libstdc++.a" });
+                exe.addObjectFile(.{ .cwd_relative = "@GCC_TARGET_LIBDIR@/libgcc_eh.a" });
+                exe.addRPath(.{ .cwd_relative = "@LOCALBASE@/lib" });
             },
             .solaris, .illumos => {
                 try addCxxKnownPath(b, cfg, exe, b.fmt("libstdc++.{s}", .{lib_suffix}), null, need_cpp_includes);


[FILE:2568:patches/patch-lib_std_zig_LibCInstallation.zig]
--- lib/std/zig/LibCInstallation.zig.orig	2025-08-19 23:20:53 UTC
+++ lib/std/zig/LibCInstallation.zig
@@ -972,23 +972,29 @@ pub fn resolveCrtPaths(
     };
     switch (target.os.tag) {
         .dragonfly => {
-            const gccv: []const u8 = if (target.os.version_range.semver.isAtLeast(.{
-                .major = 5,
-                .minor = 4,
-                .patch = 0,
-            }) orelse true) "gcc80" else "gcc54";
+            const gcc_dir_path: Path = .{
+                .root_dir = std.Build.Cache.Directory.cwd(),
+                .sub_path = "@GCC_TARGET_LIBDIR@",
+            };
+            return .{
+                .crt0 = if (crt_basenames.crt0) |basename| try crt_dir_path.join(arena, basename) else null,
+                .crti = if (crt_basenames.crti) |basename| try crt_dir_path.join(arena, basename) else null,
+                .crtn = if (crt_basenames.crtn) |basename| try crt_dir_path.join(arena, basename) else null,
+                .crtbegin = if (crt_basenames.crtbegin) |basename| try gcc_dir_path.join(arena, basename) else null,
+                .crtend = if (crt_basenames.crtend) |basename| try gcc_dir_path.join(arena, basename) else null,
+            };
+        },
+        .freebsd => {
+            const gcc_dir_path: Path = .{
+                .root_dir = std.Build.Cache.Directory.cwd(),
+                .sub_path = "@GCC_TARGET_LIBDIR@",
+            };
             return .{
                 .crt0 = if (crt_basenames.crt0) |basename| try crt_dir_path.join(arena, basename) else null,
                 .crti = if (crt_basenames.crti) |basename| try crt_dir_path.join(arena, basename) else null,
-                .crtbegin = if (crt_basenames.crtbegin) |basename| .{
-                    .root_dir = crt_dir_path.root_dir,
-                    .sub_path = try fs.path.join(arena, &.{ crt_dir_path.sub_path, gccv, basename }),
-                } else null,
-                .crtend = if (crt_basenames.crtend) |basename| .{
-                    .root_dir = crt_dir_path.root_dir,
-                    .sub_path = try fs.path.join(arena, &.{ crt_dir_path.sub_path, gccv, basename }),
-                } else null,
                 .crtn = if (crt_basenames.crtn) |basename| try crt_dir_path.join(arena, basename) else null,
+                .crtbegin = if (crt_basenames.crtbegin) |basename| try gcc_dir_path.join(arena, basename) else null,
+                .crtend = if (crt_basenames.crtend) |basename| try gcc_dir_path.join(arena, basename) else null,
             };
         },
         .haiku => {

