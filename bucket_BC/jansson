# Buildsheet autogenerated by ravenadm tool -- Do not edit.

NAMEBASE=		jansson
VERSION=		2.11
KEYWORDS=		devel
VARIANTS=		standard
SDESC[standard]=	JSON data encoding and manipulation library
HOMEPAGE=		http://www.digip.org/jansson/
CONTACT=		nobody

DOWNLOAD_GROUPS=	main
SITES[main]=		http://www.digip.org/jansson/releases/
DISTFILE[1]=		jansson-2.11.tar.bz2:main
DF_INDEX=		1
SPKGS[standard]=	single

OPTIONS_AVAILABLE=	none
OPTIONS_STANDARD=	none

USES=			cpe pkgconfig gmake libtool

LICENSE=		MIT:single
LICENSE_FILE=		MIT:{{WRKSRC}}/LICENSE
LICENSE_SCHEME=		solo

CPE_VENDOR=		jansson_project
FPC_EQUIVALENT=		devel/jansson

MUST_CONFIGURE=		gnu

INSTALL_TARGET=		install-strip
SOVERSION=		4.11.0

TEST_TARGET=		check

[FILE:284:descriptions/desc.single]
Jansson is a C library for encoding, decoding and manipulating JSON
data. Its main features and design principles are:

- Simple and intuitive API and data model
- Comprehensive documentation
- No dependencies on other libraries
- Full Unicode support (UTF-8)
- Extensive test suite



[FILE:99:distinfo]
783132e2fc970feefc2fa54199ef65ee020bd8e0e991a78ea44b8586353a0947       399179 jansson-2.11.tar.bz2


[FILE:153:manifests/plist.single]
include/
 jansson.h
 jansson_config.h
lib/
 libjansson.a
 libjansson.so
 libjansson.so.%%SOMAJOR%%
 libjansson.so.%%SOVERSION%%
lib/pkgconfig/jansson.pc


[FILE:1809:patches/patch-src_hashtable.c]
--- src/hashtable.c.orig	2016-08-25 17:21:36 UTC
+++ src/hashtable.c
@@ -108,10 +108,10 @@ static int hashtable_do_del(hashtable_t 
 {
     pair_t *pair;
     bucket_t *bucket;
-    size_t index;
+    size_t idx;
 
-    index = hash & hashmask(hashtable->order);
-    bucket = &hashtable->buckets[index];
+    idx = hash & hashmask(hashtable->order);
+    bucket = &hashtable->buckets[idx];
 
     pair = hashtable_find_pair(hashtable, bucket, key, hash);
     if(!pair)
@@ -154,7 +154,7 @@ static int hashtable_do_rehash(hashtable
 {
     list_t *list, *next;
     pair_t *pair;
-    size_t i, index, new_size, new_order;
+    size_t i, idx, new_size, new_order;
     struct hashtable_bucket *new_buckets;
 
     new_order = hashtable->order + 1;
@@ -180,8 +180,8 @@ static int hashtable_do_rehash(hashtable
     for(; list != &hashtable->list; list = next) {
         next = list->next;
         pair = list_to_pair(list);
-        index = pair->hash % new_size;
-        insert_to_bucket(hashtable, &hashtable->buckets[index], &pair->list);
+        idx = pair->hash % new_size;
+        insert_to_bucket(hashtable, &hashtable->buckets[idx], &pair->list);
     }
 
     return 0;
@@ -220,7 +220,7 @@ int hashtable_set(hashtable_t *hashtable
 {
     pair_t *pair;
     bucket_t *bucket;
-    size_t hash, index;
+    size_t hash, idx;
 
     /* rehash if the load ratio exceeds 1 */
     if(hashtable->size >= hashsize(hashtable->order))
@@ -228,8 +228,8 @@ int hashtable_set(hashtable_t *hashtable
             return -1;
 
     hash = hash_str(key);
-    index = hash & hashmask(hashtable->order);
-    bucket = &hashtable->buckets[index];
+    idx = hash & hashmask(hashtable->order);
+    bucket = &hashtable->buckets[idx];
     pair = hashtable_find_pair(hashtable, bucket, key, hash);
 
     if(pair)


[FILE:1419:patches/patch-src_jansson.h]
--- src/jansson.h.orig	2016-08-26 17:37:02 UTC
+++ src/jansson.h
@@ -159,10 +159,10 @@ int json_object_iter_set_new(json_t *obj
         key = json_object_iter_key(n), \
             n = json_object_iter_next(object, json_object_key_to_iter(key)))
 
-#define json_array_foreach(array, index, value) \
-	for(index = 0; \
-		index < json_array_size(array) && (value = json_array_get(array, index)); \
-		index++)
+#define json_array_foreach(array, idx, value) \
+	for(idx = 0; \
+		idx < json_array_size(array) && (value = json_array_get(array, idx)); \
+		idx++)
 
 static JSON_INLINE
 int json_object_set(json_t *object, const char *key, json_t *value)
@@ -183,11 +183,11 @@ int json_object_iter_set(json_t *object,
 }
 
 size_t json_array_size(const json_t *array);
-json_t *json_array_get(const json_t *array, size_t index);
-int json_array_set_new(json_t *array, size_t index, json_t *value);
+json_t *json_array_get(const json_t *array, size_t idx);
+int json_array_set_new(json_t *array, size_t idx, json_t *value);
 int json_array_append_new(json_t *array, json_t *value);
-int json_array_insert_new(json_t *array, size_t index, json_t *value);
-int json_array_remove(json_t *array, size_t index);
+int json_array_insert_new(json_t *array, size_t idx, json_t *value);
+int json_array_remove(json_t *array, size_t idx);
 int json_array_clear(json_t *array);
 int json_array_extend(json_t *array, json_t *other);
 


[FILE:236:patches/patch-src_utf.h]
--- src/utf.h.orig	2015-03-07 07:02:40 UTC
+++ src/utf.h
@@ -16,6 +16,8 @@
 #include <stdint.h>
 #endif
 
+#include <sys/types.h>
+
 int utf8_encode(int32_t codepoint, char *buffer, size_t *size);
 
 size_t utf8_check_first(char byte);


[FILE:3073:patches/patch-src_value.c]
--- src/value.c.orig	2016-08-25 17:21:36 UTC
+++ src/value.c
@@ -375,20 +375,20 @@ size_t json_array_size(const json_t *jso
     return json_to_array(json)->entries;
 }
 
-json_t *json_array_get(const json_t *json, size_t index)
+json_t *json_array_get(const json_t *json, size_t idx)
 {
     json_array_t *array;
     if(!json_is_array(json))
         return NULL;
     array = json_to_array(json);
 
-    if(index >= array->entries)
+    if(idx >= array->entries)
         return NULL;
 
-    return array->table[index];
+    return array->table[idx];
 }
 
-int json_array_set_new(json_t *json, size_t index, json_t *value)
+int json_array_set_new(json_t *json, size_t idx, json_t *value)
 {
     json_array_t *array;
 
@@ -402,14 +402,14 @@ int json_array_set_new(json_t *json, siz
     }
     array = json_to_array(json);
 
-    if(index >= array->entries)
+    if(idx >= array->entries)
     {
         json_decref(value);
         return -1;
     }
 
-    json_decref(array->table[index]);
-    array->table[index] = value;
+    json_decref(array->table[idx]);
+    array->table[idx] = value;
 
     return 0;
 }
@@ -481,7 +481,7 @@ int json_array_append_new(json_t *json, 
     return 0;
 }
 
-int json_array_insert_new(json_t *json, size_t index, json_t *value)
+int json_array_insert_new(json_t *json, size_t idx, json_t *value)
 {
     json_array_t *array;
     json_t **old_table;
@@ -495,7 +495,7 @@ int json_array_insert_new(json_t *json, 
     }
     array = json_to_array(json);
 
-    if(index > array->entries) {
+    if(idx > array->entries) {
         json_decref(value);
         return -1;
     }
@@ -507,21 +507,21 @@ int json_array_insert_new(json_t *json, 
     }
 
     if(old_table != array->table) {
-        array_copy(array->table, 0, old_table, 0, index);
-        array_copy(array->table, index + 1, old_table, index,
-                   array->entries - index);
+        array_copy(array->table, 0, old_table, 0, idx);
+        array_copy(array->table, idx + 1, old_table, idx,
+                   array->entries - idx);
         jsonp_free(old_table);
     }
     else
-        array_move(array, index + 1, index, array->entries - index);
+        array_move(array, idx + 1, idx, array->entries - idx);
 
-    array->table[index] = value;
+    array->table[idx] = value;
     array->entries++;
 
     return 0;
 }
 
-int json_array_remove(json_t *json, size_t index)
+int json_array_remove(json_t *json, size_t idx)
 {
     json_array_t *array;
 
@@ -529,14 +529,14 @@ int json_array_remove(json_t *json, size
         return -1;
     array = json_to_array(json);
 
-    if(index >= array->entries)
+    if(idx >= array->entries)
         return -1;
 
-    json_decref(array->table[index]);
+    json_decref(array->table[idx]);
 
     /* If we're removing the last element, nothing has to be moved */
-    if(index < array->entries - 1)
-        array_move(array, index, index + 1, array->entries - index - 1);
+    if(idx < array->entries - 1)
+        array_move(array, idx, idx + 1, array->entries - idx - 1);
 
     array->entries--;
 

