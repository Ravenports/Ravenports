# Buildsheet autogenerated by ravenadm tool -- Do not edit.

NAMEBASE=		libevent
VERSION=		2.1.8
KEYWORDS=		devel
VARIANTS=		standard
SDESC[standard]=	API for executing callbacks on events and timeouts
HOMEPAGE=		http://libevent.org/
CONTACT=		nobody

DOWNLOAD_GROUPS=	main
SITES[main]=		GITHUB/libevent:libevent:release-2.1.8-stable
DISTFILE[1]=		generated:main
DF_INDEX=		1
SPKGS[standard]=	single

OPTIONS_AVAILABLE=	none
OPTIONS_STANDARD=	none

USES=			autoreconf libtool ssl

FPC_EQUIVALENT=		devel/libevent

MUST_CONFIGURE=		gnu
CONFIGURE_ARGS=		--enable-openssl
			--enable-thread-support

INSTALL_TARGET=		install-strip

CPPFLAGS=		-I{{OPENSSLINC}}
LDFLAGS=		-L{{OPENSSLLIB}}
TEST_TARGET=		check

[FILE:960:descriptions/desc.single]
The libevent API provides a mechanism to execute a callback function when
a specific event occurs on a file descriptor or after a timeout has been
reached. Furthermore, libevent also support callbacks due to signals or
regular timeouts.

libevent is meant to replace the event loop found in event driven network
servers. An application just needs to call event_dispatch() and then add
or remove events dynamically without having to change the event loop.

Currently, libevent supports /dev/poll, kqueue(2), event ports, select(2),
poll(2) and epoll(4). The internal event mechanism is completely
independent of the exposed event API, and a simple update of libevent can
provide new functionality without having to redesign the applications. As
a result, Libevent allows for portable application development and provides
the most scalable event notification mechanism available on an operating
system. Libevent can also be used for multi-threaded applications.


[FILE:124:distinfo]
316ddb401745ac5d222d7c529ef1eada12f58f6376a66c1118eee803cb70f83d       700896 libevent-libevent-release-2.1.8-stable.tar.gz


[FILE:1005:manifests/plist.single]
bin/event_rpcgen.py
include/
 evdns.h
 event.h
 evhttp.h
 evrpc.h
 evutil.h
include/event2/
 buffer.h
 buffer_compat.h
 bufferevent.h
 bufferevent_compat.h
 bufferevent_ssl.h
 bufferevent_struct.h
 dns.h
 dns_compat.h
 dns_struct.h
 event-config.h
 event.h
 event_compat.h
 event_struct.h
 http.h
 http_compat.h
 http_struct.h
 keyvalq_struct.h
 listener.h
 rpc.h
 rpc_compat.h
 rpc_struct.h
 tag.h
 tag_compat.h
 thread.h
 util.h
 visibility.h
lib/
 libevent-2.1.so.6
 libevent-2.1.so.6.0.2
 libevent.a
 libevent.so
 libevent_core-2.1.so.6
 libevent_core-2.1.so.6.0.2
 libevent_core.a
 libevent_core.so
 libevent_extra-2.1.so.6
 libevent_extra-2.1.so.6.0.2
 libevent_extra.a
 libevent_extra.so
 libevent_openssl-2.1.so.6
 libevent_openssl-2.1.so.6.0.2
 libevent_openssl.a
 libevent_openssl.so
 libevent_pthreads-2.1.so.6
 libevent_pthreads-2.1.so.6.0.2
 libevent_pthreads.a
 libevent_pthreads.so
lib/pkgconfig/
 libevent.pc
 libevent_core.pc
 libevent_extra.pc
 libevent_openssl.pc
 libevent_pthreads.pc


[FILE:2549:patches/patch-gcc7]
Fix -Werror=implicit-fallthrough (fixes gcc-7)

https://github.com/libevent/libevent/commit/94e7dcebc320
https://github.com/libevent/libevent/commit/ffbce578c40a

--- bufferevent_filter.c.orig	2017-01-25 23:37:15 UTC
+++ bufferevent_filter.c
@@ -612,9 +612,12 @@ be_filter_ctrl(struct bufferevent *bev, 
 			bevf->underlying->be_ops->ctrl) {
 		    return (bevf->underlying->be_ops->ctrl)(bevf->underlying, op, data);
 		}
+		EVUTIL_FALLTHROUGH;
 
 	case BEV_CTRL_GET_FD:
+		EVUTIL_FALLTHROUGH;
 	case BEV_CTRL_CANCEL_ALL:
+		EVUTIL_FALLTHROUGH;
 	default:
 		return -1;
 	}
--- evdns.c.orig	2017-01-25 23:37:15 UTC
+++ evdns.c
@@ -2265,10 +2265,11 @@ evdns_request_transmit(struct request *r
 		nameserver_write_waiting(req->ns, 1);
 		return 1;
 	case 2:
-		/* failed to transmit the request entirely. */
+		/* failed to transmit the request entirely. we can fallthrough since
+		 * we'll set a timeout, which will time out, and make us retransmit the
+		 * request anyway. */
 		retcode = 1;
-		/* fall through: we'll set a timeout, which will time out,
-		 * and make us retransmit the request anyway. */
+		EVUTIL_FALLTHROUGH;
 	default:
 		/* all ok */
 		log(EVDNS_LOG_DEBUG,
--- event.c.orig	2017-01-25 23:37:15 UTC
+++ event.c
@@ -2960,6 +2960,7 @@ event_callback_activate_nolock_(struct e
 	switch (evcb->evcb_flags & (EVLIST_ACTIVE|EVLIST_ACTIVE_LATER)) {
 	default:
 		EVUTIL_ASSERT(0);
+		EVUTIL_FALLTHROUGH;
 	case EVLIST_ACTIVE_LATER:
 		event_queue_remove_active_later(base, evcb);
 		r = 0;
--- util-internal.h.orig	2017-01-25 23:37:15 UTC
+++ util-internal.h
@@ -50,6 +50,20 @@
 extern "C" {
 #endif
 
+/* __has_attribute() wrapper */
+#ifdef __has_attribute
+#define EVUTIL_HAS_ATTRIBUTE __has_attribute
+#endif
+/** clang 3 __has_attribute misbehaves in some versions */
+#if defined(__clang__) && \
+	__clang__ == 1 && __clang_major__ == 3 && \
+	(__clang_minor__ >= 2 && __clang_minor__ <= 5)
+#undef EVUTIL_HAS_ATTRIBUTE
+#endif
+#ifndef EVUTIL_HAS_ATTRIBUTE
+#define EVUTIL_HAS_ATTRIBUTE(x) 0
+#endif
+
 /* If we need magic to say "inline", get it for free internally. */
 #ifdef EVENT__inline
 #define inline EVENT__inline
@@ -308,6 +322,12 @@ ev_int32_t evutil_weakrand_range_(struct
 #define EVUTIL_UNLIKELY(p) (p)
 #endif
 
+#if EVUTIL_HAS_ATTRIBUTE(fallthrough)
+#define EVUTIL_FALLTHROUGH __attribute__((fallthrough))
+#else
+#define EVUTIL_FALLTHROUGH /* fallthrough */
+#endif
+
 /* Replacement for assert() that calls event_errx on failure. */
 #ifdef NDEBUG
 #define EVUTIL_ASSERT(cond) EVUTIL_NIL_CONDITION_(cond)


[FILE:3447:patches/patch-libressl]
From 28b8075400c70b2d2da2ce07e590c2ec6d11783d Mon Sep 17 00:00:00 2001
From: Bernard Spil <brnrd@FreeBSD.org>
Date: Mon, 2 Apr 2018 13:18:27 +0200
Subject: [PATCH] Fix build with LibreSSL 2.7

LibreSSL 2.7 implements OpenSSL 1.1 API except for BIO_get_init()

See also: https://bugs.freebsd.org/226900
Signed-off-by: Bernard Spil <brnrd@FreeBSD.org>
Closes: #617 (cherry-pick)
--- openssl-compat.h.orig	2017-01-25 23:37:15 UTC
+++ openssl-compat.h
@@ -1,7 +1,8 @@
 #ifndef OPENSSL_COMPAT_H
 #define OPENSSL_COMPAT_H
 
-#if OPENSSL_VERSION_NUMBER < 0x10100000L
+#if (OPENSSL_VERSION_NUMBER < 0x10100000L) || \
+	(defined(LIBRESSL_VERSION_NUMBER) && LIBRESSL_VERSION_NUMBER < 0x20700000L)
 
 static inline BIO_METHOD *BIO_meth_new(int type, const char *name)
 {
@@ -30,6 +31,11 @@ static inline BIO_METHOD *BIO_meth_new(i
 
 #define TLS_method SSLv23_method
 
-#endif /* OPENSSL_VERSION_NUMBER < 0x10100000L */
+#endif /* (OPENSSL_VERSION_NUMBER < 0x10100000L) || \
+	(defined(LIBRESSL_VERSION_NUMBER) && LIBRESSL_VERSION_NUMBER < 0x20700000L) */
+
+#if defined(LIBRESSL_VERSION_NUMBER) && LIBRESSL_VERSION_NUMBER >= 0x20700000L
+#define BIO_get_init(b) (b)->init
+#endif
 
 #endif /* OPENSSL_COMPAT_H */
--- sample/https-client.c.orig	2017-01-25 23:37:15 UTC
+++ sample/https-client.c
@@ -312,7 +312,8 @@ main(int argc, char **argv)
 	}
 	uri[sizeof(uri) - 1] = '\0';
 
-#if OPENSSL_VERSION_NUMBER < 0x10100000L
+#if (OPENSSL_VERSION_NUMBER < 0x10100000L) || \
+	(defined(LIBRESSL_VERSION_NUMBER) && LIBRESSL_VERSION_NUMBER < 0x20700000L)
 	// Initialize OpenSSL
 	SSL_library_init();
 	ERR_load_crypto_strings();
@@ -480,7 +481,8 @@ cleanup:
 		SSL_CTX_free(ssl_ctx);
 	if (type == HTTP && ssl)
 		SSL_free(ssl);
-#if OPENSSL_VERSION_NUMBER < 0x10100000L
+#if (OPENSSL_VERSION_NUMBER < 0x10100000L) || \
+	(defined(LIBRESSL_VERSION_NUMBER) && LIBRESSL_VERSION_NUMBER < 0x20700000L)
 	EVP_cleanup();
 	ERR_free_strings();
 
@@ -492,7 +494,8 @@ cleanup:
 	CRYPTO_cleanup_all_ex_data();
 
 	sk_SSL_COMP_free(SSL_COMP_get_compression_methods());
-#endif /*OPENSSL_VERSION_NUMBER < 0x10100000L */
+#endif /* (OPENSSL_VERSION_NUMBER < 0x10100000L) || \
+	(defined(LIBRESSL_VERSION_NUMBER) && LIBRESSL_VERSION_NUMBER < 0x20700000L) */
 
 #ifdef _WIN32
 	WSACleanup();
--- sample/le-proxy.c.orig	2017-01-25 23:37:15 UTC
+++ sample/le-proxy.c
@@ -259,7 +259,8 @@ main(int argc, char **argv)
 
 	if (use_ssl) {
 		int r;
-#if OPENSSL_VERSION_NUMBER < 0x10100000L
+#if (OPENSSL_VERSION_NUMBER < 0x10100000L) || \
+	(defined(LIBRESSL_VERSION_NUMBER) && LIBRESSL_VERSION_NUMBER < 0x20700000L)
 		SSL_library_init();
 		ERR_load_crypto_strings();
 		SSL_load_error_strings();
--- sample/openssl_hostname_validation.c.orig	2017-01-25 23:37:15 UTC
+++ sample/openssl_hostname_validation.c
@@ -48,7 +48,8 @@ SOFTWARE.
 
 #define HOSTNAME_MAX_SIZE 255
 
-#if OPENSSL_VERSION_NUMBER < 0x10100000L
+#if OPENSSL_VERSION_NUMBER < 0x10100000L || \
+	(defined(LIBRESSL_VERSION_NUMBER) && LIBRESSL_VERSION_NUMBER < 0x20700000L)
 #define ASN1_STRING_get0_data ASN1_STRING_data
 #endif
 
--- test/regress_ssl.c.orig	2017-01-25 23:37:15 UTC
+++ test/regress_ssl.c
@@ -186,7 +186,8 @@ get_ssl_ctx(void)
 void
 init_ssl(void)
 {
-#if OPENSSL_VERSION_NUMBER < 0x10100000L
+#if (OPENSSL_VERSION_NUMBER < 0x10100000L) || \
+	(defined(LIBRESSL_VERSION_NUMBER) && LIBRESSL_VERSION_NUMBER < 0x20700000L)
 	SSL_library_init();
 	ERR_load_crypto_strings();
 	SSL_load_error_strings();


[FILE:1972:patches/patch-test_bench]
Fix feature conditionals in bench tests.

https://github.com/libevent/libevent/commit/d9118c8daa0e
https://github.com/libevent/libevent/commit/77ec05e50dfe

--- configure.ac.orig	2017-01-25 23:37:15 UTC
+++ configure.ac
@@ -715,8 +715,7 @@ AC_CHECK_MEMBERS([struct in6_addr.s6_add
 #endif
 ])
 
-AC_CHECK_TYPES([struct so_linger],
-[#define HAVE_SO_LINGER], ,
+AC_CHECK_TYPES([struct linger],,,
 [
 #ifdef HAVE_SYS_SOCKET_H
 #include <sys/socket.h>
--- test/bench.c.orig	2017-01-25 23:37:15 UTC
+++ test/bench.c
@@ -136,7 +136,7 @@ run_once(void)
 int
 main(int argc, char **argv)
 {
-#ifdef HAVE_SETRLIMIT 
+#ifdef EVENT__HAVE_SETRLIMIT
 	struct rlimit rl;
 #endif
 	int i, c;
@@ -167,7 +167,7 @@ main(int argc, char **argv)
 		}
 	}
 
-#ifdef HAVE_SETRLIMIT
+#ifdef EVENT__HAVE_SETRLIMIT
 	rl.rlim_cur = rl.rlim_max = num_pipes * 2 + 50;
 	if (setrlimit(RLIMIT_NOFILE, &rl) == -1) {
 		perror("setrlimit");
--- test/bench_cascade.c.orig	2017-01-25 23:37:15 UTC
+++ test/bench_cascade.c
@@ -139,7 +139,7 @@ run_once(int num_pipes)
 int
 main(int argc, char **argv)
 {
-#ifdef HAVE_SETRLIMIT
+#ifdef EVENT__HAVE_SETRLIMIT
 	struct rlimit rl;
 #endif
 	int i, c;
@@ -162,7 +162,7 @@ main(int argc, char **argv)
 		}
 	}
 
-#ifdef HAVE_SETRLIMIT 
+#ifdef EVENT__HAVE_SETRLIMIT
 	rl.rlim_cur = rl.rlim_max = num_pipes * 2 + 50;
 	if (setrlimit(RLIMIT_NOFILE, &rl) == -1) {
 		perror("setrlimit");
--- test/bench_httpclient.c.orig	2017-01-25 23:37:15 UTC
+++ test/bench_httpclient.c
@@ -113,13 +113,13 @@ errorcb(struct bufferevent *b, short wha
 static void
 frob_socket(evutil_socket_t sock)
 {
-#ifdef HAVE_SO_LINGER
+#ifdef EVENT__HAVE_STRUCT_LINGER
 	struct linger l;
 #endif
 	int one = 1;
 	if (setsockopt(sock, SOL_SOCKET, SO_REUSEADDR, (void*)&one, sizeof(one))<0)
 		perror("setsockopt(SO_REUSEADDR)");
-#ifdef HAVE_SO_LINGER
+#ifdef EVENT__HAVE_STRUCT_LINGER
 	l.l_onoff = 1;
 	l.l_linger = 0;
 	if (setsockopt(sock, SOL_SOCKET, SO_LINGER, (void*)&l, sizeof(l))<0)


[FILE:908:patches/patch-test_test.sh]
regress runs multiple tests, don't silence it completely.

https://github.com/libevent/libevent/pull/446

--- test/test.sh.orig	2017-01-25 23:37:15 UTC
+++ test/test.sh
@@ -99,10 +99,10 @@ run_tests () {
 	fi
 
 	test -x $TEST_DIR/regress || return
-	announce_n " regress: "
+	announce " regress: [multiple tests]"
 	if test "$TEST_OUTPUT_FILE" = "/dev/null" ;
 	then
-		$TEST_DIR/regress --quiet $REGRESS_ARGS
+		$TEST_DIR/regress $REGRESS_ARGS
 	else
 		$TEST_DIR/regress $REGRESS_ARGS >>"$TEST_OUTPUT_FILE"
 	fi
@@ -114,10 +114,10 @@ run_tests () {
 		FAILED=yes
 	fi
 
-	announce_n " regress_debug: "
+	announce " regress_debug: [multiple tests]"
 	if test "$TEST_OUTPUT_FILE" = "/dev/null" ;
 	then
-		EVENT_DEBUG_MODE=1 $TEST_DIR/regress --quiet $REGRESS_ARGS
+		EVENT_DEBUG_MODE=1 $TEST_DIR/regress $REGRESS_ARGS
 	else
 		EVENT_DEBUG_MODE=1 $TEST_DIR/regress $REGRESS_ARGS >>"$TEST_OUTPUT_FILE"
 	fi

