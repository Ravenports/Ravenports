# Buildsheet autogenerated by ravenadm tool -- Do not edit.

NAMEBASE=		gdb
VERSION=		8.1
KEYWORDS=		devel
VARIANTS=		standard
SDESC[standard]=	GNU debugger
HOMEPAGE=		http://www.gnu.org/software/gdb/
CONTACT=		nobody

DOWNLOAD_GROUPS=	main
SITES[main]=		GNU/gdb
DISTFILE[1]=		gdb-8.1.tar.xz:main
DF_INDEX=		1
SPKGS[standard]=	single

OPTIONS_AVAILABLE=	none
OPTIONS_STANDARD=	none

NOT_FOR_ARCH=		aarch64

BUILD_DEPENDS=		expat:static:standard
BUILDRUN_DEPENDS=	expat:shared:standard

USES=			cpe iconv gmake libtool readline python

EXTRACT_HEAD[1]=	{{TAR}} -xf
EXTRACT_TAIL[1]=	--exclude dejagnu --exclude expect --exclude sim --exclude texinfo --exclude intl --exclude readline

CPE_VENDOR=		gnu
FPC_EQUIVALENT=		devel/gdb

MUST_CONFIGURE=		gnu
CONFIGURE_ARGS=		--program-suffix=81
			--enable-targets=all
			--enable-64-bit-bfd
			--enable-tui
			--disable-build-with-cxx
			--with-gdb-datadir={{PREFIX}}/share/gdb81
			{{ICONV_CONFIGURE_ARG}}
			--with-system-readline
			--with-expat=yes
			--with-libexpat-prefix={{LOCALBASE}}
			--without-libunwind-ia64
			--with-python={{PYTHON_CMD}}
CONFIGURE_ENV=		CONFIGURED_M4=m4
			CONFIGURED_BISON=byacc

PLIST_SUB=		VER=81

CFLAGS=			-DRL_NO_COMPAT
			-D__STDC_CONSTANT_MACROS
			-D__STDC_LIMIT_MACROS
			-Wno-unused-function
			-Wno-unused-variable

post-patch:
	${REINPLACE_CMD} -e 's|$$| [GDB v8.1 for ${OPSYS}]|' \
		${WRKSRC}/gdb/version.in

post-patch-dragonfly:
	${CP} ${OPSYSDIR}/dfly64.mh  ${WRKSRC}/gdb/config/i386/
	${CP} ${OPSYSDIR}/dfly-nat.* ${WRKSRC}/gdb/
	${CP} ${OPSYSDIR}/i386*      ${WRKSRC}/gdb/
	${CP} ${OPSYSDIR}/amd64*     ${WRKSRC}/gdb/

do-install:
	${INSTALL_PROGRAM} ${WRKSRC}/gdb/gdb \
		${STAGEDIR}${PREFIX}/bin/gdb81
	${INSTALL_MAN} ${WRKSRC}/gdb/doc/gdb.1 \
		${STAGEDIR}${MAN1PREFIX}/man/man1/gdb81.1
	(cd ${WRKSRC}/gdb/data-directory ; \
		${SETENV} ${MAKE_ENV} ${MAKE_CMD} ${MAKE_ARGS} install-syscalls )
	${LN} -sf gdb81 ${STAGEDIR}${PREFIX}/bin/gdbtui81
	${LN} -sf gdb81 ${STAGEDIR}${PREFIX}/bin/gdb
	(cd ${WRKSRC}/gdb && ${SETENV} ${MAKE_ENV} \
		${MAKE_CMD} ${MAKE_ARGS} install-python )
	(cd ${WRKSRC}/gdb/data-directory && ${SETENV} ${MAKE_ENV} \
		${MAKE_CMD} ${MAKE_ARGS} install-python )
. for f in gdb gdb/command gdb/function gdb/printer
	(cd ${STAGEDIR}${PREFIX}/share/gdb81/python/${f} ; ${CHMOD} 644 *.py* )
. endfor

[FILE:284:descriptions/desc.single]
GDB is a source-level debugger for Ada, C, C++, Objective-C, Pascal and
many other languages.  GDB can target (i.e., debug programs running on)
more than a dozen different processor architectures, and GDB itself can
run on most popular GNU/Linux, Unix and Microsoft Windows variants.


[FILE:93:distinfo]
af61a0263858e69c5dce51eab26662ff3d2ad9aa68da9583e8143b5426be4b34     20095080 gdb-8.1.tar.xz


[FILE:819:manifests/plist.single]
bin/
 gdb
 gdb%%VER%%
 gdbtui%%VER%%
share/man/man1/gdb%%VER%%.1.gz
share/gdb%%VER%%/python/gdb/
 __init__.py
 FrameDecorator.py
 FrameIterator.py
 frames.py
 printing.py
 prompt.py
 types.py
 unwinder.py
 xmethod.py
share/gdb%%VER%%/python/gdb/command/
 __init__.py
 explore.py
 frame_filters.py
 pretty_printers.py
 prompt.py
 type_printers.py
 unwinders.py
 xmethods.py
share/gdb%%VER%%/python/gdb/function/
 __init__.py
 as_string.py
 caller_is.py
 strfns.py
share/gdb%%VER%%/python/gdb/printer/
 __init__.py
 bound_registers.py
share/gdb%%VER%%/syscalls/
 aarch64-linux.xml
 amd64-linux.xml
 arm-linux.xml
 freebsd.xml
 gdb-syscalls.dtd
 i386-linux.xml
 mips-n32-linux.xml
 mips-n64-linux.xml
 mips-o32-linux.xml
 ppc-linux.xml
 ppc64-linux.xml
 s390-linux.xml
 s390x-linux.xml
 sparc-linux.xml
 sparc64-linux.xml


[FILE:1048:patches/patch-gdb-amd64-bsd-nat.c]
--- gdb/amd64-bsd-nat.c.orig	2018-01-05 04:07:23 UTC
+++ gdb/amd64-bsd-nat.c
@@ -28,6 +28,7 @@
 #include <sys/types.h>
 #include <sys/ptrace.h>
 #include <machine/reg.h>
+#include <machine/psl.h>
 
 #include "amd64-tdep.h"
 #include "amd64-nat.h"
@@ -122,12 +123,19 @@ amd64bsd_store_inferior_registers (struc
   if (regnum == -1 || amd64_native_gregset_supplies_p (gdbarch, regnum))
     {
       struct reg regs;
+      register_t old_rflags;
 
       if (ptrace (PT_GETREGS, pid, (PTRACE_TYPE_ARG3) &regs, 0) == -1)
         perror_with_name (_("Couldn't get registers"));
 
+      old_rflags = regs.r_rflags;
       amd64_collect_native_gregset (regcache, &regs, regnum);
 
+      /* This is a workaround about the PSL_USERCHANGE posix limitation.  */
+      if ((regs.r_rflags ^ old_rflags ) & ~PSL_USERCHANGE)
+        {
+          regs.r_rflags ^= (regs.r_rflags ^ old_rflags ) & ~PSL_USERCHANGE;
+        }
       if (ptrace (PT_SETREGS, pid, (PTRACE_TYPE_ARG3) &regs, 0) == -1)
         perror_with_name (_("Couldn't write registers"));
 


[FILE:657:patches/patch-gdb-fbsd-nat.c]
--- gdb/fbsd-nat.c.orig	2018-01-31 02:58:50 UTC
+++ gdb/fbsd-nat.c
@@ -810,6 +810,14 @@ fbsd_resume (struct target_ops *ops,
       struct thread_info *tp;
       int request;
 
+#ifndef PT_LWP_EVENTS
+      /* When LWP events are not supported, a new thread might already be
+	 running that has not yet reported an event when GDB wishes to
+         only run a single thread.  Force an update of the thread list
+	 to ensure that any such threads are suspended before the process
+	 is resumed.  */
+      fbsd_add_threads (ptid_get_pid (ptid));
+#endif
       ALL_NON_EXITED_THREADS (tp)
         {
 	  if (ptid_get_pid (tp->ptid) != ptid_get_pid (ptid))


[FILE:894:patches/patch-gdb-gdb_wchar.h]
diff --git gdb/gdb_wchar.h gdb/gdb_wchar.h
index 868fe04..1311080 100644
--- gdb/gdb_wchar.h
+++ gdb/gdb_wchar.h
@@ -59,7 +59,7 @@
    iconvlist.  */
 #if defined (HAVE_ICONV) && defined (HAVE_BTOWC) \
   && (defined (__STDC_ISO_10646__) \
-      || (defined (_LIBICONV_VERSION) && _LIBICONV_VERSION >= 0x108))
+      || (!defined (LIBICONV_PLUG) && defined (_LIBICONV_VERSION) && _LIBICONV_VERSION >= 0x108))
 
 typedef wchar_t gdb_wchar_t;
 typedef wint_t gdb_wint_t;
@@ -82,7 +82,7 @@ typedef wint_t gdb_wint_t;
 #define INTERMEDIATE_ENCODING intermediate_encoding ()
 const char *intermediate_encoding (void);
 
-#elif defined (_LIBICONV_VERSION) && _LIBICONV_VERSION >= 0x108
+#elif !defined (LIBICONV_PLUG) && defined (_LIBICONV_VERSION) && _LIBICONV_VERSION >= 0x108
 #define INTERMEDIATE_ENCODING "wchar_t"
 #else
 /* This shouldn't happen, because the earlier #if should have filtered


[FILE:662:patches/patch-gdb-gnulib-import-stddef.in.h]
diff --git gdb/gnulib/import/stddef.in.h gdb/gnulib/import/stddef.in.h
index f4c4a1070d..023ea2064d 100644
--- gdb/gnulib/import/stddef.in.h
+++ gdb/gnulib/import/stddef.in.h
@@ -84,7 +84,7 @@
 /* Some platforms lack max_align_t.  The check for _GCC_MAX_ALIGN_T is
    a hack in case the configure-time test was done with g++ even though
    we are currently compiling with gcc.  */
-#if ! (@HAVE_MAX_ALIGN_T@ || defined _GCC_MAX_ALIGN_T)
+#if 0
 /* On the x86, the maximum storage alignment of double, long, etc. is 4,
    but GCC's C11 ABI for x86 says that max_align_t has an alignment of 8,
    and the C11 standard allows this.  Work around this problem by


[FILE:317:patches/patch-gdb-i386-fbsd-nat.c]
--- gdb/i386-fbsd-nat.c.orig	2018-01-05 04:07:23 UTC
+++ gdb/i386-fbsd-nat.c
@@ -159,7 +159,6 @@ _initialize_i386fbsd_nat (void)
   t->to_read_description = i386fbsd_read_description;
 #endif
 
-  t->to_resume = i386fbsd_resume;
   fbsd_nat_add_target (t);
 
   /* Support debugging kernel virtual memory images.  */


[FILE:491:patches/patch-gdb-python-python-config.py]
diff --git gdb/python/python-config.py gdb/python/python-config.py
index c2b2969..39af8d9 100644
--- gdb/python/python-config.py
+++ gdb/python/python-config.py
@@ -59,6 +59,8 @@ for opt in opt_flags:
 
     elif opt in ('--libs', '--ldflags'):
         libs = []
+        if getvar('LDFLAGS') is not None:
+            libs.extend(getvar('LDFLAGS').split())
         if getvar('LIBS') is not None:
             libs.extend(getvar('LIBS').split())
         if getvar('SYSLIBS') is not None:


[FILE:313:patches/patch-gdb_compile_compile-loc2c.c]
--- gdb/compile/compile-loc2c.c.orig	2018-01-05 04:07:23 UTC
+++ gdb/compile/compile-loc2c.c
@@ -656,6 +656,7 @@ do_compile_dwarf_expr_to_c (int indent,
       uint64_t uoffset, reg;
       int64_t offset;
 
+      uoffset = 0;
       print_spaces (indent - 2, &stream);
       if (info[op_ptr - base].label)
 	{


[FILE:533:patches/patch-libiberty-basename]
--- include/libiberty.h
+++ include/libiberty.h
@@ -109,7 +109,7 @@
  || defined (__FreeBSD__) || defined (__OpenBSD__) || defined (__NetBSD__) \
  || defined (__CYGWIN__) || defined (__CYGWIN32__) || defined (__MINGW32__) \
  || defined (__DragonFly__) || defined (HAVE_DECL_BASENAME) 
-extern char *basename (const char *) ATTRIBUTE_RETURNS_NONNULL ATTRIBUTE_NONNULL(1);
+#include <libgen.h>
 #else
 /* Do not allow basename to be used if there is no prototype seen.  We
    either need to use the above prototype or have one from


[FILE:537:patches/patch-unified]
diff --git gdb/gdb.c gdb/gdb.c
index e554015..dcb9925 100644
--- gdb/gdb.c
+++ gdb/gdb.c
@@ -28,6 +28,12 @@ main (int argc, char **argv)
   memset (&args, 0, sizeof args);
   args.argc = argc;
   args.argv = argv;
-  args.interpreter_p = INTERP_CONSOLE;
+  if (strncmp(basename(argv[0]), "insight", 7) == 0) {
+    args.interpreter_p = "insight";
+  } else if (strncmp(basename(argv[0]), "gdbtui", 6) == 0) {
+    args.interpreter_p = INTERP_TUI;
+  } else {
+    args.interpreter_p = INTERP_CONSOLE;
+  }
   return gdb_main (&args);
 }


[FILE:9893:dragonfly/amd64-dfly-nat.c]
/* Native-dependent code for DragonFly/amd64.

   Copyright (C) 2003-2018 Free Software Foundation, Inc.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

#include "defs.h"
#include "inferior.h"
#include "regcache.h"
#include "target.h"
#include "gregset.h"

#include <signal.h>
#include <stddef.h>
#include <sys/types.h>
#include <sys/procfs.h>
#include <sys/ptrace.h>
#include <sys/sysctl.h>
#include <sys/user.h>
#include <machine/reg.h>
#include <machine/segments.h>

#include "dfly-nat.h"
#include "amd64-tdep.h"
#include "amd64-nat.h"
#include "x86-bsd-nat.h"
#include "x86-nat.h"
#include "x86-xstate.h"


/* Offset in `struct reg' where MEMBER is stored.  */
#define REG_OFFSET(member) offsetof (struct reg, member)

/* At amd64dfly64_r_reg_offset[REGNUM] you'll find the offset in
   `struct reg' location where the GDB register REGNUM is stored.
   Unsupported registers are marked with `-1'.  */
static int amd64dfly64_r_reg_offset[] =
{
  REG_OFFSET (r_rax),
  REG_OFFSET (r_rbx),
  REG_OFFSET (r_rcx),
  REG_OFFSET (r_rdx),
  REG_OFFSET (r_rsi),
  REG_OFFSET (r_rdi),
  REG_OFFSET (r_rbp),
  REG_OFFSET (r_rsp),
  REG_OFFSET (r_r8),
  REG_OFFSET (r_r9),
  REG_OFFSET (r_r10),
  REG_OFFSET (r_r11),
  REG_OFFSET (r_r12),
  REG_OFFSET (r_r13),
  REG_OFFSET (r_r14),
  REG_OFFSET (r_r15),
  REG_OFFSET (r_rip),
  REG_OFFSET (r_rflags),
  REG_OFFSET (r_cs),
  REG_OFFSET (r_ss),
  -1,
  -1,
  -1,
  -1
};


/* Mapping between the general-purpose registers in DragonFly/amd64
   `struct reg' format and GDB's register cache layout for
   DragonFly/x86.

   Note that most DragonFly/amd64 registers are 64-bit, while the
   DragonFly/x86 registers are all 32-bit, but since we're
   little-endian we get away with that.  */

/* From <machine/reg.h>.  */
static int amd64dfly32_r_reg_offset[I386_NUM_GREGS] =
{
  14 * 8, 13 * 8,		/* %eax, %ecx */
  12 * 8, 11 * 8,		/* %edx, %ebx */
  20 * 8, 10 * 8,		/* %esp, %ebp */
  9 * 8, 8 * 8,			/* %esi, %edi */
  17 * 8, 19 * 8,		/* %eip, %eflags */
  18 * 8, 21 * 8,		/* %cs, %ss */
  -1, -1, -1, -1		/* %ds, %es, %fs, %gs */
};


#ifdef DFLY_PCB_SUPPLY
/* Transfering the registers between GDB, inferiors and core files.  */

/* Fill GDB's register array with the general-purpose register values
   in *GREGSETP.  */

void
supply_gregset (struct regcache *regcache, const gregset_t *gregsetp)
{
  amd64_supply_native_gregset (regcache, gregsetp, -1);
}

/* Fill register REGNUM (if it is a general-purpose register) in
   *GREGSETPS with the value in GDB's register array.  If REGNUM is -1,
   do this for all registers.  */

void
fill_gregset (const struct regcache *regcache, gdb_gregset_t *gregsetp, int regnum)
{
  amd64_collect_native_gregset (regcache, gregsetp, regnum);
}

/* Fill GDB's register array with the floating-point register values
   in *FPREGSETP.  */

void
supply_fpregset (struct regcache *regcache, const fpregset_t *fpregsetp)
{
  amd64_supply_fxsave (regcache, -1, fpregsetp);
}

/* Fill register REGNUM (if it is a floating-point register) in
   *FPREGSETP with the value in GDB's register array.  If REGNUM is -1,
   do this for all registers.  */

void
fill_fpregset (const struct regcache *regcache, gdb_fpregset_t *fpregsetp, int regnum)
{
  amd64_collect_fxsave (regcache, regnum, fpregsetp);
}

/* Support for debugging kernel virtual memory images.  */

#include <sys/types.h>
#include <machine/pcb.h>
#include <osreldate.h>

#include "bsd-kvm.h"

static int
amd64dfly_supply_pcb (struct regcache *regcache, struct pcb *pcb)
{
  /* The following is true for FreeBSD 5.2:

     The pcb contains %rip, %rbx, %rsp, %rbp, %r12, %r13, %r14, %r15,
     %ds, %es, %fs and %gs.  This accounts for all callee-saved
     registers specified by the psABI and then some.  Here %esp
     contains the stack pointer at the point just after the call to
     cpu_switch().  From this information we reconstruct the register
     state as it would like when we just returned from cpu_switch().  */

  /* The stack pointer shouldn't be zero.  */
  if (pcb->pcb_rsp == 0)
    return 0;

  pcb->pcb_rsp += 8;
  regcache_raw_supply (regcache, AMD64_RIP_REGNUM, &pcb->pcb_rip);
  regcache_raw_supply (regcache, AMD64_RBX_REGNUM, &pcb->pcb_rbx);
  regcache_raw_supply (regcache, AMD64_RSP_REGNUM, &pcb->pcb_rsp);
  regcache_raw_supply (regcache, AMD64_RBP_REGNUM, &pcb->pcb_rbp);
  regcache_raw_supply (regcache, 12, &pcb->pcb_r12);
  regcache_raw_supply (regcache, 13, &pcb->pcb_r13);
  regcache_raw_supply (regcache, 14, &pcb->pcb_r14);
  regcache_raw_supply (regcache, 15, &pcb->pcb_r15);
#if 0 && (__FreeBSD_version < 800075) && (__FreeBSD_kernel_version < 800075)
  /* struct pcb provides the pcb_ds/pcb_es/pcb_fs/pcb_gs fields only
     up until __FreeBSD_version 800074: The removal of these fields
     occurred on 2009-04-01 while the __FreeBSD_version number was
     bumped to 800075 on 2009-04-06.  So 800075 is the closest version
     number where we should not try to access these fields.  */
  regcache_raw_supply (regcache, AMD64_DS_REGNUM, &pcb->pcb_ds);
  regcache_raw_supply (regcache, AMD64_ES_REGNUM, &pcb->pcb_es);
  regcache_raw_supply (regcache, AMD64_FS_REGNUM, &pcb->pcb_fs);
  regcache_raw_supply (regcache, AMD64_GS_REGNUM, &pcb->pcb_gs);
#endif

  return 1;
}
#endif /* DFLY_PCB_SUPPLY */


/* Implement the to_read_description method.  */

static const struct target_desc *
amd64dfly_read_description (struct target_ops *ops)
{
#ifdef PT_GETXSTATE_INFO
  static int xsave_probed;
  static uint64_t xcr0;
#endif
  struct reg regs;
  int is64;

  if (ptrace (PT_GETREGS, ptid_get_pid (inferior_ptid),
	      (PTRACE_TYPE_ARG3) &regs, 0) == -1)
    perror_with_name (_("Couldn't get registers"));
  is64 = (regs.r_cs == GSEL (GUCODE_SEL, SEL_UPL));
#ifdef PT_GETXSTATE_INFO
  if (!xsave_probed)
    {
      struct ptrace_xstate_info info;

      if (ptrace (PT_GETXSTATE_INFO, ptid_get_pid (inferior_ptid),
		  (PTRACE_TYPE_ARG3) &info, sizeof (info)) == 0)
	{
	  x86bsd_xsave_len = info.xsave_len;
	  xcr0 = info.xsave_mask;
	}
      xsave_probed = 1;
    }

  if (x86bsd_xsave_len != 0)
    {
      if (is64)
	return amd64_target_description (xcr0);
      else
	return i386_target_description (xcr0);
    }
#endif
  if (is64)
    return amd64_target_description (X86_XSTATE_SSE_MASK);
  else
    return i386_target_description (X86_XSTATE_SSE_MASK);
}

void
_initialize_amd64dfly_nat (void)
{
  struct target_ops *t;
  int offset;

  amd64_native_gregset32_reg_offset = amd64dfly32_r_reg_offset;
  amd64_native_gregset64_reg_offset = amd64dfly64_r_reg_offset;

  /* Add some extra features to the common *BSD/x86 target.  */
  t = amd64bsd_target ();
  t->to_read_description = amd64dfly_read_description;

  dfly_nat_add_target (t);

#ifdef DFLY_PCB_SUPPLY
  /* Support debugging kernel virtual memory images.  */
  bsd_kvm_add_target (amd64dfly_supply_pcb);
#endif

  /* To support the recognition of signal handlers, i386bsd-tdep.c
     hardcodes some constants.  Inclusion of this file means that we
     are compiling a native debugger, which means that we can use the
     system header files and sysctl(3) to get at the relevant
     information.  */

#define SC_REG_OFFSET amd64dfly_sc_reg_offset

  /* We only check the program counter, stack pointer and frame
     pointer since these members of `struct sigcontext' are essential
     for providing backtraces.  */

#define SC_RIP_OFFSET SC_REG_OFFSET[AMD64_RIP_REGNUM]
#define SC_RSP_OFFSET SC_REG_OFFSET[AMD64_RSP_REGNUM]
#define SC_RBP_OFFSET SC_REG_OFFSET[AMD64_RBP_REGNUM]

  /* Override the default value for the offset of the program counter
     in the sigcontext structure.  */
  offset = offsetof (struct sigcontext, sc_rip);

  if (SC_RIP_OFFSET != offset)
    {
      warning (_("\
offsetof (struct sigcontext, sc_rip) yields %d instead of %d.\n\
Please report this to <bug-gdb@gnu.org>."),
	       offset, SC_RIP_OFFSET);
    }

  SC_RIP_OFFSET = offset;

  /* Likewise for the stack pointer.  */
  offset = offsetof (struct sigcontext, sc_rsp);

  if (SC_RSP_OFFSET != offset)
    {
      warning (_("\
offsetof (struct sigcontext, sc_rsp) yields %d instead of %d.\n\
Please report this to <bug-gdb@gnu.org>."),
	       offset, SC_RSP_OFFSET);
    }

  SC_RSP_OFFSET = offset;

  /* And the frame pointer.  */
  offset = offsetof (struct sigcontext, sc_rbp);

  if (SC_RBP_OFFSET != offset)
    {
      warning (_("\
offsetof (struct sigcontext, sc_rbp) yields %d instead of %d.\n\
Please report this to <bug-gdb@gnu.org>."),
	       offset, SC_RBP_OFFSET);
    }

  SC_RBP_OFFSET = offset;

#ifdef KERN_PROC_SIGTRAMP
  {
    struct kinfo_sigtramp kst = {0};
    size_t len = sizeof (kst);
    int mib[3] = { CTL_KERN, KERN_PROC, KERN_PROC_SIGTRAMP };
    if (sysctl (mib, 3, &kst, &len, NULL, 0) == 0)
      {
        amd64dfly_sigtramp_start_addr = (uintptr_t) kst.ksigtramp_start;
        amd64dfly_sigtramp_end_addr   = (uintptr_t) kst.ksigtramp_end;
      }
  }
#else
  {
    int mib[2];
    long ps_strings;
    size_t len;

    mib[0] = CTL_KERN;
    mib[1] = KERN_PS_STRINGS;
    len = sizeof (ps_strings);
    if (sysctl (mib, 2, &ps_strings, &len, NULL, 0) == 0)
      {
	amd64dfly_sigtramp_start_addr = ps_strings - 32;
	amd64dfly_sigtramp_end_addr = ps_strings;
      }
  }
#endif
}


[FILE:4575:dragonfly/amd64-dfly-tdep.c]
/* Target-dependent code for DragonFly/amd64.

   Copyright (C) 2003-2018 Free Software Foundation, Inc.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

#include "defs.h"
#include "arch-utils.h"
#include "frame.h"
#include "gdbcore.h"
#include "regcache.h"
#include "osabi.h"
#include "x86-xstate.h"

#include <string.h>

#include "amd64-tdep.h"
#include "solib-svr4.h"

/* Support for signal handlers.  */

/* Assuming THIS_FRAME is for a BSD sigtramp routine, return the
   address of the associated sigcontext structure.  */

static CORE_ADDR
amd64dfly_sigcontext_addr (struct frame_info *this_frame)
{
  struct gdbarch *gdbarch = get_frame_arch (this_frame);
  enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);
  CORE_ADDR sp;
  gdb_byte buf[8];

  /* The `struct sigcontext' (which really is an `ucontext_t' on
     DragonFly/amd64) lives at a fixed offset in the signal frame.  See
     <machine/sigframe.h>.  */
  get_frame_register (this_frame, AMD64_RSP_REGNUM, buf);
  sp = extract_unsigned_integer (buf, 8, byte_order);
  return sp + 16;
}

/* Mapping between the general-purpose registers in `struct reg'
   format and GDB's register cache layout.

   Note that some registers are 32-bit, but since we're little-endian
   we get away with that.  */

/* From <machine/reg.h>.  */
static int amd64dfly_r_reg_offset[] =
{
  6 * 8,			/* %rax */
  7 * 8,			/* %rbx */
  3 * 8,			/* %rcx */
  2 * 8,			/* %rdx */
  1 * 8,			/* %rsi */
  0 * 8,			/* %rdi */
  8 * 8,			/* %rbp */
  23 * 8,			/* %rsp */
  4 * 8,			/* %r8 ... */
  5 * 8,
  9 * 8,
  10 * 8,
  11 * 8,
  12 * 8,
  13 * 8,
  14 * 8,			/* ... %r15 */
  20 * 8,			/* %rip */
  22 * 8,			/* %eflags */
  21 * 8,			/* %cs */
  24 * 8,			/* %ss */
  -1,				/* %ds */
  -1,				/* %es */
  -1,				/* %fs */
  -1				/* %gs */
};

/* Location of the signal trampoline.  */
CORE_ADDR amd64dfly_sigtramp_start_addr = 0x7fffffffffc0ULL;
CORE_ADDR amd64dfly_sigtramp_end_addr = 0x7fffffffffe0ULL;

/* From <machine/signal.h>.  */
int amd64dfly_sc_reg_offset[] =
{
  24 + 6 * 8,			/* %rax */
  24 + 7 * 8,			/* %rbx */
  24 + 3 * 8,			/* %rcx */
  24 + 2 * 8,			/* %rdx */
  24 + 1 * 8,			/* %rsi */
  24 + 0 * 8,			/* %rdi */
  24 + 8 * 8,			/* %rbp */
  24 + 23 * 8,			/* %rsp */
  24 + 4 * 8,			/* %r8 ... */
  24 + 5 * 8,
  24 + 9 * 8,
  24 + 10 * 8,
  24 + 11 * 8,
  24 + 12 * 8,
  24 + 13 * 8,
  24 + 14 * 8,			/* ... %r15 */
  24 + 20 * 8,			/* %rip */
  24 + 22 * 8,			/* %eflags */
  24 + 21 * 8,			/* %cs */
  24 + 24 * 8,			/* %ss */
  -1,				/* %ds */
  -1,				/* %es */
  -1,				/* %fs */
  -1				/* %gs */
};

/* From /usr/src/lib/libc/amd64/gen/_setjmp.S.  */
static int amd64dfly_jmp_buf_reg_offset[] =
{
  -1,				/* %rax */
  1 * 8,			/* %rbx */
  -1,				/* %rcx */
  -1,				/* %rdx */
  -1,				/* %rsi */
  -1,				/* %rdi */
  3 * 8,			/* %rbp */
  2 * 8,			/* %rsp */
  -1,				/* %r8 ... */
  -1,
  -1,
  -1,				/* ... %r11 */
  4 * 8,			/* %r12 ... */
  5 * 8,
  6 * 8,
  7 * 8,			/* ... %r15 */
  0 * 8				/* %rip */
};

static void
amd64dfly_init_abi (struct gdbarch_info info, struct gdbarch *gdbarch)
{
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);

  i386bsd_init_abi (info, gdbarch);

  tdep->gregset_reg_offset = amd64dfly_r_reg_offset;
  tdep->gregset_num_regs = ARRAY_SIZE (amd64dfly_r_reg_offset);
  tdep->sizeof_gregset = 25 * 8;

  amd64_init_abi (info, gdbarch,
                 amd64_target_description (X86_XSTATE_SSE_MASK));

  tdep->sigtramp_start = amd64dfly_sigtramp_start_addr;
  tdep->sigtramp_end = amd64dfly_sigtramp_end_addr;
  tdep->sigcontext_addr = amd64dfly_sigcontext_addr;
  tdep->sc_reg_offset = amd64dfly_sc_reg_offset;
  tdep->sc_num_regs = ARRAY_SIZE (amd64dfly_sc_reg_offset);

  set_solib_svr4_fetch_link_map_offsets
    (gdbarch, svr4_lp64_fetch_link_map_offsets);
}

void
_initialize_amd64dfly_tdep (void)
{
  gdbarch_register_osabi (bfd_arch_i386, bfd_mach_x86_64,
			  GDB_OSABI_DRAGONFLY, amd64dfly_init_abi);
}


[FILE:4442:dragonfly/dfly-nat.c]
/* Native-dependent code for DragonFly.

   Copyright (C) 2002-2018 Free Software Foundation, Inc.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

#include "defs.h"
#include "gdbcore.h"
#include "inferior.h"
#include "regcache.h"
#include "regset.h"
#include "gdbcmd.h"
#include "gdbthread.h"
#include "gdb_wait.h"
#include <sys/types.h>
#include <sys/procfs.h>
#include <sys/ptrace.h>
#include <sys/sysctl.h>
#ifdef HAVE_KINFO_GETVMMAP
#include <sys/user.h>
#include <libutil.h>
#endif

#include "elf-bfd.h"
#include "dfly-nat.h"

/* Return the name of a file that can be opened to get the symbols for
   the child process identified by PID.  */

static char *
dfly_pid_to_exec_file (struct target_ops *self, int pid)
{
  ssize_t len;
  static char buf[PATH_MAX];
  char name[PATH_MAX];

#ifdef KERN_PROC_PATHNAME
  size_t buflen;
  int mib[4];

  mib[0] = CTL_KERN;
  mib[1] = KERN_PROC;
  mib[2] = KERN_PROC_PATHNAME;
  mib[3] = pid;
  buflen = sizeof buf;
  if (sysctl (mib, 4, buf, &buflen, NULL, 0) == 0)
    return buf;
#endif

  xsnprintf (name, PATH_MAX, "/proc/%d/exe", pid);
  len = readlink (name, buf, PATH_MAX - 1);
  if (len != -1)
    {
      buf[len] = '\0';
      return buf;
    }

  return NULL;
}

static int
dfly_read_mapping (FILE *mapfile, unsigned long *start, unsigned long *end,
		   char *protection)
{
  /* FreeBSD 5.1-RELEASE uses a 256-byte buffer.  */
  char buf[256];
  int resident, privateresident;
  unsigned long obj;
  int ret = EOF;

  /* As of FreeBSD 5.0-RELEASE, the layout is described in
     /usr/src/sys/fs/procfs/procfs_map.c.  Somewhere in 5.1-CURRENT a
     new column was added to the procfs map.  Therefore we can't use
     fscanf since we need to support older releases too.  */
  if (fgets (buf, sizeof buf, mapfile) != NULL)
    ret = sscanf (buf, "%lx %lx %d %d %lx %s", start, end,
		  &resident, &privateresident, &obj, protection);

  return (ret != 0 && ret != EOF);
}

/* Iterate over all the memory regions in the current inferior,
   calling FUNC for each memory region.  OBFD is passed as the last
   argument to FUNC.  */

static int
dfly_find_memory_regions (struct target_ops *self,
			  find_memory_region_ftype func, void *obfd)
{
  pid_t pid = ptid_get_pid (inferior_ptid);
  char *mapfilename;
  FILE *mapfile;
  unsigned long start, end, size;
  char protection[4];
  int read, write, exec;
  struct cleanup *cleanup;

  mapfilename = xstrprintf ("/proc/%ld/map", (long) pid);
  cleanup = make_cleanup (xfree, mapfilename);
  mapfile = fopen (mapfilename, "r");
  if (mapfile == NULL)
    error (_("Couldn't open %s."), mapfilename);
  make_cleanup_fclose (mapfile);

  if (info_verbose)
    fprintf_filtered (gdb_stdout, 
		      "Reading memory regions from %s\n", mapfilename);

  /* Now iterate until end-of-file.  */
  while (dfly_read_mapping (mapfile, &start, &end, &protection[0]))
    {
      size = end - start;

      read = (strchr (protection, 'r') != 0);
      write = (strchr (protection, 'w') != 0);
      exec = (strchr (protection, 'x') != 0);

      if (info_verbose)
	{
	  fprintf_filtered (gdb_stdout, 
			    "Save segment, %ld bytes at %s (%c%c%c)\n",
			    size, paddress (target_gdbarch (), start),
			    read ? 'r' : '-',
			    write ? 'w' : '-',
			    exec ? 'x' : '-');
	}

      /* Invoke the callback function to create the corefile segment.
	 Pass MODIFIED as true, we do not know the real modification state.  */
      func (start, size, read, write, exec, 1, obfd);
    }

  do_cleanups (cleanup);
  return 0;
}

void
dfly_nat_add_target (struct target_ops *t)
{
  t->to_pid_to_exec_file = dfly_pid_to_exec_file;
  t->to_find_memory_regions = dfly_find_memory_regions;
  /* XXX: thread vfork support */
  add_target (t);
}

void
_initialize_dfly_nat (void)
{
/* XXX: todo add_setshow_boolean_cmd() */
}


[FILE:1009:dragonfly/dfly-nat.h]
/* Native-dependent code for DragonFly.

   Copyright (C) 2004-2018 Free Software Foundation, Inc.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

#ifndef DFLY_NAT_H
#define DFLY_NAT_H

/* Register the customized DragonFly target.  This should be used
   instead of calling add_target directly.  */
extern void dfly_nat_add_target (struct target_ops *);

#endif /* dfly-nat.h */


[FILE:179:dragonfly/dfly64.mh]
# Host: DragonFly/amd64
NATDEPFILES= fork-child.o inf-ptrace.o \
	dfly-nat.o amd64-nat.o x86-bsd-nat.o amd64-bsd-nat.o amd64-dfly-nat.o \
	x86-nat.o x86-dregs.o

LOADLIBES= -lkvm


[FILE:2390:dragonfly/i386-dfly-tdep.c]
/* Target-dependent code for DragonFly/i386.

   Copyright (C) 2003-2018 Free Software Foundation, Inc.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

#include "defs.h"
#include "arch-utils.h"
#include "gdbcore.h"
#include "osabi.h"
#include "regcache.h"
#include "x86-xstate.h"

#include "i386-tdep.h"
#include "i387-tdep.h"
#include "solib-svr4.h"

static int i386dfly_r_reg_offset[] =
{
  44, /* %eax */
  40, /* %ecx */
  36, /* %edx */
  32, /* %ebx */
  72, /* %esp */
  24, /* %ebp */
  20, /* %esi */
  16, /* %edi */
  60, /* %eip */
  68, /* %eflags */
  64, /* %cs */
  76, /* %ss */
  12, /* %ds */
  8, /* %es */
  4, /* %fs */
  0  /* %gs */
};

/* Sigtramp routine location.  */
CORE_ADDR i386dfly_sigtramp_start_addr = 0xbfbfdf20;
CORE_ADDR i386dfly_sigtramp_end_addr = 0xbfbfdff0;

int i386dfly_sc_reg_offset[] =
{
  64, /* %eax */
  60, /* %ecx */
  56, /* %edx */
  52, /* %ebx */
  92, /* %esp */
  44, /* %ebp */
  40, /* %esi */
  36, /* %edi */
  80, /* %eip */
  88, /* %eflags */
  84, /* %cs */
  96, /* %ss */
  32, /* %ds */
  28, /* %es */
  24, /* %fs */
  20  /* %gs */
};

static void
i386dfly_init_abi (struct gdbarch_info info, struct gdbarch *gdbarch)
{
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);

  i386_elf_init_abi(info, gdbarch);

  tdep->gregset_reg_offset = i386dfly_r_reg_offset;
  tdep->gregset_num_regs = ARRAY_SIZE (i386dfly_r_reg_offset);
  tdep->sizeof_gregset = 80;

  tdep->sc_reg_offset = i386dfly_sc_reg_offset;
  tdep->sc_num_regs = ARRAY_SIZE (i386dfly_sc_reg_offset);

  set_solib_svr4_fetch_link_map_offsets
    (gdbarch, svr4_ilp32_fetch_link_map_offsets);
}

void
_initialize_i386dfly_tdep (void)
{
  gdbarch_register_osabi (bfd_arch_i386, 0, GDB_OSABI_DRAGONFLY,
			  i386dfly_init_abi);
}


[FILE:746:dragonfly/patch-gdb_Makefile.in]
--- gdb/Makefile.in.orig	2018-01-31 02:58:50 UTC
+++ gdb/Makefile.in
@@ -641,6 +641,7 @@ ALL_64_TARGET_OBS = \
 	alpha-tdep.o \
 	amd64-darwin-tdep.o \
 	amd64-dicos-tdep.o \
+	amd64-dfly-tdep.o \
 	amd64-fbsd-tdep.o \
 	amd64-linux-tdep.o \
 	amd64-nbsd-tdep.o \
@@ -700,6 +701,7 @@ ALL_TARGET_OBS = \
 	i386-darwin-tdep.o \
 	i386-dicos-tdep.o \
 	i386-fbsd-tdep.o \
+	i386-dfly-tdep.o \
 	i386-gnu-tdep.o \
 	i386-go32-tdep.o \
 	i386-linux-tdep.o \
@@ -1198,6 +1200,7 @@ HFILES_NO_SRCDIR = \
 	darwin-nat.h \
 	dcache.h \
 	defs.h \
+	dfly-nat.h \
 	dicos-tdep.h \
 	dictionary.h \
 	disasm.h \
@@ -2227,6 +2230,7 @@ ALLDEPFILES = \
 	bsd-uthread.c \
 	darwin-nat.c \
 	dicos-tdep.c \
+	dfly-nat.c \
 	exec.c \
 	fbsd-nat.c \
 	fbsd-tdep.c \


[FILE:518:dragonfly/patch-gdb_amd64-tdep.h]
--- gdb/amd64-tdep.h.orig	2018-01-05 04:07:23 UTC
+++ gdb/amd64-tdep.h
@@ -144,8 +144,8 @@ extern int amd64nbsd_r_reg_offset[];
 extern int amd64obsd_r_reg_offset[];
 
 /* Variables exported from amd64-fbsd-tdep.c.  */
-extern CORE_ADDR amd64fbsd_sigtramp_start_addr;
-extern CORE_ADDR amd64fbsd_sigtramp_end_addr;
-extern int amd64fbsd_sc_reg_offset[];
+extern CORE_ADDR amd64dfly_sigtramp_start_addr;
+extern CORE_ADDR amd64dfly_sigtramp_end_addr;
+extern int amd64dfly_sc_reg_offset[];
 
 #endif /* amd64-tdep.h */


[FILE:361:dragonfly/patch-gdb_configure.host]
--- gdb/configure.host.orig	2018-01-05 04:07:23 UTC
+++ gdb/configure.host
@@ -177,6 +177,7 @@ vax-*-netbsdelf* | vax-*-knetbsd*-gnu)
 vax-*-openbsd*)		gdb_host=obsd ;;
 
 x86_64-*-linux*)	gdb_host=linux64 ;;
+x86_64-*-dragonfly*)	gdb_host=dfly64 ;;
 x86_64-*-freebsd* | x86_64-*-kfreebsd*-gnu)
 			gdb_host=fbsd64 ;;
 x86_64-*-netbsd* | x86_64-*-knetbsd*-gnu)


[FILE:785:dragonfly/patch-gdb_configure.tgt]
--- gdb/configure.tgt.orig	2018-01-31 02:58:50 UTC
+++ gdb/configure.tgt
@@ -714,6 +714,12 @@ x86_64-*-linux*)
 			solib-svr4.o symfile-mem.o linux-tdep.o linux-record.o"
 	build_gdbserver=yes
 	;;
+x86_64-*-dragonfly*)
+	# Target: DragonFly/amd64
+	gdb_target_obs="amd64-tdep.o amd64dfly-tdep.o i386-tdep.o \
+			i387-tdep.o i386bsd-tdep.o i386dfly-tdep.o \
+			bsd-uthread.o solib-svr4.o"
+	;;
 x86_64-*-freebsd* | x86_64-*-kfreebsd*-gnu)
 	# Target: FreeBSD/amd64
 	gdb_target_obs="amd64-fbsd-tdep.o ${i386_tobjs} \
@@ -754,6 +760,8 @@ gdb_target_obs="${cpu_obs} ${os_obs} ${g
 # map target onto default OS ABI
 
 case "${targ}" in
+*-*-dragonfly*)
+		gdb_osabi=GDB_OSABI_DRAGONFLY ;;
 *-*-freebsd* | *-*-kfreebsd*-gnu)
 		gdb_osabi=GDB_OSABI_FREEBSD ;;
 *-*-linux* | *-*-uclinux*)


[FILE:243:dragonfly/patch-gdb_defs.h]
--- gdb/defs.h.orig	2018-01-05 04:07:23 UTC
+++ gdb/defs.h
@@ -518,6 +518,7 @@ enum gdb_osabi
   GDB_OSABI_FREEBSD,
   GDB_OSABI_NETBSD,
   GDB_OSABI_OPENBSD,
+  GDB_OSABI_DRAGONFLY,
   GDB_OSABI_WINCE,
   GDB_OSABI_GO32,
   GDB_OSABI_QNXNTO,


[FILE:348:dragonfly/patch-gdb_i386-bsd-nat.c]
--- gdb/i386-bsd-nat.c.orig	2018-01-05 04:07:23 UTC
+++ gdb/i386-bsd-nat.c
@@ -300,6 +300,8 @@ _initialize_i386bsd_nat (void)
 #define SC_REG_OFFSET i386nbsd_sc_reg_offset
 #elif defined (OpenBSD)
 #define SC_REG_OFFSET i386obsd_sc_reg_offset
+#elif defined (DragonFly)
+#define SC_REG_OFFSET i386dfly_sc_reg_offset
 #endif
 
 #ifdef SC_REG_OFFSET


[FILE:773:dragonfly/patch-gdb_i386-tdep.h]
--- gdb/i386-tdep.h.orig	2018-01-05 04:07:23 UTC
+++ gdb/i386-tdep.h
@@ -449,12 +449,11 @@ extern int i386_mpx_enabled (void);
 /* Functions and variables exported from i386-bsd-tdep.c.  */
 
 extern void i386bsd_init_abi (struct gdbarch_info, struct gdbarch *);
-extern CORE_ADDR i386fbsd_sigtramp_start_addr;
-extern CORE_ADDR i386fbsd_sigtramp_end_addr;
+extern CORE_ADDR i386dfly_sigtramp_start_addr;
+extern CORE_ADDR i386dfly_sigtramp_end_addr;
 extern CORE_ADDR i386obsd_sigtramp_start_addr;
 extern CORE_ADDR i386obsd_sigtramp_end_addr;
-extern int i386fbsd4_sc_reg_offset[];
-extern int i386fbsd_sc_reg_offset[];
+extern int i386dfly_sc_reg_offset[];
 extern int i386nbsd_sc_reg_offset[];
 extern int i386obsd_sc_reg_offset[];
 extern int i386bsd_sc_reg_offset[];


[FILE:728:dragonfly/patch-gdb_osabi.c]
--- gdb/osabi.c.orig	2017-06-04 15:51:27 UTC
+++ gdb/osabi.c
@@ -67,6 +67,7 @@ static const struct osabi_names gdb_osab
   { "FreeBSD", NULL },
   { "NetBSD", NULL },
   { "OpenBSD", NULL },
+  { "DragonFly", NULL },
   { "WindowsCE", NULL },
   { "DJGPP", NULL },
   { "QNX-Neutrino", NULL },
@@ -492,6 +493,15 @@ generic_elf_osabi_sniff_abi_tag_sections
 	  return;
 	}
 
+      /* DragonFly.  */
+      if (check_note (abfd, sect, note, &sectsize, "DragonFly", 4,
+		      NT_DRAGONFLY_ABI_TAG))
+	{
+	  /* There is no need to check the version yet.  */
+	  *osabi = GDB_OSABI_DRAGONFLY;
+	  return;
+	}
+
       /* FreeBSD.  */
       if (check_note (abfd, sect, note, &sectsize, "FreeBSD", 4,
 		      NT_FREEBSD_ABI_TAG))


[FILE:390:dragonfly/patch-include_elf_common.h]
--- include/elf/common.h.orig	2018-01-05 04:07:23 UTC
+++ include/elf/common.h
@@ -785,6 +785,7 @@
 /* Values for FreeBSD .note.ABI-tag notes.  Note name is "FreeBSD".  */
 
 #define NT_FREEBSD_ABI_TAG	1
+#define NT_DRAGONFLY_ABI_TAG	1
 
 /* These three macros disassemble and assemble a symbol table st_info field,
    which contains the symbol binding and symbol type.  The STB_ and STT_

