# Buildsheet autogenerated by ravenadm tool -- Do not edit.

NAMEBASE=		gdb
VERSION=		8.3.1
KEYWORDS=		devel
VARIANTS=		standard
SDESC[standard]=	GNU debugger
HOMEPAGE=		http://www.gnu.org/software/gdb/
CONTACT=		nobody

DOWNLOAD_GROUPS=	main
SITES[main]=		GNU/gdb
DISTFILE[1]=		gdb-8.3.1.tar.xz:main
DF_INDEX=		1
SPKGS[standard]=	single

OPTIONS_AVAILABLE=	none
OPTIONS_STANDARD=	none

NOT_FOR_ARCH=		aarch64

BUILD_DEPENDS=		expat:static:standard
BUILDRUN_DEPENDS=	expat:shared:standard
			source-highlight:primary:standard

USES=			cpe iconv gmake libtool readline pkgconfig
			python:py36

EXTRACT_HEAD[1]=	{{TAR}} -xf
EXTRACT_TAIL[1]=	--exclude dejagnu --exclude expect --exclude sim --exclude texinfo --exclude intl --exclude readline

CPE_VENDOR=		gnu
FPC_EQUIVALENT=		devel/gdb

MUST_CONFIGURE=		gnu
CONFIGURE_ARGS=		--program-suffix=831
			--enable-targets=all
			--enable-64-bit-bfd
			--enable-tui
			--disable-build-with-cxx
			--with-gdb-datadir={{PREFIX}}/share/gdb831
			{{ICONV_CONFIGURE_ARG}}
			--with-system-readline
			--with-expat=yes
			--with-libexpat-prefix={{LOCALBASE}}
			--without-libunwind-ia64
			--with-python={{PYTHON_CMD}}
			--with-source-highlight
CONFIGURE_ENV=		CONFIGURED_M4=m4
			CONFIGURED_BISON=byacc

PLIST_SUB=		VER=831

CFLAGS=			-DRL_NO_COMPAT
			-D__STDC_CONSTANT_MACROS
			-D__STDC_LIMIT_MACROS
			-Wno-unused-function
			-Wno-unused-variable

post-patch:
	${REINPLACE_CMD} -e 's|$$| [GDB v8.3.1 for ${OPSYS}]|' \
		${WRKSRC}/gdb/version.in

post-patch-dragonfly:
	${CP} ${OPSYSDIR}/dfly-tdep.* ${WRKSRC}/gdb/
	${CP} ${OPSYSDIR}/dfly-nat.*  ${WRKSRC}/gdb/
	${CP} ${OPSYSDIR}/i386*       ${WRKSRC}/gdb/
	${CP} ${OPSYSDIR}/amd64*      ${WRKSRC}/gdb/

do-install:
	${INSTALL_PROGRAM} ${WRKSRC}/gdb/gdb \
		${STAGEDIR}${PREFIX}/bin/gdb831
	${INSTALL_MAN} ${WRKSRC}/gdb/doc/gdb.1 \
		${STAGEDIR}${MAN1PREFIX}/man/man1/gdb831.1
	(cd ${WRKSRC}/gdb/data-directory ; \
		${SETENV} ${MAKE_ENV} ${MAKE_CMD} ${MAKE_ARGS} install-syscalls )
	${LN} -sf gdb831 ${STAGEDIR}${PREFIX}/bin/gdbtui831
	${LN} -sf gdb831 ${STAGEDIR}${PREFIX}/bin/gdb
	(cd ${WRKSRC}/gdb && ${SETENV} ${MAKE_ENV} \
		${MAKE_CMD} ${MAKE_ARGS} install-python )
	(cd ${WRKSRC}/gdb/data-directory && ${SETENV} ${MAKE_ENV} \
		${MAKE_CMD} ${MAKE_ARGS} install-python )
. for f in gdb gdb/command gdb/function gdb/printer
	(cd ${STAGEDIR}${PREFIX}/share/gdb831/python/${f} ; ${CHMOD} 644 *.py* )
. endfor

[FILE:284:descriptions/desc.single]
GDB is a source-level debugger for Ada, C, C++, Objective-C, Pascal and
many other languages.  GDB can target (i.e., debug programs running on)
more than a dozen different processor architectures, and GDB itself can
run on most popular GNU/Linux, Unix and Microsoft Windows variants.


[FILE:95:distinfo]
1e55b4d7cdca7b34be12f4ceae651623aa73b2fd640152313f9f66a7149757c4     20489528 gdb-8.3.1.tar.xz


[FILE:819:manifests/plist.single]
bin/
 gdb
 gdb%%VER%%
 gdbtui%%VER%%
share/gdb%%VER%%/python/gdb/
 FrameDecorator.py
 FrameIterator.py
 __init__.py
 frames.py
 printing.py
 prompt.py
 types.py
 unwinder.py
 xmethod.py
share/gdb%%VER%%/python/gdb/command/
 __init__.py
 explore.py
 frame_filters.py
 pretty_printers.py
 prompt.py
 type_printers.py
 unwinders.py
 xmethods.py
share/gdb%%VER%%/python/gdb/function/
 __init__.py
 as_string.py
 caller_is.py
 strfns.py
share/gdb%%VER%%/python/gdb/printer/
 __init__.py
 bound_registers.py
share/gdb%%VER%%/syscalls/
 aarch64-linux.xml
 amd64-linux.xml
 arm-linux.xml
 freebsd.xml
 gdb-syscalls.dtd
 i386-linux.xml
 mips-n32-linux.xml
 mips-n64-linux.xml
 mips-o32-linux.xml
 ppc-linux.xml
 ppc64-linux.xml
 s390-linux.xml
 s390x-linux.xml
 sparc-linux.xml
 sparc64-linux.xml
share/man/man1/gdb%%VER%%.1.gz


[FILE:15911:patches/patch-01-commit-1163a4b7a3]
commit 1163a4b7a38a79ebd153dc5ee76ce93877d21dbd
Author: John Baldwin <jhb@FreeBSD.org>
Date:   Tue Mar 12 13:39:02 2019 -0700

    Support the fs_base and gs_base registers on i386.
    
    As on amd64, these registers hold the base address of the fs and gs
    segments, respectively.  For i386 these two registers are 32 bits.
    
    gdb/ChangeLog:
    
            * amd64-fbsd-nat.c (amd64_fbsd_nat_target::read_description):
            Update calls to i386_target_description to add 'segments'
            parameter.
            * amd64-tdep.c (amd64_init_abi): Set tdep->fsbase_regnum.  Don't
            add segment base registers.
            * arch/i386.c (i386_create_target_description): Add 'segments'
            parameter to enable segment base registers.
            * arch/i386.h (i386_create_target_description): Likewise.
            * features/i386/32bit-segments.xml: New file.
            * features/i386/32bit-segments.c: Generate.
            * i386-fbsd-nat.c (i386_fbsd_nat_target::read_description): Update
            call to i386_target_description to add 'segments' parameter.
            * i386-fbsd-tdep.c (i386fbsd_core_read_description): Likewise.
            * i386-go32-tdep.c (i386_go32_init_abi): Likewise.
            * i386-linux-tdep.c (i386_linux_read_description): Likewise.
            * i386-tdep.c (i386_validate_tdesc_p): Add segment base registers
            if feature is present.
            (i386_gdbarch_init): Pass I386_NUM_REGS to set_gdbarch_num_regs.
            Add 'segments' parameter to call to i386_target_description.
            (i386_target_description): Add 'segments' parameter to enable
            segment base registers.
            (_initialize_i386_tdep) [GDB_SELF_TEST]: Add 'segments' parameter
            to call to i386_target_description.
            * i386-tdep.h (struct gdbarch_tdep): Add 'fsbase_regnum'.
            (enum i386_regnum): Add I386_FSBASE_REGNUM and I386_GSBASE_REGNUM.
            Define I386_NUM_REGS.
            (i386_target_description): Add 'segments' parameter to enable
            segment base registers.
    
    gdb/gdbserver/ChangeLog:
    
            * linux-x86-tdesc.c (i386_linux_read_description): Update call to
            i386_create_target_description for 'segments' parameter.
            * lynx-i386-low.c (lynx_i386_arch_setup): Likewise.
            * nto-x86-low.c (nto_x86_arch_setup): Likewise.
            * win32-i386-low.c (i386_arch_setup): Likewise.

diff --git gdb/amd64-fbsd-nat.c gdb/amd64-fbsd-nat.c
index 74ef240766..9fff763dd3 100644
--- gdb/amd64-fbsd-nat.c
+++ gdb/amd64-fbsd-nat.c
@@ -190,13 +190,13 @@ amd64_fbsd_nat_target::read_description ()
       if (is64)
 	return amd64_target_description (xcr0, true);
       else
-	return i386_target_description (xcr0);
+	return i386_target_description (xcr0, false);
     }
 #endif
   if (is64)
     return amd64_target_description (X86_XSTATE_SSE_MASK, true);
   else
-    return i386_target_description (X86_XSTATE_SSE_MASK);
+    return i386_target_description (X86_XSTATE_SSE_MASK, false);
 }
 
 #if defined(HAVE_PT_GETDBREGS) && defined(USE_SIGTRAP_SIGINFO)
diff --git gdb/amd64-tdep.c gdb/amd64-tdep.c
index 3f61997d66..d5892954d7 100644
--- gdb/amd64-tdep.c
+++ gdb/amd64-tdep.c
@@ -3107,15 +3107,7 @@ amd64_init_abi (struct gdbarch_info info, struct gdbarch *gdbarch,
 
   if (tdesc_find_feature (tdesc, "org.gnu.gdb.i386.segments") != NULL)
     {
-      const struct tdesc_feature *feature =
-	  tdesc_find_feature (tdesc, "org.gnu.gdb.i386.segments");
-      struct tdesc_arch_data *tdesc_data_segments =
-	  (struct tdesc_arch_data *) info.tdep_info;
-
-      tdesc_numbered_register (feature, tdesc_data_segments,
-		       AMD64_FSBASE_REGNUM, "fs_base");
-      tdesc_numbered_register (feature, tdesc_data_segments,
-		       AMD64_GSBASE_REGNUM, "gs_base");
+      tdep->fsbase_regnum = AMD64_FSBASE_REGNUM;
     }
 
   if (tdesc_find_feature (tdesc, "org.gnu.gdb.i386.pkeys") != NULL)
diff --git gdb/arch/i386.c gdb/arch/i386.c
index 7d2901333b..ab24cf71cb 100644
--- gdb/arch/i386.c
+++ gdb/arch/i386.c
@@ -28,11 +28,12 @@
 #include "../features/i386/32bit-avx512.c"
 #include "../features/i386/32bit-mpx.c"
 #include "../features/i386/32bit-pkeys.c"
+#include "../features/i386/32bit-segments.c"
 
 /* Create i386 target descriptions according to XCR0.  */
 
 target_desc *
-i386_create_target_description (uint64_t xcr0, bool is_linux)
+i386_create_target_description (uint64_t xcr0, bool is_linux, bool segments)
 {
   target_desc *tdesc = allocate_target_description ();
 
@@ -53,6 +54,9 @@ i386_create_target_description (uint64_t xcr0, bool is_linux)
   if (is_linux)
     regnum = create_feature_i386_32bit_linux (tdesc, regnum);
 
+  if (segments)
+    regnum = create_feature_i386_32bit_segments (tdesc, regnum);
+
   if (xcr0 & X86_XSTATE_AVX)
     regnum = create_feature_i386_32bit_avx (tdesc, regnum);
 
diff --git gdb/arch/i386.h gdb/arch/i386.h
index fa85438080..9a831cea30 100644
--- gdb/arch/i386.h
+++ gdb/arch/i386.h
@@ -21,6 +21,7 @@
 #include "common/tdesc.h"
 #include <stdint.h>
 
-target_desc *i386_create_target_description (uint64_t xcr0, bool is_linux);
+target_desc *i386_create_target_description (uint64_t xcr0, bool is_linux,
+					     bool segments);
 
 #endif /* ARCH_I386_H */
diff --git gdb/features/i386/32bit-segments.c gdb/features/i386/32bit-segments.c
new file mode 100644
index 0000000000..c22c3dfbc3
--- /dev/null
+++ gdb/features/i386/32bit-segments.c
@@ -0,0 +1,15 @@
+/* THIS FILE IS GENERATED.  -*- buffer-read-only: t -*- vi:set ro:
+  Original: 32bit-segments.xml */
+
+#include "common/tdesc.h"
+
+static int
+create_feature_i386_32bit_segments (struct target_desc *result, long regnum)
+{
+  struct tdesc_feature *feature;
+
+  feature = tdesc_create_feature (result, "org.gnu.gdb.i386.segments");
+  tdesc_create_reg (feature, "fs_base", regnum++, 1, NULL, 32, "int");
+  tdesc_create_reg (feature, "gs_base", regnum++, 1, NULL, 32, "int");
+  return regnum;
+}
diff --git gdb/features/i386/32bit-segments.xml gdb/features/i386/32bit-segments.xml
new file mode 100644
index 0000000000..098948e5ec
--- /dev/null
+++ gdb/features/i386/32bit-segments.xml
@@ -0,0 +1,12 @@
+<?xml version="1.0"?>
+<!-- Copyright (C) 2016-2018 Free Software Foundation, Inc.
+
+     Copying and distribution of this file, with or without modification,
+     are permitted in any medium without royalty provided the copyright
+     notice and this notice are preserved.  -->
+
+<!DOCTYPE feature SYSTEM "gdb-target.dtd">
+<feature name="org.gnu.gdb.i386.segments">
+  <reg name="fs_base" bitsize="32" type="int"/>
+  <reg name="gs_base" bitsize="32" type="int"/>
+</feature>
diff --git gdb/gdbserver/linux-x86-tdesc.c gdb/gdbserver/linux-x86-tdesc.c
index 04bccc84ed..8f24a3d72d 100644
--- gdb/gdbserver/linux-x86-tdesc.c
+++ gdb/gdbserver/linux-x86-tdesc.c
@@ -87,7 +87,7 @@ i386_linux_read_description (uint64_t xcr0)
 
   if (*tdesc == NULL)
     {
-      *tdesc = i386_create_target_description (xcr0, true);
+      *tdesc = i386_create_target_description (xcr0, true, false);
 
       init_target_desc (*tdesc, i386_expedite_regs);
     }
diff --git gdb/gdbserver/lynx-i386-low.c gdb/gdbserver/lynx-i386-low.c
index bc1027dc52..e47f6b92f6 100644
--- gdb/gdbserver/lynx-i386-low.c
+++ gdb/gdbserver/lynx-i386-low.c
@@ -331,7 +331,7 @@ static void
 lynx_i386_arch_setup (void)
 {
   struct target_desc *tdesc
-    = i386_create_target_description (X86_XSTATE_SSE_MASK, false);
+    = i386_create_target_description (X86_XSTATE_SSE_MASK, false, false);
 
   init_target_desc (tdesc, i386_expedite_regs);
 
diff --git gdb/gdbserver/nto-x86-low.c gdb/gdbserver/nto-x86-low.c
index 1b00f7f6cc..cfbe7ba6d8 100644
--- gdb/gdbserver/nto-x86-low.c
+++ gdb/gdbserver/nto-x86-low.c
@@ -89,7 +89,7 @@ nto_x86_arch_setup (void)
 {
   the_low_target.num_regs = 16;
   struct target_desc *tdesc
-    = i386_create_target_description (X86_XSTATE_SSE_MASK, false);
+    = i386_create_target_description (X86_XSTATE_SSE_MASK, false, false);
 
   init_target_desc (tdesc, i386_expedite_regs);
 
diff --git gdb/gdbserver/win32-i386-low.c gdb/gdbserver/win32-i386-low.c
index 3be75d2bf2..7b187d3bea 100644
--- gdb/gdbserver/win32-i386-low.c
+++ gdb/gdbserver/win32-i386-low.c
@@ -439,7 +439,7 @@ i386_arch_setup (void)
 					   false, false);
   const char **expedite_regs = amd64_expedite_regs;
 #else
-  tdesc = i386_create_target_description (X86_XSTATE_SSE_MASK, false);
+  tdesc = i386_create_target_description (X86_XSTATE_SSE_MASK, false, false);
   const char **expedite_regs = i386_expedite_regs;
 #endif
 
diff --git gdb/i386-fbsd-nat.c gdb/i386-fbsd-nat.c
index 2309b76506..7106e90801 100644
--- gdb/i386-fbsd-nat.c
+++ gdb/i386-fbsd-nat.c
@@ -160,7 +160,7 @@ i386_fbsd_nat_target::read_description ()
   if (x86bsd_xsave_len == 0)
     xcr0 = X86_XSTATE_SSE_MASK;
 
-  return i386_target_description (xcr0);
+  return i386_target_description (xcr0, false);
 }
 #endif
 
diff --git gdb/i386-fbsd-tdep.c gdb/i386-fbsd-tdep.c
index 236edd692a..2f28bad728 100644
--- gdb/i386-fbsd-tdep.c
+++ gdb/i386-fbsd-tdep.c
@@ -267,7 +267,7 @@ i386fbsd_core_read_description (struct gdbarch *gdbarch,
 				struct target_ops *target,
 				bfd *abfd)
 {
-  return i386_target_description (i386fbsd_core_read_xcr0 (abfd));
+  return i386_target_description (i386fbsd_core_read_xcr0 (abfd), false);
 }
 
 /* Similar to i386_supply_fpregset, but use XSAVE extended state.  */
diff --git gdb/i386-go32-tdep.c gdb/i386-go32-tdep.c
index 06833c346c..30db72d880 100644
--- gdb/i386-go32-tdep.c
+++ gdb/i386-go32-tdep.c
@@ -35,7 +35,7 @@ i386_go32_init_abi (struct gdbarch_info info, struct gdbarch *gdbarch)
 
   /* DJGPP does not support the SSE registers.  */
   if (!tdesc_has_registers (info.target_desc))
-    tdep->tdesc = i386_target_description (X86_XSTATE_X87_MASK);
+    tdep->tdesc = i386_target_description (X86_XSTATE_X87_MASK, false);
 
   /* Native compiler is GCC, which uses the SVR4 register numbering
      even in COFF and STABS.  See the comment in i386_gdbarch_init,
diff --git gdb/i386-linux-tdep.c gdb/i386-linux-tdep.c
index da81715061..fa6b86f1c8 100644
--- gdb/i386-linux-tdep.c
+++ gdb/i386-linux-tdep.c
@@ -694,7 +694,7 @@ i386_linux_read_description (uint64_t xcr0)
     [(xcr0 & X86_XSTATE_PKRU) ? 1 : 0];
 
   if (*tdesc == NULL)
-    *tdesc = i386_create_target_description (xcr0, true);
+    *tdesc = i386_create_target_description (xcr0, true, false);
 
   return *tdesc;
 }
diff --git gdb/i386-tdep.c gdb/i386-tdep.c
index bc9ba752ed..4e63832b0e 100644
--- gdb/i386-tdep.c
+++ gdb/i386-tdep.c
@@ -8175,7 +8175,7 @@ i386_validate_tdesc_p (struct gdbarch_tdep *tdep,
   const struct tdesc_feature *feature_core;
 
   const struct tdesc_feature *feature_sse, *feature_avx, *feature_mpx,
-			     *feature_avx512, *feature_pkeys;
+			     *feature_avx512, *feature_pkeys, *feature_segments;
   int i, num_regs, valid_p;
 
   if (! tdesc_has_registers (tdesc))
@@ -8198,6 +8198,9 @@ i386_validate_tdesc_p (struct gdbarch_tdep *tdep,
   /* Try AVX512 registers.  */
   feature_avx512 = tdesc_find_feature (tdesc, "org.gnu.gdb.i386.avx512");
 
+  /* Try segment base registers.  */
+  feature_segments = tdesc_find_feature (tdesc, "org.gnu.gdb.i386.segments");
+
   /* Try PKEYS  */
   feature_pkeys = tdesc_find_feature (tdesc, "org.gnu.gdb.i386.pkeys");
 
@@ -8307,6 +8310,16 @@ i386_validate_tdesc_p (struct gdbarch_tdep *tdep,
 	    tdep->mpx_register_names[i]);
     }
 
+  if (feature_segments)
+    {
+      if (tdep->fsbase_regnum < 0)
+	tdep->fsbase_regnum = I386_FSBASE_REGNUM;
+      valid_p &= tdesc_numbered_register (feature_segments, tdesc_data,
+					  tdep->fsbase_regnum, "fs_base");
+      valid_p &= tdesc_numbered_register (feature_segments, tdesc_data,
+					  tdep->fsbase_regnum + 1, "gs_base");
+    }
+
   if (feature_pkeys)
     {
       tdep->xcr0 |= X86_XSTATE_PKRU;
@@ -8543,14 +8556,14 @@ i386_gdbarch_init (struct gdbarch_info info, struct gdbarch_list *arches)
   /* Even though the default ABI only includes general-purpose registers,
      floating-point registers and the SSE registers, we have to leave a
      gap for the upper AVX, MPX and AVX512 registers.  */
-  set_gdbarch_num_regs (gdbarch, I386_PKEYS_NUM_REGS);
+  set_gdbarch_num_regs (gdbarch, I386_NUM_REGS);
 
   set_gdbarch_gnu_triplet_regexp (gdbarch, i386_gnu_triplet_regexp);
 
   /* Get the x86 target description from INFO.  */
   tdesc = info.target_desc;
   if (! tdesc_has_registers (tdesc))
-    tdesc = i386_target_description (X86_XSTATE_SSE_MASK);
+    tdesc = i386_target_description (X86_XSTATE_SSE_MASK, false);
   tdep->tdesc = tdesc;
 
   tdep->num_core_regs = I386_NUM_GREGS + I387_NUM_REGS;
@@ -8592,6 +8605,9 @@ i386_gdbarch_init (struct gdbarch_info info, struct gdbarch_list *arches)
   tdep->pkru_regnum = -1;
   tdep->num_pkeys_regs = 0;
 
+  /* No segment base registers.  */
+  tdep->fsbase_regnum = -1;
+
   tdesc_data = tdesc_data_alloc ();
 
   set_gdbarch_relocate_instruction (gdbarch, i386_relocate_instruction);
@@ -8717,20 +8733,21 @@ i386_gdbarch_init (struct gdbarch_info info, struct gdbarch_list *arches)
 /* Return the target description for a specified XSAVE feature mask.  */
 
 const struct target_desc *
-i386_target_description (uint64_t xcr0)
+i386_target_description (uint64_t xcr0, bool segments)
 {
   static target_desc *i386_tdescs \
-    [2/*SSE*/][2/*AVX*/][2/*MPX*/][2/*AVX512*/][2/*PKRU*/] = {};
+    [2/*SSE*/][2/*AVX*/][2/*MPX*/][2/*AVX512*/][2/*PKRU*/][2/*segments*/] = {};
   target_desc **tdesc;
 
   tdesc = &i386_tdescs[(xcr0 & X86_XSTATE_SSE) ? 1 : 0]
     [(xcr0 & X86_XSTATE_AVX) ? 1 : 0]
     [(xcr0 & X86_XSTATE_MPX) ? 1 : 0]
     [(xcr0 & X86_XSTATE_AVX512) ? 1 : 0]
-    [(xcr0 & X86_XSTATE_PKRU) ? 1 : 0];
+    [(xcr0 & X86_XSTATE_PKRU) ? 1 : 0]
+    [segments ? 1 : 0];
 
   if (*tdesc == NULL)
-    *tdesc = i386_create_target_description (xcr0, false);
+    *tdesc = i386_create_target_description (xcr0, false, segments);
 
   return *tdesc;
 }
@@ -9072,7 +9089,7 @@ Show Intel Memory Protection Extensions specific variables."),
 
   for (auto &a : xml_masks)
     {
-      auto tdesc = i386_target_description (a.mask);
+      auto tdesc = i386_target_description (a.mask, false);
 
       selftests::record_xml_tdesc (a.xml, tdesc);
     }
diff --git gdb/i386-tdep.h gdb/i386-tdep.h
index 2532306e5c..c0d494824c 100644
--- gdb/i386-tdep.h
+++ gdb/i386-tdep.h
@@ -200,6 +200,10 @@ struct gdbarch_tdep
   /* PKEYS register names.  */
   const char **pkeys_register_names;
 
+  /* Register number for %fsbase.  Set this to -1 to indicate the
+     absence of segment base registers.  */
+  int fsbase_regnum;
+
   /* Target description.  */
   const struct target_desc *tdesc;
 
@@ -296,7 +300,9 @@ enum i386_regnum
   I386_K7_REGNUM = I386_K0_REGNUM + 7,
   I386_ZMM0H_REGNUM,		/* %zmm0h */
   I386_ZMM7H_REGNUM = I386_ZMM0H_REGNUM + 7,
-  I386_PKRU_REGNUM
+  I386_PKRU_REGNUM,
+  I386_FSBASE_REGNUM,
+  I386_GSBASE_REGNUM
 };
 
 /* Register numbers of RECORD_REGMAP.  */
@@ -337,6 +343,7 @@ enum record_i386_regnum
 #define I386_MPX_NUM_REGS	(I386_BNDSTATUS_REGNUM + 1)
 #define I386_AVX512_NUM_REGS	(I386_ZMM7H_REGNUM + 1)
 #define I386_PKEYS_NUM_REGS	(I386_PKRU_REGNUM + 1)
+#define I386_NUM_REGS		(I386_GSBASE_REGNUM + 1)
 
 /* Size of the largest register.  */
 #define I386_MAX_REGISTER_SIZE	64
@@ -440,7 +447,8 @@ extern int i386_svr4_reg_to_regnum (struct gdbarch *gdbarch, int reg);
 
 extern int i386_process_record (struct gdbarch *gdbarch,
                                 struct regcache *regcache, CORE_ADDR addr);
-extern const struct target_desc *i386_target_description (uint64_t xcr0);
+extern const struct target_desc *i386_target_description (uint64_t xcr0,
+							  bool segments);
 
 /* Return true iff the current target is MPX enabled.  */
 extern int i386_mpx_enabled (void);


[FILE:8131:patches/patch-02-commit-dd6876c91c]
commit dd6876c91cd40cc105b1a91f418ca2c80683b314
Author: John Baldwin <jhb@FreeBSD.org>
Date:   Tue Mar 12 13:39:02 2019 -0700

    Support fs_base and gs_base on FreeBSD/i386.
    
    The i386 BSD native target uses the same ptrace operations
    (PT_[GS]ET[FG]SBASE) as the amd64 BSD native target to fetch and store
    the registers.
    
    The amd64 BSD native now uses 'tdep->fsbase_regnum' instead of
    hardcoding AMD64_FSBASE_REGNUM and AMD64_GSBASE_REGNUM to support
    32-bit targets.  In addition, the store operations explicitly zero the
    new register value before fetching it from the register cache to
    ensure 32-bit values are zero-extended.
    
    gdb/ChangeLog:
    
            * amd64-bsd-nat.c (amd64bsd_fetch_inferior_registers): Use
            tdep->fsbase_regnum instead of constants for fs_base and gs_base.
            (amd64bsd_store_inferior_registers): Likewise.
            * amd64-fbsd-nat.c (amd64_fbsd_nat_target::read_description):
            Enable segment base registers.
            * i386-bsd-nat.c (i386bsd_fetch_inferior_registers): Use
            PT_GETFSBASE and PT_GETGSBASE.
            (i386bsd_store_inferior_registers): Use PT_SETFSBASE and
            PT_SETGSBASE.
            * i386-fbsd-nat.c (i386_fbsd_nat_target::read_description): Enable
            segment base registers.
            * i386-fbsd-tdep.c (i386fbsd_core_read_description): Likewise.

diff --git gdb/amd64-bsd-nat.c gdb/amd64-bsd-nat.c
index a2a91abb91..35763a5b95 100644
--- gdb/amd64-bsd-nat.c
+++ gdb/amd64-bsd-nat.c
@@ -43,6 +43,9 @@ amd64bsd_fetch_inferior_registers (struct regcache *regcache, int regnum)
 {
   struct gdbarch *gdbarch = regcache->arch ();
   pid_t pid = get_ptrace_pid (regcache->ptid ());
+#if defined(PT_GETFSBASE) || defined(PT_GETGSBASE)
+  const struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);
+#endif
 
   if (regnum == -1 || amd64_native_gregset_supplies_p (gdbarch, regnum))
     {
@@ -57,27 +60,27 @@ amd64bsd_fetch_inferior_registers (struct regcache *regcache, int regnum)
     }
 
 #ifdef PT_GETFSBASE
-  if (regnum == -1 || regnum == AMD64_FSBASE_REGNUM)
+  if (regnum == -1 || regnum == tdep->fsbase_regnum)
     {
       register_t base;
 
       if (ptrace (PT_GETFSBASE, pid, (PTRACE_TYPE_ARG3) &base, 0) == -1)
 	perror_with_name (_("Couldn't get segment register fs_base"));
 
-      regcache->raw_supply (AMD64_FSBASE_REGNUM, &base);
+      regcache->raw_supply (tdep->fsbase_regnum, &base);
       if (regnum != -1)
 	return;
     }
 #endif
 #ifdef PT_GETGSBASE
-  if (regnum == -1 || regnum == AMD64_GSBASE_REGNUM)
+  if (regnum == -1 || regnum == tdep->fsbase_regnum + 1)
     {
       register_t base;
 
       if (ptrace (PT_GETGSBASE, pid, (PTRACE_TYPE_ARG3) &base, 0) == -1)
 	perror_with_name (_("Couldn't get segment register gs_base"));
 
-      regcache->raw_supply (AMD64_GSBASE_REGNUM, &base);
+      regcache->raw_supply (tdep->fsbase_regnum + 1, &base);
       if (regnum != -1)
 	return;
     }
@@ -116,6 +119,9 @@ amd64bsd_store_inferior_registers (struct regcache *regcache, int regnum)
 {
   struct gdbarch *gdbarch = regcache->arch ();
   pid_t pid = get_ptrace_pid (regcache->ptid ());
+#if defined(PT_SETFSBASE) || defined(PT_SETGSBASE)
+  const struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);
+#endif
 
   if (regnum == -1 || amd64_native_gregset_supplies_p (gdbarch, regnum))
     {
@@ -134,11 +140,13 @@ amd64bsd_store_inferior_registers (struct regcache *regcache, int regnum)
     }
 
 #ifdef PT_SETFSBASE
-  if (regnum == -1 || regnum == AMD64_FSBASE_REGNUM)
+  if (regnum == -1 || regnum == tdep->fsbase_regnum)
     {
       register_t base;
 
-      regcache->raw_collect (AMD64_FSBASE_REGNUM, &base);
+      /* Clear the full base value to support 32-bit targets.  */
+      base = 0;
+      regcache->raw_collect (tdep->fsbase_regnum, &base);
 
       if (ptrace (PT_SETFSBASE, pid, (PTRACE_TYPE_ARG3) &base, 0) == -1)
 	perror_with_name (_("Couldn't write segment register fs_base"));
@@ -147,11 +155,13 @@ amd64bsd_store_inferior_registers (struct regcache *regcache, int regnum)
     }
 #endif
 #ifdef PT_SETGSBASE
-  if (regnum == -1 || regnum == AMD64_GSBASE_REGNUM)
+  if (regnum == -1 || regnum == tdep->fsbase_regnum + 1)
     {
       register_t base;
 
-      regcache->raw_collect (AMD64_GSBASE_REGNUM, &base);
+      /* Clear the full base value to support 32-bit targets.  */
+      base = 0;
+      regcache->raw_collect (tdep->fsbase_regnum + 1, &base);
 
       if (ptrace (PT_SETGSBASE, pid, (PTRACE_TYPE_ARG3) &base, 0) == -1)
 	perror_with_name (_("Couldn't write segment register gs_base"));
diff --git gdb/amd64-fbsd-nat.c gdb/amd64-fbsd-nat.c
index 9fff763dd3..cc676d3214 100644
--- gdb/amd64-fbsd-nat.c
+++ gdb/amd64-fbsd-nat.c
@@ -190,13 +190,13 @@ amd64_fbsd_nat_target::read_description ()
       if (is64)
 	return amd64_target_description (xcr0, true);
       else
-	return i386_target_description (xcr0, false);
+	return i386_target_description (xcr0, true);
     }
 #endif
   if (is64)
     return amd64_target_description (X86_XSTATE_SSE_MASK, true);
   else
-    return i386_target_description (X86_XSTATE_SSE_MASK, false);
+    return i386_target_description (X86_XSTATE_SSE_MASK, true);
 }
 
 #if defined(HAVE_PT_GETDBREGS) && defined(USE_SIGTRAP_SIGINFO)
diff --git gdb/i386-bsd-nat.c gdb/i386-bsd-nat.c
index 009a8dc1b2..a10b496096 100644
--- gdb/i386-bsd-nat.c
+++ gdb/i386-bsd-nat.c
@@ -144,6 +144,33 @@ i386bsd_fetch_inferior_registers (struct regcache *regcache, int regnum)
 	return;
     }
 
+#ifdef PT_GETFSBASE
+  if (regnum == -1 || regnum == I386_FSBASE_REGNUM)
+    {
+      register_t base;
+
+      if (ptrace (PT_GETFSBASE, pid, (PTRACE_TYPE_ARG3) &base, 0) == -1)
+	perror_with_name (_("Couldn't get segment register fs_base"));
+
+      regcache->raw_supply (I386_FSBASE_REGNUM, &base);
+      if (regnum != -1)
+	return;
+    }
+#endif
+#ifdef PT_GETGSBASE
+  if (regnum == -1 || regnum == I386_GSBASE_REGNUM)
+    {
+      register_t base;
+
+      if (ptrace (PT_GETGSBASE, pid, (PTRACE_TYPE_ARG3) &base, 0) == -1)
+	perror_with_name (_("Couldn't get segment register gs_base"));
+
+      regcache->raw_supply (I386_GSBASE_REGNUM, &base);
+      if (regnum != -1)
+	return;
+    }
+#endif
+
   if (regnum == -1 || regnum >= I386_ST0_REGNUM)
     {
       struct fpreg fpregs;
@@ -211,6 +238,33 @@ i386bsd_store_inferior_registers (struct regcache *regcache, int regnum)
 	return;
     }
 
+#ifdef PT_SETFSBASE
+  if (regnum == -1 || regnum == I386_FSBASE_REGNUM)
+    {
+      register_t base;
+
+      regcache->raw_collect (I386_FSBASE_REGNUM, &base);
+
+      if (ptrace (PT_SETFSBASE, pid, (PTRACE_TYPE_ARG3) &base, 0) == -1)
+	perror_with_name (_("Couldn't write segment register fs_base"));
+      if (regnum != -1)
+	return;
+    }
+#endif
+#ifdef PT_SETGSBASE
+  if (regnum == -1 || regnum == I386_GSBASE_REGNUM)
+    {
+      register_t base;
+
+      regcache->raw_collect (I386_GSBASE_REGNUM, &base);
+
+      if (ptrace (PT_SETGSBASE, pid, (PTRACE_TYPE_ARG3) &base, 0) == -1)
+	perror_with_name (_("Couldn't write segment register gs_base"));
+      if (regnum != -1)
+	return;
+    }
+#endif
+
   if (regnum == -1 || regnum >= I386_ST0_REGNUM)
     {
       struct fpreg fpregs;
diff --git gdb/i386-fbsd-nat.c gdb/i386-fbsd-nat.c
index 7106e90801..be5d4c67be 100644
--- gdb/i386-fbsd-nat.c
+++ gdb/i386-fbsd-nat.c
@@ -160,7 +160,7 @@ i386_fbsd_nat_target::read_description ()
   if (x86bsd_xsave_len == 0)
     xcr0 = X86_XSTATE_SSE_MASK;
 
-  return i386_target_description (xcr0, false);
+  return i386_target_description (xcr0, true);
 }
 #endif
 
diff --git gdb/i386-fbsd-tdep.c gdb/i386-fbsd-tdep.c
index 2f28bad728..ac57e7383d 100644
--- gdb/i386-fbsd-tdep.c
+++ gdb/i386-fbsd-tdep.c
@@ -267,7 +267,7 @@ i386fbsd_core_read_description (struct gdbarch *gdbarch,
 				struct target_ops *target,
 				bfd *abfd)
 {
-  return i386_target_description (i386fbsd_core_read_xcr0 (abfd), false);
+  return i386_target_description (i386fbsd_core_read_xcr0 (abfd), true);
 }
 
 /* Similar to i386_supply_fpregset, but use XSAVE extended state.  */


[FILE:7691:patches/patch-03-commit-6e056c8178]
commit 6e056c817845f3d736a1be6b68c69b439c6c6d25
Author: John Baldwin <jhb@FreeBSD.org>
Date:   Tue Mar 12 13:39:02 2019 -0700

    Add a new gdbarch method to resolve the address of TLS variables.
    
    Permit TLS variable addresses to be resolved purely by an ABI rather
    than requiring a target method.  This doesn't try the target method if
    the ABI function is present (even if the ABI function fails) to
    simplify error handling.
    
    gdb/ChangeLog:
    
            * gdbarch.sh (get_thread_local_address): New method.
            * gdbarch.h, gdbarch.c: Regenerate.
            * target.c (target_translate_tls_address): Use
            gdbarch_get_thread_local_address if present instead of
            target::get_thread_local_address.

diff --git gdb/gdbarch.c gdb/gdbarch.c
index 434ee3bfcf..2b3fcef004 100644
--- gdb/gdbarch.c
+++ gdb/gdbarch.c
@@ -251,6 +251,7 @@ struct gdbarch
   CORE_ADDR deprecated_function_start_offset;
   gdbarch_remote_register_number_ftype *remote_register_number;
   gdbarch_fetch_tls_load_module_address_ftype *fetch_tls_load_module_address;
+  gdbarch_get_thread_local_address_ftype *get_thread_local_address;
   CORE_ADDR frame_args_skip;
   gdbarch_unwind_pc_ftype *unwind_pc;
   gdbarch_unwind_sp_ftype *unwind_sp;
@@ -613,6 +614,7 @@ verify_gdbarch (struct gdbarch *gdbarch)
   /* Skip verify of deprecated_function_start_offset, invalid_p == 0 */
   /* Skip verify of remote_register_number, invalid_p == 0 */
   /* Skip verify of fetch_tls_load_module_address, has predicate.  */
+  /* Skip verify of get_thread_local_address, has predicate.  */
   /* Skip verify of frame_args_skip, invalid_p == 0 */
   /* Skip verify of unwind_pc, invalid_p == 0 */
   /* Skip verify of unwind_sp, invalid_p == 0 */
@@ -1073,6 +1075,12 @@ gdbarch_dump (struct gdbarch *gdbarch, struct ui_file *file)
   fprintf_unfiltered (file,
                       "gdbarch_dump: get_syscall_number = <%s>\n",
                       host_address_to_string (gdbarch->get_syscall_number));
+  fprintf_unfiltered (file,
+                      "gdbarch_dump: gdbarch_get_thread_local_address_p() = %d\n",
+                      gdbarch_get_thread_local_address_p (gdbarch));
+  fprintf_unfiltered (file,
+                      "gdbarch_dump: get_thread_local_address = <%s>\n",
+                      host_address_to_string (gdbarch->get_thread_local_address));
   fprintf_unfiltered (file,
                       "gdbarch_dump: gnu_triplet_regexp = <%s>\n",
                       host_address_to_string (gdbarch->gnu_triplet_regexp));
@@ -3018,6 +3026,30 @@ set_gdbarch_fetch_tls_load_module_address (struct gdbarch *gdbarch,
   gdbarch->fetch_tls_load_module_address = fetch_tls_load_module_address;
 }
 
+int
+gdbarch_get_thread_local_address_p (struct gdbarch *gdbarch)
+{
+  gdb_assert (gdbarch != NULL);
+  return gdbarch->get_thread_local_address != NULL;
+}
+
+CORE_ADDR
+gdbarch_get_thread_local_address (struct gdbarch *gdbarch, ptid_t ptid, CORE_ADDR lm_addr, CORE_ADDR offset)
+{
+  gdb_assert (gdbarch != NULL);
+  gdb_assert (gdbarch->get_thread_local_address != NULL);
+  if (gdbarch_debug >= 2)
+    fprintf_unfiltered (gdb_stdlog, "gdbarch_get_thread_local_address called\n");
+  return gdbarch->get_thread_local_address (gdbarch, ptid, lm_addr, offset);
+}
+
+void
+set_gdbarch_get_thread_local_address (struct gdbarch *gdbarch,
+                                      gdbarch_get_thread_local_address_ftype get_thread_local_address)
+{
+  gdbarch->get_thread_local_address = get_thread_local_address;
+}
+
 CORE_ADDR
 gdbarch_frame_args_skip (struct gdbarch *gdbarch)
 {
diff --git gdb/gdbarch.h gdb/gdbarch.h
index 75618376ab..abb72e752b 100644
--- gdb/gdbarch.h
+++ gdb/gdbarch.h
@@ -649,6 +649,18 @@ typedef CORE_ADDR (gdbarch_fetch_tls_load_module_address_ftype) (struct objfile
 extern CORE_ADDR gdbarch_fetch_tls_load_module_address (struct gdbarch *gdbarch, struct objfile *objfile);
 extern void set_gdbarch_fetch_tls_load_module_address (struct gdbarch *gdbarch, gdbarch_fetch_tls_load_module_address_ftype *fetch_tls_load_module_address);
 
+/* Return the thread-local address at OFFSET in the thread-local
+   storage for the thread PTID and the shared library or executable
+   file given by LM_ADDR.  If that block of thread-local storage hasn't
+   been allocated yet, this function may throw an error.  LM_ADDR may
+   be zero for statically linked multithreaded inferiors. */
+
+extern int gdbarch_get_thread_local_address_p (struct gdbarch *gdbarch);
+
+typedef CORE_ADDR (gdbarch_get_thread_local_address_ftype) (struct gdbarch *gdbarch, ptid_t ptid, CORE_ADDR lm_addr, CORE_ADDR offset);
+extern CORE_ADDR gdbarch_get_thread_local_address (struct gdbarch *gdbarch, ptid_t ptid, CORE_ADDR lm_addr, CORE_ADDR offset);
+extern void set_gdbarch_get_thread_local_address (struct gdbarch *gdbarch, gdbarch_get_thread_local_address_ftype *get_thread_local_address);
+
 extern CORE_ADDR gdbarch_frame_args_skip (struct gdbarch *gdbarch);
 extern void set_gdbarch_frame_args_skip (struct gdbarch *gdbarch, CORE_ADDR frame_args_skip);
 
diff --git gdb/gdbarch.sh gdb/gdbarch.sh
index 48fcebd19a..63bfbad7d9 100755
--- gdb/gdbarch.sh
+++ gdb/gdbarch.sh
@@ -602,6 +602,14 @@ m;int;remote_register_number;int regno;regno;;default_remote_register_number;;0
 
 # Fetch the target specific address used to represent a load module.
 F;CORE_ADDR;fetch_tls_load_module_address;struct objfile *objfile;objfile
+
+# Return the thread-local address at OFFSET in the thread-local
+# storage for the thread PTID and the shared library or executable
+# file given by LM_ADDR.  If that block of thread-local storage hasn't
+# been allocated yet, this function may throw an error.  LM_ADDR may
+# be zero for statically linked multithreaded inferiors.
+
+M;CORE_ADDR;get_thread_local_address;ptid_t ptid, CORE_ADDR lm_addr, CORE_ADDR offset;ptid, lm_addr, offset
 #
 v;CORE_ADDR;frame_args_skip;;;0;;;0
 m;CORE_ADDR;unwind_pc;struct frame_info *next_frame;next_frame;;default_unwind_pc;;0
diff --git gdb/target.c gdb/target.c
index 8579c19d05..c27157d209 100644
--- gdb/target.c
+++ gdb/target.c
@@ -698,8 +698,9 @@ target_translate_tls_address (struct objfile *objfile, CORE_ADDR offset)
 {
   volatile CORE_ADDR addr = 0;
   struct target_ops *target = current_top_target ();
+  struct gdbarch *gdbarch = target_gdbarch ();
 
-  if (gdbarch_fetch_tls_load_module_address_p (target_gdbarch ()))
+  if (gdbarch_fetch_tls_load_module_address_p (gdbarch))
     {
       ptid_t ptid = inferior_ptid;
 
@@ -708,10 +709,14 @@ target_translate_tls_address (struct objfile *objfile, CORE_ADDR offset)
 	  CORE_ADDR lm_addr;
 	  
 	  /* Fetch the load module address for this objfile.  */
-	  lm_addr = gdbarch_fetch_tls_load_module_address (target_gdbarch (),
+	  lm_addr = gdbarch_fetch_tls_load_module_address (gdbarch,
 	                                                   objfile);
 
-	  addr = target->get_thread_local_address (ptid, lm_addr, offset);
+	  if (gdbarch_get_thread_local_address_p (gdbarch))
+	    addr = gdbarch_get_thread_local_address (gdbarch, ptid, lm_addr,
+						     offset);
+	  else
+	    addr = target->get_thread_local_address (ptid, lm_addr, offset);
 	}
       /* If an error occurred, print TLS related messages here.  Otherwise,
          throw the error to some higher catcher.  */
@@ -766,8 +771,6 @@ target_translate_tls_address (struct objfile *objfile, CORE_ADDR offset)
 	}
       END_CATCH
     }
-  /* It wouldn't be wrong here to try a gdbarch method, too; finding
-     TLS is an ABI-specific thing.  But we don't do that yet.  */
   else
     error (_("Cannot find thread-local variables on this target"));
 


[FILE:2156:patches/patch-04-commit-36c53a0262]
commit 36c53a0262f84ad11d738471789dadfa9c4eb320
Author: John Baldwin <jhb@FreeBSD.org>
Date:   Tue Mar 12 13:39:02 2019 -0700

    Remove code disabled since at least 1999 from lookup_struct_elt_type.
    
    Update the comment above the function to reflect the code removal and
    document the existing behavior.
    
    gdb/ChangeLog:
    
            * gdbtypes.c (lookup_struct_elt_type): Update comment and
            remove disabled code block.

diff --git gdb/gdbtypes.c gdb/gdbtypes.c
index 09284ef259..5924b15520 100644
--- gdb/gdbtypes.c
+++ gdb/gdbtypes.c
@@ -1644,8 +1644,7 @@ lookup_template_type (char *name, struct type *type,
   return (SYMBOL_TYPE (sym));
 }
 
-/* Given a type TYPE, lookup the type of the component of type named
-   NAME.
+/* Given a type TYPE, lookup the type of the component named NAME.
 
    TYPE can be either a struct or union, or a pointer or reference to
    a struct or union.  If it is a pointer or reference, its target
@@ -1653,8 +1652,8 @@ lookup_template_type (char *name, struct type *type,
    as specified for the definitions of the expression element types
    STRUCTOP_STRUCT and STRUCTOP_PTR.
 
-   If NOERR is nonzero, return zero if NAME is not suitably defined.
-   If NAME is the name of a baseclass type, return that type.  */
+   If NOERR is nonzero, return NULL if there is no component named
+   NAME.  */
 
 struct type *
 lookup_struct_elt_type (struct type *type, const char *name, int noerr)
@@ -1678,20 +1677,6 @@ lookup_struct_elt_type (struct type *type, const char *name, int noerr)
 	     type_name.c_str ());
     }
 
-#if 0
-  /* FIXME: This change put in by Michael seems incorrect for the case
-     where the structure tag name is the same as the member name.
-     I.e. when doing "ptype bell->bar" for "struct foo { int bar; int
-     foo; } bell;" Disabled by fnf.  */
-  {
-    char *type_name;
-
-    type_name = TYPE_NAME (type);
-    if (type_name != NULL && strcmp (type_name, name) == 0)
-      return type;
-  }
-#endif
-
   for (i = TYPE_NFIELDS (type) - 1; i >= TYPE_N_BASECLASSES (type); i--)
     {
       const char *t_field_name = TYPE_FIELD_NAME (type, i);


[FILE:5624:patches/patch-05-commit-ef0bd2046f]
commit ef0bd2046f58fac69577892c2d3b44b20d027476
Author: John Baldwin <jhb@FreeBSD.org>
Date:   Tue Mar 12 13:39:02 2019 -0700

    Add a more general version of lookup_struct_elt_type.
    
    lookup_struct_elt is a new function which returns a tuple of
    information about a component of a structure or union.  The returned
    tuple contains a pointer to the struct field object for the component
    as well as a bit offset of that field within the structure.  If the
    field names a field in an anonymous substructure, the offset is the
    "global" offset relative to the original structure type.  If noerr is
    set, then the returned tuple will set the field pointer to NULL to
    indicate a missing component rather than throwing an error.
    
    lookup_struct_elt_type is now reimplemented in terms of this new
    function.  It simply returns the type of the returned field.
    
    gdb/ChangeLog:
    
            * gdbtypes.c (lookup_struct_elt): New function.
            (lookup_struct_elt_type): Reimplement via lookup_struct_elt.
            * gdbtypes.h (struct struct_elt): New type.
            (lookup_struct_elt): New prototype.

diff --git gdb/gdbtypes.c gdb/gdbtypes.c
index 5924b15520..db470dafac 100644
--- gdb/gdbtypes.c
+++ gdb/gdbtypes.c
@@ -1644,19 +1644,10 @@ lookup_template_type (char *name, struct type *type,
   return (SYMBOL_TYPE (sym));
 }
 
-/* Given a type TYPE, lookup the type of the component named NAME.
+/* See gdbtypes.h.  */
 
-   TYPE can be either a struct or union, or a pointer or reference to
-   a struct or union.  If it is a pointer or reference, its target
-   type is automatically used.  Thus '.' and '->' are interchangable,
-   as specified for the definitions of the expression element types
-   STRUCTOP_STRUCT and STRUCTOP_PTR.
-
-   If NOERR is nonzero, return NULL if there is no component named
-   NAME.  */
-
-struct type *
-lookup_struct_elt_type (struct type *type, const char *name, int noerr)
+struct_elt
+lookup_struct_elt (struct type *type, const char *name, int noerr)
 {
   int i;
 
@@ -1683,39 +1674,47 @@ lookup_struct_elt_type (struct type *type, const char *name, int noerr)
 
       if (t_field_name && (strcmp_iw (t_field_name, name) == 0))
 	{
-	  return TYPE_FIELD_TYPE (type, i);
+	  return {&TYPE_FIELD (type, i), TYPE_FIELD_BITPOS (type, i)};
 	}
      else if (!t_field_name || *t_field_name == '\0')
 	{
-	  struct type *subtype 
-	    = lookup_struct_elt_type (TYPE_FIELD_TYPE (type, i), name, 1);
-
-	  if (subtype != NULL)
-	    return subtype;
+	  struct_elt elt
+	    = lookup_struct_elt (TYPE_FIELD_TYPE (type, i), name, 1);
+	  if (elt.field != NULL)
+	    {
+	      elt.offset += TYPE_FIELD_BITPOS (type, i);
+	      return elt;
+	    }
 	}
     }
 
   /* OK, it's not in this class.  Recursively check the baseclasses.  */
   for (i = TYPE_N_BASECLASSES (type) - 1; i >= 0; i--)
     {
-      struct type *t;
-
-      t = lookup_struct_elt_type (TYPE_BASECLASS (type, i), name, 1);
-      if (t != NULL)
-	{
-	  return t;
-	}
+      struct_elt elt = lookup_struct_elt (TYPE_BASECLASS (type, i), name, 1);
+      if (elt.field != NULL)
+	return elt;
     }
 
   if (noerr)
-    {
-      return NULL;
-    }
+    return {nullptr, 0};
 
   std::string type_name = type_to_string (type);
   error (_("Type %s has no component named %s."), type_name.c_str (), name);
 }
 
+/* See gdbtypes.h.  */
+
+struct type *
+lookup_struct_elt_type (struct type *type, const char *name, int noerr)
+{
+  struct_elt elt = lookup_struct_elt (type, name, noerr);
+  if (elt.field != NULL)
+    return FIELD_TYPE (*elt.field);
+  else
+    return NULL;
+}
+
 /* Store in *MAX the largest number representable by unsigned integer type
    TYPE.  */
 
diff --git gdb/gdbtypes.h gdb/gdbtypes.h
index a6d4f64e9b..66051cf02c 100644
--- gdb/gdbtypes.h
+++ gdb/gdbtypes.h
@@ -1873,6 +1873,44 @@ extern struct type *allocate_stub_method (struct type *);
 
 extern const char *type_name_or_error (struct type *type);
 
+struct struct_elt
+{
+  /* The field of the element, or NULL if no element was found.  */
+  struct field *field;
+
+  /* The bit offset of the element in the parent structure.  */
+  LONGEST offset;
+};
+
+/* Given a type TYPE, lookup the field and offset of the component named
+   NAME.
+
+   TYPE can be either a struct or union, or a pointer or reference to
+   a struct or union.  If it is a pointer or reference, its target
+   type is automatically used.  Thus '.' and '->' are interchangable,
+   as specified for the definitions of the expression element types
+   STRUCTOP_STRUCT and STRUCTOP_PTR.
+
+   If NOERR is nonzero, the returned structure will have field set to
+   NULL if there is no component named NAME.
+
+   If the component NAME is a field in an anonymous substructure of
+   TYPE, the returned offset is a "global" offset relative to TYPE
+   rather than an offset within the substructure.  */
+
+extern struct_elt lookup_struct_elt (struct type *, const char *, int);
+
+/* Given a type TYPE, lookup the type of the component named NAME.
+
+   TYPE can be either a struct or union, or a pointer or reference to
+   a struct or union.  If it is a pointer or reference, its target
+   type is automatically used.  Thus '.' and '->' are interchangable,
+   as specified for the definitions of the expression element types
+   STRUCTOP_STRUCT and STRUCTOP_PTR.
+
+   If NOERR is nonzero, return NULL if there is no component named
+   NAME.  */
+
 extern struct type *lookup_struct_elt_type (struct type *, const char *, int);
 
 extern struct type *make_pointer_type (struct type *, struct type **);


[FILE:7725:patches/patch-06-commit-945f3901b5]
commit 945f3901b5889e57edf5a2ee25acb51f0078a719
Author: John Baldwin <jhb@FreeBSD.org>
Date:   Tue Mar 12 13:39:02 2019 -0700

    Add a helper function to resolve TLS variable addresses for FreeBSD.
    
    The fbsd_get_thread_local_address function accepts the base address of
    a thread's DTV array and the base address of an object file's link map
    and uses this to compute a TLS variable's address.  FreeBSD
    architectures use an architecture-specific method to determine the
    address of the DTV array pointer and call this helper function to
    perform the rest of the address calculation.
    
            * fbsd-tdep.c (fbsd_pspace_data_handle): New variable.
            (struct fbsd_pspace_data): New type.
            (get_fbsd_pspace_data, fbsd_pspace_data_cleanup)
            (fbsd_read_integer_by_name, fbsd_fetch_rtld_offsets)
            (fbsd_get_tls_index, fbsd_get_thread_local_address): New function.
            (_initialize_fbsd_tdep): Initialize 'fbsd_pspace_data_handle'.
            * fbsd-tdep.c (fbsd_get_thread_local_address): New prototype.

diff --git gdb/fbsd-tdep.c gdb/fbsd-tdep.c
index d971d3a653..f06836216d 100644
--- gdb/fbsd-tdep.c
+++ gdb/fbsd-tdep.c
@@ -24,6 +24,7 @@
 #include "regcache.h"
 #include "regset.h"
 #include "gdbthread.h"
+#include "objfiles.h"
 #include "xml-syscall.h"
 #include <sys/socket.h>
 #include <arpa/inet.h>
@@ -444,6 +445,41 @@ get_fbsd_gdbarch_data (struct gdbarch *gdbarch)
 	  gdbarch_data (gdbarch, fbsd_gdbarch_data_handle));
 }
 
+/* Per-program-space data for FreeBSD architectures.  */
+static const struct program_space_data *fbsd_pspace_data_handle;
+
+struct fbsd_pspace_data
+{
+  /* Offsets in the runtime linker's 'Obj_Entry' structure.  */
+  LONGEST off_linkmap;
+  LONGEST off_tlsindex;
+  bool rtld_offsets_valid;
+};
+
+static struct fbsd_pspace_data *
+get_fbsd_pspace_data (struct program_space *pspace)
+{
+  struct fbsd_pspace_data *data;
+
+  data = ((struct fbsd_pspace_data *)
+	  program_space_data (pspace, fbsd_pspace_data_handle));
+  if (data == NULL)
+    {
+      data = XCNEW (struct fbsd_pspace_data);
+      set_program_space_data (pspace, fbsd_pspace_data_handle, data);
+    }
+
+  return data;
+}
+
+/* The cleanup callback for FreeBSD architecture per-program-space data.  */
+
+static void
+fbsd_pspace_data_cleanup (struct program_space *pspace, void *data)
+{
+  xfree (data);
+}
+
 /* This is how we want PTIDs from core files to be printed.  */
 
 static const char *
@@ -1932,6 +1968,121 @@ fbsd_get_syscall_number (struct gdbarch *gdbarch, thread_info *thread)
   internal_error (__FILE__, __LINE__, _("fbsd_get_sycall_number called"));
 }
 
+/* Read an integer symbol value from the current target.  */
+
+static LONGEST
+fbsd_read_integer_by_name (struct gdbarch *gdbarch, const char *name)
+{
+  bound_minimal_symbol ms = lookup_minimal_symbol (name, NULL, NULL);
+  if (ms.minsym == NULL)
+    error (_("Unable to resolve symbol '%s'"), name);
+
+  gdb_byte buf[4];
+  if (target_read_memory (BMSYMBOL_VALUE_ADDRESS (ms), buf, sizeof buf) != 0)
+    error (_("Unable to read value of '%s'"), name);
+
+  return extract_signed_integer (buf, sizeof buf, gdbarch_byte_order (gdbarch));
+}
+
+/* Lookup offsets of fields in the runtime linker's 'Obj_Entry'
+   structure needed to determine the TLS index of an object file.  */
+
+static void
+fbsd_fetch_rtld_offsets (struct gdbarch *gdbarch, struct fbsd_pspace_data *data)
+{
+  TRY
+    {
+      /* Fetch offsets from debug symbols in rtld.  */
+      struct symbol *obj_entry_sym
+	= lookup_symbol_in_language ("Struct_Obj_Entry", NULL, STRUCT_DOMAIN,
+				     language_c, NULL).symbol;
+      if (obj_entry_sym == NULL)
+	error (_("Unable to find Struct_Obj_Entry symbol"));
+      data->off_linkmap = lookup_struct_elt (SYMBOL_TYPE(obj_entry_sym),
+					     "linkmap", 0).offset / 8;
+      data->off_tlsindex = lookup_struct_elt (SYMBOL_TYPE(obj_entry_sym),
+					      "tlsindex", 0).offset / 8;
+      data->rtld_offsets_valid = true;
+      return;
+    }
+  CATCH (e, RETURN_MASK_ERROR)
+    {
+      data->off_linkmap = -1;
+    }
+  END_CATCH
+
+  TRY
+    {
+      /* Fetch offsets from global variables in libthr.  Note that
+	 this does not work for single-threaded processes that are not
+	 linked against libthr.  */
+      data->off_linkmap = fbsd_read_integer_by_name (gdbarch,
+						     "_thread_off_linkmap");
+      data->off_tlsindex = fbsd_read_integer_by_name (gdbarch,
+						      "_thread_off_tlsindex");
+      data->rtld_offsets_valid = true;
+      return;
+    }
+  CATCH (e, RETURN_MASK_ERROR)
+    {
+      data->off_linkmap = -1;
+    }
+  END_CATCH
+}
+
+/* Helper function to read the TLS index of an object file associated
+   with a link map entry at LM_ADDR.  */
+
+static LONGEST
+fbsd_get_tls_index (struct gdbarch *gdbarch, CORE_ADDR lm_addr)
+{
+  struct fbsd_pspace_data *data = get_fbsd_pspace_data (current_program_space);
+
+  if (!data->rtld_offsets_valid)
+    fbsd_fetch_rtld_offsets (gdbarch, data);
+
+  if (data->off_linkmap == -1)
+    throw_error (TLS_GENERIC_ERROR,
+		 _("Cannot fetch runtime linker structure offsets"));
+
+  /* Simulate container_of to convert from LM_ADDR to the Obj_Entry
+     pointer and then compute the offset of the tlsindex member.  */
+  CORE_ADDR tlsindex_addr = lm_addr - data->off_linkmap + data->off_tlsindex;
+
+  gdb_byte buf[4];
+  if (target_read_memory (tlsindex_addr, buf, sizeof buf) != 0)
+    throw_error (TLS_GENERIC_ERROR,
+		 _("Cannot find thread-local variables on this target"));
+
+  return extract_signed_integer (buf, sizeof buf, gdbarch_byte_order (gdbarch));
+}
+
+/* See fbsd-tdep.h.  */
+
+CORE_ADDR
+fbsd_get_thread_local_address (struct gdbarch *gdbarch, CORE_ADDR dtv_addr,
+			       CORE_ADDR lm_addr, CORE_ADDR offset)
+{
+  LONGEST tls_index = fbsd_get_tls_index (gdbarch, lm_addr);
+
+  gdb_byte buf[gdbarch_ptr_bit (gdbarch) / TARGET_CHAR_BIT];
+  if (target_read_memory (dtv_addr, buf, sizeof buf) != 0)
+    throw_error (TLS_GENERIC_ERROR,
+		 _("Cannot find thread-local variables on this target"));
+
+  const struct builtin_type *builtin = builtin_type (gdbarch);
+  CORE_ADDR addr = gdbarch_pointer_to_address (gdbarch,
+					       builtin->builtin_data_ptr, buf);
+
+  addr += (tls_index + 1) * TYPE_LENGTH (builtin->builtin_data_ptr);
+  if (target_read_memory (addr, buf, sizeof buf) != 0)
+    throw_error (TLS_GENERIC_ERROR,
+		 _("Cannot find thread-local variables on this target"));
+
+  addr = gdbarch_pointer_to_address (gdbarch, builtin->builtin_data_ptr, buf);
+  return addr + offset;
+}
+
 /* To be called from GDB_OSABI_FREEBSD handlers. */
 
 void
@@ -1957,4 +2108,6 @@ _initialize_fbsd_tdep (void)
 {
   fbsd_gdbarch_data_handle =
     gdbarch_data_register_post_init (init_fbsd_gdbarch_data);
+  fbsd_pspace_data_handle
+    = register_program_space_data_with_cleanup (NULL, fbsd_pspace_data_cleanup);
 }
diff --git gdb/fbsd-tdep.h gdb/fbsd-tdep.h
index efd7c2c78f..0e29508c9f 100644
--- gdb/fbsd-tdep.h
+++ gdb/fbsd-tdep.h
@@ -60,4 +60,15 @@ extern void fbsd_info_proc_mappings_entry (int addr_bit, ULONGEST kve_start,
 					   int kve_flags, int kve_protection,
 					   const void *kve_path);
 
+/* Helper function to fetch the address of a thread-local variable.
+   DTV_ADDR is the base address of the thread's dtv array.  LM_ADDR is
+   the address of the link_map structure for the associated object
+   file.  OFFSET is the offset of the variable in the object file's
+   thread-local variable block.  */
+
+extern CORE_ADDR fbsd_get_thread_local_address (struct gdbarch *gdbarch,
+						CORE_ADDR dtv_addr,
+						CORE_ADDR lm_addr,
+						CORE_ADDR offset);
+
 #endif /* fbsd-tdep.h */


[FILE:2257:patches/patch-07-commit-f5424cfa7e]
commit f5424cfa7e9337a6cb02a1f83c9feea0995c5350
Author: John Baldwin <jhb@FreeBSD.org>
Date:   Tue Mar 12 13:39:02 2019 -0700

    Support TLS variables on FreeBSD/amd64.
    
    Use the fs_base register to fetch the address of a thread's tcb and
    calculate the address of the DTV array.  This value is then passed to
    fbsd_get_thread_local_address to compute the final variable address.
    
    Note that fs_base is currently only available via the native target as
    core dumps on FreeBSD do not store the value of fs_base.
    
    gdb/ChangeLog:
    
            * amd64-fbsd-tdep.c (amd64fbsd_get_thread_local_address): New.
            (amd64fbsd_init_abi): Install gdbarch
            "fetch_tls_load_module_address" and "get_thread_local_address"
            methods.

diff --git gdb/amd64-fbsd-tdep.c gdb/amd64-fbsd-tdep.c
index 403e65022d..7e2e9edf21 100644
--- gdb/amd64-fbsd-tdep.c
+++ gdb/amd64-fbsd-tdep.c
@@ -204,6 +204,26 @@ amd64fbsd_iterate_over_regset_sections (struct gdbarch *gdbarch,
       &amd64fbsd_xstateregset, "XSAVE extended state", cb_data);
 }
 
+/* Implement the get_thread_local_address gdbarch method.  */
+
+static CORE_ADDR
+amd64fbsd_get_thread_local_address (struct gdbarch *gdbarch, ptid_t ptid,
+				    CORE_ADDR lm_addr, CORE_ADDR offset)
+{
+  struct regcache *regcache;
+
+  regcache = get_thread_arch_regcache (ptid, gdbarch);
+
+  target_fetch_registers (regcache, AMD64_FSBASE_REGNUM);
+
+  ULONGEST fsbase;
+  if (regcache->cooked_read (AMD64_FSBASE_REGNUM, &fsbase) != REG_VALID)
+    error (_("Unable to fetch %%fsbase"));
+
+  CORE_ADDR dtv_addr = fsbase + gdbarch_ptr_bit (gdbarch) / 8;
+  return fbsd_get_thread_local_address (gdbarch, dtv_addr, lm_addr, offset);
+}
+
 static void
 amd64fbsd_init_abi (struct gdbarch_info info, struct gdbarch *gdbarch)
 {
@@ -241,6 +261,11 @@ amd64fbsd_init_abi (struct gdbarch_info info, struct gdbarch *gdbarch)
   /* FreeBSD uses SVR4-style shared libraries.  */
   set_solib_svr4_fetch_link_map_offsets
     (gdbarch, svr4_lp64_fetch_link_map_offsets);
+
+  set_gdbarch_fetch_tls_load_module_address (gdbarch,
+					     svr4_fetch_objfile_link_map);
+  set_gdbarch_get_thread_local_address (gdbarch,
+					amd64fbsd_get_thread_local_address);
 }
 
 void


[FILE:2104:patches/patch-08-commit-ce25aa57a3]
commit ce25aa57a3cdd028be5868423e6e55506ccd1053
Author: John Baldwin <jhb@FreeBSD.org>
Date:   Tue Mar 12 13:39:02 2019 -0700

    Support TLS variables on FreeBSD/i386.
    
    Derive the pointer to the DTV array from the gs_base register.  As
    with FreeBSD/amd64, gs_base is currently only available via the native
    target.
    
    gdb/ChangeLog:
    
            * i386-fbsd-tdep.c (i386fbsd_get_thread_local_address): New.
            (i386fbsd_init_abi): Install gdbarch
            "fetch_tls_load_module_address" and "get_thread_local_address"
            methods.

diff --git gdb/i386-fbsd-tdep.c gdb/i386-fbsd-tdep.c
index ac57e7383d..f274847174 100644
--- gdb/i386-fbsd-tdep.c
+++ gdb/i386-fbsd-tdep.c
@@ -320,6 +320,30 @@ i386fbsd_iterate_over_regset_sections (struct gdbarch *gdbarch,
 	"XSAVE extended state", cb_data);
 }
 
+/* Implement the get_thread_local_address gdbarch method.  */
+
+static CORE_ADDR
+i386fbsd_get_thread_local_address (struct gdbarch *gdbarch, ptid_t ptid,
+				   CORE_ADDR lm_addr, CORE_ADDR offset)
+{
+  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);
+  struct regcache *regcache;
+
+  if (tdep->fsbase_regnum == -1)
+    error (_("Unable to fetch %%gsbase"));
+
+  regcache = get_thread_arch_regcache (ptid, gdbarch);
+
+  target_fetch_registers (regcache, tdep->fsbase_regnum + 1);
+
+  ULONGEST gsbase;
+  if (regcache->cooked_read (tdep->fsbase_regnum + 1, &gsbase) != REG_VALID)
+    error (_("Unable to fetch %%gsbase"));
+
+  CORE_ADDR dtv_addr = gsbase + gdbarch_ptr_bit (gdbarch) / 8;
+  return fbsd_get_thread_local_address (gdbarch, dtv_addr, lm_addr, offset);
+}
+
 static void
 i386fbsd_init_abi (struct gdbarch_info info, struct gdbarch *gdbarch)
 {
@@ -418,6 +442,11 @@ i386fbsd4_init_abi (struct gdbarch_info info, struct gdbarch *gdbarch)
 
   set_gdbarch_core_read_description (gdbarch,
 				     i386fbsd_core_read_description);
+
+  set_gdbarch_fetch_tls_load_module_address (gdbarch,
+					     svr4_fetch_objfile_link_map);
+  set_gdbarch_get_thread_local_address (gdbarch,
+					i386fbsd_get_thread_local_address);
 }
 
 void


[FILE:2168:patches/patch-09-commit-8399425f5f]
commit 8399425f5f472ad8e630bb30ad2dbefeddbb68b7
Author: John Baldwin <jhb@FreeBSD.org>
Date:   Tue Mar 12 13:39:02 2019 -0700

    Support TLS variables on FreeBSD/powerpc.
    
    Derive the pointer to the DTV array from the %r2 register on 32-bit
    powerpc and %r13 on 64-bit powerpc.
    
    gdb/ChangeLog:
    
            * ppc-fbsd-tdep.c (ppcfbsd_get_thread_local_address): New.
            (ppcfbsd_init_abi): Install gdbarch
            "fetch_tls_load_module_address" and "get_thread_local_address"
            methods.

diff --git gdb/ppc-fbsd-tdep.c gdb/ppc-fbsd-tdep.c
index c21a52c898..290bd1fd88 100644
--- gdb/ppc-fbsd-tdep.c
+++ gdb/ppc-fbsd-tdep.c
@@ -279,6 +279,39 @@ ppcfbsd_return_value (struct gdbarch *gdbarch, struct value *function,
 					   regcache, readbuf, writebuf);
 }
 
+/* Implement the "get_thread_local_address" gdbarch method.  */
+
+static CORE_ADDR
+ppcfbsd_get_thread_local_address (struct gdbarch *gdbarch, ptid_t ptid,
+				  CORE_ADDR lm_addr, CORE_ADDR offset)
+{
+  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);
+  struct regcache *regcache;
+  int tp_offset, tp_regnum;
+
+  regcache = get_thread_arch_regcache (ptid, gdbarch);
+
+  if (tdep->wordsize == 4)
+    {
+      tp_offset = 0x7008;
+      tp_regnum = PPC_R0_REGNUM + 2;
+    }
+  else
+    {
+      tp_offset = 0x7010;
+      tp_regnum = PPC_R0_REGNUM + 13;
+    }
+  target_fetch_registers (regcache, tp_regnum);
+
+  ULONGEST tp;
+  if (regcache->cooked_read (tp_regnum, &tp) != REG_VALID)
+    error (_("Unable to fetch tcb pointer"));
+
+  /* tp points to the end of the TCB block.  The first member of the
+     TCB is the pointer to the DTV array.  */
+  CORE_ADDR dtv_addr = tp - tp_offset;
+  return fbsd_get_thread_local_address (gdbarch, dtv_addr, lm_addr, offset);
+}
 
 static void
 ppcfbsd_init_abi (struct gdbarch_info info, struct gdbarch *gdbarch)
@@ -322,6 +355,8 @@ ppcfbsd_init_abi (struct gdbarch_info info, struct gdbarch *gdbarch)
 
   set_gdbarch_fetch_tls_load_module_address (gdbarch,
 					     svr4_fetch_objfile_link_map);
+  set_gdbarch_get_thread_local_address (gdbarch,
+					ppcfbsd_get_thread_local_address);
 }
 
 void


[FILE:1048:patches/patch-gdb-amd64-bsd-nat.c]
--- gdb/amd64-bsd-nat.c.orig	2019-05-11 18:19:02 UTC
+++ gdb/amd64-bsd-nat.c
@@ -28,6 +28,7 @@
 #include <sys/types.h>
 #include <sys/ptrace.h>
 #include <machine/reg.h>
+#include <machine/psl.h>
 
 #include "amd64-tdep.h"
 #include "amd64-nat.h"
@@ -120,12 +121,19 @@ amd64bsd_store_inferior_registers (struc
   if (regnum == -1 || amd64_native_gregset_supplies_p (gdbarch, regnum))
     {
       struct reg regs;
+      register_t old_rflags;
 
       if (ptrace (PT_GETREGS, pid, (PTRACE_TYPE_ARG3) &regs, 0) == -1)
         perror_with_name (_("Couldn't get registers"));
 
+      old_rflags = regs.r_rflags;
       amd64_collect_native_gregset (regcache, &regs, regnum);
 
+      /* This is a workaround about the PSL_USERCHANGE posix limitation.  */
+      if ((regs.r_rflags ^ old_rflags ) & ~PSL_USERCHANGE)
+        {
+          regs.r_rflags ^= (regs.r_rflags ^ old_rflags ) & ~PSL_USERCHANGE;
+        }
       if (ptrace (PT_SETREGS, pid, (PTRACE_TYPE_ARG3) &regs, 0) == -1)
         perror_with_name (_("Couldn't write registers"));
 


[FILE:923:patches/patch-gdb-gdb_wchar.h]
diff --git gdb/gdb_wchar.h gdb/gdb_wchar.h
index 868fe04..1311080 100644
--- gdb/gdb_wchar.h.orig	2019-02-27 04:51:50 UTC
+++ gdb/gdb_wchar.h
@@ -59,7 +59,7 @@
    iconvlist.  */
 #if defined (HAVE_ICONV) && defined (HAVE_BTOWC) \
   && (defined (__STDC_ISO_10646__) \
-      || (defined (_LIBICONV_VERSION) && _LIBICONV_VERSION >= 0x108))
+      || (!defined (LIBICONV_PLUG) && defined (_LIBICONV_VERSION) && _LIBICONV_VERSION >= 0x108))
 
 typedef wchar_t gdb_wchar_t;
 typedef wint_t gdb_wint_t;
@@ -82,7 +82,7 @@ typedef wint_t gdb_wint_t;
 #define INTERMEDIATE_ENCODING intermediate_encoding ()
 const char *intermediate_encoding (void);
 
-#elif defined (_LIBICONV_VERSION) && _LIBICONV_VERSION >= 0x108
+#elif !defined (LIBICONV_PLUG) && defined (_LIBICONV_VERSION) && _LIBICONV_VERSION >= 0x108
 #define INTERMEDIATE_ENCODING "wchar_t"
 #else
 /* This shouldn't happen, because the earlier #if should have filtered


[FILE:691:patches/patch-gdb-gnulib-import-stddef.in.h]
diff --git gdb/gnulib/import/stddef.in.h gdb/gnulib/import/stddef.in.h
index f4c4a1070d..023ea2064d 100644
--- gdb/gnulib/import/stddef.in.h.orig	2018-12-23 05:49:37 UTC
+++ gdb/gnulib/import/stddef.in.h
@@ -84,7 +84,7 @@
 /* Some platforms lack max_align_t.  The check for _GCC_MAX_ALIGN_T is
    a hack in case the configure-time test was done with g++ even though
    we are currently compiling with gcc.  */
-#if ! (@HAVE_MAX_ALIGN_T@ || defined _GCC_MAX_ALIGN_T)
+#if 0
 /* On the x86, the maximum storage alignment of double, long, etc. is 4,
    but GCC's C11 ABI for x86 says that max_align_t has an alignment of 8,
    and the C11 standard allows this.  Work around this problem by


[FILE:312:patches/patch-gdb_compile_compile-loc2c.c]
--- gdb/compile/compile-loc2c.c.orig	2019-02-27 04:51:50 UTC
+++ gdb/compile/compile-loc2c.c
@@ -657,6 +657,7 @@ do_compile_dwarf_expr_to_c (int indent,
       uint64_t uoffset, reg;
       int64_t offset;
 
+      uoffset = 0;
       print_spaces (indent - 2, stream);
       if (info[op_ptr - base].label)
 	{


[FILE:711:patches/patch-gdb_fbsd-nat.c]
--- gdb/fbsd-nat.c.orig	2019-05-11 18:19:03 UTC
+++ gdb/fbsd-nat.c
@@ -1178,6 +1178,14 @@ fbsd_nat_target::resume (ptid_t ptid, in
       /* If ptid is a specific LWP, suspend all other LWPs in the process.  */
       inferior *inf = find_inferior_ptid (ptid);
 
+#ifndef PT_LWP_EVENTS
+      /* When LWP events are not supported, a new thread might already be
+	 running that has not yet reported an event when GDB wishes to
+	 only run a single thread.  Force an update of the thread list
+	 to ensure that any such threads are suspended before the process
+	 is resumed.  */
+      fbsd_add_threads (ptid.pid ());
+#endif
       for (thread_info *tp : inf->non_exited_threads ())
         {
 	  int request;


[FILE:801:patches/patch-gdb_i386-fbsd-nat.c]
--- gdb/i386-fbsd-nat.c.orig	2019-05-11 18:19:03 UTC
+++ gdb/i386-fbsd-nat.c
@@ -43,8 +43,6 @@ public:
   const struct target_desc *read_description () override;
 #endif
 
-  void resume (ptid_t, int, enum gdb_signal) override;
-
 #if defined(HAVE_PT_GETDBREGS) && defined(USE_SIGTRAP_SIGINFO)
   bool supports_stopped_by_hw_breakpoint () override;
 #endif
@@ -52,6 +50,7 @@ public:
 
 static i386_fbsd_nat_target the_i386_fbsd_nat_target;
 
+#if 0
 /* Resume execution of the inferior process.  If STEP is nonzero,
    single-step it.  If SIGNAL is nonzero, give it that signal.  */
 
@@ -98,6 +97,7 @@ i386_fbsd_nat_target::resume (ptid_t pti
 	      gdb_signal_to_host (signal)) == -1)
     perror_with_name (("ptrace"));
 }
+#endif
 
 
 /* Support for debugging kernel virtual memory images.  */


[FILE:452:patches/patch-gdb_python_python-config.py]
--- gdb/python/python-config.py.orig	2018-09-05 07:27:13 UTC
+++ gdb/python/python-config.py
@@ -59,6 +59,8 @@ for opt in opt_flags:
 
     elif opt in ('--libs', '--ldflags'):
         libs = ['-lpython' + pyver + abiflags]
+        if getvar('LDFLAGS') is not None:
+            libs.extend(getvar('LDFLAGS').split())
         if getvar('LIBS') is not None:
             libs.extend(getvar('LIBS').split())
         if getvar('SYSLIBS') is not None:


[FILE:601:patches/patch-libiberty-basename]
--- include/libiberty.h.orig	2019-02-27 04:51:50 UTC
+++ include/libiberty.h
@@ -109,7 +109,7 @@ extern int countargv (char * const *);
  || defined (__FreeBSD__) || defined (__OpenBSD__) || defined (__NetBSD__) \
  || defined (__CYGWIN__) || defined (__CYGWIN32__) || defined (__MINGW32__) \
  || defined (__DragonFly__) || defined (HAVE_DECL_BASENAME) 
-extern char *basename (const char *) ATTRIBUTE_RETURNS_NONNULL ATTRIBUTE_NONNULL(1);
+#include <libgen.h>
 #else
 /* Do not allow basename to be used if there is no prototype seen.  We
    either need to use the above prototype or have one from


[FILE:505:patches/patch-unified]
--- gdb/gdb.c.orig	2019-02-27 04:51:50 UTC
+++ gdb/gdb.c
@@ -28,6 +28,12 @@ main (int argc, char **argv)
   memset (&args, 0, sizeof args);
   args.argc = argc;
   args.argv = argv;
-  args.interpreter_p = INTERP_CONSOLE;
+  if (strncmp(basename(argv[0]), "insight", 7) == 0) {
+    args.interpreter_p = "insight";
+  } else if (strncmp(basename(argv[0]), "gdbtui", 6) == 0) {
+    args.interpreter_p = INTERP_TUI;
+  } else {
+    args.interpreter_p = INTERP_CONSOLE;
+  }
   return gdb_main (&args);
 }


[FILE:9616:dragonfly/amd64-dfly-nat.c]
/* Native-dependent code for DragonFly/amd64.

   Copyright (C) 2003-2019 Free Software Foundation, Inc.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

#include "defs.h"
#include "inferior.h"
#include "regcache.h"
#include "target.h"
#include "gregset.h"

#include <signal.h>
#include <stddef.h>
#include <sys/types.h>
#include <sys/procfs.h>
#include <sys/ptrace.h>
#include <sys/sysctl.h>
#include <sys/user.h>
#include <machine/reg.h>
#include <machine/segments.h>

#include "dfly-nat.h"
#include "amd64-tdep.h"
#include "amd64-nat.h"
#include "amd64-bsd-nat.h"
#include "x86-nat.h"
#include "common/x86-xstate.h"


class amd64_dfly_nat_target final
  : public amd64_bsd_nat_target<dfly_nat_target>
{
public:
  /* Add some extra features to the common *BSD/amd64 target.  */
  const struct target_desc *read_description () override;

#if defined(HAVE_PT_GETDBREGS) && defined(USE_SIGTRAP_SIGINFO)
  bool supports_stopped_by_hw_breakpoint () override;
#endif
};

static amd64_dfly_nat_target the_amd64_dfly_nat_target;

/* Offset in `struct reg' where MEMBER is stored.  */
#define REG_OFFSET(member) offsetof (struct reg, member)

/* At amd64dfly64_r_reg_offset[REGNUM] you'll find the offset in
   `struct reg' location where the GDB register REGNUM is stored.
   Unsupported registers are marked with `-1'.  */
static int amd64dfly64_r_reg_offset[] =
{
  REG_OFFSET (r_rax),
  REG_OFFSET (r_rbx),
  REG_OFFSET (r_rcx),
  REG_OFFSET (r_rdx),
  REG_OFFSET (r_rsi),
  REG_OFFSET (r_rdi),
  REG_OFFSET (r_rbp),
  REG_OFFSET (r_rsp),
  REG_OFFSET (r_r8),
  REG_OFFSET (r_r9),
  REG_OFFSET (r_r10),
  REG_OFFSET (r_r11),
  REG_OFFSET (r_r12),
  REG_OFFSET (r_r13),
  REG_OFFSET (r_r14),
  REG_OFFSET (r_r15),
  REG_OFFSET (r_rip),
  REG_OFFSET (r_rflags),
  REG_OFFSET (r_cs),
  REG_OFFSET (r_ss),
  -1,
  -1,
  -1,
  -1
};


/* Mapping between the general-purpose registers in DragonFly/amd64
   `struct reg' format and GDB's register cache layout for
   DragonFly/x86.

   Note that most DragonFly/amd64 registers are 64-bit, while the
   DragonFly/x86 registers are all 32-bit, but since we're
   little-endian we get away with that.  */

/* From <machine/reg.h>.  */
static int amd64dfly32_r_reg_offset[I386_NUM_GREGS] =
{
  14 * 8, 13 * 8,		/* %eax, %ecx */
  12 * 8, 11 * 8,		/* %edx, %ebx */
  20 * 8, 10 * 8,		/* %esp, %ebp */
  9 * 8, 8 * 8,			/* %esi, %edi */
  17 * 8, 19 * 8,		/* %eip, %eflags */
  18 * 8, 21 * 8,		/* %cs, %ss */
  -1, -1, -1, -1		/* %ds, %es, %fs, %gs */
};


#ifdef DFLY_PCB_SUPPLY
/* Transfering the registers between GDB, inferiors and core files.  */

/* Fill GDB's register array with the general-purpose register values
   in *GREGSETP.  */

void
supply_gregset (struct regcache *regcache, const gregset_t *gregsetp)
{
  amd64_supply_native_gregset (regcache, gregsetp, -1);
}

/* Fill register REGNUM (if it is a general-purpose register) in
   *GREGSETPS with the value in GDB's register array.  If REGNUM is -1,
   do this for all registers.  */

void
fill_gregset (const struct regcache *regcache, gdb_gregset_t *gregsetp, int regnum)
{
  amd64_collect_native_gregset (regcache, gregsetp, regnum);
}

/* Fill GDB's register array with the floating-point register values
   in *FPREGSETP.  */

void
supply_fpregset (struct regcache *regcache, const fpregset_t *fpregsetp)
{
  amd64_supply_fxsave (regcache, -1, fpregsetp);
}

/* Fill register REGNUM (if it is a floating-point register) in
   *FPREGSETP with the value in GDB's register array.  If REGNUM is -1,
   do this for all registers.  */

void
fill_fpregset (const struct regcache *regcache, gdb_fpregset_t *fpregsetp, int regnum)
{
  amd64_collect_fxsave (regcache, regnum, fpregsetp);
}

/* Support for debugging kernel virtual memory images.  */

#include <sys/types.h>
#include <machine/pcb.h>
#include <osreldate.h>

#include "bsd-kvm.h"

static int
amd64dfly_supply_pcb (struct regcache *regcache, struct pcb *pcb)
{
  /* The following is true for FreeBSD 5.2:

     The pcb contains %rip, %rbx, %rsp, %rbp, %r12, %r13, %r14, %r15,
     %ds, %es, %fs and %gs.  This accounts for all callee-saved
     registers specified by the psABI and then some.  Here %esp
     contains the stack pointer at the point just after the call to
     cpu_switch().  From this information we reconstruct the register
     state as it would like when we just returned from cpu_switch().  */

  /* The stack pointer shouldn't be zero.  */
  if (pcb->pcb_rsp == 0)
    return 0;

  pcb->pcb_rsp += 8;
  regcache->raw_supply (AMD64_RIP_REGNUM, &pcb->pcb_rip);
  regcache->raw_supply (AMD64_RBX_REGNUM, &pcb->pcb_rbx);
  regcache->raw_supply (AMD64_RSP_REGNUM, &pcb->pcb_rsp);
  regcache->raw_supply (AMD64_RBP_REGNUM, &pcb->pcb_rbp);
  regcache->raw_supply (12, &pcb->pcb_r12);
  regcache->raw_supply (13, &pcb->pcb_r13);
  regcache->raw_supply (14, &pcb->pcb_r14);
  regcache->raw_supply (15, &pcb->pcb_r15);

  return 1;
}
#endif /* DFLY_PCB_SUPPLY */


/* Implement the read_description method.  */

const struct target_desc *
amd64_dfly_nat_target::read_description ()
{
#ifdef PT_GETXSTATE_INFO
  static int xsave_probed;
  static uint64_t xcr0;
#endif
  struct reg regs;
  int is64;

  if (ptrace (PT_GETREGS, inferior_ptid.pid (),
	      (PTRACE_TYPE_ARG3) &regs, 0) == -1)
    perror_with_name (_("Couldn't get registers"));
  is64 = (regs.r_cs == GSEL (GUCODE_SEL, SEL_UPL));
#ifdef PT_GETXSTATE_INFO
  if (!xsave_probed)
    {
      struct ptrace_xstate_info info;

      if (ptrace (PT_GETXSTATE_INFO, inferior_ptid.pid (),
		  (PTRACE_TYPE_ARG3) &info, sizeof (info)) == 0)
	{
	  x86bsd_xsave_len = info.xsave_len;
	  xcr0 = info.xsave_mask;
	}
      xsave_probed = 1;
    }

  if (x86bsd_xsave_len != 0)
    {
      if (is64)
	return amd64_target_description (xcr0, true);
      else
	return i386_target_description (xcr0, true);
    }
#endif
  if (is64)
    return amd64_target_description (X86_XSTATE_SSE_MASK, true);
  else
    return i386_target_description (X86_XSTATE_SSE_MASK, true);
}

#if defined(HAVE_PT_GETDBREGS) && defined(USE_SIGTRAP_SIGINFO)
/* Implement the supports_stopped_by_hw_breakpoints method.  */

bool
amd64_dfly_nat_target::supports_stopped_by_hw_breakpoint ()
{
  return true;
}
#endif

void
_initialize_amd64dfly_nat (void)
{
  int offset;

  amd64_native_gregset32_reg_offset = amd64dfly32_r_reg_offset;
  amd64_native_gregset64_reg_offset = amd64dfly64_r_reg_offset;

  add_inf_child_target (&the_amd64_dfly_nat_target);

#ifdef DFLY_PCB_SUPPLY
  /* Support debugging kernel virtual memory images.  */
  bsd_kvm_add_target (amd64dfly_supply_pcb);
#endif

  /* To support the recognition of signal handlers, i386-bsd-tdep.c
     hardcodes some constants.  Inclusion of this file means that we
     are compiling a native debugger, which means that we can use the
     system header files and sysctl(3) to get at the relevant
     information.  */

#define SC_REG_OFFSET amd64dfly_sc_reg_offset

  /* We only check the program counter, stack pointer and frame
     pointer since these members of `struct sigcontext' are essential
     for providing backtraces.  */

#define SC_RIP_OFFSET SC_REG_OFFSET[AMD64_RIP_REGNUM]
#define SC_RSP_OFFSET SC_REG_OFFSET[AMD64_RSP_REGNUM]
#define SC_RBP_OFFSET SC_REG_OFFSET[AMD64_RBP_REGNUM]

  /* Override the default value for the offset of the program counter
     in the sigcontext structure.  */
  offset = offsetof (struct sigcontext, sc_rip);

  if (SC_RIP_OFFSET != offset)
    {
      warning (_("\
offsetof (struct sigcontext, sc_rip) yields %d instead of %d.\n\
Please report this to <bug-gdb@gnu.org>."),
	       offset, SC_RIP_OFFSET);
    }

  SC_RIP_OFFSET = offset;

  /* Likewise for the stack pointer.  */
  offset = offsetof (struct sigcontext, sc_rsp);

  if (SC_RSP_OFFSET != offset)
    {
      warning (_("\
offsetof (struct sigcontext, sc_rsp) yields %d instead of %d.\n\
Please report this to <bug-gdb@gnu.org>."),
	       offset, SC_RSP_OFFSET);
    }

  SC_RSP_OFFSET = offset;

  /* And the frame pointer.  */
  offset = offsetof (struct sigcontext, sc_rbp);

  if (SC_RBP_OFFSET != offset)
    {
      warning (_("\
offsetof (struct sigcontext, sc_rbp) yields %d instead of %d.\n\
Please report this to <bug-gdb@gnu.org>."),
	       offset, SC_RBP_OFFSET);
    }

  SC_RBP_OFFSET = offset;

#ifdef KERN_PROC_SIGTRAMP
  {
    struct kinfo_sigtramp kst = {0};
    size_t len = sizeof (kst);
    int mib[3] = { CTL_KERN, KERN_PROC, KERN_PROC_SIGTRAMP };
    if (sysctl (mib, 3, &kst, &len, NULL, 0) == 0)
      {
        amd64dfly_sigtramp_start_addr = (uintptr_t) kst.ksigtramp_start;
        amd64dfly_sigtramp_end_addr   = (uintptr_t) kst.ksigtramp_end;
      }
  }
#else
  {
    int mib[2];
    long ps_strings;
    size_t len;

    mib[0] = CTL_KERN;
    mib[1] = KERN_PS_STRINGS;
    len = sizeof (ps_strings);
    if (sysctl (mib, 2, &ps_strings, &len, NULL, 0) == 0)
      {
	amd64dfly_sigtramp_start_addr = ps_strings - 32;
	amd64dfly_sigtramp_end_addr = ps_strings;
      }
  }
#endif
}


[FILE:6085:dragonfly/amd64-dfly-tdep.c]
/* Target-dependent code for DragonFly/amd64.

   Copyright (C) 2003-2019 Free Software Foundation, Inc.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

#include "defs.h"
#include "arch-utils.h"
#include "frame.h"
#include "gdbcore.h"
#include "regcache.h"
#include "osabi.h"
#include "regset.h"
#include "common/x86-xstate.h"

#include <string.h>

#include "amd64-tdep.h"
#include "dfly-tdep.h"
#include "solib-svr4.h"

/* Support for signal handlers.  */

#if 0
/* Return whether THIS_FRAME corresponds to a FreeBSD sigtramp
   routine.  */

static const gdb_byte amd64fbsd_sigtramp_code[] =
{
  0x48, 0x8d, 0x7c, 0x24, 0x10, /* lea     SIGF_UC(%rsp),%rdi */
  0x6a, 0x00,			/* pushq   $0 */
  0x48, 0xc7, 0xc0, 0xa1, 0x01, 0x00, 0x00,
				/* movq    $SYS_sigreturn,%rax */
  0x0f, 0x05                    /* syscall */
};

static int
amd64fbsd_sigtramp_p (struct frame_info *this_frame)
{
  CORE_ADDR pc = get_frame_pc (this_frame);
  gdb_byte buf[sizeof amd64fbsd_sigtramp_code];

  if (!safe_frame_unwind_memory (this_frame, pc, buf, sizeof buf))
    return 0;
  if (memcmp (buf, amd64fbsd_sigtramp_code, sizeof amd64fbsd_sigtramp_code)
      != 0)
    return 0;

  return 1;
}
#endif

/* Assuming THIS_FRAME is for a BSD sigtramp routine, return the
   address of the associated sigcontext structure.  */

static CORE_ADDR
amd64dfly_sigcontext_addr (struct frame_info *this_frame)
{
  struct gdbarch *gdbarch = get_frame_arch (this_frame);
  enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);
  CORE_ADDR sp;
  gdb_byte buf[8];

  /* The `struct sigcontext' (which really is an `ucontext_t' on
     DragonFly/amd64) lives at a fixed offset in the signal frame.  See
     <machine/sigframe.h>.  */
  get_frame_register (this_frame, AMD64_RSP_REGNUM, buf);
  sp = extract_unsigned_integer (buf, 8, byte_order);
  return sp + 16;
}

/* Mapping between the general-purpose registers in `struct reg'
   format and GDB's register cache layout.

   Note that some registers are 32-bit, but since we're little-endian
   we get away with that.  */

/* From <machine/reg.h>.  */
static int amd64dfly_r_reg_offset[] =
{
  6 * 8,			/* %rax */
  7 * 8,			/* %rbx */
  3 * 8,			/* %rcx */
  2 * 8,			/* %rdx */
  1 * 8,			/* %rsi */
  0 * 8,			/* %rdi */
  8 * 8,			/* %rbp */
  23 * 8,			/* %rsp */
  4 * 8,			/* %r8 ... */
  5 * 8,
  9 * 8,
  10 * 8,
  11 * 8,
  12 * 8,
  13 * 8,
  14 * 8,			/* ... %r15 */
  20 * 8,			/* %rip */
  22 * 8,			/* %eflags */
  21 * 8,			/* %cs */
  24 * 8,			/* %ss */
  -1,				/* %ds */
  -1,				/* %es */
  -1,				/* %fs */
  -1				/* %gs */
};

/* Location of the signal trampoline.  */
CORE_ADDR amd64dfly_sigtramp_start_addr = 0x7fffffffffc0ULL;
CORE_ADDR amd64dfly_sigtramp_end_addr = 0x7fffffffffe0ULL;

/* From <machine/signal.h>.  */
int amd64dfly_sc_reg_offset[] =
{
  24 + 6 * 8,			/* %rax */
  24 + 7 * 8,			/* %rbx */
  24 + 3 * 8,			/* %rcx */
  24 + 2 * 8,			/* %rdx */
  24 + 1 * 8,			/* %rsi */
  24 + 0 * 8,			/* %rdi */
  24 + 8 * 8,			/* %rbp */
  24 + 23 * 8,			/* %rsp */
  24 + 4 * 8,			/* %r8 ... */
  24 + 5 * 8,
  24 + 9 * 8,
  24 + 10 * 8,
  24 + 11 * 8,
  24 + 12 * 8,
  24 + 13 * 8,
  24 + 14 * 8,			/* ... %r15 */
  24 + 20 * 8,			/* %rip */
  24 + 22 * 8,			/* %eflags */
  24 + 21 * 8,			/* %cs */
  24 + 24 * 8,			/* %ss */
  -1,				/* %ds */
  -1,				/* %es */
  -1,				/* %fs */
  -1				/* %gs */
};

/* From /usr/src/lib/libc/amd64/gen/_setjmp.S.  */
static int amd64dfly_jmp_buf_reg_offset[] =
{
  -1,				/* %rax */
  1 * 8,			/* %rbx */
  -1,				/* %rcx */
  -1,				/* %rdx */
  -1,				/* %rsi */
  -1,				/* %rdi */
  3 * 8,			/* %rbp */
  2 * 8,			/* %rsp */
  -1,				/* %r8 ... */
  -1,
  -1,
  -1,				/* ... %r11 */
  4 * 8,			/* %r12 ... */
  5 * 8,
  6 * 8,
  7 * 8,			/* ... %r15 */
  0 * 8				/* %rip */
};

static void
amd64dfly_init_abi (struct gdbarch_info info, struct gdbarch *gdbarch)
{
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);

  /* Generic DragonFly support. */
  dfly_init_abi (info, gdbarch);

  /* Obviously DragonFly is BSD-based.  */
  i386bsd_init_abi (info, gdbarch);

  tdep->gregset_reg_offset = amd64dfly_r_reg_offset;
  tdep->gregset_num_regs = ARRAY_SIZE (amd64dfly_r_reg_offset);
  tdep->sizeof_gregset = 25 * 8;

  amd64_init_abi (info, gdbarch,
		  amd64_target_description (X86_XSTATE_SSE_MASK, true));

#if 0
  tdep->sigtramp_p = amd64dfly_sigtramp_p;
#endif
  tdep->sigtramp_start = amd64dfly_sigtramp_start_addr;
  tdep->sigtramp_end = amd64dfly_sigtramp_end_addr;
  tdep->sigcontext_addr = amd64dfly_sigcontext_addr;
  tdep->sc_reg_offset = amd64dfly_sc_reg_offset;
  tdep->sc_num_regs = ARRAY_SIZE (amd64dfly_sc_reg_offset);

#if 0
  tdep->xsave_xcr0_offset = I386_DFLY_XSAVE_XCR0_OFFSET;

  /* Iterate over core file register note sections.  */
  set_gdbarch_iterate_over_regset_sections
    (gdbarch, amd64dfly_iterate_over_regset_sections);

  set_gdbarch_core_read_description (gdbarch,
				     amd64dfly_core_read_description);
#endif

  /* FreeBSD uses SVR4-style shared libraries.  */
  set_solib_svr4_fetch_link_map_offsets
    (gdbarch, svr4_lp64_fetch_link_map_offsets);

  set_gdbarch_fetch_tls_load_module_address (gdbarch,
					     svr4_fetch_objfile_link_map);
#if 0
  set_gdbarch_get_thread_local_address (gdbarch,
					amd64fbsd_get_thread_local_address);
#endif
}

void
_initialize_amd64dfly_tdep (void)
{
  gdbarch_register_osabi (bfd_arch_i386, bfd_mach_x86_64,
			  GDB_OSABI_DRAGONFLY, amd64dfly_init_abi);
}


[FILE:4761:dragonfly/dfly-nat.c]
/* Native-dependent code for DragonFly.

   Copyright (C) 2002-2016 Free Software Foundation, Inc.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

#include "defs.h"
#include "common/byte-vector.h"
#include "gdbcore.h"
#include "inferior.h"
#include "regcache.h"
#include "regset.h"
#include "gdbcmd.h"
#include "gdbthread.h"
#include "common/gdb_wait.h"
#include "inf-ptrace.h"
#include <sys/types.h>
#include <sys/procfs.h>
#include <sys/ptrace.h>
#include <sys/signal.h>
#include <sys/sysctl.h>
#include <sys/user.h>
#ifdef HAVE_KINFO_GETVMMAP
#include <libutil.h>
#endif
#include "common/filestuff.h"

#include "elf-bfd.h"
#include "dfly-nat.h"
#include "dfly-tdep.h"

#include <list>

/* Return the name of a file that can be opened to get the symbols for
   the child process identified by PID.  */

char *
dfly_nat_target::pid_to_exec_file (int pid)
{
  ssize_t len;
  static char buf[PATH_MAX];
  char name[PATH_MAX];

#ifdef KERN_PROC_PATHNAME
  size_t buflen;
  int mib[4];

  mib[0] = CTL_KERN;
  mib[1] = KERN_PROC;
  mib[2] = KERN_PROC_PATHNAME;
  mib[3] = pid;
  buflen = sizeof buf;
  if (sysctl (mib, 4, buf, &buflen, NULL, 0) == 0)
    /* The kern.proc.pathname.<pid> sysctl returns a length of zero
       for processes without an associated executable such as kernel
       processes.  */
    return buflen == 0 ? NULL : buf;
#endif

  xsnprintf (name, PATH_MAX, "/proc/%d/exe", pid);
  len = readlink (name, buf, PATH_MAX - 1);
  if (len != -1)
    {
      buf[len] = '\0';
      return buf;
    }

  return NULL;
}

static int
dfly_read_mapping (FILE *mapfile, unsigned long *start, unsigned long *end,
		   char *protection)
{
  /* FreeBSD 5.1-RELEASE uses a 256-byte buffer.  */
  char buf[256];
  int resident, privateresident;
  unsigned long obj;
  int ret = EOF;

  /* As of FreeBSD 5.0-RELEASE, the layout is described in
     /usr/src/sys/fs/procfs/procfs_map.c.  Somewhere in 5.1-CURRENT a
     new column was added to the procfs map.  Therefore we can't use
     fscanf since we need to support older releases too.  */
  if (fgets (buf, sizeof buf, mapfile) != NULL)
    ret = sscanf (buf, "%lx %lx %d %d %lx %s", start, end,
		  &resident, &privateresident, &obj, protection);

  return (ret != 0 && ret != EOF);
}

/* Iterate over all the memory regions in the current inferior,
   calling FUNC for each memory region.  OBFD is passed as the last
   argument to FUNC.  */

int
dfly_nat_target::find_memory_regions (find_memory_region_ftype func,
				      void *obfd)
{
  pid_t pid = inferior_ptid.pid ();
  unsigned long start, end, size;
  char protection[4];
  int read, write, exec;

  std::string mapfilename = string_printf ("/proc/%ld/map", (long) pid);
  gdb_file_up mapfile (fopen (mapfilename.c_str (), "r"));
  if (mapfile == NULL)
    error (_("Couldn't open %s."), mapfilename.c_str ());

  if (info_verbose)
    fprintf_filtered (gdb_stdout, 
		      "Reading memory regions from %s\n", mapfilename.c_str ());

  /* Now iterate until end-of-file.  */
  while (dfly_read_mapping (mapfile.get (), &start, &end, &protection[0]))
    {
      size = end - start;

      read = (strchr (protection, 'r') != 0);
      write = (strchr (protection, 'w') != 0);
      exec = (strchr (protection, 'x') != 0);

      if (info_verbose)
	{
	  fprintf_filtered (gdb_stdout, 
			    "Save segment, %ld bytes at %s (%c%c%c)\n",
			    size, paddress (target_gdbarch (), start),
			    read ? 'r' : '-',
			    write ? 'w' : '-',
			    exec ? 'x' : '-');
	}

      /* Invoke the callback function to create the corefile segment.
	 Pass MODIFIED as true, we do not know the real modification state.  */
      func (start, size, read, write, exec, 1, obfd);
    }

  return 0;
}

#ifdef OLDCODE
void
dfly_nat_add_target (struct target_ops *t)
{
  t->to_pid_to_exec_file = dfly_pid_to_exec_file;
  t->to_find_memory_regions = dfly_find_memory_regions;
  /* XXX: thread vfork support */
  add_target (t);
}
#endif

/* Provide a prototype to silence -Wmissing-prototypes.  */
extern initialize_file_ftype _initialize_dfly_nat;

void
_initialize_dfly_nat (void)
{
/* XXX: todo add_setshow_boolean_cmd() */
}


[FILE:1305:dragonfly/dfly-nat.h]
/* Native-dependent code for DragonFly.

   Copyright (C) 2004-2019 Free Software Foundation, Inc.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

#ifndef DFLY_NAT_H
#define DFLY_NAT_H

#include "inf-ptrace.h"
#include <sys/user.h>

/* A prototype DragonFly target. */

class dfly_nat_target : public inf_ptrace_target
{
public:
  char *pid_to_exec_file (int pid) override;

  int find_memory_regions (find_memory_region_ftype func, void *data) override;

};

#ifdef OLDCODE
/* Register the customized DragonFly target.  This should be used
   instead of calling add_target directly.  */
extern void dfly_nat_add_target (struct target_ops *);
#endif

#endif /* dfly-nat.h */


[FILE:59357:dragonfly/dfly-tdep.c]
/* Target-dependent code for DragonFly, architecture-independent.

   Copyright (C) 2002-2019 Free Software Foundation, Inc.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

#include "defs.h"
#include "auxv.h"
#include "gdbcore.h"
#include "inferior.h"
#include "regcache.h"
#include "regset.h"
#include "gdbthread.h"
#include "objfiles.h"
#include "xml-syscall.h"
#include <sys/socket.h>
#include <arpa/inet.h>

#include "elf-bfd.h"
#include "dfly-tdep.h"

/* This enum is derived from FreeBSD's <sys/signal.h>.  */

enum
  {
    DRAGONFLY_SIGHUP = 1,
    DRAGONFLY_SIGINT = 2,
    DRAGONFLY_SIGQUIT = 3,
    DRAGONFLY_SIGILL = 4,
    DRAGONFLY_SIGTRAP = 5,
    DRAGONFLY_SIGABRT = 6,
    DRAGONFLY_SIGEMT = 7,
    DRAGONFLY_SIGFPE = 8,
    DRAGONFLY_SIGKILL = 9,
    DRAGONFLY_SIGBUS = 10,
    DRAGONFLY_SIGSEGV = 11,
    DRAGONFLY_SIGSYS = 12,
    DRAGONFLY_SIGPIPE = 13,
    DRAGONFLY_SIGALRM = 14,
    DRAGONFLY_SIGTERM = 15,
    DRAGONFLY_SIGURG = 16,
    DRAGONFLY_SIGSTOP = 17,
    DRAGONFLY_SIGTSTP = 18,
    DRAGONFLY_SIGCONT = 19,
    DRAGONFLY_SIGCHLD = 20,
    DRAGONFLY_SIGTTIN = 21,
    DRAGONFLY_SIGTTOU = 22,
    DRAGONFLY_SIGIO = 23,
    DRAGONFLY_SIGXCPU = 24,
    DRAGONFLY_SIGXFSZ = 25,
    DRAGONFLY_SIGVTALRM = 26,
    DRAGONFLY_SIGPROF = 27,
    DRAGONFLY_SIGWINCH = 28,
    DRAGONFLY_SIGINFO = 29,
    DRAGONFLY_SIGUSR1 = 30,
    DRAGONFLY_SIGUSR2 = 31,
    DRAGONFLY_SIGTHR = 32,
    DRAGONFLY_SIGCKPT = 33,
    DRAGONFLY_SIGCKPTEXIT = 34,
  };

#if 0
/* Flags in pl_flags.  */
#define	PL_FLAG_SI	0x20	/* siginfo is valid */

/* Sizes of siginfo_t.	*/
#define	SIZE64_SIGINFO_T	80
#define	SIZE32_SIGINFO_T	64

/* Offsets in data structure used in NT_FREEBSD_PROCSTAT_VMMAP core
   dump notes.  See <sys/user.h> for the definition of struct
   kinfo_vmentry.  This data structure should have the same layout on
   all architectures.

   Note that FreeBSD 7.0 used an older version of this structure
   (struct kinfo_ovmentry), but the NT_FREEBSD_PROCSTAT_VMMAP core
   dump note wasn't introduced until FreeBSD 9.2.  As a result, the
   core dump note has always used the 7.1 and later structure
   format.  */

#define	KVE_STRUCTSIZE		0x0
#define	KVE_START		0x8
#define	KVE_END			0x10
#define	KVE_OFFSET		0x18
#define	KVE_FLAGS		0x2c
#define	KVE_PROTECTION		0x38
#define	KVE_PATH		0x88

/* Flags in the 'kve_protection' field in struct kinfo_vmentry.  These
   match the KVME_PROT_* constants in <sys/user.h>.  */

#define	KINFO_VME_PROT_READ	0x00000001
#define	KINFO_VME_PROT_WRITE	0x00000002
#define	KINFO_VME_PROT_EXEC	0x00000004

/* Flags in the 'kve_flags' field in struct kinfo_vmentry.  These
   match the KVME_FLAG_* constants in <sys/user.h>.  */

#define	KINFO_VME_FLAG_COW		0x00000001
#define	KINFO_VME_FLAG_NEEDS_COPY	0x00000002
#define	KINFO_VME_FLAG_NOCOREDUMP	0x00000004
#define	KINFO_VME_FLAG_SUPER		0x00000008
#define	KINFO_VME_FLAG_GROWS_UP		0x00000010
#define	KINFO_VME_FLAG_GROWS_DOWN	0x00000020

/* Offsets in data structure used in NT_FREEBSD_PROCSTAT_FILES core
   dump notes.  See <sys/user.h> for the definition of struct
   kinfo_file.  This data structure should have the same layout on all
   architectures.

   Note that FreeBSD 7.0 used an older version of this structure
   (struct kinfo_ofile), but the NT_FREEBSD_PROCSTAT_FILES core dump
   note wasn't introduced until FreeBSD 9.2.  As a result, the core
   dump note has always used the 7.1 and later structure format.  */

#define	KF_STRUCTSIZE		0x0
#define	KF_TYPE			0x4
#define	KF_FD			0x8
#define	KF_FLAGS		0x10
#define	KF_OFFSET		0x18
#define	KF_VNODE_TYPE		0x20
#define	KF_SOCK_DOMAIN		0x24
#define	KF_SOCK_TYPE		0x28
#define	KF_SOCK_PROTOCOL	0x2c
#define	KF_SA_LOCAL		0x30
#define	KF_SA_PEER		0xb0
#define	KF_PATH			0x170

/* Constants for the 'kf_type' field in struct kinfo_file.  These
   match the KF_TYPE_* constants in <sys/user.h>.  */

#define	KINFO_FILE_TYPE_VNODE	1
#define	KINFO_FILE_TYPE_SOCKET	2
#define	KINFO_FILE_TYPE_PIPE	3
#define	KINFO_FILE_TYPE_FIFO	4
#define	KINFO_FILE_TYPE_KQUEUE	5
#define	KINFO_FILE_TYPE_CRYPTO	6
#define	KINFO_FILE_TYPE_MQUEUE	7
#define	KINFO_FILE_TYPE_SHM	8
#define	KINFO_FILE_TYPE_SEM	9
#define	KINFO_FILE_TYPE_PTS	10
#define	KINFO_FILE_TYPE_PROCDESC 11

/* Special values for the 'kf_fd' field in struct kinfo_file.  These
   match the KF_FD_TYPE_* constants in <sys/user.h>.  */

#define	KINFO_FILE_FD_TYPE_CWD	-1
#define	KINFO_FILE_FD_TYPE_ROOT	-2
#define	KINFO_FILE_FD_TYPE_JAIL	-3
#define	KINFO_FILE_FD_TYPE_TRACE -4
#define	KINFO_FILE_FD_TYPE_TEXT	-5
#define	KINFO_FILE_FD_TYPE_CTTY	-6

/* Flags in the 'kf_flags' field in struct kinfo_file.  These match
   the KF_FLAG_* constants in <sys/user.h>.  */

#define	KINFO_FILE_FLAG_READ		0x00000001
#define	KINFO_FILE_FLAG_WRITE		0x00000002
#define	KINFO_FILE_FLAG_APPEND		0x00000004
#define	KINFO_FILE_FLAG_ASYNC		0x00000008
#define	KINFO_FILE_FLAG_FSYNC		0x00000010
#define	KINFO_FILE_FLAG_NONBLOCK	0x00000020
#define	KINFO_FILE_FLAG_DIRECT		0x00000040
#define	KINFO_FILE_FLAG_HASLOCK		0x00000080
#define	KINFO_FILE_FLAG_EXEC		0x00004000

/* Constants for the 'kf_vnode_type' field in struct kinfo_file.
   These match the KF_VTYPE_* constants in <sys/user.h>.  */

#define	KINFO_FILE_VTYPE_VREG	1
#define	KINFO_FILE_VTYPE_VDIR	2
#define	KINFO_FILE_VTYPE_VCHR	4
#define	KINFO_FILE_VTYPE_VLNK	5
#define	KINFO_FILE_VTYPE_VSOCK	6
#define	KINFO_FILE_VTYPE_VFIFO	7
#endif

/* Constants for socket address families.  These match AF_* constants
   in <sys/socket.h>.  */

#define	DFLY_AF_UNIX		1
#define	DFLY_AF_INET		2
#define	DFLY_AF_INET6		28

/* Constants for socket types.  These match SOCK_* constants in
   <sys/socket.h>.  */

#define	DFLY_SOCK_STREAM	1
#define	DFLY_SOCK_DGRAM		2
#define	DFLY_SOCK_SEQPACKET	5

/* Constants for IP protocols.  These match IPPROTO_* constants in
   <netinet/in.h>.  */

#define	DFLY_IPPROTO_ICMP	1
#define	DFLY_IPPROTO_TCP	6
#define	DFLY_IPPROTO_UDP	17

/* Socket address structures.  These have the same layout on all
   DragonFly architectures.  In addition, multibyte fields such as IP
   addresses are always stored in network byte order.  */

struct dfly_sockaddr_in
{
  uint8_t sin_len;
  uint8_t sin_family;
  uint8_t sin_port[2];
  uint8_t sin_addr[4];
  char sin_zero[8];
};

struct dfly_sockaddr_in6
{
  uint8_t sin6_len;
  uint8_t sin6_family;
  uint8_t sin6_port[2];
  uint32_t sin6_flowinfo;
  uint8_t sin6_addr[16];
  uint32_t sin6_scope_id;
};

struct dfly_sockaddr_un
{
  uint8_t sun_len;
  uint8_t sun_family;
  char sun_path[104];
};

#if 0
/* Number of 32-bit words in a signal set.  This matches _SIG_WORDS in
   <sys/_sigset.h> and is the same value on all architectures.  */

#define	SIG_WORDS		4

/* Offsets in data structure used in NT_FREEBSD_PROCSTAT_PROC core
   dump notes.  See <sys/user.h> for the definition of struct
   kinfo_proc.  This data structure has different layouts on different
   architectures mostly due to ILP32 vs LP64.  However, FreeBSD/i386
   uses a 32-bit time_t while all other architectures use a 64-bit
   time_t.

   The core dump note actually contains one kinfo_proc structure for
   each thread, but all of the process-wide data can be obtained from
   the first structure.  One result of this note's format is that some
   of the process-wide status available in the native target method
   from the kern.proc.pid.<pid> sysctl such as ki_stat and ki_siglist
   is not available from a core dump.  Instead, the per-thread data
   structures contain the value of these fields for individual
   threads.  */

struct kinfo_proc_layout
{
  /* Offsets of struct kinfo_proc members.  */
  int ki_layout;
  int ki_pid;
  int ki_ppid;
  int ki_pgid;
  int ki_tpgid;
  int ki_sid;
  int ki_tdev_freebsd11;
  int ki_sigignore;
  int ki_sigcatch;
  int ki_uid;
  int ki_ruid;
  int ki_svuid;
  int ki_rgid;
  int ki_svgid;
  int ki_ngroups;
  int ki_groups;
  int ki_size;
  int ki_rssize;
  int ki_tsize;
  int ki_dsize;
  int ki_ssize;
  int ki_start;
  int ki_nice;
  int ki_comm;
  int ki_tdev;
  int ki_rusage;
  int ki_rusage_ch;

  /* Offsets of struct rusage members.  */
  int ru_utime;
  int ru_stime;
  int ru_maxrss;
  int ru_minflt;
  int ru_majflt;
};

const struct kinfo_proc_layout kinfo_proc_layout_64 =
  {
    .ki_layout = 0x4,
    .ki_pid = 0x48,
    .ki_ppid = 0x4c,
    .ki_pgid = 0x50,
    .ki_tpgid = 0x54,
    .ki_sid = 0x58,
    .ki_tdev_freebsd11 = 0x64,
    .ki_sigignore = 0x88,
    .ki_sigcatch = 0x98,
    .ki_uid = 0xa8,
    .ki_ruid = 0xac,
    .ki_svuid = 0xb0,
    .ki_rgid = 0xb4,
    .ki_svgid = 0xb8,
    .ki_ngroups = 0xbc,
    .ki_groups = 0xc0,
    .ki_size = 0x100,
    .ki_rssize = 0x108,
    .ki_tsize = 0x118,
    .ki_dsize = 0x120,
    .ki_ssize = 0x128,
    .ki_start = 0x150,
    .ki_nice = 0x185,
    .ki_comm = 0x1bf,
    .ki_tdev = 0x230,
    .ki_rusage = 0x260,
    .ki_rusage_ch = 0x2f0,

    .ru_utime = 0x0,
    .ru_stime = 0x10,
    .ru_maxrss = 0x20,
    .ru_minflt = 0x40,
    .ru_majflt = 0x48,
  };
#endif

static struct gdbarch_data *dfly_gdbarch_data_handle;

struct dfly_gdbarch_data
  {
    struct type *siginfo_type;
  };

static void *
init_dfly_gdbarch_data (struct gdbarch *gdbarch)
{
  return GDBARCH_OBSTACK_ZALLOC (gdbarch, struct dfly_gdbarch_data);
}

static struct dfly_gdbarch_data *
get_dfly_gdbarch_data (struct gdbarch *gdbarch)
{
  return ((struct dfly_gdbarch_data *)
	  gdbarch_data (gdbarch, dfly_gdbarch_data_handle));
}

/* Per-program-space data for DragonFly architectures.  */
static const struct program_space_data *dfly_pspace_data_handle;

struct dfly_pspace_data
{
  /* Offsets in the runtime linker's 'Obj_Entry' structure.  */
  LONGEST off_linkmap;
  LONGEST off_tlsindex;
  bool rtld_offsets_valid;
};

static struct dfly_pspace_data *
get_dfly_pspace_data (struct program_space *pspace)
{
  struct dfly_pspace_data *data;

  data = ((struct dfly_pspace_data *)
	  program_space_data (pspace, dfly_pspace_data_handle));
  if (data == NULL)
    {
      data = XCNEW (struct dfly_pspace_data);
      set_program_space_data (pspace, dfly_pspace_data_handle, data);
    }

  return data;
}

/* The cleanup callback for DragonFly architecture per-program-space data.  */

static void
dfly_pspace_data_cleanup (struct program_space *pspace, void *data)
{
  xfree (data);
}

/* This is how we want PTIDs from core files to be printed.  */

static const char *
dfly_core_pid_to_str (struct gdbarch *gdbarch, ptid_t ptid)
{
  static char buf[80];

  if (ptid.lwp () != 0)
    {
      xsnprintf (buf, sizeof buf, "LWP %ld", ptid.lwp ());
      return buf;
    }

  return normal_pid_to_str (ptid);
}

/* Extract the name assigned to a thread from a core.  Returns the
   string in a static buffer.  */

#if 0
static const char *
dfly_core_thread_name (struct gdbarch *gdbarch, struct thread_info *thr)
{
  static char buf[80];
  struct bfd_section *section;
  bfd_size_type size;

  if (thr->ptid.lwp () != 0)
    {
      /* FreeBSD includes a NT_FREEBSD_THRMISC note for each thread
	 whose contents are defined by a "struct thrmisc" declared in
	 <sys/procfs.h> on FreeBSD.  The per-thread name is stored as
	 a null-terminated string as the first member of the
	 structure.  Rather than define the full structure here, just
	 extract the null-terminated name from the start of the
	 note.  */
      thread_section_name section_name (".thrmisc", thr->ptid);

      section = bfd_get_section_by_name (core_bfd, section_name.c_str ());
      if (section != NULL && bfd_section_size (core_bfd, section) > 0)
	{
	  /* Truncate the name if it is longer than "buf".  */
	  size = bfd_section_size (core_bfd, section);
	  if (size > sizeof buf - 1)
	    size = sizeof buf - 1;
	  if (bfd_get_section_contents (core_bfd, section, buf, (file_ptr) 0,
					size)
	      && buf[0] != '\0')
	    {
	      buf[size] = '\0';

	      /* Note that each thread will report the process command
		 as its thread name instead of an empty name if a name
		 has not been set explicitly.  Return a NULL name in
		 that case.  */
	      if (strcmp (buf, elf_tdata (core_bfd)->core->program) != 0)
		return buf;
	    }
	}
    }

  return NULL;
}
#endif

/* Implement the "core_xfer_siginfo" gdbarch method.  */

#if 0
static LONGEST
dfly_core_xfer_siginfo (struct gdbarch *gdbarch, gdb_byte *readbuf,
			ULONGEST offset, ULONGEST len)
{
  size_t siginfo_size;

  if (gdbarch_long_bit (gdbarch) == 32)
    siginfo_size = SIZE32_SIGINFO_T;
  else
    siginfo_size = SIZE64_SIGINFO_T;
  if (offset > siginfo_size)
    return -1;

  thread_section_name section_name (".note.freebsdcore.lwpinfo", inferior_ptid);
  asection *section = bfd_get_section_by_name (core_bfd, section_name.c_str ());
  if (section == NULL)
    return -1;

  gdb_byte buf[4];
  if (!bfd_get_section_contents (core_bfd, section, buf,
				 LWPINFO_OFFSET + LWPINFO_PL_FLAGS, 4))
    return -1;

  int pl_flags = extract_signed_integer (buf, 4, gdbarch_byte_order (gdbarch));
  if (!(pl_flags & PL_FLAG_SI))
    return -1;

  if (offset + len > siginfo_size)
    len = siginfo_size - offset;

  ULONGEST siginfo_offset;
  if (gdbarch_long_bit (gdbarch) == 32)
    siginfo_offset = LWPINFO_OFFSET + LWPINFO32_PL_SIGINFO;
  else
    siginfo_offset = LWPINFO_OFFSET + LWPINFO64_PL_SIGINFO;

  if (!bfd_get_section_contents (core_bfd, section, readbuf,
				 siginfo_offset + offset, len))
    return -1;

  return len;
}
#endif

#if 0
static int
find_signalled_thread (struct thread_info *info, void *data)
{
  if (info->suspend.stop_signal != GDB_SIGNAL_0
      && info->ptid.pid () == inferior_ptid.pid ())
    return 1;

  return 0;
}
#endif

/* Structure for passing information from
   dfly_collect_thread_registers via an iterator to
   dfly_collect_regset_section_cb. */

#if 0
struct dfly_collect_regset_section_cb_data
{
  const struct regcache *regcache;
  bfd *obfd;
  char *note_data;
  int *note_size;
  unsigned long lwp;
  enum gdb_signal stop_signal;
  int abort_iteration;
};
#endif

#if 0
static void
dfly_collect_regset_section_cb (const char *sect_name, int supply_size,
				int collect_size, const struct regset *regset,
				const char *human_name, void *cb_data)
{
  char *buf;
  struct dfly_collect_regset_section_cb_data *data
    = (struct dfly_collect_regset_section_cb_data *) cb_data;

  if (data->abort_iteration)
    return;

  gdb_assert (regset->collect_regset);

  buf = (char *) xmalloc (collect_size);
  regset->collect_regset (regset, data->regcache, -1, buf, collect_size);

  /* PRSTATUS still needs to be treated specially.  */
  if (strcmp (sect_name, ".reg") == 0)
    data->note_data = (char *) elfcore_write_prstatus
      (data->obfd, data->note_data, data->note_size, data->lwp,
       gdb_signal_to_host (data->stop_signal), buf);
  else
    data->note_data = (char *) elfcore_write_register_note
      (data->obfd, data->note_data, data->note_size,
       sect_name, buf, collect_size);
  xfree (buf);

  if (data->note_data == NULL)
    data->abort_iteration = 1;
}
#endif

/* Records the thread's register state for the corefile note
   section.  */

#if 0
static char *
dfly_collect_thread_registers (const struct regcache *regcache,
			       ptid_t ptid, bfd *obfd,
			       char *note_data, int *note_size,
			       enum gdb_signal stop_signal)
{
  struct gdbarch *gdbarch = regcache->arch ();
  struct dfly_collect_regset_section_cb_data data;

  data.regcache = regcache;
  data.obfd = obfd;
  data.note_data = note_data;
  data.note_size = note_size;
  data.stop_signal = stop_signal;
  data.abort_iteration = 0;
  data.lwp = ptid.lwp ();

  gdbarch_iterate_over_regset_sections (gdbarch,
					dfly_collect_regset_section_cb,
					&data, regcache);
  return data.note_data;
}
#endif

#if 0
struct dfly_corefile_thread_data
{
  struct gdbarch *gdbarch;
  bfd *obfd;
  char *note_data;
  int *note_size;
  enum gdb_signal stop_signal;
};
#endif

/* Records the thread's register state for the corefile note
   section.  */

#if 0
static void
dfly_corefile_thread (struct thread_info *info,
		      struct dfly_corefile_thread_data *args)
{
  struct regcache *regcache;

  regcache = get_thread_arch_regcache (info->ptid, args->gdbarch);

  target_fetch_registers (regcache, -1);

  args->note_data = dfly_collect_thread_registers
    (regcache, info->ptid, args->obfd, args->note_data,
     args->note_size, args->stop_signal);
}
#endif

/* Return a byte_vector containing the contents of a core dump note
   for the target object of type OBJECT.  If STRUCTSIZE is non-zero,
   the data is prefixed with a 32-bit integer size to match the format
   used in FreeBSD NT_PROCSTAT_* notes.  */

#if 0
static gdb::optional<gdb::byte_vector>
dfly_make_note_desc (enum target_object object, uint32_t structsize)
{
  gdb::optional<gdb::byte_vector> buf =
    target_read_alloc (current_top_target (), object, NULL);
  if (!buf || buf->empty ())
    return {};

  if (structsize == 0)
    return buf;

  gdb::byte_vector desc (sizeof (structsize) + buf->size ());
  memcpy (desc.data (), &structsize, sizeof (structsize));
  memcpy (desc.data () + sizeof (structsize), buf->data (), buf->size ());
  return desc;
}
#endif

/* Create appropriate note sections for a corefile, returning them in
   allocated memory.  */

#if 0
static char *
dfly_make_corefile_notes (struct gdbarch *gdbarch, bfd *obfd, int *note_size)
{
  struct dfly_corefile_thread_data thread_args;
  char *note_data = NULL;
  Elf_Internal_Ehdr *i_ehdrp;
  struct thread_info *curr_thr, *signalled_thr;

  gdb_assert (gdbarch_iterate_over_regset_sections_p (gdbarch));

  if (get_exec_file (0))
    {
      const char *fname = lbasename (get_exec_file (0));
      char *psargs = xstrdup (fname);

      if (get_inferior_args ())
	psargs = reconcat (psargs, psargs, " ", get_inferior_args (),
			   (char *) NULL);

      note_data = elfcore_write_prpsinfo (obfd, note_data, note_size,
					  fname, psargs);
    }

  /* Thread register information.  */
  TRY
    {
      update_thread_list ();
    }
  CATCH (e, RETURN_MASK_ERROR)
    {
      exception_print (gdb_stderr, e);
    }
  END_CATCH

  /* Like the kernel, prefer dumping the signalled thread first.
     "First thread" is what tools use to infer the signalled thread.
     In case there's more than one signalled thread, prefer the
     current thread, if it is signalled.  */
  curr_thr = inferior_thread ();
  if (curr_thr->suspend.stop_signal != GDB_SIGNAL_0)
    signalled_thr = curr_thr;
  else
    {
      signalled_thr = iterate_over_threads (find_signalled_thread, NULL);
      if (signalled_thr == NULL)
	signalled_thr = curr_thr;
    }

  thread_args.gdbarch = gdbarch;
  thread_args.obfd = obfd;
  thread_args.note_data = note_data;
  thread_args.note_size = note_size;
  thread_args.stop_signal = signalled_thr->suspend.stop_signal;

  dfly_corefile_thread (signalled_thr, &thread_args);
  for (thread_info *thr : current_inferior ()->non_exited_threads ())
    {
      if (thr == signalled_thr)
	continue;

      dfly_corefile_thread (thr, &thread_args);
    }

  note_data = thread_args.note_data;

  /* Auxiliary vector.  */
  uint32_t structsize = gdbarch_ptr_bit (gdbarch) / 4; /* Elf_Auxinfo  */
  gdb::optional<gdb::byte_vector> note_desc =
    dfly_make_note_desc (TARGET_OBJECT_AUXV, structsize);
  if (note_desc && !note_desc->empty ())
    {
      note_data = elfcore_write_note (obfd, note_data, note_size, "FreeBSD",
				      NT_FREEBSD_PROCSTAT_AUXV,
				      note_desc->data (), note_desc->size ());
      if (!note_data)
	return NULL;
    }

  /* Virtual memory mappings.  */
  note_desc = dfly_make_note_desc (TARGET_OBJECT_FREEBSD_VMMAP, 0);
  if (note_desc && !note_desc->empty ())
    {
      note_data = elfcore_write_note (obfd, note_data, note_size, "FreeBSD",
				      NT_FREEBSD_PROCSTAT_VMMAP,
				      note_desc->data (), note_desc->size ());
      if (!note_data)
	return NULL;
    }

  note_desc = dfly_make_note_desc (TARGET_OBJECT_FREEBSD_PS_STRINGS, 0);
  if (note_desc && !note_desc->empty ())
    {
      note_data = elfcore_write_note (obfd, note_data, note_size, "FreeBSD",
				      NT_FREEBSD_PROCSTAT_PSSTRINGS,
				      note_desc->data (), note_desc->size ());
      if (!note_data)
	return NULL;
    }

  return note_data;
}
#endif

/* Helper function to generate the file descriptor description for a
   single open file in 'info proc files'.  */

#if 0
static const char *
dfly_file_fd (int kf_fd)
{
  switch (kf_fd)
    {
    case KINFO_FILE_FD_TYPE_CWD:
      return "cwd";
    case KINFO_FILE_FD_TYPE_ROOT:
      return "root";
    case KINFO_FILE_FD_TYPE_JAIL:
      return "jail";
    case KINFO_FILE_FD_TYPE_TRACE:
      return "trace";
    case KINFO_FILE_FD_TYPE_TEXT:
      return "text";
    case KINFO_FILE_FD_TYPE_CTTY:
      return "ctty";
    default:
      return int_string (kf_fd, 10, 1, 0, 0);
    }
}
#endif

/* Helper function to generate the file type for a single open file in
   'info proc files'.  */

#if 0
static const char *
dfly_file_type (int kf_type, int kf_vnode_type)
{
  switch (kf_type)
    {
    case KINFO_FILE_TYPE_VNODE:
      switch (kf_vnode_type)
	{
	case KINFO_FILE_VTYPE_VREG:
	  return "file";
	case KINFO_FILE_VTYPE_VDIR:
	  return "dir";
	case KINFO_FILE_VTYPE_VCHR:
	  return "chr";
	case KINFO_FILE_VTYPE_VLNK:
	  return "link";
	case KINFO_FILE_VTYPE_VSOCK:
	  return "socket";
	case KINFO_FILE_VTYPE_VFIFO:
	  return "fifo";
	default:
	  {
	    char *str = get_print_cell ();

	    xsnprintf (str, PRINT_CELL_SIZE, "vn:%d", kf_vnode_type);
	    return str;
	  }
	}
    case KINFO_FILE_TYPE_SOCKET:
      return "socket";
    case KINFO_FILE_TYPE_PIPE:
      return "pipe";
    case KINFO_FILE_TYPE_FIFO:
      return "fifo";
    case KINFO_FILE_TYPE_KQUEUE:
      return "kqueue";
    case KINFO_FILE_TYPE_CRYPTO:
      return "crypto";
    case KINFO_FILE_TYPE_MQUEUE:
      return "mqueue";
    case KINFO_FILE_TYPE_SHM:
      return "shm";
    case KINFO_FILE_TYPE_SEM:
      return "sem";
    case KINFO_FILE_TYPE_PTS:
      return "pts";
    case KINFO_FILE_TYPE_PROCDESC:
      return "proc";
    default:
      return int_string (kf_type, 10, 1, 0, 0);
    }
}
#endif

/* Helper function to generate the file flags for a single open file in
   'info proc files'.  */

#if 0
static const char *
dfly_file_flags (int kf_flags)
{
  static char file_flags[10];

  file_flags[0] = (kf_flags & KINFO_FILE_FLAG_READ) ? 'r' : '-';
  file_flags[1] = (kf_flags & KINFO_FILE_FLAG_WRITE) ? 'w' : '-';
  file_flags[2] = (kf_flags & KINFO_FILE_FLAG_EXEC) ? 'x' : '-';
  file_flags[3] = (kf_flags & KINFO_FILE_FLAG_APPEND) ? 'a' : '-';
  file_flags[4] = (kf_flags & KINFO_FILE_FLAG_ASYNC) ? 's' : '-';
  file_flags[5] = (kf_flags & KINFO_FILE_FLAG_FSYNC) ? 'f' : '-';
  file_flags[6] = (kf_flags & KINFO_FILE_FLAG_NONBLOCK) ? 'n' : '-';
  file_flags[7] = (kf_flags & KINFO_FILE_FLAG_DIRECT) ? 'd' : '-';
  file_flags[8] = (kf_flags & KINFO_FILE_FLAG_HASLOCK) ? 'l' : '-';
  file_flags[9] = '\0';

  return file_flags;
}
#endif

/* Helper function to generate the name of an IP protocol.  */

static const char *
dfly_ipproto (int protocol)
{
  switch (protocol)
    {
    case DFLY_IPPROTO_ICMP:
      return "icmp";
    case DFLY_IPPROTO_TCP:
      return "tcp";
    case DFLY_IPPROTO_UDP:
      return "udp";
    default:
      {
	char *str = get_print_cell ();

	xsnprintf (str, PRINT_CELL_SIZE, "ip<%d>", protocol);
	return str;
      }
    }
}

/* Helper function to print out an IPv4 socket address.  */

static void
dfly_print_sockaddr_in (const void *sockaddr)
{
  const struct dfly_sockaddr_in *sin =
    reinterpret_cast<const struct dfly_sockaddr_in *> (sockaddr);
  char buf[INET_ADDRSTRLEN];

  if (inet_ntop (AF_INET, sin->sin_addr, buf, sizeof buf) == nullptr)
    error (_("Failed to format IPv4 address"));
  printf_filtered ("%s:%u", buf,
		   (sin->sin_port[0] << 8) | sin->sin_port[1]);
}

/* Helper function to print out an IPv6 socket address.  */

static void
dfly_print_sockaddr_in6 (const void *sockaddr)
{
  const struct dfly_sockaddr_in6 *sin6 =
    reinterpret_cast<const struct dfly_sockaddr_in6 *> (sockaddr);
  char buf[INET6_ADDRSTRLEN];

  if (inet_ntop (AF_INET6, sin6->sin6_addr, buf, sizeof buf) == nullptr)
    error (_("Failed to format IPv6 address"));
  printf_filtered ("%s.%u", buf,
		   (sin6->sin6_port[0] << 8) | sin6->sin6_port[1]);
}

/* See dfly-tdep.h.  */

#if 0
void
dfly_info_proc_files_header ()
{
  printf_filtered (_("Open files:\n\n"));
  printf_filtered ("  %6s %6s %10s %9s %s\n",
		   "FD", "Type", "Offset", "Flags  ", "Name");
}
#endif

/* See dfly-tdep.h.  */

#if 0
void
dfly_info_proc_files_entry (int kf_type, int kf_fd, int kf_flags,
			    LONGEST kf_offset, int kf_vnode_type,
			    int kf_sock_domain, int kf_sock_type,
			    int kf_sock_protocol, const void *kf_sa_local,
			    const void *kf_sa_peer, const void *kf_path)
{
  printf_filtered ("  %6s %6s %10s %8s ",
		   dfly_file_fd (kf_fd),
		   dfly_file_type (kf_type, kf_vnode_type),
		   kf_offset > -1 ? hex_string (kf_offset) : "-",
		   dfly_file_flags (kf_flags));
  if (kf_type == KINFO_FILE_TYPE_SOCKET)
    {
      switch (kf_sock_domain)
	{
	case DFLY_AF_UNIX:
	  {
	    switch (kf_sock_type)
	      {
	      case DFLY_SOCK_STREAM:
		printf_filtered ("unix stream:");
		break;
	      case DFLY_SOCK_DGRAM:
		printf_filtered ("unix dgram:");
		break;
	      case DFLY_SOCK_SEQPACKET:
		printf_filtered ("unix seqpacket:");
		break;
	      default:
		printf_filtered ("unix <%d>:", kf_sock_type);
		break;
	      }

	    /* For local sockets, print out the first non-nul path
	       rather than both paths.  */
	    const struct dfly_sockaddr_un *sun
	      = reinterpret_cast<const struct dfly_sockaddr_un *> (kf_sa_local);
	    if (sun->sun_path[0] == 0)
	      sun = reinterpret_cast<const struct dfly_sockaddr_un *>
		(kf_sa_peer);
	    printf_filtered ("%s", sun->sun_path);
	    break;
	  }
	case DFLY_AF_INET:
	  printf_filtered ("%s4 ", dfly_ipproto (kf_sock_protocol));
	  dfly_print_sockaddr_in (kf_sa_local);
	  printf_filtered (" -> ");
	  dfly_print_sockaddr_in (kf_sa_peer);
	  break;
	case DFLY_AF_INET6:
	  printf_filtered ("%s6 ", dfly_ipproto (kf_sock_protocol));
	  dfly_print_sockaddr_in6 (kf_sa_local);
	  printf_filtered (" -> ");
	  dfly_print_sockaddr_in6 (kf_sa_peer);
	  break;
	}
    }
  else
    printf_filtered ("%s", reinterpret_cast<const char *> (kf_path));
  printf_filtered ("\n");
}
#endif

/* Implement "info proc files" for a corefile.  */

#if 0
static void
dfly_core_info_proc_files (struct gdbarch *gdbarch)
{
  asection *section
    = bfd_get_section_by_name (core_bfd, ".note.freebsdcore.files");
  if (section == NULL)
    {
      warning (_("unable to find open files in core file"));
      return;
    }

  size_t note_size = bfd_get_section_size (section);
  if (note_size < 4)
    error (_("malformed core note - too short for header"));

  gdb::def_vector<unsigned char> contents (note_size);
  if (!bfd_get_section_contents (core_bfd, section, contents.data (),
				 0, note_size))
    error (_("could not get core note contents"));

  unsigned char *descdata = contents.data ();
  unsigned char *descend = descdata + note_size;

  /* Skip over the structure size.  */
  descdata += 4;

  dfly_info_proc_files_header ();

  while (descdata + KF_PATH < descend)
    {
      ULONGEST structsize = bfd_get_32 (core_bfd, descdata + KF_STRUCTSIZE);
      if (structsize < KF_PATH)
	error (_("malformed core note - file structure too small"));

      LONGEST type = bfd_get_signed_32 (core_bfd, descdata + KF_TYPE);
      LONGEST fd = bfd_get_signed_32 (core_bfd, descdata + KF_FD);
      LONGEST flags = bfd_get_signed_32 (core_bfd, descdata + KF_FLAGS);
      LONGEST offset = bfd_get_signed_64 (core_bfd, descdata + KF_OFFSET);
      LONGEST vnode_type = bfd_get_signed_32 (core_bfd,
					      descdata + KF_VNODE_TYPE);
      LONGEST sock_domain = bfd_get_signed_32 (core_bfd,
					       descdata + KF_SOCK_DOMAIN);
      LONGEST sock_type = bfd_get_signed_32 (core_bfd, descdata + KF_SOCK_TYPE);
      LONGEST sock_protocol = bfd_get_signed_32 (core_bfd,
						 descdata + KF_SOCK_PROTOCOL);
      dfly_info_proc_files_entry (type, fd, flags, offset, vnode_type,
				  sock_domain, sock_type, sock_protocol,
				  descdata + KF_SA_LOCAL, descdata + KF_SA_PEER,
				  descdata + KF_PATH);

      descdata += structsize;
    }
}
#endif

/* Helper function to generate mappings flags for a single VM map
   entry in 'info proc mappings'.  */

#if 0
static const char *
dfly_vm_map_entry_flags (int kve_flags, int kve_protection)
{
  static char vm_flags[9];

  vm_flags[0] = (kve_protection & KINFO_VME_PROT_READ) ? 'r' : '-';
  vm_flags[1] = (kve_protection & KINFO_VME_PROT_WRITE) ? 'w' : '-';
  vm_flags[2] = (kve_protection & KINFO_VME_PROT_EXEC) ? 'x' : '-';
  vm_flags[3] = ' ';
  vm_flags[4] = (kve_flags & KINFO_VME_FLAG_COW) ? 'C' : '-';
  vm_flags[5] = (kve_flags & KINFO_VME_FLAG_NEEDS_COPY) ? 'N' : '-';
  vm_flags[6] = (kve_flags & KINFO_VME_FLAG_SUPER) ? 'S' : '-';
  vm_flags[7] = (kve_flags & KINFO_VME_FLAG_GROWS_UP) ? 'U'
    : (kve_flags & KINFO_VME_FLAG_GROWS_DOWN) ? 'D' : '-';
  vm_flags[8] = '\0';

  return vm_flags;
}
#endif

/* See dfly-tdep.h.  */

#if 0
void
dfly_info_proc_mappings_header (int addr_bit)
{
  printf_filtered (_("Mapped address spaces:\n\n"));
  if (addr_bit == 64)
    {
      printf_filtered ("  %18s %18s %10s %10s %9s %s\n",
		       "Start Addr",
		       "  End Addr",
		       "      Size", "    Offset", "Flags  ", "File");
    }
  else
    {
      printf_filtered ("\t%10s %10s %10s %10s %9s %s\n",
		       "Start Addr",
		       "  End Addr",
		       "      Size", "    Offset", "Flags  ", "File");
    }
}
#endif

/* See dfly-tdep.h.  */

#if 0
void
dfly_info_proc_mappings_entry (int addr_bit, ULONGEST kve_start,
			       ULONGEST kve_end, ULONGEST kve_offset,
			       int kve_flags, int kve_protection,
			       const void *kve_path)
{
  if (addr_bit == 64)
    {
      printf_filtered ("  %18s %18s %10s %10s %9s %s\n",
		       hex_string (kve_start),
		       hex_string (kve_end),
		       hex_string (kve_end - kve_start),
		       hex_string (kve_offset),
		       dfly_vm_map_entry_flags (kve_flags, kve_protection),
		       reinterpret_cast<const char *> (kve_path));
    }
  else
    {
      printf_filtered ("\t%10s %10s %10s %10s %9s %s\n",
		       hex_string (kve_start),
		       hex_string (kve_end),
		       hex_string (kve_end - kve_start),
		       hex_string (kve_offset),
		       dfly_vm_map_entry_flags (kve_flags, kve_protection),
		       reinterpret_cast<const char *> (kve_path));
    }
}
#endif

/* Implement "info proc mappings" for a corefile.  */

#if 0
static void
dfly_core_info_proc_mappings (struct gdbarch *gdbarch)
{
  asection *section;
  unsigned char *descdata, *descend;
  size_t note_size;

  section = bfd_get_section_by_name (core_bfd, ".note.freebsdcore.vmmap");
  if (section == NULL)
    {
      warning (_("unable to find mappings in core file"));
      return;
    }

  note_size = bfd_get_section_size (section);
  if (note_size < 4)
    error (_("malformed core note - too short for header"));

  gdb::def_vector<unsigned char> contents (note_size);
  if (!bfd_get_section_contents (core_bfd, section, contents.data (),
				 0, note_size))
    error (_("could not get core note contents"));

  descdata = contents.data ();
  descend = descdata + note_size;

  /* Skip over the structure size.  */
  descdata += 4;

  dfly_info_proc_mappings_header (gdbarch_addr_bit (gdbarch));
  while (descdata + KVE_PATH < descend)
    {
      ULONGEST structsize = bfd_get_32 (core_bfd, descdata + KVE_STRUCTSIZE);
      if (structsize < KVE_PATH)
	error (_("malformed core note - vmmap entry too small"));

      ULONGEST start = bfd_get_64 (core_bfd, descdata + KVE_START);
      ULONGEST end = bfd_get_64 (core_bfd, descdata + KVE_END);
      ULONGEST offset = bfd_get_64 (core_bfd, descdata + KVE_OFFSET);
      LONGEST flags = bfd_get_signed_32 (core_bfd, descdata + KVE_FLAGS);
      LONGEST prot = bfd_get_signed_32 (core_bfd, descdata + KVE_PROTECTION);
      dfly_info_proc_mappings_entry (gdbarch_addr_bit (gdbarch), start, end,
				     offset, flags, prot, descdata + KVE_PATH);

      descdata += structsize;
    }
}
#endif

/* Fetch the pathname of a vnode for a single file descriptor from the
   file table core note.  */

#if 0
static gdb::unique_xmalloc_ptr<char>
dfly_core_vnode_path (struct gdbarch *gdbarch, int fd)
{
  asection *section;
  unsigned char *descdata, *descend;
  size_t note_size;

  section = bfd_get_section_by_name (core_bfd, ".note.freebsdcore.files");
  if (section == NULL)
    return nullptr;

  note_size = bfd_get_section_size (section);
  if (note_size < 4)
    error (_("malformed core note - too short for header"));

  gdb::def_vector<unsigned char> contents (note_size);
  if (!bfd_get_section_contents (core_bfd, section, contents.data (),
				 0, note_size))
    error (_("could not get core note contents"));

  descdata = contents.data ();
  descend = descdata + note_size;

  /* Skip over the structure size.  */
  descdata += 4;

  while (descdata + KF_PATH < descend)
    {
      ULONGEST structsize;

      structsize = bfd_get_32 (core_bfd, descdata + KF_STRUCTSIZE);
      if (structsize < KF_PATH)
	error (_("malformed core note - file structure too small"));

      if (bfd_get_32 (core_bfd, descdata + KF_TYPE) == KINFO_FILE_TYPE_VNODE
	  && bfd_get_signed_32 (core_bfd, descdata + KF_FD) == fd)
	{
	  char *path = (char *) descdata + KF_PATH;
	  return gdb::unique_xmalloc_ptr<char> (xstrdup (path));
	}

      descdata += structsize;
    }
  return nullptr;
}
#endif

/* Helper function to read a struct timeval.  */

#if 0
static void
dfly_core_fetch_timeval (struct gdbarch *gdbarch, unsigned char *data,
			 LONGEST &sec, ULONGEST &usec)
{
  if (gdbarch_addr_bit (gdbarch) == 64)
    {
      sec = bfd_get_signed_64 (core_bfd, data);
      usec = bfd_get_64 (core_bfd, data + 8);
    }
  else if (bfd_get_arch (core_bfd) == bfd_arch_i386)
    {
      sec = bfd_get_signed_32 (core_bfd, data);
      usec = bfd_get_32 (core_bfd, data + 4);
    }
  else
    {
      sec = bfd_get_signed_64 (core_bfd, data);
      usec = bfd_get_32 (core_bfd, data + 8);
    }
}
#endif

/* Print out the contents of a signal set.  */

#if 0
static void
dfly_print_sigset (const char *descr, unsigned char *sigset)
{
  printf_filtered ("%s: ", descr);
  for (int i = 0; i < SIG_WORDS; i++)
    printf_filtered ("%08x ",
		     (unsigned int) bfd_get_32 (core_bfd, sigset + i * 4));
  printf_filtered ("\n");
}
#endif

/* Implement "info proc status" for a corefile.  */

#if 0
static void
dfly_core_info_proc_status (struct gdbarch *gdbarch)
{
  const struct kinfo_proc_layout *kp;
  asection *section;
  unsigned char *descdata;
  int addr_bit, long_bit;
  size_t note_size;
  ULONGEST value;
  LONGEST sec;

  section = bfd_get_section_by_name (core_bfd, ".note.freebsdcore.proc");
  if (section == NULL)
    {
      warning (_("unable to find process info in core file"));
      return;
    }

  addr_bit = gdbarch_addr_bit (gdbarch);
  if (addr_bit == 64)
    kp = &kinfo_proc_layout_64;
  else if (bfd_get_arch (core_bfd) == bfd_arch_i386)
    kp = &kinfo_proc_layout_i386;
  else
    kp = &kinfo_proc_layout_32;
  long_bit = gdbarch_long_bit (gdbarch);

  /*
   * Ensure that the note is large enough for all of the fields fetched
   * by this function.  In particular, the note must contain the 32-bit
   * structure size, then it must be long enough to access the last
   * field used (ki_rusage_ch.ru_majflt) which is the size of a long.
   */
  note_size = bfd_get_section_size (section);
  if (note_size < (4 + kp->ki_rusage_ch + kp->ru_majflt
		   + long_bit / TARGET_CHAR_BIT))
    error (_("malformed core note - too short"));

  gdb::def_vector<unsigned char> contents (note_size);
  if (!bfd_get_section_contents (core_bfd, section, contents.data (),
				 0, note_size))
    error (_("could not get core note contents"));

  descdata = contents.data ();

  /* Skip over the structure size.  */
  descdata += 4;

  /* Verify 'ki_layout' is 0.  */
  if (bfd_get_32 (core_bfd, descdata + kp->ki_layout) != 0)
    {
      warning (_("unsupported process information in core file"));
      return;
    }

  printf_filtered ("Name: %.19s\n", descdata + kp->ki_comm);
  printf_filtered ("Process ID: %s\n",
		   pulongest (bfd_get_32 (core_bfd, descdata + kp->ki_pid)));
  printf_filtered ("Parent process: %s\n",
		   pulongest (bfd_get_32 (core_bfd, descdata + kp->ki_ppid)));
  printf_filtered ("Process group: %s\n",
		   pulongest (bfd_get_32 (core_bfd, descdata + kp->ki_pgid)));
  printf_filtered ("Session id: %s\n",
		   pulongest (bfd_get_32 (core_bfd, descdata + kp->ki_sid)));

  /* FreeBSD 12.0 and later store a 64-bit dev_t at 'ki_tdev'.  Older
     kernels store a 32-bit dev_t at 'ki_tdev_freebsd11'.  In older
     kernels the 64-bit 'ki_tdev' field is in a reserved section of
     the structure that is cleared to zero.  Assume that a zero value
     in ki_tdev indicates a core dump from an older kernel and use the
     value in 'ki_tdev_freebsd11' instead.  */
  value = bfd_get_64 (core_bfd, descdata + kp->ki_tdev);
  if (value == 0)
    value = bfd_get_32 (core_bfd, descdata + kp->ki_tdev_freebsd11);
  printf_filtered ("TTY: %s\n", pulongest (value));
  printf_filtered ("TTY owner process group: %s\n",
		   pulongest (bfd_get_32 (core_bfd, descdata + kp->ki_tpgid)));
  printf_filtered ("User IDs (real, effective, saved): %s %s %s\n",
		   pulongest (bfd_get_32 (core_bfd, descdata + kp->ki_ruid)),
		   pulongest (bfd_get_32 (core_bfd, descdata + kp->ki_uid)),
		   pulongest (bfd_get_32 (core_bfd, descdata + kp->ki_svuid)));
  printf_filtered ("Group IDs (real, effective, saved): %s %s %s\n",
		   pulongest (bfd_get_32 (core_bfd, descdata + kp->ki_rgid)),
		   pulongest (bfd_get_32 (core_bfd, descdata + kp->ki_groups)),
		   pulongest (bfd_get_32 (core_bfd, descdata + kp->ki_svgid)));
  printf_filtered ("Groups: ");
  uint16_t ngroups = bfd_get_16 (core_bfd, descdata + kp->ki_ngroups);
  for (int i = 0; i < ngroups; i++)
    printf_filtered ("%s ",
		     pulongest (bfd_get_32 (core_bfd,
					    descdata + kp->ki_groups + i * 4)));
  printf_filtered ("\n");
  value = bfd_get (long_bit, core_bfd,
		   descdata + kp->ki_rusage + kp->ru_minflt);
  printf_filtered ("Minor faults (no memory page): %s\n", pulongest (value));
  value = bfd_get (long_bit, core_bfd,
		   descdata + kp->ki_rusage_ch + kp->ru_minflt);
  printf_filtered ("Minor faults, children: %s\n", pulongest (value));
  value = bfd_get (long_bit, core_bfd,
		   descdata + kp->ki_rusage + kp->ru_majflt);
  printf_filtered ("Major faults (memory page faults): %s\n",
		   pulongest (value));
  value = bfd_get (long_bit, core_bfd,
		   descdata + kp->ki_rusage_ch + kp->ru_majflt);
  printf_filtered ("Major faults, children: %s\n", pulongest (value));
  dfly_core_fetch_timeval (gdbarch,
			   descdata + kp->ki_rusage + kp->ru_utime,
			   sec, value);
  printf_filtered ("utime: %s.%06d\n", plongest (sec), (int) value);
  dfly_core_fetch_timeval (gdbarch,
			   descdata + kp->ki_rusage + kp->ru_stime,
			   sec, value);
  printf_filtered ("stime: %s.%06d\n", plongest (sec), (int) value);
  dfly_core_fetch_timeval (gdbarch,
			   descdata + kp->ki_rusage_ch + kp->ru_utime,
			   sec, value);
  printf_filtered ("utime, children: %s.%06d\n", plongest (sec), (int) value);
  dfly_core_fetch_timeval (gdbarch,
			   descdata + kp->ki_rusage_ch + kp->ru_stime,
			   sec, value);
  printf_filtered ("stime, children: %s.%06d\n", plongest (sec), (int) value);
  printf_filtered ("'nice' value: %d\n",
		   bfd_get_signed_8 (core_bfd, descdata + kp->ki_nice));
  dfly_core_fetch_timeval (gdbarch, descdata + kp->ki_start, sec, value);
  printf_filtered ("Start time: %s.%06d\n", plongest (sec), (int) value);
  printf_filtered ("Virtual memory size: %s kB\n",
		   pulongest (bfd_get (addr_bit, core_bfd,
				       descdata + kp->ki_size) / 1024));
  printf_filtered ("Data size: %s pages\n",
		   pulongest (bfd_get (addr_bit, core_bfd,
				       descdata + kp->ki_dsize)));
  printf_filtered ("Stack size: %s pages\n",
		   pulongest (bfd_get (addr_bit, core_bfd,
				       descdata + kp->ki_ssize)));
  printf_filtered ("Text size: %s pages\n",
		   pulongest (bfd_get (addr_bit, core_bfd,
				       descdata + kp->ki_tsize)));
  printf_filtered ("Resident set size: %s pages\n",
		   pulongest (bfd_get (addr_bit, core_bfd,
				       descdata + kp->ki_rssize)));
  printf_filtered ("Maximum RSS: %s pages\n",
		   pulongest (bfd_get (long_bit, core_bfd,
				       descdata + kp->ki_rusage
				       + kp->ru_maxrss)));
  dfly_print_sigset ("Ignored Signals", descdata + kp->ki_sigignore);
  dfly_print_sigset ("Caught Signals", descdata + kp->ki_sigcatch);
}
#endif

/* Implement the "core_info_proc" gdbarch method.  */

#if 0
static void
dfly_core_info_proc (struct gdbarch *gdbarch, const char *args,
		     enum info_proc_what what)
{
  bool do_cmdline = false;
  bool do_cwd = false;
  bool do_exe = false;
  bool do_files = false;
  bool do_mappings = false;
  bool do_status = false;
  int pid;

  switch (what)
    {
    case IP_MINIMAL:
      do_cmdline = true;
      do_cwd = true;
      do_exe = true;
      break;
    case IP_MAPPINGS:
      do_mappings = true;
      break;
    case IP_STATUS:
    case IP_STAT:
      do_status = true;
      break;
    case IP_CMDLINE:
      do_cmdline = true;
      break;
    case IP_EXE:
      do_exe = true;
      break;
    case IP_CWD:
      do_cwd = true;
      break;
    case IP_FILES:
      do_files = true;
      break;
    case IP_ALL:
      do_cmdline = true;
      do_cwd = true;
      do_exe = true;
      do_files = true;
      do_mappings = true;
      do_status = true;
      break;
    default:
      return;
    }

  pid = bfd_core_file_pid (core_bfd);
  if (pid != 0)
    printf_filtered (_("process %d\n"), pid);

  if (do_cmdline)
    {
      const char *cmdline;

      cmdline = bfd_core_file_failing_command (core_bfd);
      if (cmdline)
	printf_filtered ("cmdline = '%s'\n", cmdline);
      else
	warning (_("Command line unavailable"));
    }
  if (do_cwd)
    {
      gdb::unique_xmalloc_ptr<char> cwd =
	dfly_core_vnode_path (gdbarch, KINFO_FILE_FD_TYPE_CWD);
      if (cwd)
	printf_filtered ("cwd = '%s'\n", cwd.get ());
      else
	warning (_("unable to read current working directory"));
    }
  if (do_exe)
    {
      gdb::unique_xmalloc_ptr<char> exe =
	dfly_core_vnode_path (gdbarch, KINFO_FILE_FD_TYPE_TEXT);
      if (exe)
	printf_filtered ("exe = '%s'\n", exe.get ());
      else
	warning (_("unable to read executable path name"));
    }
  if (do_files)
    dfly_core_info_proc_files (gdbarch);
  if (do_mappings)
    dfly_core_info_proc_mappings (gdbarch);
  if (do_status)
    dfly_core_info_proc_status (gdbarch);
}
#endif

/* Print descriptions of FreeBSD-specific AUXV entries to FILE.  */

#if 0
static void
dfly_print_auxv_entry (struct gdbarch *gdbarch, struct ui_file *file,
		       CORE_ADDR type, CORE_ADDR val)
{
  const char *name = "???";
  const char *description = "";
  enum auxv_format format = AUXV_FORMAT_HEX;

  switch (type)
    {
    case AT_NULL:
    case AT_IGNORE:
    case AT_EXECFD:
    case AT_PHDR:
    case AT_PHENT:
    case AT_PHNUM:
    case AT_PAGESZ:
    case AT_BASE:
    case AT_FLAGS:
    case AT_ENTRY:
    case AT_NOTELF:
    case AT_UID:
    case AT_EUID:
    case AT_GID:
    case AT_EGID:
      default_print_auxv_entry (gdbarch, file, type, val);
      return;
#define _TAGNAME(tag) #tag
#define TAGNAME(tag) _TAGNAME(AT_##tag)
#define TAG(tag, text, kind) \
      case AT_FREEBSD_##tag: name = TAGNAME(tag); description = text; format = kind; break
      TAG (EXECPATH, _("Executable path"), AUXV_FORMAT_STR);
      TAG (CANARY, _("Canary for SSP"), AUXV_FORMAT_HEX);
      TAG (CANARYLEN, ("Length of the SSP canary"), AUXV_FORMAT_DEC);
      TAG (OSRELDATE, _("OSRELDATE"), AUXV_FORMAT_DEC);
      TAG (NCPUS, _("Number of CPUs"), AUXV_FORMAT_DEC);
      TAG (PAGESIZES, _("Pagesizes"), AUXV_FORMAT_HEX);
      TAG (PAGESIZESLEN, _("Number of pagesizes"), AUXV_FORMAT_DEC);
      TAG (TIMEKEEP, _("Pointer to timehands"), AUXV_FORMAT_HEX);
      TAG (STACKPROT, _("Initial stack protection"), AUXV_FORMAT_HEX);
      TAG (EHDRFLAGS, _("ELF header e_flags"), AUXV_FORMAT_HEX);
      TAG (HWCAP, _("Machine-dependent CPU capability hints"), AUXV_FORMAT_HEX);
      TAG (HWCAP2, _("Extension of AT_HWCAP"), AUXV_FORMAT_HEX);
    }

  fprint_auxv_entry (file, name, description, format, type, val);
}
#endif

/* Implement the "get_siginfo_type" gdbarch method.  */

#if 0
static struct type *
dfly_get_siginfo_type (struct gdbarch *gdbarch)
{
  struct dfly_gdbarch_data *dfly_gdbarch_data;
  struct type *int_type, *int32_type, *uint32_type, *long_type, *void_ptr_type;
  struct type *uid_type, *pid_type;
  struct type *sigval_type, *reason_type;
  struct type *siginfo_type;
  struct type *type;

  dfly_gdbarch_data = get_dfly_gdbarch_data (gdbarch);
  if (dfly_gdbarch_data->siginfo_type != NULL)
    return dfly_gdbarch_data->siginfo_type;

  int_type = arch_integer_type (gdbarch, gdbarch_int_bit (gdbarch),
				0, "int");
  int32_type = arch_integer_type (gdbarch, 32, 0, "int32_t");
  uint32_type = arch_integer_type (gdbarch, 32, 1, "uint32_t");
  long_type = arch_integer_type (gdbarch, gdbarch_long_bit (gdbarch),
				 0, "long");
  void_ptr_type = lookup_pointer_type (builtin_type (gdbarch)->builtin_void);

  /* union sigval */
  sigval_type = arch_composite_type (gdbarch, NULL, TYPE_CODE_UNION);
  TYPE_NAME (sigval_type) = xstrdup ("sigval");
  append_composite_type_field (sigval_type, "sival_int", int_type);
  append_composite_type_field (sigval_type, "sival_ptr", void_ptr_type);

  /* __pid_t */
  pid_type = arch_type (gdbarch, TYPE_CODE_TYPEDEF,
			TYPE_LENGTH (int32_type) * TARGET_CHAR_BIT, "__pid_t");
  TYPE_TARGET_TYPE (pid_type) = int32_type;
  TYPE_TARGET_STUB (pid_type) = 1;

  /* __uid_t */
  uid_type = arch_type (gdbarch, TYPE_CODE_TYPEDEF,
			TYPE_LENGTH (uint32_type) * TARGET_CHAR_BIT,
			"__uid_t");
  TYPE_TARGET_TYPE (uid_type) = uint32_type;
  TYPE_TARGET_STUB (uid_type) = 1;

  /* _reason */
  reason_type = arch_composite_type (gdbarch, NULL, TYPE_CODE_UNION);

  /* _fault */
  type = arch_composite_type (gdbarch, NULL, TYPE_CODE_STRUCT);
  append_composite_type_field (type, "si_trapno", int_type);
  append_composite_type_field (reason_type, "_fault", type);

  /* _timer */
  type = arch_composite_type (gdbarch, NULL, TYPE_CODE_STRUCT);
  append_composite_type_field (type, "si_timerid", int_type);
  append_composite_type_field (type, "si_overrun", int_type);
  append_composite_type_field (reason_type, "_timer", type);

  /* _mesgq */
  type = arch_composite_type (gdbarch, NULL, TYPE_CODE_STRUCT);
  append_composite_type_field (type, "si_mqd", int_type);
  append_composite_type_field (reason_type, "_mesgq", type);

  /* _poll */
  type = arch_composite_type (gdbarch, NULL, TYPE_CODE_STRUCT);
  append_composite_type_field (type, "si_band", long_type);
  append_composite_type_field (reason_type, "_poll", type);

  /* __spare__ */
  type = arch_composite_type (gdbarch, NULL, TYPE_CODE_STRUCT);
  append_composite_type_field (type, "__spare1__", long_type);
  append_composite_type_field (type, "__spare2__",
			       init_vector_type (int_type, 7));
  append_composite_type_field (reason_type, "__spare__", type);

  /* struct siginfo */
  siginfo_type = arch_composite_type (gdbarch, NULL, TYPE_CODE_STRUCT);
  TYPE_NAME (siginfo_type) = xstrdup ("siginfo");
  append_composite_type_field (siginfo_type, "si_signo", int_type);
  append_composite_type_field (siginfo_type, "si_errno", int_type);
  append_composite_type_field (siginfo_type, "si_code", int_type);
  append_composite_type_field (siginfo_type, "si_pid", pid_type);
  append_composite_type_field (siginfo_type, "si_uid", uid_type);
  append_composite_type_field (siginfo_type, "si_status", int_type);
  append_composite_type_field (siginfo_type, "si_addr", void_ptr_type);
  append_composite_type_field (siginfo_type, "si_value", sigval_type);
  append_composite_type_field (siginfo_type, "_reason", reason_type);

  dfly_gdbarch_data->siginfo_type = siginfo_type;

  return siginfo_type;
}
#endif

/* Implement the "gdb_signal_from_target" gdbarch method.  */

static enum gdb_signal
dfly_gdb_signal_from_target (struct gdbarch *gdbarch, int signal)
{
  switch (signal)
    {
    case 0:
      return GDB_SIGNAL_0;

    case DRAGONFLY_SIGHUP:
      return GDB_SIGNAL_HUP;

    case DRAGONFLY_SIGINT:
      return GDB_SIGNAL_INT;

    case DRAGONFLY_SIGQUIT:
      return GDB_SIGNAL_QUIT;

    case DRAGONFLY_SIGILL:
      return GDB_SIGNAL_ILL;

    case DRAGONFLY_SIGTRAP:
      return GDB_SIGNAL_TRAP;

    case DRAGONFLY_SIGABRT:
      return GDB_SIGNAL_ABRT;

    case DRAGONFLY_SIGEMT:
      return GDB_SIGNAL_EMT;

    case DRAGONFLY_SIGFPE:
      return GDB_SIGNAL_FPE;

    case DRAGONFLY_SIGKILL:
      return GDB_SIGNAL_KILL;

    case DRAGONFLY_SIGBUS:
      return GDB_SIGNAL_BUS;

    case DRAGONFLY_SIGSEGV:
      return GDB_SIGNAL_SEGV;

    case DRAGONFLY_SIGSYS:
      return GDB_SIGNAL_SYS;

    case DRAGONFLY_SIGPIPE:
      return GDB_SIGNAL_PIPE;

    case DRAGONFLY_SIGALRM:
      return GDB_SIGNAL_ALRM;

    case DRAGONFLY_SIGTERM:
      return GDB_SIGNAL_TERM;

    case DRAGONFLY_SIGURG:
      return GDB_SIGNAL_URG;

    case DRAGONFLY_SIGSTOP:
      return GDB_SIGNAL_STOP;

    case DRAGONFLY_SIGTSTP:
      return GDB_SIGNAL_TSTP;

    case DRAGONFLY_SIGCONT:
      return GDB_SIGNAL_CONT;

    case DRAGONFLY_SIGCHLD:
      return GDB_SIGNAL_CHLD;

    case DRAGONFLY_SIGTTIN:
      return GDB_SIGNAL_TTIN;

    case DRAGONFLY_SIGTTOU:
      return GDB_SIGNAL_TTOU;

    case DRAGONFLY_SIGIO:
      return GDB_SIGNAL_IO;

    case DRAGONFLY_SIGXCPU:
      return GDB_SIGNAL_XCPU;

    case DRAGONFLY_SIGXFSZ:
      return GDB_SIGNAL_XFSZ;

    case DRAGONFLY_SIGVTALRM:
      return GDB_SIGNAL_VTALRM;

    case DRAGONFLY_SIGPROF:
      return GDB_SIGNAL_PROF;

    case DRAGONFLY_SIGWINCH:
      return GDB_SIGNAL_WINCH;

    case DRAGONFLY_SIGINFO:
      return GDB_SIGNAL_INFO;

    case DRAGONFLY_SIGUSR1:
      return GDB_SIGNAL_USR1;

    case DRAGONFLY_SIGUSR2:
      return GDB_SIGNAL_USR2;

#if 0
    /* SIGTHR is the same as SIGLWP on FreeBSD. */
    case FREEBSD_SIGTHR:
      return GDB_SIGNAL_LWP;

    case FREEBSD_SIGLIBRT:
      return GDB_SIGNAL_LIBRT;
#endif
    }

#if 0
  if (signal >= FREEBSD_SIGRTMIN && signal <= FREEBSD_SIGRTMAX)
    {
      int offset = signal - FREEBSD_SIGRTMIN;

      return (enum gdb_signal) ((int) GDB_SIGNAL_REALTIME_65 + offset);
    }
#endif

  return GDB_SIGNAL_UNKNOWN;
}

/* Implement the "gdb_signal_to_target" gdbarch method.  */

static int
dfly_gdb_signal_to_target (struct gdbarch *gdbarch,
                enum gdb_signal signal)
{
  switch (signal)
    {
    case GDB_SIGNAL_0:
      return 0;

    case GDB_SIGNAL_HUP:
      return DRAGONFLY_SIGHUP;

    case GDB_SIGNAL_INT:
      return DRAGONFLY_SIGINT;

    case GDB_SIGNAL_QUIT:
      return DRAGONFLY_SIGQUIT;

    case GDB_SIGNAL_ILL:
      return DRAGONFLY_SIGILL;

    case GDB_SIGNAL_TRAP:
      return DRAGONFLY_SIGTRAP;

    case GDB_SIGNAL_ABRT:
      return DRAGONFLY_SIGABRT;

    case GDB_SIGNAL_EMT:
      return DRAGONFLY_SIGEMT;

    case GDB_SIGNAL_FPE:
      return DRAGONFLY_SIGFPE;

    case GDB_SIGNAL_KILL:
      return DRAGONFLY_SIGKILL;

    case GDB_SIGNAL_BUS:
      return DRAGONFLY_SIGBUS;

    case GDB_SIGNAL_SEGV:
      return DRAGONFLY_SIGSEGV;

    case GDB_SIGNAL_SYS:
      return DRAGONFLY_SIGSYS;

    case GDB_SIGNAL_PIPE:
      return DRAGONFLY_SIGPIPE;

    case GDB_SIGNAL_ALRM:
      return DRAGONFLY_SIGALRM;

    case GDB_SIGNAL_TERM:
      return DRAGONFLY_SIGTERM;

    case GDB_SIGNAL_URG:
      return DRAGONFLY_SIGURG;

    case GDB_SIGNAL_STOP:
      return DRAGONFLY_SIGSTOP;

    case GDB_SIGNAL_TSTP:
      return DRAGONFLY_SIGTSTP;

    case GDB_SIGNAL_CONT:
      return DRAGONFLY_SIGCONT;

    case GDB_SIGNAL_CHLD:
      return DRAGONFLY_SIGCHLD;

    case GDB_SIGNAL_TTIN:
      return DRAGONFLY_SIGTTIN;

    case GDB_SIGNAL_TTOU:
      return DRAGONFLY_SIGTTOU;

    case GDB_SIGNAL_IO:
      return DRAGONFLY_SIGIO;

    case GDB_SIGNAL_XCPU:
      return DRAGONFLY_SIGXCPU;

    case GDB_SIGNAL_XFSZ:
      return DRAGONFLY_SIGXFSZ;

    case GDB_SIGNAL_VTALRM:
      return DRAGONFLY_SIGVTALRM;

    case GDB_SIGNAL_PROF:
      return DRAGONFLY_SIGPROF;

    case GDB_SIGNAL_WINCH:
      return DRAGONFLY_SIGWINCH;

    case GDB_SIGNAL_INFO:
      return DRAGONFLY_SIGINFO;

    case GDB_SIGNAL_USR1:
      return DRAGONFLY_SIGUSR1;

    case GDB_SIGNAL_USR2:
      return DRAGONFLY_SIGUSR2;

#if 0
    case GDB_SIGNAL_LWP:
      return FREEBSD_SIGTHR;

    case GDB_SIGNAL_LIBRT:
      return FREEBSD_SIGLIBRT;
#endif
    }

#if 0
  if (signal >= GDB_SIGNAL_REALTIME_65
      && signal <= GDB_SIGNAL_REALTIME_126)
    {
      int offset = signal - GDB_SIGNAL_REALTIME_65;

      return FREEBSD_SIGRTMIN + offset;
    }
#endif

  return -1;
}

#if 0
/* Implement the "get_syscall_number" gdbarch method.  */

static LONGEST
dfly_get_syscall_number (struct gdbarch *gdbarch, thread_info *thread)
{

  /* FreeBSD doesn't use gdbarch_get_syscall_number since FreeBSD
     native targets fetch the system call number from the
     'pl_syscall_code' member of struct ptrace_lwpinfo in dfly_wait.
     However, system call catching requires this function to be
     set.  */

  internal_error (__FILE__, __LINE__, _("dfly_get_sycall_number called"));
}
#endif

/* Read an integer symbol value from the current target.  */

#if 0
static LONGEST
dfly_read_integer_by_name (struct gdbarch *gdbarch, const char *name)
{
  bound_minimal_symbol ms = lookup_minimal_symbol (name, NULL, NULL);
  if (ms.minsym == NULL)
    error (_("Unable to resolve symbol '%s'"), name);

  gdb_byte buf[4];
  if (target_read_memory (BMSYMBOL_VALUE_ADDRESS (ms), buf, sizeof buf) != 0)
    error (_("Unable to read value of '%s'"), name);

  return extract_signed_integer (buf, sizeof buf, gdbarch_byte_order (gdbarch));
}
#endif

/* Lookup offsets of fields in the runtime linker's 'Obj_Entry'
   structure needed to determine the TLS index of an object file.  */

#if 0
static void
dfly_fetch_rtld_offsets (struct gdbarch *gdbarch, struct dfly_pspace_data *data)
{
  TRY
    {
      /* Fetch offsets from debug symbols in rtld.  */
      struct symbol *obj_entry_sym
	= lookup_symbol_in_language ("Struct_Obj_Entry", NULL, STRUCT_DOMAIN,
				     language_c, NULL).symbol;
      if (obj_entry_sym == NULL)
	error (_("Unable to find Struct_Obj_Entry symbol"));
      data->off_linkmap = lookup_struct_elt (SYMBOL_TYPE(obj_entry_sym),
					     "linkmap", 0).offset / 8;
      data->off_tlsindex = lookup_struct_elt (SYMBOL_TYPE(obj_entry_sym),
					      "tlsindex", 0).offset / 8;
      data->rtld_offsets_valid = true;
      return;
    }
  CATCH (e, RETURN_MASK_ERROR)
    {
      data->off_linkmap = -1;
    }
  END_CATCH

  TRY
    {
      /* Fetch offsets from global variables in libthr.  Note that
	 this does not work for single-threaded processes that are not
	 linked against libthr.  */
      data->off_linkmap = dfly_read_integer_by_name (gdbarch,
						     "_thread_off_linkmap");
      data->off_tlsindex = dfly_read_integer_by_name (gdbarch,
						      "_thread_off_tlsindex");
      data->rtld_offsets_valid = true;
      return;
    }
  CATCH (e, RETURN_MASK_ERROR)
    {
      data->off_linkmap = -1;
    }
  END_CATCH
}
#endif

/* Helper function to read the TLS index of an object file associated
   with a link map entry at LM_ADDR.  */

#if 0
static LONGEST
dfly_get_tls_index (struct gdbarch *gdbarch, CORE_ADDR lm_addr)
{
  struct dfly_pspace_data *data = get_dfly_pspace_data (current_program_space);

  if (!data->rtld_offsets_valid)
    dfly_fetch_rtld_offsets (gdbarch, data);

  if (data->off_linkmap == -1)
    throw_error (TLS_GENERIC_ERROR,
		 _("Cannot fetch runtime linker structure offsets"));

  /* Simulate container_of to convert from LM_ADDR to the Obj_Entry
     pointer and then compute the offset of the tlsindex member.  */
  CORE_ADDR tlsindex_addr = lm_addr - data->off_linkmap + data->off_tlsindex;

  gdb_byte buf[4];
  if (target_read_memory (tlsindex_addr, buf, sizeof buf) != 0)
    throw_error (TLS_GENERIC_ERROR,
		 _("Cannot find thread-local variables on this target"));

  return extract_signed_integer (buf, sizeof buf, gdbarch_byte_order (gdbarch));
}
#endif

/* See dfly-tdep.h.  */

#if 0
CORE_ADDR
dfly_get_thread_local_address (struct gdbarch *gdbarch, CORE_ADDR dtv_addr,
			       CORE_ADDR lm_addr, CORE_ADDR offset)
{
  LONGEST tls_index = dfly_get_tls_index (gdbarch, lm_addr);

  gdb_byte buf[gdbarch_ptr_bit (gdbarch) / TARGET_CHAR_BIT];
  if (target_read_memory (dtv_addr, buf, sizeof buf) != 0)
    throw_error (TLS_GENERIC_ERROR,
		 _("Cannot find thread-local variables on this target"));

  const struct builtin_type *builtin = builtin_type (gdbarch);
  CORE_ADDR addr = gdbarch_pointer_to_address (gdbarch,
					       builtin->builtin_data_ptr, buf);

  addr += (tls_index + 1) * TYPE_LENGTH (builtin->builtin_data_ptr);
  if (target_read_memory (addr, buf, sizeof buf) != 0)
    throw_error (TLS_GENERIC_ERROR,
		 _("Cannot find thread-local variables on this target"));

  addr = gdbarch_pointer_to_address (gdbarch, builtin->builtin_data_ptr, buf);
  return addr + offset;
}
#endif

/* To be called from GDB_OSABI_DRAGONFLY handlers. */

void
dfly_init_abi (struct gdbarch_info info, struct gdbarch *gdbarch)
{
#if 0
  set_gdbarch_core_pid_to_str (gdbarch, dfly_core_pid_to_str);
  set_gdbarch_core_thread_name (gdbarch, dfly_core_thread_name);
  set_gdbarch_core_xfer_siginfo (gdbarch, dfly_core_xfer_siginfo);
  set_gdbarch_make_corefile_notes (gdbarch, dfly_make_corefile_notes);
  set_gdbarch_core_info_proc (gdbarch, dfly_core_info_proc);
  set_gdbarch_print_auxv_entry (gdbarch, dfly_print_auxv_entry);
  set_gdbarch_get_siginfo_type (gdbarch, dfly_get_siginfo_type);
#endif
  set_gdbarch_gdb_signal_from_target (gdbarch, dfly_gdb_signal_from_target);
  set_gdbarch_gdb_signal_to_target (gdbarch, dfly_gdb_signal_to_target);

#if 0
  /* `catch syscall' */
  set_xml_syscall_file_name (gdbarch, "syscalls/dragonfly.xml");
  set_gdbarch_get_syscall_number (gdbarch, dfly_get_syscall_number);
#endif
}

void
_initialize_dfly_tdep (void)
{
  dfly_gdbarch_data_handle =
    gdbarch_data_register_post_init (init_dfly_gdbarch_data);
  dfly_pspace_data_handle
    = register_program_space_data_with_cleanup (NULL, dfly_pspace_data_cleanup);
}


[FILE:2986:dragonfly/dfly-tdep.h]
/* Target-dependent code for DragonFly, architecture independent.

   Copyright (C) 2009-2019 Free Software Foundation, Inc.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

#ifndef DFLY_TDEP_H
#define DFLY_TDEP_H

extern void dfly_init_abi (struct gdbarch_info info, struct gdbarch *gdbarch);

/* Output the header for "info proc files".  */

extern void dfly_info_proc_files_header ();

/* Output description of a single file descriptor for "info proc
   files".  The KF_TYPE, KF_FD, KF_FLAGS, KF_OFFSET, KF_VNODE_TYPE,
   KF_SOCK_DOMAIN, KF_SOCK_TYPE, and KF_SOCK_PROTOCOL parameters
   should contain the value of the corresponding fields in a 'struct
   kinfo_file'.  The KF_SA_LOCAL, KF_SA_PEER, and KF_PATH parameters
   should contain pointers to the corresponding fields in a 'struct
   kinfo_file'. */

extern void dfly_info_proc_files_entry (int kf_type, int kf_fd, int kf_flags,
					LONGEST kf_offset, int kf_vnode_type,
					int kf_sock_domain, int kf_sock_type,
					int kf_sock_protocol,
					const void *kf_sa_local,
					const void *kf_sa_peer,
					const void *kf_path);

/* Output the header for "info proc mappings".  ADDR_BIT is the size
   of a virtual address in bits.  */

extern void dfly_info_proc_mappings_header (int addr_bit);

/* Output description of a single memory range for "info proc
   mappings".  ADDR_BIT is the size of a virtual address in bits.  The
   KVE_START, KVE_END, KVE_OFFSET, KVE_FLAGS, and KVE_PROTECTION
   parameters should contain the value of the corresponding fields in
   a 'struct kinfo_vmentry'.  The KVE_PATH parameter should contain a
   pointer to the 'kve_path' field in a 'struct kinfo_vmentry'. */

extern void dfly_info_proc_mappings_entry (int addr_bit, ULONGEST kve_start,
					   ULONGEST kve_end,
					   ULONGEST kve_offset,
					   int kve_flags, int kve_protection,
					   const void *kve_path);

/* Helper function to fetch the address of a thread-local variable.
   DTV_ADDR is the base address of the thread's dtv array.  LM_ADDR is
   the address of the link_map structure for the associated object
   file.  OFFSET is the offset of the variable in the object file's
   thread-local variable block.  */

extern CORE_ADDR dfly_get_thread_local_address (struct gdbarch *gdbarch,
						CORE_ADDR dtv_addr,
						CORE_ADDR lm_addr,
						CORE_ADDR offset);

#endif /* dfly-tdep.h */


[FILE:2542:dragonfly/i386-dfly-tdep.c]
/* Target-dependent code for DragonFly/i386.

   Copyright (C) 2003-2013 Free Software Foundation, Inc.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

#include "defs.h"
#include "arch-utils.h"
#include "gdbcore.h"
#include "osabi.h"
#include "regcache.h"
#include "regset.h"
#include "common/x86-xstate.h"

#include "i386-tdep.h"
#include "i387-tdep.h"
#include "dfly-tdep.h"
#include "solib-svr4.h"

static int i386dfly_r_reg_offset[] =
{
  44, /* %eax */
  40, /* %ecx */
  36, /* %edx */
  32, /* %ebx */
  72, /* %esp */
  24, /* %ebp */
  20, /* %esi */
  16, /* %edi */
  60, /* %eip */
  68, /* %eflags */
  64, /* %cs */
  76, /* %ss */
  12, /* %ds */
  8, /* %es */
  4, /* %fs */
  0  /* %gs */
};

/* Sigtramp routine location.  */
CORE_ADDR i386dfly_sigtramp_start_addr = 0xbfbfdf20;
CORE_ADDR i386dfly_sigtramp_end_addr = 0xbfbfdff0;

int i386dfly_sc_reg_offset[] =
{
  64, /* %eax */
  60, /* %ecx */
  56, /* %edx */
  52, /* %ebx */
  92, /* %esp */
  44, /* %ebp */
  40, /* %esi */
  36, /* %edi */
  80, /* %eip */
  88, /* %eflags */
  84, /* %cs */
  96, /* %ss */
  32, /* %ds */
  28, /* %es */
  24, /* %fs */
  20  /* %gs */
};

static void
i386dfly_init_abi (struct gdbarch_info info, struct gdbarch *gdbarch)
{
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);

  i386_elf_init_abi(info, gdbarch);

  tdep->gregset_reg_offset = i386dfly_r_reg_offset;
  tdep->gregset_num_regs = ARRAY_SIZE (i386dfly_r_reg_offset);
  tdep->sizeof_gregset = 80;

  tdep->sc_reg_offset = i386dfly_sc_reg_offset;
  tdep->sc_num_regs = ARRAY_SIZE (i386dfly_sc_reg_offset);

  set_solib_svr4_fetch_link_map_offsets
    (gdbarch, svr4_ilp32_fetch_link_map_offsets);
}


/* Provide a prototype to silence -Wmissing-prototypes.  */
void _initialize_i386dfly_tdep (void);

void
_initialize_i386dfly_tdep (void)
{
  gdbarch_register_osabi (bfd_arch_i386, 0, GDB_OSABI_DRAGONFLY,
			  i386dfly_init_abi);
}


[FILE:420:dragonfly/patch-bfd_config.bfd]
--- bfd/config.bfd.orig	2019-05-11 18:19:02 UTC
+++ bfd/config.bfd
@@ -679,7 +679,7 @@ case "${targ}" in
     ;;
   x86_64-*-dragonfly*)
     targ_defvec=x86_64_elf64_vec
-    targ_selvecs="i386_elf32_vec iamcu_elf32_vec l1om_elf64_vec k1om_elf64_vec"
+    targ_selvecs="i386_elf32_vec iamcu_elf32_vec l1om_elf64_vec k1om_elf64_vec x86_64_pei_vec"
     want64=true
     ;;
   x86_64-*-freebsd* | x86_64-*-kfreebsd*-gnu)


[FILE:788:dragonfly/patch-gdb_Makefile.in]
--- gdb/Makefile.in.orig	2019-05-11 18:19:02 UTC
+++ gdb/Makefile.in
@@ -645,6 +645,7 @@ ALL_64_TARGET_OBS = \
 	alpha-tdep.o \
 	amd64-darwin-tdep.o \
 	amd64-dicos-tdep.o \
+	amd64-dfly-tdep.o \
 	amd64-fbsd-tdep.o \
 	amd64-linux-tdep.o \
 	amd64-nbsd-tdep.o \
@@ -693,6 +694,7 @@ ALL_TARGET_OBS = \
 	csky-linux-tdep.o \
 	csky-tdep.o \
 	dicos-tdep.o \
+	dfly-tdep.o \
 	fbsd-tdep.o \
 	frv-linux-tdep.o \
 	frv-tdep.o \
@@ -708,6 +710,7 @@ ALL_TARGET_OBS = \
 	i386-cygwin-tdep.o \
 	i386-darwin-tdep.o \
 	i386-dicos-tdep.o \
+	i386-dfly-tdep.o \
 	i386-fbsd-tdep.o \
 	i386-gnu-tdep.o \
 	i386-go32-tdep.o \
@@ -1247,6 +1250,8 @@ HFILES_NO_SRCDIR = \
 	extension.h \
 	extension-priv.h \
 	f-lang.h \
+	dfly-nat.h \
+	dfly-tdep.h \
 	fbsd-nat.h \
 	fbsd-tdep.h \
 	filesystem.h \


[FILE:518:dragonfly/patch-gdb_amd64-tdep.h]
--- gdb/amd64-tdep.h.orig	2018-09-05 07:27:13 UTC
+++ gdb/amd64-tdep.h
@@ -145,8 +145,8 @@ extern int amd64nbsd_r_reg_offset[];
 extern int amd64obsd_r_reg_offset[];
 
 /* Variables exported from amd64-fbsd-tdep.c.  */
-extern CORE_ADDR amd64fbsd_sigtramp_start_addr;
-extern CORE_ADDR amd64fbsd_sigtramp_end_addr;
-extern int amd64fbsd_sc_reg_offset[];
+extern CORE_ADDR amd64dfly_sigtramp_start_addr;
+extern CORE_ADDR amd64dfly_sigtramp_end_addr;
+extern int amd64dfly_sc_reg_offset[];
 
 #endif /* amd64-tdep.h */


[FILE:644:dragonfly/patch-gdb_bsd-kvm.c]
--- gdb/bsd-kvm.c.orig	2019-05-11 18:19:02 UTC
+++ gdb/bsd-kvm.c
@@ -38,10 +38,10 @@
 #include <paths.h>
 #include "readline/readline.h"
 #include <sys/param.h>
-#include <sys/proc.h>
 #ifdef HAVE_SYS_USER_H
 #include <sys/user.h>
 #endif
+#include <sys/proc.h>
 
 #include "bsd-kvm.h"
 
@@ -330,8 +330,10 @@ bsd_kvm_proc_cmd (const char *arg, int f
 #ifdef HAVE_STRUCT_LWP
   addr += offsetof (struct lwp, l_addr);
 #else
+#ifndef __DragonFly__  /* XXX FIXME */
   addr += offsetof (struct proc, p_addr);
 #endif
+#endif
 
   if (kvm_read (core_kd, addr, &bsd_kvm_paddr, sizeof bsd_kvm_paddr) == -1)
     error (("%s"), kvm_geterr (core_kd));


[FILE:361:dragonfly/patch-gdb_configure.host]
--- gdb/configure.host.orig	2018-09-05 07:44:28 UTC
+++ gdb/configure.host
@@ -176,6 +176,7 @@ vax-*-netbsdelf* | vax-*-knetbsd*-gnu)
 vax-*-openbsd*)		gdb_host=obsd ;;
 
 x86_64-*-linux*)	gdb_host=linux64 ;;
+x86_64-*-dragonfly*)	gdb_host=dfly64 ;;
 x86_64-*-freebsd* | x86_64-*-kfreebsd*-gnu)
 			gdb_host=fbsd64 ;;
 x86_64-*-netbsd* | x86_64-*-knetbsd*-gnu)


[FILE:786:dragonfly/patch-gdb_configure.nat]
--- gdb/configure.nat.orig	2019-02-27 04:51:50 UTC
+++ gdb/configure.nat
@@ -62,6 +62,11 @@ case ${gdb_host} in
 	NAT_CDEPS='$(srcdir)/proc-service.list'
 	LOADLIBES='-ldl $(RDYNAMIC)'
 	;;
+    dfly*)
+	NATDEPFILES='fork-child.o nat/fork-inferior.o inf-ptrace.o dfly-nat.o'
+	HAVE_NATIVE_GCORE_HOST=1
+	LOADLIBES='-lkvm'
+	;;
     fbsd*)
 	NATDEPFILES='fork-child.o nat/fork-inferior.o inf-ptrace.o fbsd-nat.o'
 	HAVE_NATIVE_GCORE_HOST=1
@@ -197,6 +202,16 @@ case ${gdb_host} in
 		x86-bsd-nat.o"
 		;;
 	esac
+	;;
+    dfly64)
+	case ${gdb_host_cpu} in
+	    i386)
+		# Host: DragonFly/amd64
+		NATDEPFILES="${NATDEPFILES} amd64-nat.o amd64-bsd-nat.o \
+		amd64-dfly-nat.o bsd-kvm.o x86-nat.o nat/x86-dregs.o \
+		x86-bsd-nat.o"
+		;;
+	esac
 	;;
     go32)
 	case ${gdb_host_cpu} in


[FILE:976:dragonfly/patch-gdb_configure.tgt]
--- gdb/configure.tgt.orig	2019-02-27 04:51:48 UTC
+++ gdb/configure.tgt
@@ -97,6 +97,8 @@ esac
 # 2. Get the objects per os in $TARG.
 
 case "${targ}" in
+*-*-dragonfly*)
+	os_obs="dfly-tdep.o solib-svr4.o";;
 *-*-freebsd* | *-*-kfreebsd*-gnu)
 	os_obs="fbsd-tdep.o solib-svr4.o";;
 *-*-netbsd* | *-*-knetbsd*-gnu)
@@ -747,6 +749,11 @@ x86_64-*-linux*)
 			solib-svr4.o symfile-mem.o linux-tdep.o linux-record.o"
 	build_gdbserver=yes
 	;;
+x86_64-*-dragonfly*)
+	# Target: DragonFly/amd64
+	gdb_target_obs="amd64-dfly-tdep.o ${i386_tobjs} \
+			i386-bsd-tdep.o i386-dfly-tdep.o"
+	;;
 x86_64-*-freebsd* | x86_64-*-kfreebsd*-gnu)
 	# Target: FreeBSD/amd64
 	gdb_target_obs="amd64-fbsd-tdep.o ${i386_tobjs} \
@@ -787,6 +794,8 @@ gdb_target_obs="${cpu_obs} ${os_obs} ${g
 # map target onto default OS ABI
 
 case "${targ}" in
+*-*-dragonfly*)
+		gdb_osabi=GDB_OSABI_DRAGONFLY ;;
 *-*-freebsd* | *-*-kfreebsd*-gnu)
 		gdb_osabi=GDB_OSABI_FREEBSD ;;
 *-*-linux* | *-*-uclinux*)


[FILE:243:dragonfly/patch-gdb_defs.h]
--- gdb/defs.h.orig	2018-09-05 07:27:32 UTC
+++ gdb/defs.h
@@ -483,6 +483,7 @@ enum gdb_osabi
   GDB_OSABI_FREEBSD,
   GDB_OSABI_NETBSD,
   GDB_OSABI_OPENBSD,
+  GDB_OSABI_DRAGONFLY,
   GDB_OSABI_WINCE,
   GDB_OSABI_GO32,
   GDB_OSABI_QNXNTO,


[FILE:348:dragonfly/patch-gdb_i386-bsd-nat.c]
--- gdb/i386-bsd-nat.c.orig	2018-09-05 07:27:13 UTC
+++ gdb/i386-bsd-nat.c
@@ -284,6 +284,8 @@ _initialize_i386bsd_nat (void)
 #define SC_REG_OFFSET i386nbsd_sc_reg_offset
 #elif defined (OpenBSD)
 #define SC_REG_OFFSET i386obsd_sc_reg_offset
+#elif defined (DragonFly)
+#define SC_REG_OFFSET i386dfly_sc_reg_offset
 #endif
 
 #ifdef SC_REG_OFFSET


[FILE:773:dragonfly/patch-gdb_i386-tdep.h]
--- gdb/i386-tdep.h.orig	2018-09-05 07:27:13 UTC
+++ gdb/i386-tdep.h
@@ -449,12 +449,11 @@ extern int i386_mpx_enabled (void);
 /* Functions and variables exported from i386-bsd-tdep.c.  */
 
 extern void i386bsd_init_abi (struct gdbarch_info, struct gdbarch *);
-extern CORE_ADDR i386fbsd_sigtramp_start_addr;
-extern CORE_ADDR i386fbsd_sigtramp_end_addr;
+extern CORE_ADDR i386dfly_sigtramp_start_addr;
+extern CORE_ADDR i386dfly_sigtramp_end_addr;
 extern CORE_ADDR i386obsd_sigtramp_start_addr;
 extern CORE_ADDR i386obsd_sigtramp_end_addr;
-extern int i386fbsd4_sc_reg_offset[];
-extern int i386fbsd_sc_reg_offset[];
+extern int i386dfly_sc_reg_offset[];
 extern int i386nbsd_sc_reg_offset[];
 extern int i386obsd_sc_reg_offset[];
 extern int i386bsd_sc_reg_offset[];


[FILE:728:dragonfly/patch-gdb_osabi.c]
--- gdb/osabi.c.orig	2018-09-05 07:27:13 UTC
+++ gdb/osabi.c
@@ -68,6 +68,7 @@ static const struct osabi_names gdb_osab
   { "FreeBSD", NULL },
   { "NetBSD", NULL },
   { "OpenBSD", NULL },
+  { "DragonFly", NULL },
   { "WindowsCE", NULL },
   { "DJGPP", NULL },
   { "QNX-Neutrino", NULL },
@@ -495,6 +496,15 @@ generic_elf_osabi_sniff_abi_tag_sections
 	  return;
 	}
 
+      /* DragonFly.  */
+      if (check_note (abfd, sect, note, &sectsize, "DragonFly", 4,
+		      NT_DRAGONFLY_ABI_TAG))
+	{
+	  /* There is no need to check the version yet.  */
+	  *osabi = GDB_OSABI_DRAGONFLY;
+	  return;
+	}
+
       /* FreeBSD.  */
       if (check_note (abfd, sect, note, &sectsize, "FreeBSD", 4,
 		      NT_FREEBSD_ABI_TAG))


[FILE:390:dragonfly/patch-include_elf_common.h]
--- include/elf/common.h.orig	2018-09-05 07:44:28 UTC
+++ include/elf/common.h
@@ -790,6 +790,7 @@
 /* Values for FreeBSD .note.ABI-tag notes.  Note name is "FreeBSD".  */
 
 #define NT_FREEBSD_ABI_TAG	1
+#define NT_DRAGONFLY_ABI_TAG	1
 
 /* These three macros disassemble and assemble a symbol table st_info field,
    which contains the symbol binding and symbol type.  The STB_ and STT_

