# Buildsheet autogenerated by ravenadm tool -- Do not edit.

NAMEBASE=		gdb
VERSION=		7.12.1
KEYWORDS=		devel
VARIANTS=		standard
SDESC[standard]=	GNU debugger
HOMEPAGE=		http://www.gnu.org/software/gdb/
CONTACT=		nobody

DOWNLOAD_GROUPS=	main
SITES[main]=		GNU/gdb
DISTFILE[1]=		gdb-7.12.1.tar.xz:main
DF_INDEX=		1
SPKGS[standard]=	single

OPTIONS_AVAILABLE=	none
OPTIONS_STANDARD=	none

NOT_FOR_ARCH=		aarch64

BUILD_DEPENDS=		expat:static:standard
BUILDRUN_DEPENDS=	expat:shared:standard

USES=			cpe iconv gmake libtool readline python

EXTRACT_HEAD[1]=	{{TAR}} -xf
EXTRACT_TAIL[1]=	--exclude dejagnu --exclude expect --exclude sim --exclude texinfo --exclude intl --exclude readline

CPE_VENDOR=		gnu
FPC_EQUIVALENT=		devel/gdb

MUST_CONFIGURE=		gnu
CONFIGURE_ARGS=		--program-suffix=7121
			--enable-targets=all
			--enable-64-bit-bfd
			--enable-tui
			--disable-build-with-cxx
			--with-gdb-datadir={{PREFIX}}/share/gdb7121
			{{ICONV_CONFIGURE_ARG}}
			--with-system-readline
			--with-expat=yes
			--with-libexpat-prefix={{LOCALBASE}}
			--without-libunwind-ia64
			--with-python={{PYTHON_CMD}}
CONFIGURE_ENV=		CONFIGURED_M4=m4
			CONFIGURED_BISON=byacc

PLIST_SUB=		VER=7121

CFLAGS=			-DRL_NO_COMPAT
			-D__STDC_CONSTANT_MACROS
			-D__STDC_LIMIT_MACROS
			-Wno-unused-function
			-Wno-unused-variable

post-patch:
	@${REINPLACE_CMD} -e 's|$$| [GDB v7.12.1 for ${OPSYS}]|' \
		${WRKSRC}/gdb/version.in

post-patch-dragonfly:
	${CP} ${OPSYSDIR}/dfly64.mh  ${WRKSRC}/gdb/config/i386/
	${CP} ${OPSYSDIR}/dfly-nat.* ${WRKSRC}/gdb/
	${CP} ${OPSYSDIR}/i386*      ${WRKSRC}/gdb/
	${CP} ${OPSYSDIR}/amd64*     ${WRKSRC}/gdb/

do-install:
	${INSTALL_PROGRAM} ${WRKSRC}/gdb/gdb \
		${STAGEDIR}${PREFIX}/bin/gdb7121
	${INSTALL_MAN} ${WRKSRC}/gdb/doc/gdb.1 \
		${STAGEDIR}${MAN1PREFIX}/man/man1/gdb7121.1
	(cd ${WRKSRC}/gdb/data-directory ; \
		${SETENV} ${MAKE_ENV} ${MAKE_CMD} ${MAKE_ARGS} install-syscalls )
	${LN} -sf gdb7121 ${STAGEDIR}${PREFIX}/bin/gdbtui7121
	${LN} -sf gdb7121 ${STAGEDIR}${PREFIX}/bin/gdb
	(cd ${WRKSRC}/gdb && ${SETENV} ${MAKE_ENV} \
		${MAKE_CMD} ${MAKE_ARGS} install-python )
	(cd ${WRKSRC}/gdb/data-directory && ${SETENV} ${MAKE_ENV} \
		${MAKE_CMD} ${MAKE_ARGS} install-python )
. for f in gdb gdb/command gdb/function gdb/printer
	@(cd ${STAGEDIR}${PREFIX}/share/gdb7121/python/${f} ; ${CHMOD} 644 *.py* )
. endfor

[FILE:284:descriptions/desc.single]
GDB is a source-level debugger for Ada, C, C++, Objective-C, Pascal and
many other languages.  GDB can target (i.e., debug programs running on)
more than a dozen different processor architectures, and GDB itself can
run on most popular GNU/Linux, Unix and Microsoft Windows variants.


[FILE:96:distinfo]
4607680b973d3ec92c30ad029f1b7dbde3876869e6b3a117d8a7e90081113186     19225392 gdb-7.12.1.tar.xz


[FILE:819:manifests/plist.single]
bin/
 gdb
 gdb%%VER%%
 gdbtui%%VER%%
share/man/man1/gdb%%VER%%.1.gz
share/gdb%%VER%%/python/gdb/
 __init__.py
 FrameDecorator.py
 FrameIterator.py
 frames.py
 printing.py
 prompt.py
 types.py
 unwinder.py
 xmethod.py
share/gdb%%VER%%/python/gdb/command/
 __init__.py
 explore.py
 frame_filters.py
 pretty_printers.py
 prompt.py
 type_printers.py
 unwinders.py
 xmethods.py
share/gdb%%VER%%/python/gdb/function/
 __init__.py
 as_string.py
 caller_is.py
 strfns.py
share/gdb%%VER%%/python/gdb/printer/
 __init__.py
 bound_registers.py
share/gdb%%VER%%/syscalls/
 aarch64-linux.xml
 amd64-linux.xml
 arm-linux.xml
 freebsd.xml
 gdb-syscalls.dtd
 i386-linux.xml
 mips-n32-linux.xml
 mips-n64-linux.xml
 mips-o32-linux.xml
 ppc-linux.xml
 ppc64-linux.xml
 s390-linux.xml
 s390x-linux.xml
 sparc-linux.xml
 sparc64-linux.xml


[FILE:11153:patches/patch-armfbsd]
diff --git gdb/armfbsd-nat.c gdb/armfbsd-nat.c
new file mode 100644
index 0000000..b883411
--- /dev/null
+++ gdb/armfbsd-nat.c
@@ -0,0 +1,215 @@
+/* Native-dependent code for BSD Unix running on ARM's, for GDB.
+
+   Copyright (C) 1988-2015 Free Software Foundation, Inc.
+
+   This file is part of GDB.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+#include "defs.h"
+#include "gdbcore.h"
+#include "inferior.h"
+#include "regcache.h"
+#include "target.h"
+#include "gregset.h"
+#include <sys/types.h>
+#include <sys/ptrace.h>
+#include <machine/reg.h>
+#include <machine/frame.h>
+
+#include "fbsd-nat.h"
+#include "arm-tdep.h"
+#include "inf-ptrace.h"
+
+extern int arm_apcs_32;
+
+static pid_t
+ptrace_pid (ptid_t ptid)
+{
+  pid_t pid;
+
+#ifdef __FreeBSD__
+  pid = ptid_get_lwp (ptid);
+  if (pid == 0)
+#endif
+    pid = ptid_get_pid (ptid);
+  return pid;
+}
+
+static void
+arm_supply_gregset (struct regcache *regcache, const gregset_t *gregset, int regnum)
+{
+  int r;
+  CORE_ADDR r_pc;
+
+  /* Integer registers.  */
+  for (r = ARM_A1_REGNUM; r < ARM_SP_REGNUM; r++)
+    if ((r == regnum) || (regnum == -1))
+      regcache_raw_supply (regcache, r, (char *) &gregset->r[r]);
+
+  if ((regnum == ARM_SP_REGNUM) || (regnum == -1))
+    regcache_raw_supply (regcache, ARM_SP_REGNUM,
+		       (char *) &gregset->r_sp);
+  if ((regnum == ARM_LR_REGNUM) || (regnum == -1))
+    regcache_raw_supply (regcache, ARM_LR_REGNUM,
+		       (char *) &gregset->r_lr);
+  /* This is ok: we're running native...  */
+  if ((regnum == ARM_PC_REGNUM) || (regnum == -1))
+    {
+      r_pc = gdbarch_addr_bits_remove (get_regcache_arch (regcache), gregset->r_pc);
+      regcache_raw_supply (regcache, ARM_PC_REGNUM, (char *) &r_pc);
+    }
+
+  if ((regnum == ARM_PS_REGNUM) || (regnum == -1))
+    {
+      if (arm_apcs_32)
+        regcache_raw_supply (regcache, ARM_PS_REGNUM,
+			 (char *) &gregset->r_cpsr);
+      else
+        regcache_raw_supply (regcache, ARM_PS_REGNUM,
+			 (char *) &gregset->r_pc);
+    }
+}
+
+static void
+armbsd_collect_gregset (const struct regcache *regcache, gregset_t *gregset, int regnum)
+{
+  int ret;
+  int r;
+
+  for (r = ARM_A1_REGNUM; r < ARM_SP_REGNUM; r++)
+    if ((regnum == r) || (regnum == -1))
+      regcache_raw_collect (regcache, r,
+			  (char *) &gregset->r[r]);
+
+  if ((regnum == ARM_SP_REGNUM) || (regnum == -1))
+    regcache_raw_collect (regcache, ARM_SP_REGNUM,
+			(char *) &gregset->r_sp);
+  if ((regnum == ARM_LR_REGNUM) || (regnum == -1))
+    regcache_raw_collect (regcache, ARM_LR_REGNUM,
+			(char *) &gregset->r_lr);
+
+
+  if ((regnum == ARM_PC_REGNUM) || (regnum == -1))
+    regcache_raw_collect (regcache, ARM_PC_REGNUM,
+			(char *) &gregset->r_pc);
+  if ((regnum == ARM_PS_REGNUM) || (regnum == -1))
+    {
+      if (arm_apcs_32)
+        {
+          regcache_raw_collect (regcache, ARM_PS_REGNUM,
+			    (char *) &gregset->r_cpsr);
+        }
+      else
+        {
+          unsigned psr_val;
+
+          regcache_raw_collect (regcache, ARM_PS_REGNUM,
+			   (char *) &psr_val);
+
+          psr_val ^= gdbarch_addr_bits_remove (get_regcache_arch (regcache), psr_val);
+          gregset->r_pc = gdbarch_addr_bits_remove
+    			   (get_regcache_arch (regcache), gregset->r_pc);
+          gregset->r_pc |= psr_val;
+        }
+    }
+}
+
+/* Fill GDB's register array with the general-purpose register values
+   in *GREGSETP.  */
+
+void
+supply_gregset (struct regcache *regcache, const gregset_t *gregsetp)
+{
+  arm_supply_gregset (regcache, gregsetp, -1);
+}
+
+/* Fill register REGNUM (if it is a general-purpose register) in
+   *GREGSETPS with the value in GDB's register array.  If REGNUM is -1,
+   do this for all registers.  */
+
+void
+fill_gregset (const struct regcache *regcache, gdb_gregset_t *gregsetp, int regnum)
+{
+  armbsd_collect_gregset (regcache, gregsetp, regnum);
+}
+
+/* Fill GDB's register array with the floating-point register values
+   in *FPREGSETP.  */
+
+void
+supply_fpregset (struct regcache *regcache, const fpregset_t *fpregsetp)
+{
+}
+
+/* Fill register REGNUM (if it is a floating-point register) in
+   *FPREGSETP with the value in GDB's register array.  If REGNUM is -1,
+   do this for all registers.  */
+
+void
+fill_fpregset (const struct regcache *regcache, gdb_fpregset_t *fpregsetp, int regnum)
+{
+}
+
+/* Fetch register REGNO from the child process. If REGNO is -1, do it
+   for all registers.  */
+
+static void
+armfbsd_fetch_inferior_registers (struct target_ops *ops,
+				  struct regcache *regcache, int regno)
+{
+  gdb_gregset_t regs;
+
+  if (ptrace (PT_GETREGS, ptrace_pid (inferior_ptid),
+	      (PTRACE_TYPE_ARG3) &regs, 0) == -1)
+    perror_with_name (_("Couldn't get registers"));
+
+  arm_supply_gregset (regcache, &regs, regno);
+  /* TODO: fpregs */
+}
+
+/* Store register REGNO back into the child process. If REGNO is -1,
+   do this for all registers.  */
+
+static void
+armfbsd_store_inferior_registers (struct target_ops *ops,
+				  struct regcache *regcache, int regno)
+{
+  gdb_gregset_t regs;
+
+  if (ptrace (PT_GETREGS, ptrace_pid (inferior_ptid),
+	      (PTRACE_TYPE_ARG3) &regs, 0) == -1)
+    perror_with_name (_("Couldn't get registers"));
+
+  fill_gregset (regcache, &regs, regno);
+
+  if (ptrace (PT_SETREGS, ptrace_pid (inferior_ptid),
+	      (PTRACE_TYPE_ARG3) &regs, 0) == -1)
+    perror_with_name (_("Couldn't write registers"));
+  /* TODO: FP regs */
+}
+
+void _initialize_armfbsd_nat (void);
+
+void
+_initialize_armfbsd_nat (void)
+{
+  struct target_ops *t;
+
+  /* Add in local overrides.  */
+  t = inf_ptrace_target ();
+  t->to_fetch_registers = armfbsd_fetch_inferior_registers;
+  t->to_store_registers = armfbsd_store_inferior_registers;
+  fbsd_nat_add_target (t);
+}
diff --git gdb/armfbsd-tdep.c gdb/armfbsd-tdep.c
new file mode 100644
index 0000000..f58c323
--- /dev/null
+++ gdb/armfbsd-tdep.c
@@ -0,0 +1,109 @@
+/* Target-dependent code for PowerPC systems running FreeBSD.
+
+   Copyright (C) 2013-2015 Free Software Foundation, Inc.
+
+   This file is part of GDB.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+#include "defs.h"
+#include "arch-utils.h"
+#include "frame.h"
+#include "gdbcore.h"
+#include "frame-unwind.h"
+#include "gdbtypes.h"
+#include "osabi.h"
+#include "regcache.h"
+#include "regset.h"
+#include "symtab.h"
+#include "target.h"
+#include "trad-frame.h"
+
+#include "arm-tdep.h"
+#include "solib-svr4.h"
+
+/* Description of the longjmp buffer.  */
+#define ARM_FBSD_JB_PC 24
+#define ARM_FBSD_JB_ELEMENT_SIZE INT_REGISTER_SIZE
+
+/* For compatibility with previous implemenations of GDB on arm/FreeBSD,
+   override the default little-endian breakpoint.  */
+static const gdb_byte arm_fbsd_arm_le_breakpoint[] = {0x11, 0x00, 0x00, 0xe6};
+static const gdb_byte arm_fbsd_arm_be_breakpoint[] = {0xe6, 0x00, 0x00, 0x11};
+static const gdb_byte arm_fbsd_thumb_le_breakpoint[] = {0xfe, 0xde};
+static const gdb_byte arm_fbsd_thumb_be_breakpoint[] = {0xde, 0xfe};
+
+static void
+arm_freebsd_init_abi_common (struct gdbarch_info info,
+			    struct gdbarch *gdbarch)
+{
+  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);
+
+  tdep->lowest_pc = 0x8000;
+  switch (info.byte_order)
+    {
+    case BFD_ENDIAN_LITTLE:
+      tdep->arm_breakpoint = arm_fbsd_arm_le_breakpoint;
+      tdep->thumb_breakpoint = arm_fbsd_thumb_le_breakpoint;
+      tdep->arm_breakpoint_size = sizeof (arm_fbsd_arm_le_breakpoint);
+      tdep->thumb_breakpoint_size = sizeof (arm_fbsd_thumb_le_breakpoint);
+      break;
+
+    case BFD_ENDIAN_BIG:
+      tdep->arm_breakpoint = arm_fbsd_arm_be_breakpoint;
+      tdep->thumb_breakpoint = arm_fbsd_thumb_be_breakpoint;
+      tdep->arm_breakpoint_size = sizeof (arm_fbsd_arm_be_breakpoint);
+      tdep->thumb_breakpoint_size = sizeof (arm_fbsd_thumb_be_breakpoint);
+      break;
+
+    default:
+      internal_error (__FILE__, __LINE__,
+		      _("arm_gdbarch_init: bad byte order for float format"));
+    }
+
+  tdep->jb_pc = ARM_FBSD_JB_PC;
+  tdep->jb_elt_size = ARM_FBSD_JB_ELEMENT_SIZE;
+
+  /* Single stepping.  */
+  set_gdbarch_software_single_step (gdbarch, arm_software_single_step);
+}
+
+static void
+arm_freebsd_elf_init_abi (struct gdbarch_info info,
+			 struct gdbarch *gdbarch)
+{
+  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);
+
+  arm_freebsd_init_abi_common (info, gdbarch);
+  if (tdep->fp_model == ARM_FLOAT_AUTO)
+    tdep->fp_model = ARM_FLOAT_SOFT_VFP;
+
+  /* NetBSD ELF uses SVR4-style shared libraries.  */
+  set_solib_svr4_fetch_link_map_offsets
+    (gdbarch, svr4_ilp32_fetch_link_map_offsets);
+}
+
+
+
+/* Provide a prototype to silence -Wmissing-prototypes.  */
+
+void _initialize_armfbsd_tdep (void);
+
+void
+_initialize_armfbsd_tdep (void)
+{
+
+  gdbarch_register_osabi (bfd_arch_arm, 0, GDB_OSABI_FREEBSD_ELF,
+                          arm_freebsd_elf_init_abi);
+}
diff --git gdb/config/arm/fbsd.mh gdb/config/arm/fbsd.mh
new file mode 100644
index 0000000..0a2d8b1
--- /dev/null
+++ gdb/config/arm/fbsd.mh
@@ -0,0 +1,3 @@
+# Host: FreeBSD/arm
+NATDEPFILES= armfbsd-nat.o fbsd-nat.o fork-child.o inf-ptrace.o
+HAVE_NATIVE_GCORE_HOST = 1
diff --git gdb/Makefile.in gdb/Makefile.in
index dfaa8a3..ddad28d 100644
--- gdb/Makefile.in
+++ gdb/Makefile.in
@@ -659,7 +659,7 @@
 ALL_TARGET_OBS = \
 	armbsd-tdep.o arm.o arm-linux.o arm-linux-tdep.o \
 	arm-get-next-pcs.o arm-symbian-tdep.o \
-	armnbsd-tdep.o armobsd-tdep.o \
+	armnbsd-tdep.o armobsd-tdep.o armfbsd-tdep.o \
 	arm-tdep.o arm-wince-tdep.o \
 	avr-tdep.o \
 	bfin-linux-tdep.o bfin-tdep.o \
@@ -1666,7 +1666,7 @@
 	arm.c arm-get-next-pcs.c \
 	arm-linux.c arm-linux-nat.c arm-linux-tdep.c \
 	arm-symbian-tdep.c arm-tdep.c \
-	armnbsd-nat.c armbsd-tdep.c armnbsd-tdep.c armobsd-tdep.c \
+	armnbsd-nat.c armbsd-tdep.c armnbsd-tdep.c armobsd-tdep.c armfbsd-tdep.c \
 	avr-tdep.c \
 	bfin-linux-tdep.c bfin-tdep.c \
 	bsd-uthread.c bsd-kvm.c \


[FILE:393:patches/patch-fixes]
--- gdb/compile/compile-loc2c.c.orig	2016-07-05 12:30:44.811467295 +0200
+++ gdb/compile/compile-loc2c.c	2016-07-05 12:38:46.432434206 +0200
@@ -670,7 +670,7 @@
       enum dwarf_location_atom op = (enum dwarf_location_atom) *op_ptr;
       uint64_t uoffset, reg;
       int64_t offset;
-
+      uoffset = 0;
       print_spaces (indent - 2, stream);
       if (info[op_ptr - base].label)
 	{


[FILE:1448:patches/patch-gdb-amd64bsd-nat.c]
--- gdb/amd64bsd-nat.c.orig	2016-02-10 04:19:39.000000000 +0100
+++ gdb/amd64bsd-nat.c	2016-03-04 11:17:58.581638025 +0100
@@ -28,6 +28,7 @@
 #include <sys/types.h>
 #include <sys/ptrace.h>
 #include <machine/reg.h>
+#include <machine/psl.h>
 
 #include "amd64-tdep.h"
 #include "amd64-nat.h"
@@ -98,14 +99,25 @@
 
   if (regnum == -1 || amd64_native_gregset_supplies_p (gdbarch, regnum))
     {
-      struct reg regs;
+      struct reg regs, oldregs;
 
+      memset( &regs, 0, sizeof(struct reg));
+      memset( &oldregs, 0, sizeof(struct reg));
       if (ptrace (PT_GETREGS, get_ptrace_pid (inferior_ptid),
                   (PTRACE_TYPE_ARG3) &regs, 0) == -1)
         perror_with_name (_("Couldn't get registers"));
 
+      ptrace (PT_GETREGS, get_ptrace_pid (inferior_ptid),
+		  (PTRACE_TYPE_ARG3) &oldregs, 0);
       amd64_collect_native_gregset (regcache, &regs, regnum);
 
+      if( (regs.r_rflags ^ oldregs.r_rflags ) & ~PSL_USERCHANGE)
+        {
+          //printf("regs.r_rflags = 0x%8.8lX\n", regs.r_rflags );
+          //printf("oldregs.r_rflags = 0x%8.8lX\n", oldregs.r_rflags );
+          regs.r_rflags ^= (regs.r_rflags ^ oldregs.r_rflags ) & ~PSL_USERCHANGE;
+          //printf("    allowed regs.r_rflags = 0x%8.8X\n", regs.r_rflags );
+        }
       if (ptrace (PT_SETREGS, get_ptrace_pid (inferior_ptid),
 	          (PTRACE_TYPE_ARG3) &regs, 0) == -1)
         perror_with_name (_("Couldn't write registers"));


[FILE:911:patches/patch-gdb-configure]
--- gdb/configure.orig	2016-10-07 19:09:21.000000000 +0200
+++ gdb/configure	2016-10-18 11:11:30.452542000 +0200
@@ -14256,9 +14256,8 @@
 
 # These options work in either C or C++ modes.
 build_warnings="-Wall -Wpointer-arith \
--Wno-unused -Wunused-value -Wunused-function \
--Wno-switch -Wno-char-subscripts \
--Wempty-body -Wunused-but-set-parameter -Wunused-but-set-variable"
+-Wno-unused -Wno-switch -Wno-char-subscripts \
+-Wempty-body"
 
 # Now add in C and C++ specific options, depending on mode.
 if test "$enable_build_with_cxx" = "yes"; then
@@ -14266,8 +14265,7 @@
 -Wno-narrowing"
 else
    build_warnings="$build_warnings -Wpointer-sign -Wmissing-prototypes \
--Wdeclaration-after-statement -Wmissing-parameter-type \
--Wold-style-declaration -Wold-style-definition"
+-Wdeclaration-after-statement -Wold-style-definition"
 fi
 
 # Enable -Wno-format by default when using gcc on mingw since many


[FILE:381:patches/patch-gdb-configure.host]
diff --git gdb/configure.host gdb/configure.host
index 48714f4..53989d3 100644
--- gdb/configure.host
+++ gdb/configure.host
@@ -90,6 +90,7 @@ alpha*-*-netbsd* | alpha*-*-knetbsd*-gnu)
 			gdb_host=nbsd ;;
 alpha*-*-openbsd*)	gdb_host=nbsd ;;
 
+arm*-*-freebsd*)	gdb_host=fbsd ;;
 arm*-*-linux*)		gdb_host=linux ;;
 arm*-*-netbsdelf* | arm*-*-knetbsd*-gnu)
 			gdb_host=nbsdelf ;;


[FILE:484:patches/patch-gdb-corelow.c]
--- gdb/corelow.c.orig	2017-01-16 10:40:23.118428000 +0100
+++ gdb/corelow.c	2017-01-17 22:39:10.524216000 +0100
@@ -541,7 +541,8 @@
       warning (_("Section `%s' in core file too small."), section_name);
       return;
     }
-  if (size != min_size && !(regset->flags & REGSET_VARIABLE_SIZE))
+  if (size != min_size && regset != NULL &&
+	!(regset->flags & REGSET_VARIABLE_SIZE))
     {
       warning (_("Unexpected size of section `%s' in core file."),
 	       section_name);


[FILE:968:patches/patch-gdb-fbsd-nat.c]
--- gdb/fbsd-nat.c.orig	2016-08-01 17:50:20.000000000 +0200
+++ gdb/fbsd-nat.c	2016-12-14 23:23:39.467449000 +0100
@@ -680,6 +680,9 @@
   if (!ptid_match (tp->ptid, *filter))
     return 0;
 
+  if (tp->state == THREAD_EXITED) {
+    return 0;
+  }
   if (ptrace (PT_RESUME, ptid_get_lwp (tp->ptid), NULL, 0) == -1)
     perror_with_name (("ptrace"));
   return 0;
@@ -710,6 +713,14 @@
 			ptid_get_tid (ptid));
   if (ptid_lwp_p (ptid))
     {
+#ifndef PT_LWP_EVENTS
+      /* When LWP events are not supported, a new thread might already be
+	 running that has not yet reported an event when GDB wishes to
+         only run a single thread.  Force an update of the thread list
+	 to ensure that any such threads are suspended before the process
+	 is resumed.  */
+      fbsd_add_threads (ptid_get_pid (ptid));
+#endif
       /* If ptid is a specific LWP, suspend all other LWPs in the process.  */
       iterate_over_threads (resume_one_thread_cb, &ptid);
     }


[FILE:894:patches/patch-gdb-gdb_wchar.h]
diff --git gdb/gdb_wchar.h gdb/gdb_wchar.h
index 868fe04..1311080 100644
--- gdb/gdb_wchar.h
+++ gdb/gdb_wchar.h
@@ -59,7 +59,7 @@
    iconvlist.  */
 #if defined (HAVE_ICONV) && defined (HAVE_BTOWC) \
   && (defined (__STDC_ISO_10646__) \
-      || (defined (_LIBICONV_VERSION) && _LIBICONV_VERSION >= 0x108))
+      || (!defined (LIBICONV_PLUG) && defined (_LIBICONV_VERSION) && _LIBICONV_VERSION >= 0x108))
 
 typedef wchar_t gdb_wchar_t;
 typedef wint_t gdb_wint_t;
@@ -82,7 +82,7 @@ typedef wint_t gdb_wint_t;
 #define INTERMEDIATE_ENCODING intermediate_encoding ()
 const char *intermediate_encoding (void);
 
-#elif defined (_LIBICONV_VERSION) && _LIBICONV_VERSION >= 0x108
+#elif !defined (LIBICONV_PLUG) && defined (_LIBICONV_VERSION) && _LIBICONV_VERSION >= 0x108
 #define INTERMEDIATE_ENCODING "wchar_t"
 #else
 /* This shouldn't happen, because the earlier #if should have filtered


[FILE:462:patches/patch-gdb-gnulib-import-stddef.in.h]
--- gdb/gnulib/import/stddef.in.h.orig	2016-10-07 23:33:10.529558000 -0700
+++ gdb/gnulib/import/stddef.in.h	2016-10-07 23:33:23.824676000 -0700
@@ -82,7 +82,7 @@
 #endif
 
 /* Some platforms lack max_align_t.  */
-#if !@HAVE_MAX_ALIGN_T@
+#if 0
 /* On the x86, the maximum storage alignment of double, long, etc. is 4,
    but GCC's C11 ABI for x86 says that max_align_t has an alignment of 8,
    and the C11 standard allows this.  Work around this problem by


[FILE:363:patches/patch-gdb-i386fbsd-nat.c]
diff --git gdb/i386fbsd-nat.c gdb/i386fbsd-nat.c
index 6c43f2c..a205a26 100644
--- gdb/i386fbsd-nat.c
+++ gdb/i386fbsd-nat.c
@@ -175,7 +175,6 @@ _initialize_i386fbsd_nat (void)
   t->to_read_description = i386fbsd_read_description;
 #endif
 
-  t->to_resume = i386fbsd_resume;
   fbsd_nat_add_target (t);
   /* Support debugging kernel virtual memory images.  */


[FILE:491:patches/patch-gdb-python-python-config.py]
diff --git gdb/python/python-config.py gdb/python/python-config.py
index c2b2969..39af8d9 100644
--- gdb/python/python-config.py
+++ gdb/python/python-config.py
@@ -59,6 +59,8 @@ for opt in opt_flags:
 
     elif opt in ('--libs', '--ldflags'):
         libs = []
+        if getvar('LDFLAGS') is not None:
+            libs.extend(getvar('LDFLAGS').split())
         if getvar('LIBS') is not None:
             libs.extend(getvar('LIBS').split())
         if getvar('SYSLIBS') is not None:


[FILE:492:patches/patch-gdb-x86bsd-nat.c]
--- gdb/x86bsd-nat.c.orig	2016-10-18 13:27:55.820837000 +0200
+++ gdb/x86bsd-nat.c	2016-10-18 13:29:02.518927000 +0200
@@ -82,7 +82,11 @@
   /* For some mysterious reason, some of the reserved bits in the
      debug control register get set.  Mask these off, otherwise the
      ptrace call below will fail.  */
+#ifdef __i386__
+  DBREG_DRX ((&dbregs), 7) &= ~(0x0000fc00);
+#else
   DBREG_DRX ((&dbregs), 7) &= ~(0xffffffff0000fc00);
+#endif 
 
   DBREG_DRX ((&dbregs), regnum) = value;
 


[FILE:533:patches/patch-libiberty-basename]
--- include/libiberty.h
+++ include/libiberty.h
@@ -109,7 +109,7 @@
  || defined (__FreeBSD__) || defined (__OpenBSD__) || defined (__NetBSD__) \
  || defined (__CYGWIN__) || defined (__CYGWIN32__) || defined (__MINGW32__) \
  || defined (__DragonFly__) || defined (HAVE_DECL_BASENAME) 
-extern char *basename (const char *) ATTRIBUTE_RETURNS_NONNULL ATTRIBUTE_NONNULL(1);
+#include <libgen.h>
 #else
 /* Do not allow basename to be used if there is no prototype seen.  We
    either need to use the above prototype or have one from


[FILE:2404:patches/patch-nowarning]
--- gdb/arm-tdep.c.orig	2016-07-08 15:42:17.131392993 +0200
+++ gdb/arm-tdep.c	2016-07-08 15:44:10.506386463 +0200
@@ -9880,7 +9880,7 @@
       && !INSN_RECORDED(arm_insn_r))
     {
       /* Handle MLA(S) and MUL(S).  */
-      if (0 <= insn_op1 && 3 >= insn_op1)
+      if (3 >= insn_op1)
       {
         record_buf[0] = bits (arm_insn_r->arm_insn, 12, 15);
         record_buf[1] = ARM_PS_REGNUM;
--- gdb/cris-tdep.c.orig	2016-07-08 15:45:26.575379589 +0200
+++ gdb/cris-tdep.c	2016-07-08 15:47:07.849372792 +0200
@@ -1441,7 +1441,7 @@
       /* Indeterminate/obsolete.  */
       return 0;
     case cris_ver_v0_3:
-      return (version >= 0 && version <= 3);
+      return (version <= 3);
     case cris_ver_v3p:
       return (version >= 3);
     case cris_ver_v8:
@@ -1449,7 +1449,7 @@
     case cris_ver_v8p:
       return (version >= 8);
     case cris_ver_v0_10:
-      return (version >= 0 && version <= 10);
+      return (version <= 10);
     case cris_ver_v3_10:
       return (version >= 3 && version <= 10);
     case cris_ver_v8_10:
--- gdb/main.c.orig	2016-08-03 17:55:42.243017327 +0200
+++ gdb/main.c	2016-08-03 17:56:04.478015630 +0200
@@ -226,7 +226,7 @@
 	    {
 	      /* Append the part of SYSTEM_GDBINIT that follows GDB_DATADIR
 		 to gdb_datadir.  */
-	      char *tmp_sys_gdbinit = xstrdup (SYSTEM_GDBINIT + datadir_len);
+	      char *tmp_sys_gdbinit = xstrdup (&(SYSTEM_GDBINIT[datadir_len]));
 	      char *p;
 
 	      for (p = tmp_sys_gdbinit; IS_DIR_SEPARATOR (*p); ++p)
--- gdb/dtrace-probe.c.orig	2016-08-03 17:57:18.454010903 +0200
+++ gdb/dtrace-probe.c	2016-08-03 17:58:01.001007519 +0200
@@ -421,7 +421,8 @@
 	  arg.type_str = xstrdup (p);
 
 	  /* Use strtab_size as a sentinel.  */
-	  while (*p++ != '\0' && p - strtab < strtab_size);
+	  while (*p++ != '\0' && p - strtab < strtab_size)
+		;
 
 	  /* Try to parse a type expression from the type string.  If
 	     this does not work then we set the type to `long
--- libiberty/stack-limit.c.orig	2016-08-05 14:12:21.942893014 +0200
+++ libiberty/stack-limit.c	2016-08-05 14:12:58.794890125 +0200
@@ -51,7 +51,7 @@
   struct rlimit rlim;
   if (getrlimit (RLIMIT_STACK, &rlim) == 0
       && rlim.rlim_cur != RLIM_INFINITY
-      && rlim.rlim_cur < pref
+      && rlim.rlim_cur < (rlim_t)pref
       && (rlim.rlim_max == RLIM_INFINITY || rlim.rlim_cur < rlim.rlim_max))
     {
       rlim.rlim_cur = pref;


[FILE:537:patches/patch-unified]
diff --git gdb/gdb.c gdb/gdb.c
index e554015..dcb9925 100644
--- gdb/gdb.c
+++ gdb/gdb.c
@@ -28,6 +28,12 @@ main (int argc, char **argv)
   memset (&args, 0, sizeof args);
   args.argc = argc;
   args.argv = argv;
-  args.interpreter_p = INTERP_CONSOLE;
+  if (strncmp(basename(argv[0]), "insight", 7) == 0) {
+    args.interpreter_p = "insight";
+  } else if (strncmp(basename(argv[0]), "gdbtui", 6) == 0) {
+    args.interpreter_p = INTERP_TUI;
+  } else {
+    args.interpreter_p = INTERP_CONSOLE;
+  }
   return gdb_main (&args);
 }


[FILE:9903:dragonfly/amd64dfly-nat.c]
/* Native-dependent code for DragonFly/amd64.

   Copyright (C) 2003-2016 Free Software Foundation, Inc.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

#include "defs.h"
#include "inferior.h"
#include "regcache.h"
#include "target.h"
#include "gregset.h"

#include "gdb_assert.h"
#include <signal.h>
#include <stddef.h>
#include <sys/types.h>
#include <sys/procfs.h>
#include <sys/ptrace.h>
#include <sys/sysctl.h>
#include <sys/user.h>
#include <machine/reg.h>
#include <machine/segments.h>

#include "dfly-nat.h"
#include "amd64-tdep.h"
#include "amd64-nat.h"
#include "x86bsd-nat.h"
#include "x86-nat.h"


/* Offset in `struct reg' where MEMBER is stored.  */
#define REG_OFFSET(member) offsetof (struct reg, member)

/* At amd64dfly64_r_reg_offset[REGNUM] you'll find the offset in
   `struct reg' location where the GDB register REGNUM is stored.
   Unsupported registers are marked with `-1'.  */
static int amd64dfly64_r_reg_offset[] =
{
  REG_OFFSET (r_rax),
  REG_OFFSET (r_rbx),
  REG_OFFSET (r_rcx),
  REG_OFFSET (r_rdx),
  REG_OFFSET (r_rsi),
  REG_OFFSET (r_rdi),
  REG_OFFSET (r_rbp),
  REG_OFFSET (r_rsp),
  REG_OFFSET (r_r8),
  REG_OFFSET (r_r9),
  REG_OFFSET (r_r10),
  REG_OFFSET (r_r11),
  REG_OFFSET (r_r12),
  REG_OFFSET (r_r13),
  REG_OFFSET (r_r14),
  REG_OFFSET (r_r15),
  REG_OFFSET (r_rip),
  REG_OFFSET (r_rflags),
  REG_OFFSET (r_cs),
  REG_OFFSET (r_ss),
  -1,
  -1,
  -1,
  -1
};


/* Mapping between the general-purpose registers in DragonFly/amd64
   `struct reg' format and GDB's register cache layout for
   DragonFly/x86.

   Note that most DragonFly/amd64 registers are 64-bit, while the
   DragonFly/x86 registers are all 32-bit, but since we're
   little-endian we get away with that.  */

/* From <machine/reg.h>.  */
static int amd64dfly32_r_reg_offset[I386_NUM_GREGS] =
{
  14 * 8, 13 * 8,		/* %eax, %ecx */
  12 * 8, 11 * 8,		/* %edx, %ebx */
  20 * 8, 10 * 8,		/* %esp, %ebp */
  9 * 8, 8 * 8,			/* %esi, %edi */
  17 * 8, 19 * 8,		/* %eip, %eflags */
  18 * 8, 21 * 8,		/* %cs, %ss */
  -1, -1, -1, -1		/* %ds, %es, %fs, %gs */
};


#ifdef DFLY_PCB_SUPPLY
/* Transfering the registers between GDB, inferiors and core files.  */

/* Fill GDB's register array with the general-purpose register values
   in *GREGSETP.  */

void
supply_gregset (struct regcache *regcache, const gregset_t *gregsetp)
{
  amd64_supply_native_gregset (regcache, gregsetp, -1);
}

/* Fill register REGNUM (if it is a general-purpose register) in
   *GREGSETPS with the value in GDB's register array.  If REGNUM is -1,
   do this for all registers.  */

void
fill_gregset (const struct regcache *regcache, gdb_gregset_t *gregsetp, int regnum)
{
  amd64_collect_native_gregset (regcache, gregsetp, regnum);
}

/* Fill GDB's register array with the floating-point register values
   in *FPREGSETP.  */

void
supply_fpregset (struct regcache *regcache, const fpregset_t *fpregsetp)
{
  amd64_supply_fxsave (regcache, -1, fpregsetp);
}

/* Fill register REGNUM (if it is a floating-point register) in
   *FPREGSETP with the value in GDB's register array.  If REGNUM is -1,
   do this for all registers.  */

void
fill_fpregset (const struct regcache *regcache, gdb_fpregset_t *fpregsetp, int regnum)
{
  amd64_collect_fxsave (regcache, regnum, fpregsetp);
}

/* Support for debugging kernel virtual memory images.  */

#include <sys/types.h>
#include <machine/pcb.h>
#include <osreldate.h>

#include "bsd-kvm.h"

static int
amd64dfly_supply_pcb (struct regcache *regcache, struct pcb *pcb)
{
  /* The following is true for FreeBSD 5.2:

     The pcb contains %rip, %rbx, %rsp, %rbp, %r12, %r13, %r14, %r15,
     %ds, %es, %fs and %gs.  This accounts for all callee-saved
     registers specified by the psABI and then some.  Here %esp
     contains the stack pointer at the point just after the call to
     cpu_switch().  From this information we reconstruct the register
     state as it would like when we just returned from cpu_switch().  */

  /* The stack pointer shouldn't be zero.  */
  if (pcb->pcb_rsp == 0)
    return 0;

  pcb->pcb_rsp += 8;
  regcache_raw_supply (regcache, AMD64_RIP_REGNUM, &pcb->pcb_rip);
  regcache_raw_supply (regcache, AMD64_RBX_REGNUM, &pcb->pcb_rbx);
  regcache_raw_supply (regcache, AMD64_RSP_REGNUM, &pcb->pcb_rsp);
  regcache_raw_supply (regcache, AMD64_RBP_REGNUM, &pcb->pcb_rbp);
  regcache_raw_supply (regcache, 12, &pcb->pcb_r12);
  regcache_raw_supply (regcache, 13, &pcb->pcb_r13);
  regcache_raw_supply (regcache, 14, &pcb->pcb_r14);
  regcache_raw_supply (regcache, 15, &pcb->pcb_r15);
#if 0 && (__FreeBSD_version < 800075) && (__FreeBSD_kernel_version < 800075)
  /* struct pcb provides the pcb_ds/pcb_es/pcb_fs/pcb_gs fields only
     up until __FreeBSD_version 800074: The removal of these fields
     occurred on 2009-04-01 while the __FreeBSD_version number was
     bumped to 800075 on 2009-04-06.  So 800075 is the closest version
     number where we should not try to access these fields.  */
  regcache_raw_supply (regcache, AMD64_DS_REGNUM, &pcb->pcb_ds);
  regcache_raw_supply (regcache, AMD64_ES_REGNUM, &pcb->pcb_es);
  regcache_raw_supply (regcache, AMD64_FS_REGNUM, &pcb->pcb_fs);
  regcache_raw_supply (regcache, AMD64_GS_REGNUM, &pcb->pcb_gs);
#endif

  return 1;
}
#endif /* DFLY_PCB_SUPPLY */


/* Implement the to_read_description method.  */

static const struct target_desc *
amd64dfly_read_description (struct target_ops *ops)
{
#ifdef PT_GETXSTATE_INFO
  static int xsave_probed;
  static uint64_t xcr0;
#endif
  struct reg regs;
  int is64;

  if (ptrace (PT_GETREGS, ptid_get_pid (inferior_ptid),
	      (PTRACE_TYPE_ARG3) &regs, 0) == -1)
    perror_with_name (_("Couldn't get registers"));
  is64 = (regs.r_cs == GSEL (GUCODE_SEL, SEL_UPL));
#ifdef PT_GETXSTATE_INFO
  if (!xsave_probed)
    {
      struct ptrace_xstate_info info;

      if (ptrace (PT_GETXSTATE_INFO, ptid_get_pid (inferior_ptid),
		  (PTRACE_TYPE_ARG3) &info, sizeof (info)) == 0)
	{
	  x86bsd_xsave_len = info.xsave_len;
	  xcr0 = info.xsave_mask;
	}
      xsave_probed = 1;
    }

  if (x86bsd_xsave_len != 0)
    {
      if (is64)
	return amd64_target_description (xcr0);
      else
	return i386_target_description (xcr0);
    }
#endif
  if (is64)
    return tdesc_amd64;
  else
    return tdesc_i386;
}

/* Provide a prototype to silence -Wmissing-prototypes.  */
void _initialize_amd64dfly_nat (void);

void
_initialize_amd64dfly_nat (void)
{
  struct target_ops *t;
  int offset;

  amd64_native_gregset32_reg_offset = amd64dfly32_r_reg_offset;
  amd64_native_gregset64_reg_offset = amd64dfly64_r_reg_offset;

  /* Add some extra features to the common *BSD/x86 target.  */
  t = amd64bsd_target ();
  t->to_read_description = amd64dfly_read_description;

  dfly_nat_add_target (t);

#ifdef DFLY_PCB_SUPPLY
  /* Support debugging kernel virtual memory images.  */
  bsd_kvm_add_target (amd64dfly_supply_pcb);
#endif

  /* To support the recognition of signal handlers, i386bsd-tdep.c
     hardcodes some constants.  Inclusion of this file means that we
     are compiling a native debugger, which means that we can use the
     system header files and sysctl(3) to get at the relevant
     information.  */

#define SC_REG_OFFSET amd64dfly_sc_reg_offset

  /* We only check the program counter, stack pointer and frame
     pointer since these members of `struct sigcontext' are essential
     for providing backtraces.  */

#define SC_RIP_OFFSET SC_REG_OFFSET[AMD64_RIP_REGNUM]
#define SC_RSP_OFFSET SC_REG_OFFSET[AMD64_RSP_REGNUM]
#define SC_RBP_OFFSET SC_REG_OFFSET[AMD64_RBP_REGNUM]

  /* Override the default value for the offset of the program counter
     in the sigcontext structure.  */
  offset = offsetof (struct sigcontext, sc_rip);

  if (SC_RIP_OFFSET != offset)
    {
      warning (_("\
offsetof (struct sigcontext, sc_rip) yields %d instead of %d.\n\
Please report this to <bug-gdb@gnu.org>."),
	       offset, SC_RIP_OFFSET);
    }

  SC_RIP_OFFSET = offset;

  /* Likewise for the stack pointer.  */
  offset = offsetof (struct sigcontext, sc_rsp);

  if (SC_RSP_OFFSET != offset)
    {
      warning (_("\
offsetof (struct sigcontext, sc_rsp) yields %d instead of %d.\n\
Please report this to <bug-gdb@gnu.org>."),
	       offset, SC_RSP_OFFSET);
    }

  SC_RSP_OFFSET = offset;

  /* And the frame pointer.  */
  offset = offsetof (struct sigcontext, sc_rbp);

  if (SC_RBP_OFFSET != offset)
    {
      warning (_("\
offsetof (struct sigcontext, sc_rbp) yields %d instead of %d.\n\
Please report this to <bug-gdb@gnu.org>."),
	       offset, SC_RBP_OFFSET);
    }

  SC_RBP_OFFSET = offset;

  /* DragonFly provides a kern.ps_strings sysctl that we can use to
     locate the sigtramp.  That way we can still recognize a sigtramp
     if its location is changed in a new kernel.  Of course this is
     still based on the assumption that the sigtramp is placed
     directly under the location where the program arguments and
     environment can be found.  */
  {
    int mib[2];
    long ps_strings;
    size_t len;

    mib[0] = CTL_KERN;
    mib[1] = KERN_PS_STRINGS;
    len = sizeof (ps_strings);
    if (sysctl (mib, 2, &ps_strings, &len, NULL, 0) == 0)
      {
	amd64dfly_sigtramp_start_addr = ps_strings - 32;
	amd64dfly_sigtramp_end_addr = ps_strings;
      }
  }
}


[FILE:4613:dragonfly/amd64dfly-tdep.c]
/* Target-dependent code for DragonFly/amd64.

   Copyright (C) 2003-2013 Free Software Foundation, Inc.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

#include "defs.h"
#include "arch-utils.h"
#include "frame.h"
#include "gdbcore.h"
#include "regcache.h"
#include "osabi.h"

#include "gdb_assert.h"
#include <string.h>

#include "amd64-tdep.h"
#include "solib-svr4.h"

/* Support for signal handlers.  */

/* Assuming THIS_FRAME is for a BSD sigtramp routine, return the
   address of the associated sigcontext structure.  */

static CORE_ADDR
amd64dfly_sigcontext_addr (struct frame_info *this_frame)
{
  struct gdbarch *gdbarch = get_frame_arch (this_frame);
  enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);
  CORE_ADDR sp;
  gdb_byte buf[8];

  /* The `struct sigcontext' (which really is an `ucontext_t' on
     DragonFly/amd64) lives at a fixed offset in the signal frame.  See
     <machine/sigframe.h>.  */
  get_frame_register (this_frame, AMD64_RSP_REGNUM, buf);
  sp = extract_unsigned_integer (buf, 8, byte_order);
  return sp + 16;
}

/* Mapping between the general-purpose registers in `struct reg'
   format and GDB's register cache layout.

   Note that some registers are 32-bit, but since we're little-endian
   we get away with that.  */

/* From <machine/reg.h>.  */
static int amd64dfly_r_reg_offset[] =
{
  6 * 8,			/* %rax */
  7 * 8,			/* %rbx */
  3 * 8,			/* %rcx */
  2 * 8,			/* %rdx */
  1 * 8,			/* %rsi */
  0 * 8,			/* %rdi */
  8 * 8,			/* %rbp */
  23 * 8,			/* %rsp */
  4 * 8,			/* %r8 ... */
  5 * 8,
  9 * 8,
  10 * 8,
  11 * 8,
  12 * 8,
  13 * 8,
  14 * 8,			/* ... %r15 */
  20 * 8,			/* %rip */
  22 * 8,			/* %eflags */
  21 * 8,			/* %cs */
  24 * 8,			/* %ss */
  -1,				/* %ds */
  -1,				/* %es */
  -1,				/* %fs */
  -1				/* %gs */
};

/* Location of the signal trampoline.  */
CORE_ADDR amd64dfly_sigtramp_start_addr = 0x7fffffffffc0ULL;
CORE_ADDR amd64dfly_sigtramp_end_addr = 0x7fffffffffe0ULL;

/* From <machine/signal.h>.  */
int amd64dfly_sc_reg_offset[] =
{
  24 + 6 * 8,			/* %rax */
  24 + 7 * 8,			/* %rbx */
  24 + 3 * 8,			/* %rcx */
  24 + 2 * 8,			/* %rdx */
  24 + 1 * 8,			/* %rsi */
  24 + 0 * 8,			/* %rdi */
  24 + 8 * 8,			/* %rbp */
  24 + 23 * 8,			/* %rsp */
  24 + 4 * 8,			/* %r8 ... */
  24 + 5 * 8,
  24 + 9 * 8,
  24 + 10 * 8,
  24 + 11 * 8,
  24 + 12 * 8,
  24 + 13 * 8,
  24 + 14 * 8,			/* ... %r15 */
  24 + 20 * 8,			/* %rip */
  24 + 22 * 8,			/* %eflags */
  24 + 21 * 8,			/* %cs */
  24 + 24 * 8,			/* %ss */
  -1,				/* %ds */
  -1,				/* %es */
  -1,				/* %fs */
  -1				/* %gs */
};

/* From /usr/src/lib/libc/amd64/gen/_setjmp.S.  */
static int amd64dfly_jmp_buf_reg_offset[] =
{
  -1,				/* %rax */
  1 * 8,			/* %rbx */
  -1,				/* %rcx */
  -1,				/* %rdx */
  -1,				/* %rsi */
  -1,				/* %rdi */
  3 * 8,			/* %rbp */
  2 * 8,			/* %rsp */
  -1,				/* %r8 ... */
  -1,
  -1,
  -1,				/* ... %r11 */
  4 * 8,			/* %r12 ... */
  5 * 8,
  6 * 8,
  7 * 8,			/* ... %r15 */
  0 * 8				/* %rip */
};

static void
amd64dfly_init_abi (struct gdbarch_info info, struct gdbarch *gdbarch)
{
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);

  i386bsd_init_abi (info, gdbarch);

  tdep->gregset_reg_offset = amd64dfly_r_reg_offset;
  tdep->gregset_num_regs = ARRAY_SIZE (amd64dfly_r_reg_offset);
  tdep->sizeof_gregset = 25 * 8;

  amd64_init_abi (info, gdbarch);

  tdep->sigtramp_start = amd64dfly_sigtramp_start_addr;
  tdep->sigtramp_end = amd64dfly_sigtramp_end_addr;
  tdep->sigcontext_addr = amd64dfly_sigcontext_addr;
  tdep->sc_reg_offset = amd64dfly_sc_reg_offset;
  tdep->sc_num_regs = ARRAY_SIZE (amd64dfly_sc_reg_offset);

  set_solib_svr4_fetch_link_map_offsets
    (gdbarch, svr4_lp64_fetch_link_map_offsets);
}


/* Provide a prototype to silence -Wmissing-prototypes.  */
void _initialize_amd64dfly_tdep (void);

void
_initialize_amd64dfly_tdep (void)
{
  gdbarch_register_osabi (bfd_arch_i386, bfd_mach_x86_64,
			  GDB_OSABI_DRAGONFLY, amd64dfly_init_abi);
}


[FILE:4554:dragonfly/dfly-nat.c]
/* Native-dependent code for DragonFly.

   Copyright (C) 2002-2016 Free Software Foundation, Inc.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

#include "defs.h"
#include "gdbcore.h"
#include "inferior.h"
#include "regcache.h"
#include "regset.h"
#include "gdbcmd.h"
#include "gdbthread.h"
#include "gdb_wait.h"
#include <sys/types.h>
#include <sys/procfs.h>
#include <sys/ptrace.h>
#include <sys/sysctl.h>
#ifdef HAVE_KINFO_GETVMMAP
#include <sys/user.h>
#include <libutil.h>
#endif

#include "elf-bfd.h"
#include "dfly-nat.h"

/* Return the name of a file that can be opened to get the symbols for
   the child process identified by PID.  */

static char *
dfly_pid_to_exec_file (struct target_ops *self, int pid)
{
  ssize_t len;
  static char buf[PATH_MAX];
  char name[PATH_MAX];

#ifdef KERN_PROC_PATHNAME
  size_t buflen;
  int mib[4];

  mib[0] = CTL_KERN;
  mib[1] = KERN_PROC;
  mib[2] = KERN_PROC_PATHNAME;
  mib[3] = pid;
  buflen = sizeof buf;
  if (sysctl (mib, 4, buf, &buflen, NULL, 0) == 0)
    return buf;
#endif

  xsnprintf (name, PATH_MAX, "/proc/%d/exe", pid);
  len = readlink (name, buf, PATH_MAX - 1);
  if (len != -1)
    {
      buf[len] = '\0';
      return buf;
    }

  return NULL;
}

static int
dfly_read_mapping (FILE *mapfile, unsigned long *start, unsigned long *end,
		   char *protection)
{
  /* FreeBSD 5.1-RELEASE uses a 256-byte buffer.  */
  char buf[256];
  int resident, privateresident;
  unsigned long obj;
  int ret = EOF;

  /* As of FreeBSD 5.0-RELEASE, the layout is described in
     /usr/src/sys/fs/procfs/procfs_map.c.  Somewhere in 5.1-CURRENT a
     new column was added to the procfs map.  Therefore we can't use
     fscanf since we need to support older releases too.  */
  if (fgets (buf, sizeof buf, mapfile) != NULL)
    ret = sscanf (buf, "%lx %lx %d %d %lx %s", start, end,
		  &resident, &privateresident, &obj, protection);

  return (ret != 0 && ret != EOF);
}

/* Iterate over all the memory regions in the current inferior,
   calling FUNC for each memory region.  OBFD is passed as the last
   argument to FUNC.  */

static int
dfly_find_memory_regions (struct target_ops *self,
			  find_memory_region_ftype func, void *obfd)
{
  pid_t pid = ptid_get_pid (inferior_ptid);
  char *mapfilename;
  FILE *mapfile;
  unsigned long start, end, size;
  char protection[4];
  int read, write, exec;
  struct cleanup *cleanup;

  mapfilename = xstrprintf ("/proc/%ld/map", (long) pid);
  cleanup = make_cleanup (xfree, mapfilename);
  mapfile = fopen (mapfilename, "r");
  if (mapfile == NULL)
    error (_("Couldn't open %s."), mapfilename);
  make_cleanup_fclose (mapfile);

  if (info_verbose)
    fprintf_filtered (gdb_stdout, 
		      "Reading memory regions from %s\n", mapfilename);

  /* Now iterate until end-of-file.  */
  while (dfly_read_mapping (mapfile, &start, &end, &protection[0]))
    {
      size = end - start;

      read = (strchr (protection, 'r') != 0);
      write = (strchr (protection, 'w') != 0);
      exec = (strchr (protection, 'x') != 0);

      if (info_verbose)
	{
	  fprintf_filtered (gdb_stdout, 
			    "Save segment, %ld bytes at %s (%c%c%c)\n",
			    size, paddress (target_gdbarch (), start),
			    read ? 'r' : '-',
			    write ? 'w' : '-',
			    exec ? 'x' : '-');
	}

      /* Invoke the callback function to create the corefile segment.
	 Pass MODIFIED as true, we do not know the real modification state.  */
      func (start, size, read, write, exec, 1, obfd);
    }

  do_cleanups (cleanup);
  return 0;
}

void
dfly_nat_add_target (struct target_ops *t)
{
  t->to_pid_to_exec_file = dfly_pid_to_exec_file;
  t->to_find_memory_regions = dfly_find_memory_regions;
  /* XXX: thread vfork support */
  add_target (t);
}

/* Provide a prototype to silence -Wmissing-prototypes.  */
extern initialize_file_ftype _initialize_dfly_nat;

void
_initialize_dfly_nat (void)
{
/* XXX: todo add_setshow_boolean_cmd() */
}


[FILE:1009:dragonfly/dfly-nat.h]
/* Native-dependent code for DragonFly.

   Copyright (C) 2004-2015 Free Software Foundation, Inc.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

#ifndef DFLY_NAT_H
#define DFLY_NAT_H

/* Register the customized DragonFly target.  This should be used
   instead of calling add_target directly.  */
extern void dfly_nat_add_target (struct target_ops *);

#endif /* dfly-nat.h */


[FILE:176:dragonfly/dfly64.mh]
# Host: DragonFly/amd64
NATDEPFILES= fork-child.o inf-ptrace.o \
	dfly-nat.o amd64-nat.o x86bsd-nat.o amd64bsd-nat.o amd64dfly-nat.o \
	x86-nat.o x86-dregs.o

LOADLIBES= -lkvm


[FILE:2493:dragonfly/i386dfly-tdep.c]
/* Target-dependent code for DragonFly/i386.

   Copyright (C) 2003-2013 Free Software Foundation, Inc.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

#include "defs.h"
#include "arch-utils.h"
#include "gdbcore.h"
#include "osabi.h"
#include "regcache.h"

#include "gdb_assert.h"

#include "i386-tdep.h"
#include "i387-tdep.h"
#include "solib-svr4.h"

static int i386dfly_r_reg_offset[] =
{
  44, /* %eax */
  40, /* %ecx */
  36, /* %edx */
  32, /* %ebx */
  72, /* %esp */
  24, /* %ebp */
  20, /* %esi */
  16, /* %edi */
  60, /* %eip */
  68, /* %eflags */
  64, /* %cs */
  76, /* %ss */
  12, /* %ds */
  8, /* %es */
  4, /* %fs */
  0  /* %gs */
};

/* Sigtramp routine location.  */
CORE_ADDR i386dfly_sigtramp_start_addr = 0xbfbfdf20;
CORE_ADDR i386dfly_sigtramp_end_addr = 0xbfbfdff0;

int i386dfly_sc_reg_offset[] =
{
  64, /* %eax */
  60, /* %ecx */
  56, /* %edx */
  52, /* %ebx */
  92, /* %esp */
  44, /* %ebp */
  40, /* %esi */
  36, /* %edi */
  80, /* %eip */
  88, /* %eflags */
  84, /* %cs */
  96, /* %ss */
  32, /* %ds */
  28, /* %es */
  24, /* %fs */
  20  /* %gs */
};

static void
i386dfly_init_abi (struct gdbarch_info info, struct gdbarch *gdbarch)
{
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);

  i386_elf_init_abi(info, gdbarch);

  tdep->gregset_reg_offset = i386dfly_r_reg_offset;
  tdep->gregset_num_regs = ARRAY_SIZE (i386dfly_r_reg_offset);
  tdep->sizeof_gregset = 80;

  tdep->sc_reg_offset = i386dfly_sc_reg_offset;
  tdep->sc_num_regs = ARRAY_SIZE (i386dfly_sc_reg_offset);

  set_solib_svr4_fetch_link_map_offsets
    (gdbarch, svr4_ilp32_fetch_link_map_offsets);
}


/* Provide a prototype to silence -Wmissing-prototypes.  */
void _initialize_i386dfly_tdep (void);

void
_initialize_i386dfly_tdep (void)
{
  gdbarch_register_osabi (bfd_arch_i386, 0, GDB_OSABI_DRAGONFLY,
			  i386dfly_init_abi);
}


[FILE:1894:dragonfly/patch-gdb_Makefile.in]
--- gdb/Makefile.in.intermediate	2016-12-19 09:53:30.000000000 +0200
+++ gdb/Makefile.in
@@ -648,7 +648,7 @@ ALL_64_TARGET_OBS = \
 	aarch64-tdep.o aarch64-linux-tdep.o aarch64-newlib-tdep.o aarch64-insn.o \
 	alphabsd-tdep.o alphafbsd-tdep.o alpha-linux-tdep.o alpha-mdebug-tdep.o \
 	alphanbsd-tdep.o alphaobsd-tdep.o alpha-tdep.o \
-	amd64fbsd-tdep.o amd64-darwin-tdep.o amd64-dicos-tdep.o \
+	amd64dfly-tdep.o amd64fbsd-tdep.o amd64-darwin-tdep.o amd64-dicos-tdep.o \
 	amd64-linux-tdep.o amd64nbsd-tdep.o \
 	amd64obsd-tdep.o amd64-sol2-tdep.o amd64-tdep.o amd64-windows-tdep.o \
 	ia64-linux-tdep.o ia64-vms-tdep.o ia64-tdep.o \
@@ -673,7 +673,7 @@ ALL_TARGET_OBS = \
 	h8300-tdep.o \
 	hppabsd-tdep.o hppanbsd-tdep.o hppaobsd-tdep.o \
 	hppa-linux-tdep.o hppa-tdep.o \
-	i386bsd-tdep.o i386-cygwin-tdep.o i386fbsd-tdep.o i386gnu-tdep.o \
+	i386bsd-tdep.o i386-cygwin-tdep.o i386dfly-tdep.o i386fbsd-tdep.o i386gnu-tdep.o \
 	i386-linux-tdep.o i386nbsd-tdep.o i386-nto-tdep.o i386obsd-tdep.o \
 	i386-sol2-tdep.o i386-tdep.o i387-tdep.o \
 	i386-dicos-tdep.o i386-darwin-tdep.o \
@@ -933,7 +933,7 @@ ser-unix.h inf-ptrace.h terminal.h ui-ou
 f-lang.h dwarf2loc.h value.h sparc-tdep.h defs.h target-descriptions.h \
 objfiles.h common/vec.h disasm.h mips-tdep.h ser-base.h \
 gdb_curses.h bfd-target.h memattr.h inferior.h ax.h dummy-frame.h \
-inflow.h fbsd-nat.h ia64-libunwind-tdep.h completer.h \
+inflow.h dfly-nat.h fbsd-nat.h ia64-libunwind-tdep.h completer.h \
 solib-target.h gdb_vfork.h alpha-tdep.h dwarf2expr.h \
 m2-lang.h stack.h charset.h addrmap.h command.h solist.h source.h \
 target.h target-dcache.h prologue-value.h cp-abi.h tui/tui-hooks.h tui/tui.h \
@@ -1703,7 +1703,7 @@ ALLDEPFILES = \
 	fbsd-tdep.c \
 	fork-child.c \
 	ft32-tdep.c \
-	glibc-tdep.c \
+	dfly-nat.c glibc-tdep.c \
 	go32-nat.c h8300-tdep.c \
 	hppa-tdep.c \
 	hppa-linux-tdep.c hppa-linux-nat.c \


[FILE:629:dragonfly/patch-gdb_amd64-tdep.h]
--- gdb/amd64-tdep.h.orig	2013-01-01 06:32:37.000000000 +0000
+++ gdb/amd64-tdep.h
@@ -121,9 +121,9 @@ extern int amd64nbsd_r_reg_offset[];
 /* Variables exported from amd64obsd-tdep.c.  */
 extern int amd64obsd_r_reg_offset[];
 
-/* Variables exported from amd64fbsd-tdep.c.  */
-extern CORE_ADDR amd64fbsd_sigtramp_start_addr;
-extern CORE_ADDR amd64fbsd_sigtramp_end_addr;
-extern int amd64fbsd_sc_reg_offset[];
+/* Variables exported from amd64dfly-tdep.c.  */
+extern CORE_ADDR amd64dfly_sigtramp_start_addr;
+extern CORE_ADDR amd64dfly_sigtramp_end_addr;
+extern int amd64dfly_sc_reg_offset[];
 
 #endif /* amd64-tdep.h */


[FILE:361:dragonfly/patch-gdb_configure.host]
--- gdb/configure.host.orig	2015-05-13 17:36:05 UTC
+++ gdb/configure.host
@@ -175,6 +175,7 @@ vax-*-netbsdelf* | vax-*-knetbsd*-gnu)
 vax-*-openbsd*)		gdb_host=obsd ;;
 
 x86_64-*-linux*)	gdb_host=linux64 ;;
+x86_64-*-dragonfly*)	gdb_host=dfly64 ;;
 x86_64-*-freebsd* | x86_64-*-kfreebsd*-gnu)
 			gdb_host=fbsd64 ;;
 x86_64-*-netbsd* | x86_64-*-knetbsd*-gnu)


[FILE:763:dragonfly/patch-gdb_configure.tgt]
--- gdb/configure.tgt.orig	2015-05-13 17:36:05 UTC
+++ gdb/configure.tgt
@@ -659,6 +659,12 @@ x86_64-*-linux*)
 			solib-svr4.o symfile-mem.o linux-tdep.o linux-record.o"
 	build_gdbserver=yes
 	;;
+x86_64-*-dragonfly*)
+	# Target: DragonFly/amd64
+	gdb_target_obs="amd64-tdep.o amd64dfly-tdep.o i386-tdep.o \
+			i387-tdep.o i386bsd-tdep.o i386dfly-tdep.o \
+			bsd-uthread.o solib-svr4.o"
+	;;
 x86_64-*-freebsd* | x86_64-*-kfreebsd*-gnu)
 	# Target: FreeBSD/amd64
 	gdb_target_obs="amd64-tdep.o amd64fbsd-tdep.o i386-tdep.o \
@@ -699,6 +705,8 @@ esac
 # map target onto default OS ABI
 
 case "${targ}" in
+*-*-dragonfly*)
+		gdb_osabi=GDB_OSABI_DRAGONFLY ;;
 *-*-freebsd* | *-*-kfreebsd*-gnu)
 		gdb_osabi=GDB_OSABI_FREEBSD_ELF ;;
 *-*-linux* | *-*-uclinux*)


[FILE:265:dragonfly/patch-gdb_defs.h]
--- gdb/defs.h.orig	2013-02-04 12:57:44.000000000 +0000
+++ gdb/defs.h
@@ -581,6 +581,7 @@ enum gdb_osabi
   GDB_OSABI_NETBSD_AOUT,
   GDB_OSABI_NETBSD_ELF,
   GDB_OSABI_OPENBSD_ELF,
+  GDB_OSABI_DRAGONFLY,
   GDB_OSABI_WINCE,
   GDB_OSABI_GO32,
   GDB_OSABI_IRIX,


[FILE:789:dragonfly/patch-gdb_i386-tdep.h]
--- gdb/i386-tdep.h.orig	2013-01-01 06:32:45.000000000 +0000
+++ gdb/i386-tdep.h
@@ -387,12 +387,11 @@ extern int i386_process_record (struct g
 /* Functions and variables exported from i386bsd-tdep.c.  */
 
 extern void i386bsd_init_abi (struct gdbarch_info, struct gdbarch *);
-extern CORE_ADDR i386fbsd_sigtramp_start_addr;
-extern CORE_ADDR i386fbsd_sigtramp_end_addr;
+extern CORE_ADDR i386dfly_sigtramp_start_addr;
+extern CORE_ADDR i386dfly_sigtramp_end_addr;
 extern CORE_ADDR i386obsd_sigtramp_start_addr;
 extern CORE_ADDR i386obsd_sigtramp_end_addr;
-extern int i386fbsd4_sc_reg_offset[];
-extern int i386fbsd_sc_reg_offset[];
+extern int i386dfly_sc_reg_offset[];
 extern int i386nbsd_sc_reg_offset[];
 extern int i386obsd_sc_reg_offset[];
 extern int i386bsd_sc_reg_offset[];


[FILE:358:dragonfly/patch-gdb_i386bsd-nat.c]
--- gdb/i386bsd-nat.c.orig	2013-05-17 18:49:06.543945000 +0000
+++ gdb/i386bsd-nat.c
@@ -353,6 +353,8 @@ _initialize_i386bsd_nat (void)
 #define SC_REG_OFFSET i386nbsd_sc_reg_offset
 #elif defined (OpenBSD)
 #define SC_REG_OFFSET i386obsd_sc_reg_offset
+#elif defined (DragonFly)
+#define SC_REG_OFFSET i386dfly_sc_reg_offset
 #endif
 
 #ifdef SC_REG_OFFSET


[FILE:737:dragonfly/patch-gdb_osabi.c]
--- gdb/osabi.c.orig	2015-02-19 11:58:07 UTC
+++ gdb/osabi.c
@@ -69,6 +69,7 @@ static const struct osabi_names gdb_osab
   { "NetBSD/a.out", NULL },
   { "NetBSD/ELF", NULL },
   { "OpenBSD/ELF", NULL },
+  { "DragonFly/ELF", NULL },
   { "WindowsCE", NULL },
   { "DJGPP", NULL },
   { "Irix", NULL },
@@ -501,6 +502,15 @@ generic_elf_osabi_sniff_abi_tag_sections
 	  return;
 	}
 
+      /* DragonFly.  */
+      if (check_note (abfd, sect, note, &sectsize, "DragonFly", 4,
+		      NT_DRAGONFLY_ABI_TAG))
+	{
+	  /* There is no need to check the version yet.  */
+	  *osabi = GDB_OSABI_DRAGONFLY;
+	  return;
+	}
+
       /* FreeBSD.  */
       if (check_note (abfd, sect, note, &sectsize, "FreeBSD", 4,
 		      NT_FREEBSD_ABI_TAG))


[FILE:402:dragonfly/patch-include_elf_common.h]
--- include/elf/common.h.orig	2013-03-08 17:13:31.000000000 +0000
+++ include/elf/common.h
@@ -628,6 +628,7 @@
 /* Values for FreeBSD .note.ABI-tag notes.  Note name is "FreeBSD".  */
 
 #define NT_FREEBSD_ABI_TAG	1
+#define NT_DRAGONFLY_ABI_TAG	1
 
 /* These three macros disassemble and assemble a symbol table st_info field,
    which contains the symbol binding and symbol type.  The STB_ and STT_

