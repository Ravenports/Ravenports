# Buildsheet autogenerated by ravenadm tool -- Do not edit.

NAMEBASE=		upx
VERSION=		5.0.2
KEYWORDS=		archivers
VARIANTS=		std
SDESC[std]=		Ultimate Packer for eXecutables
HOMEPAGE=		https://upx.github.io/
CONTACT=		nobody

DOWNLOAD_GROUPS=	main
SITES[main]=		https://github.com/upx/upx/releases/download/v5.0.2/
DISTFILE[1]=		upx-5.0.2-src.tar.xz:main
DF_INDEX=		1
SPKGS[std]=		set
			primary
			man
			docs

OPTIONS_AVAILABLE=	none
OPTIONS_STANDARD=	none

USES=			cpe cmake c++:primary

DISTNAME=		upx-5.0.2-src

LICENSE=		GPLv2+:primary
LICENSE_TERMS=		primary:{{WRKSRC}}/LICENSE
LICENSE_FILE=		GPLv2+:{{WRKSRC}}/COPYING
LICENSE_SCHEME=		solo

FPC_EQUIVALENT=		archivers/upx

post-install:
	${RM} ${STAGEDIR}${STD_DOCDIR}/COPYING
	${RM} ${STAGEDIR}${STD_DOCDIR}/LICENSE
	${STRIP_CMD} ${STAGEDIR}${PREFIX}/bin/upx

[FILE:290:descriptions/desc.primary]
UPX is a free, portable, extendable, high-performance executable packer for
several different executable formats. It achieves an excellent compression
ratio and offers very fast decompression. Your executables suffer no memory
overhead or other drawbacks because of in-place decompression.


[FILE:99:distinfo]
209b219bbcfa58c249ffe6eba3c244e0910fa8be792b5521e4daf938167f05cc      1351136 upx-5.0.2-src.tar.xz


[FILE:8:manifests/plist.primary]
bin/upx


[FILE:21:manifests/plist.man]
share/man/man1/upx.1


[FILE:68:manifests/plist.docs]
share/doc/upx/
 NEWS
 README
 THANKS.txt
 upx-doc.html
 upx-doc.txt


[FILE:401:patches/patch-src-packer.h]
--- src/packer.h.orig	2025-07-20 12:41:25 UTC
+++ src/packer.h
@@ -202,7 +202,7 @@ protected:
     void addLoader(C, C, C, C, C, C, C, C, C);
     void addLoader(C, C, C, C, C, C, C, C, C, C);
 #undef C
-#if (ACC_CC_CLANG || ACC_CC_GNUC)
+#if 0 && (ACC_CC_CLANG || ACC_CC_GNUC)
     void addLoaderVA(const char *s, ...) __attribute__((__sentinel__));
 #else
     void addLoaderVA(const char *s, ...);


[FILE:1761:patches/patch-src_bele.h]
--- src/bele.h.orig	2025-07-20 12:41:25 UTC
+++ src/bele.h
@@ -262,7 +262,7 @@ forceinline bele_constexpr upx_uint64_t
 
 #else
 
-forceinline constexpr unsigned bswap16(unsigned v) noexcept {
+forceinline constexpr unsigned upx_bswap16(unsigned v) noexcept {
 #if defined(__riscv) && __riscv_xlen == 64
     return (unsigned) __builtin_bswap64(upx_uint64_t(v) << 48);
 #else
@@ -270,14 +270,14 @@ forceinline constexpr unsigned bswap16(u
     return __builtin_bswap32(v << 16);
 #endif
 }
-forceinline constexpr unsigned bswap32(unsigned v) noexcept {
+forceinline constexpr unsigned upx_bswap32(unsigned v) noexcept {
 #if defined(__riscv) && __riscv_xlen == 64
     return (unsigned) __builtin_bswap64(upx_uint64_t(v) << 32);
 #else
     return __builtin_bswap32(v);
 #endif
 }
-forceinline constexpr upx_uint64_t bswap64(upx_uint64_t v) noexcept { return __builtin_bswap64(v); }
+forceinline constexpr upx_uint64_t upx_bswap64(upx_uint64_t v) noexcept { return __builtin_bswap64(v); }
 
 #endif
 
@@ -292,13 +292,13 @@ forceinline constexpr upx_uint64_t no_bs
 #define ne16_to_be16(v) no_bswap16(v)
 #define ne32_to_be32(v) no_bswap32(v)
 #define ne64_to_be64(v) no_bswap64(v)
-#define ne16_to_le16(v) bswap16(v)
-#define ne32_to_le32(v) bswap32(v)
-#define ne64_to_le64(v) bswap64(v)
+#define ne16_to_le16(v) upx_bswap16(v)
+#define ne32_to_le32(v) upx_bswap32(v)
+#define ne64_to_le64(v) upx_bswap64(v)
 #else
-#define ne16_to_be16(v) bswap16(v)
-#define ne32_to_be32(v) bswap32(v)
-#define ne64_to_be64(v) bswap64(v)
+#define ne16_to_be16(v) upx_bswap16(v)
+#define ne32_to_be32(v) upx_bswap32(v)
+#define ne64_to_be64(v) upx_bswap64(v)
 #define ne16_to_le16(v) no_bswap16(v)
 #define ne32_to_le32(v) no_bswap32(v)
 #define ne64_to_le64(v) no_bswap64(v)


[FILE:1231:patches/patch-src_check_dt__check.cpp]
--- src/check/dt_check.cpp.orig	2025-07-20 12:41:25 UTC
+++ src/check/dt_check.cpp
@@ -275,12 +275,12 @@ static_assert(no_bswap16(0x04030201) ==
 static_assert(no_bswap32(0x04030201) == 0x04030201);
 static_assert(no_bswap64(0x0807060504030201ull) == 0x0807060504030201ull);
 #if !(ACC_CC_MSC) || defined(upx_is_constant_evaluated)
-static_assert(bswap16(0x04030201) == 0x0102);
-static_assert(bswap32(0x04030201) == 0x01020304);
-static_assert(bswap64(0x0807060504030201ull) == 0x0102030405060708ull);
-static_assert(bswap16(bswap16(0xf4f3f2f1)) == no_bswap16(0xf4f3f2f1));
-static_assert(bswap32(bswap32(0xf4f3f2f1)) == no_bswap32(0xf4f3f2f1));
-static_assert(bswap64(bswap64(0xf8f7f6f5f4f3f2f1ull)) == no_bswap64(0xf8f7f6f5f4f3f2f1ull));
+static_assert(upx_bswap16(0x04030201) == 0x0102);
+static_assert(upx_bswap32(0x04030201) == 0x01020304);
+static_assert(upx_bswap64(0x0807060504030201ull) == 0x0102030405060708ull);
+static_assert(upx_bswap16(bswap16(0xf4f3f2f1)) == no_bswap16(0xf4f3f2f1));
+static_assert(upx_bswap32(bswap32(0xf4f3f2f1)) == no_bswap32(0xf4f3f2f1));
+static_assert(upx_bswap64(bswap64(0xf8f7f6f5f4f3f2f1ull)) == no_bswap64(0xf8f7f6f5f4f3f2f1ull));
 #endif
 
 static_assert(sign_extend32(0u + 0, 8) == 0);


[FILE:491:patches/patch-src_p__lx__exc.cpp]
--- src/p_lx_exc.cpp.orig	2025-07-20 12:41:25 UTC
+++ src/p_lx_exc.cpp
@@ -371,7 +371,7 @@ PackLinuxI386::buildLinuxLoader(
             (res->lit_pos_bits << 8) |
             (res->pos_bits << 16);
         if (bele->isBE()) // big endian - bswap32
-            properties = bswap32(properties);
+            properties = upx_bswap32(properties);
         linker->defineSymbol("lzma_properties", properties);
 
         // These lengths assume only one block (typ. 524288 bytes: 0.5 MiB).


[FILE:505:patches/patch-src_p__vmlinz.cpp]
--- src/p_vmlinz.cpp.orig	2025-07-20 12:41:25 UTC
+++ src/p_vmlinz.cpp
@@ -597,7 +597,7 @@ void PackBvmlinuzI386::pack(OutputFile *
             (res->lit_pos_bits << 8) |
             (res->pos_bits << 16);
         if (bele->isBE()) // big endian - bswap32
-            properties = bswap32(properties);
+            properties = upx_bswap32(properties);
         linker->defineSymbol("lzma_properties", properties);
         // -2 for properties
         if (linker->findSymbol("lzma_c_len", false)) {


[FILE:537:patches/patch-src_packer__c.cpp]
--- src/packer_c.cpp.orig	2025-07-20 12:41:25 UTC
+++ src/packer_c.cpp
@@ -258,7 +258,7 @@ void Packer::defineDecompressorSymbols()
         upx_uint32_t properties = // lc, lp, pb, dummy
             (res->lit_context_bits << 0) | (res->lit_pos_bits << 8) | (res->pos_bits << 16);
         if (bele->isBE()) // big endian - bswap32
-            properties = bswap32(properties);
+            properties = upx_bswap32(properties);
 
         linker->defineSymbol("lzma_properties", properties);
         // len - 2 because of properties

