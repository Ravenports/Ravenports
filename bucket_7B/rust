# Buildsheet autogenerated by ravenadm tool -- Do not edit.

NAMEBASE=		rust
VERSION=		1.38.0
KEYWORDS=		lang
VARIANTS=		standard
SDESC[standard]=	Systems programming language from Mozilla
HOMEPAGE=		https://www.rust-lang.org/
CONTACT=		Michael_Neumann[mneumann@ntecs.de]

DOWNLOAD_GROUPS=	main dflyboot
SITES[dflyboot]=	https://leaf.dragonflybsd.org/~marino/dports-src/rust/
SITES[main]=		https://static.rust-lang.org/dist/
DISTFILE[1]=		rustc-1.38.0-src.tar.xz:main
DISTFILE[2]=		rustc-1.37.0-x86_64-unknown-dragonfly.tar.zst:dflyboot
DISTFILE[3]=		rust-std-1.37.0-x86_64-unknown-dragonfly.tar.zst:dflyboot
DISTFILE[4]=		cargo-0.38.0-x86_64-unknown-dragonfly.tar.zst:dflyboot
DISTFILE[5]=		rustc-1.37.0-x86_64-unknown-freebsd.tar.gz:main
DISTFILE[6]=		rust-std-1.37.0-x86_64-unknown-freebsd.tar.gz:main
DISTFILE[7]=		cargo-0.38.0-x86_64-unknown-freebsd.tar.gz:main
DISTFILE[8]=		rustc-1.37.0-x86_64-unknown-linux-gnu.tar.gz:main
DISTFILE[9]=		rust-std-1.37.0-x86_64-unknown-linux-gnu.tar.gz:main
DISTFILE[10]=		cargo-0.38.0-x86_64-unknown-linux-gnu.tar.gz:main
DF_INDEX=		1
SPKGS[standard]=	single

OPTIONS_AVAILABLE=	none
OPTIONS_STANDARD=	none

ONLY_FOR_OPSYS=		dragonfly freebsd linux

BUILD_DEPENDS=		bash:primary:standard
			cmake:single:standard
			autoselect-python:single:standard
BUILDRUN_DEPENDS=	curl:primary:standard
			libssh2:single:standard
			libgit2:single:standard
EXRUN[single]=		gcc8:compilers:standard

USES=			gmake ssl zlib python:build shebangfix ncurses
			execinfo c++:single

DISTNAME=		rustc-1.38.0-src
EXTRACT_ONLY=		1

LICENSE=		APACHE20:single MIT:single
LICENSE_TERMS=		single:{{WRKSRC}}/COPYRIGHT
LICENSE_FILE=		APACHE20:{{WRKSRC}}/LICENSE-APACHE
			MIT:{{WRKSRC}}/LICENSE-MIT
LICENSE_SCHEME=		dual

FPC_EQUIVALENT=		lang/rust
SHEBANG_FILES=		src/llvm-project/compiler-rt/lib/sanitizer_common/symbolizer/scripts/*.sh
			src/llvm-project/compiler-rt/lib/asan/scripts/asan_device_setup
			src/llvm-project/compiler-rt/lib/tsan/*.sh
			src/llvm-project/compiler-rt/lib/fuzzer/scripts/*.py
			src/llvm-project/compiler-rt/lib/dfsan/scripts/build-libc-list.py
			src/llvm-project/compiler-rt/lib/sanitizer_common/scripts/*.py
			src/llvm-project/compiler-rt/lib/asan/scripts/asan_symbolize.py
			src/libcore/unicode/unicode.py

MUST_CONFIGURE=		yes
CONFIGURE_ARGS=		--release-channel=stable
			--enable-rpath
			--enable-extended
			--enable-vendor
			--enable-locked-deps
			--local-rust-root={{WRKDIR}}/bootstrap
			--prefix={{PREFIX}}
			--disable-ninja
			--default-linker={{LOCALBASE}}/toolchain/gcc8/bin/cc

MAKE_ENV=		LD_LIBRARY_PATH={{WRKDIR}}/bootstrap/lib
			LIBGIT2_SYS_USE_PKG_CONFIG=1
			LIBSSH2_SYS_USE_PKG_CONFIG=1
			OPENSSL_NO_PKG_CONFIG=1
			RUST_BACKTRACE=1
			PROFILE=release
			OPENSSL_DIR="{{OPENSSLBASE}}"
			HOME="{{WRKDIR}}"

INSTALL_REQ_TOOLCHAIN=	yes

BLOCK_WATCHDOG=		yes

post-patch:
	# Use rpath suitable for libz et al.
	${REINPLACE_CMD} -e 's|@PREFIX@|${PREFIX}|g' \
		-e 's|@OPENSSLLIB@|${OPENSSLLIB}|g' \
		${WRKSRC}/src/bootstrap/bin/rustc.rs
	# Disable vendor checksums
	${REINPLACE_CMD} -e 's/"files":{[^}]*}/"files":{}/' \
		 ${WRKSRC}/vendor/*/.cargo-checksum.json

post-configure-freebsd:
	${LN} -s ${LOCALBASE}/toolchain/gcc8/lib/libstdc++.so \
	${LOCALBASE}/lib/libc++.so

post-configure-dragonfly:
	${LN} -s ${LOCALBASE}/toolchain/gcc8/lib/libgcc_s.so \
	${WRKDIR}/bootstrap/lib/rustlib/${SFX}/lib/libgcc_pic.so

do-build:
	(cd ${BUILD_WRKSRC} && ${SETENV} ${MAKE_ENV} \
		${PYTHON_CMD} x.py build --verbose --config ./config.toml \
		--jobs ${MAKE_JOBS_NUMBER})

post-install:
	${RM} ${STAGEDIR}${PREFIX}/lib/rustlib/install.log
	${RM} ${STAGEDIR}${PREFIX}/lib/rustlib/uninstall.sh
	${RM} -r ${STAGEDIR}${PREFIX}/share/doc/rust
	# Taken from FreeBSD Ports
	# In post-install, we use the manifests generated during Rust install
	# to in turn generate the PLIST. We do that because several libraries
	# have a computed filename based on the absolute path of the source
	# files. As it is user-specific, we can't know the filename in advance.
	#
	# Both rustc and Cargo components install the same README.md and
	# LICENSE files. The install process backs up the first copy to
	# install the second. Thus here, we need to remove those backups.
	# Actually we remove the entire share/doc/rust contents.
	# We also need to dedup the entries in the generated PLIST, because
	# both components manifests list them.
	#
	# We fix manpage entries in the generated manifests because Rust
	# installs them uncompressed but the Ports framework compresses them.
	for f in ${STAGEDIR}${PREFIX}/lib/rustlib/manifest-*; do \
	    ${SED} -i'' -E \
		-e '/share\/doc\/rust/d' \
	        -e 's|:${STAGEDIR}|:|' \
	        -e 's|(man/man[1-9]/.*\.[0-9])|\1.gz|' \
	        $$f; \
	    ${AWK} '\
	        /^file:/ { \
	            file=$$0; \
	            sub(/^file:/, "", file); \
	            print file; \
	        } \
	        /^dir:/ { \
	            dir=$$0; \
	            sub(/^dir:/, "", dir); \
	            system("find ${STAGEDIR}" dir " -type f | ${SED} -E -e \"s|${STAGEDIR}||\""); \
	        }' \
	        $$f >> ${WRKDIR}/.manifest.gen.unsorted; \
	    ${RM} $$f; \
	done
	${SORT} -u ${WRKDIR}/.manifest.gen.unsorted > ${WRKDIR}/.manifest.gen.sorted
	${CAT} ${WRKDIR}/.manifest.gen.sorted >> ${WRKDIR}/.manifest.single.mktmp
	# Strip binaries and libraries
	${STRIP_CMD} \
		${STAGEDIR}${PREFIX}/bin/cargo \
		${STAGEDIR}${PREFIX}/bin/cargo-clippy \
		${STAGEDIR}${PREFIX}/bin/cargo-miri \
		${STAGEDIR}${PREFIX}/bin/cargo-fmt \
		${STAGEDIR}${PREFIX}/bin/clippy-driver \
		${STAGEDIR}${PREFIX}/bin/miri \
		${STAGEDIR}${PREFIX}/bin/rls \
		${STAGEDIR}${PREFIX}/bin/rustc \
		${STAGEDIR}${PREFIX}/bin/rustdoc \
		${STAGEDIR}${PREFIX}/bin/rustfmt \
		${STAGEDIR}${PREFIX}/lib/*.so \
		${STAGEDIR}${PREFIX}/lib/rustlib/*/lib/*.so \
		${STAGEDIR}${PREFIX}/lib/rustlib/*/codegen-backends/*.so

post-build-freebsd:
	${RM} ${LOCALBASE}/lib/libc++.so

post-configure:
	${MKDIR} ${WRKDIR}/bootstrap
	# Extract OS-specific bootstrap components
	# then install bootstrap components
	for F in ${SRC_RUSTC} ${SRC_RUSTSTD} ${SRC_CARGO}; do\
	   ${TAR} -C ${WRKDIR} -xf ${DISTDIR}/$$F.tar.${COMPEXT}\
	     --no-same-owner --no-same-permissions;\
	   ${LOCALBASE}/bin/bash ${WRKDIR}/$$F/install.sh\
	     --prefix=${WRKDIR}/bootstrap;\
	done

do-install:
	(cd ${BUILD_WRKSRC} && ${SETENV} ${MAKE_ENV} DESTDIR=${STAGEDIR} \
		${PYTHON_CMD} x.py install --verbose --config ./config.toml \
		--jobs ${MAKE_JOBS_NUMBER})

[FILE:753:descriptions/desc.single]
Rust is a systems programming language that runs blazingly fast, prevents
segfaults, and guarantees thread safety.

Performance
Rust is blazingly fast and memory-efficient: with no runtime or garbage
collector, it can power performance-critical services, run on embedded
devices, and easily integrate with other languages.

Reliability
Rust's rich type system and ownership model guarantee memory-safety and
thread-safety -- and enable you to eliminate many classes of bugs at
compile-time.

Productivity
Rust has great documentation, a friendly compiler with useful error
messages, and top-notch tooling -- an integrated package manager and
build tool, smart multi-editor support with auto-completion and type
inspections, an auto-formatter, and more.


[FILE:1215:distinfo]
3a7991aa4cb44ef941d71636e45a95468b520dc6fc7cf725364925bd3e3d3a34     96163304 rustc-1.38.0-src.tar.xz
eb4cf65177870d95a14db9a39dd671a04b83117af48ee2c831647c6de88c5d0b     60450746 rustc-1.37.0-x86_64-unknown-dragonfly.tar.zst
6797c37bf80b71fe39ac7a598253b1ce30b3067d8f3906c97b76ea50a447dd1a     63199888 rust-std-1.37.0-x86_64-unknown-dragonfly.tar.zst
40d978790988517bc91523f55bb660eca916338f3660e1ca1c48ff7f9ced22ff      3816049 cargo-0.38.0-x86_64-unknown-dragonfly.tar.zst
a4dd357a0b39abf1ebbe8a0f64973c3b0c5bc527e374c12afe51266279fc1ca6     70318740 rustc-1.37.0-x86_64-unknown-freebsd.tar.gz
8783a667ea9c46f27027d494098c51563faa734c5ddb23c6b9b3eda804eb9742     87956779 rust-std-1.37.0-x86_64-unknown-freebsd.tar.gz
ec5051df58aeff6720f386067c05de21bbc0f6532d74d2646f7b7bc36d341629      6712004 cargo-0.38.0-x86_64-unknown-freebsd.tar.gz
c759b318f333639a45f29c1551ca7ce55b1bf64e0fc3a3357d6b9356885d1626    122271590 rustc-1.37.0-x86_64-unknown-linux-gnu.tar.gz
09a531a97a16701eb794ecbeeded5d8f8da33da7f1bd372661ad385e3f31c048     83166788 rust-std-1.37.0-x86_64-unknown-linux-gnu.tar.gz
70f694f49a60a0c13e8b07d36b5c8b4e1000a25282c4d8496e8747e9df36fa7f      6740172 cargo-0.38.0-x86_64-unknown-linux-gnu.tar.gz


[FILE:96:manifests/plist.single]
@comment generated from lib/rustlib/manifest-*
lib/rustlib/
 components
 rust-installer-version


[FILE:4857:patches/patch-fix-multiple-llvm-builds]
From d6bd0a479ceaf6abdd696c3b955a56f66275c562 Mon Sep 17 00:00:00 2001
From: Georgy Yakovlev <gyakovlev@gentoo.org>
Date: Sat, 25 May 2019 22:21:16 -0700
Subject: [PATCH] revert commits triggering multiple llvm rebuilds

this reverts the following commits
https://github.com/rust-lang/rust/commit/105692c3ad281c63bf0f75a26a66bb9cff5b4553
https://github.com/rust-lang/rust/commit/975ba58f42b34ff07cd7c2bd73350daed2057186
https://github.com/rust-lang/rust/commit/e1daa36ba7df88788c2684bbe5ff6eb37f1cda69
---
 src/bootstrap/llvm-rebuild-trigger |  4 +++
 src/bootstrap/native.rs            | 46 +++++++++++++-----------------
 2 files changed, 24 insertions(+), 26 deletions(-)
 create mode 100644 src/bootstrap/llvm-rebuild-trigger

diff --git a/src/bootstrap/llvm-rebuild-trigger b/src/bootstrap/llvm-rebuild-trigger
new file mode 100644
index 0000000000..0f18c6a4ac
--- /dev/null	2019-10-22 14:43:51 UTC
+++ src/rustllvm/llvm-rebuild-trigger
@@ -0,0 +1,4 @@
+# If this file is modified, then llvm will be (optionally) cleaned and then rebuilt.
+# The actual contents of this file do not matter, but to trigger a change on the
+# build bots then the contents should be changed so git updates the mtime.
+2019-03-18
--- src/bootstrap/native.rs.orig	2019-09-23 21:15:52 UTC
+++ src/bootstrap/native.rs
@@ -67,40 +67,30 @@ impl Step for Llvm {
             }
         }
 
-        let (llvm_info, root, out_dir, llvm_config_ret_dir) = if emscripten {
-            let info = &builder.emscripten_llvm_info;
+        let rebuild_trigger = builder.src.join("src/rustllvm/llvm-rebuild-trigger");
+        let rebuild_trigger_contents = t!(fs::read_to_string(&rebuild_trigger));
+
+        let (out_dir, llvm_config_ret_dir) = if emscripten {
             let dir = builder.emscripten_llvm_out(target);
             let config_dir = dir.join("bin");
-            (info, "src/llvm-emscripten", dir, config_dir)
+            (dir, config_dir)
         } else {
-            let info = &builder.in_tree_llvm_info;
             let mut dir = builder.llvm_out(builder.config.build);
             if !builder.config.build.contains("msvc") || builder.config.ninja {
                 dir.push("build");
             }
-            (info, "src/llvm-project/llvm", builder.llvm_out(target), dir.join("bin"))
+            (builder.llvm_out(target), dir.join("bin"))
         };
-
-        if !llvm_info.is_git() {
-            println!(
-                "git could not determine the LLVM submodule commit hash. \
-                Assuming that an LLVM build is necessary.",
-            );
-        }
-
+        let done_stamp = out_dir.join("llvm-finished-building");
         let build_llvm_config = llvm_config_ret_dir
             .join(exe("llvm-config", &*builder.config.build));
-        let done_stamp = out_dir.join("llvm-finished-building");
+        if done_stamp.exists() {
+            let done_contents = t!(fs::read_to_string(&done_stamp));
 
-        if let Some(llvm_commit) = llvm_info.sha() {
-            if done_stamp.exists() {
-                let done_contents = t!(fs::read(&done_stamp));
-
-                // If LLVM was already built previously and the submodule's commit didn't change
-                // from the previous build, then no action is required.
-                if done_contents == llvm_commit.as_bytes() {
-                    return build_llvm_config
-                }
+            // If LLVM was already built previously and contents of the rebuild-trigger file
+            // didn't change from the previous build, then no action is required.
+            if done_contents == rebuild_trigger_contents {
+                return build_llvm_config
             }
         }
 
@@ -110,6 +100,7 @@ impl Step for Llvm {
         t!(fs::create_dir_all(&out_dir));
 
         // http://llvm.org/docs/CMake.html
+        let root = if self.emscripten { "src/llvm-emscripten" } else { "src/llvm-project/llvm" };
         let mut cfg = cmake::Config::new(builder.src.join(root));
 
         let profile = match (builder.config.llvm_optimize, builder.config.llvm_release_debuginfo) {
@@ -271,6 +262,11 @@ impl Step for Llvm {
                 channel::CFG_RELEASE_NUM,
                 builder.config.channel,
             );
+            let llvm_info = if self.emscripten {
+                &builder.emscripten_llvm_info
+            } else {
+                &builder.in_tree_llvm_info
+            };
             if let Some(sha) = llvm_info.sha_short() {
                 default_suffix.push_str("-");
                 default_suffix.push_str(sha);
@@ -303,9 +299,7 @@ impl Step for Llvm {
 
         cfg.build();
 
-        if let Some(llvm_commit) = llvm_info.sha() {
-            t!(fs::write(&done_stamp, llvm_commit));
-        }
+        t!(fs::write(&done_stamp, &rebuild_trigger_contents));
 
         build_llvm_config
     }


[FILE:500:patches/patch-src_bootstrap_bin_rustc.rs]
--- src/bootstrap/bin/rustc.rs.orig	2019-09-23 21:15:52 UTC
+++ src/bootstrap/bin/rustc.rs
@@ -270,7 +270,7 @@ fn main() {
             } else if !target.contains("windows") &&
                       !target.contains("wasm32") &&
                       !target.contains("fuchsia") {
-                Some("-Wl,-rpath,$ORIGIN/../lib")
+                Some("-Wl,-z,origin -Wl,-rpath,$ORIGIN/../lib:@PREFIX@/lib:@OPENSSLLIB@ -L@PREFIX@/lib")
             } else {
                 None
             };


[FILE:536:patches/patch-src_libunwind_build.rs]
--- src/libunwind/build.rs.orig	2019-09-23 21:15:52 UTC
+++ src/libunwind/build.rs
@@ -29,7 +29,7 @@ fn main() {
     } else if target.contains("solaris") {
         println!("cargo:rustc-link-lib=gcc_s");
     } else if target.contains("dragonfly") {
-        println!("cargo:rustc-link-lib=gcc_pic");
+        println!("cargo:rustc-link-lib=gcc_s");
     } else if target.contains("pc-windows-gnu") {
         println!("cargo:rustc-link-lib=static-nobundle=gcc_eh");
         println!("cargo:rustc-link-lib=static-nobundle=pthread");


[FILE:1176:patches/patch-vendor_libgit2-sys_lib.rs]
Revert to libgit2 0.28 API per https://github.com/rust-lang/git2-rs/issues/458

--- vendor/libgit2-sys/lib.rs.orig	2019-09-23 23:15:02 UTC
+++ vendor/libgit2-sys/lib.rs
@@ -331,7 +331,6 @@ pub struct git_remote_callbacks {
     pub push_negotiation: Option<git_push_negotiation>,
     pub transport: Option<git_transport_cb>,
     pub payload: *mut c_void,
-    pub resolve_url: Option<git_url_resolve_cb>,
 }
 
 #[repr(C)]
@@ -385,8 +384,6 @@ pub type git_push_negotiation =
 
 pub type git_push_update_reference_cb =
     extern "C" fn(*const c_char, *const c_char, *mut c_void) -> c_int;
-pub type git_url_resolve_cb =
-    extern "C" fn(*mut git_buf, *const c_char, c_int, *mut c_void) -> c_int;
 
 #[repr(C)]
 pub struct git_push_update {
@@ -2233,7 +2230,7 @@ extern "C" {
         source: *const git_tree,
     ) -> c_int;
     pub fn git_treebuilder_clear(bld: *mut git_treebuilder);
-    pub fn git_treebuilder_entrycount(bld: *mut git_treebuilder) -> size_t;
+    pub fn git_treebuilder_entrycount(bld: *mut git_treebuilder) -> c_uint;
     pub fn git_treebuilder_free(bld: *mut git_treebuilder);
     pub fn git_treebuilder_get(
         bld: *mut git_treebuilder,


[FILE:789:patches/patch-vendor_openssl-sys_build_cfgs.rs]
--- vendor/openssl-sys/build/cfgs.rs.orig	2019-09-23 23:15:03 UTC
+++ vendor/openssl-sys/build/cfgs.rs
@@ -13,6 +13,9 @@ pub fn get(openssl_version: Option<u64>,
         if libressl_version >= 0x2_07_00_00_0 {
             cfgs.push("libressl270");
         }
+        if libressl_version >= 0x2_07_01_00_0 {
+            cfgs.push("libressl271");
+        }
         if libressl_version >= 0x2_07_03_00_0 {
             cfgs.push("libressl273");
         }
@@ -22,6 +25,9 @@ pub fn get(openssl_version: Option<u64>,
         if libressl_version >= 0x2_08_01_00_0 {
             cfgs.push("libressl281");
         }
+        if libressl_version >= 0x2_09_01_00_0 {
+            cfgs.push("libressl291");
+        }
     } else {
         let openssl_version = openssl_version.unwrap();
 


[FILE:705:patches/patch-vendor_openssl-sys_build_main.rs]
--- vendor/openssl-sys/build/main.rs.orig	2019-09-23 23:15:03 UTC
+++ vendor/openssl-sys/build/main.rs
@@ -199,6 +199,7 @@ See rust-openssl README for more informa
             (8, 1) => ('8', '1'),
             (8, _) => ('8', 'x'),
             (9, 0) => ('9', '0'),
+            (9, _) => ('9', 'x'),
             _ => version_error(),
         };
 
@@ -239,7 +240,7 @@ fn version_error() -> ! {
         "
 
 This crate is only compatible with OpenSSL 1.0.1 through 1.1.1, or LibreSSL 2.5
-through 2.9.0, but a different version of OpenSSL was found. The build is now aborting
+through 2.9.x, but a different version of OpenSSL was found. The build is now aborting
 due to this version mismatch.
 
 "


[FILE:859:patches/patch-vendor_openssl-sys_src_crypto.rs]
--- vendor/openssl-sys/src/crypto.rs.orig	2019-09-23 23:15:03 UTC
+++ vendor/openssl-sys/src/crypto.rs
@@ -15,7 +15,13 @@ cfg_if! {
     if #[cfg(ossl110)] {
         pub const CRYPTO_EX_INDEX_SSL: c_int = 0;
         pub const CRYPTO_EX_INDEX_SSL_CTX: c_int = 1;
-
+    } else if #[cfg(libressl)] {
+        pub const CRYPTO_EX_INDEX_SSL: c_int = 1;
+        pub const CRYPTO_EX_INDEX_SSL_CTX: c_int = 2;
+    }
+}
+cfg_if! {
+    if #[cfg(any(ossl110, libressl271))] {
         extern "C" {
             pub fn OpenSSL_version_num() -> c_ulong;
             pub fn OpenSSL_version(key: c_int) -> *const c_char;
@@ -64,7 +70,7 @@ pub type CRYPTO_EX_free = unsafe extern
     argp: *mut c_void,
 );
 extern "C" {
-    #[cfg(ossl110)]
+    #[cfg(any(ossl110, libressl))]
     pub fn CRYPTO_get_ex_new_index(
         class_index: c_int,
         argl: c_long,


[FILE:297:patches/patch-vendor_openssl-sys_src_ssl.rs]
--- vendor/openssl-sys/src/ssl.rs.orig	2019-09-23 23:15:03 UTC
+++ vendor/openssl-sys/src/ssl.rs
@@ -1057,7 +1057,7 @@ extern "C" {
 }
 
 cfg_if! {
-    if #[cfg(ossl110)] {
+    if #[cfg(any(ossl110, libressl291))] {
         extern "C" {
             pub fn TLS_method() -> *const SSL_METHOD;
 


[FILE:647:patches/patch-vendor_openssl_build.rs]
--- vendor/openssl/build.rs.orig	2019-09-23 23:15:03 UTC
+++ vendor/openssl/build.rs
@@ -46,6 +46,10 @@ fn main() {
             println!("cargo:rustc-cfg=libressl270");
         }
 
+        if version >= 0x2_07_01_00_0 {
+            println!("cargo:rustc-cfg=libressl271");
+        }
+
         if version >= 0x2_07_03_00_0 {
             println!("cargo:rustc-cfg=libressl273");
         }
@@ -53,5 +57,9 @@ fn main() {
         if version >= 0x2_08_00_00_0 {
             println!("cargo:rustc-cfg=libressl280");
         }
+
+        if version >= 0x2_09_01_00_0 {
+            println!("cargo:rustc-cfg=libressl291");
+        }
     }
 }


[FILE:873:patches/patch-vendor_openssl_src_ssl_mod.rs]
--- vendor/openssl/src/ssl/mod.rs.orig	2019-09-23 23:15:03 UTC
+++ vendor/openssl/src/ssl/mod.rs
@@ -3690,9 +3690,14 @@ cfg_if! {
 }
 
 cfg_if! {
-    if #[cfg(ossl110)] {
+    if #[cfg(any(ossl110, libressl291))] {
         use ffi::{TLS_method, DTLS_method};
-
+    } else {
+        use ffi::{SSLv23_method as TLS_method, DTLSv1_method as DTLS_method};
+    }
+}
+cfg_if! {
+    if #[cfg(ossl110)] {
         unsafe fn get_new_idx(f: ffi::CRYPTO_EX_free) -> c_int {
             ffi::CRYPTO_get_ex_new_index(
                 ffi::CRYPTO_EX_INDEX_SSL_CTX,
@@ -3715,8 +3720,6 @@ cfg_if! {
             )
         }
     } else {
-        use ffi::{SSLv23_method as TLS_method, DTLSv1_method as DTLS_method};
-
         unsafe fn get_new_idx(f: ffi::CRYPTO_EX_free) -> c_int {
             ffi::SSL_CTX_get_ex_new_index(0, ptr::null_mut(), None, None, Some(f))
         }


[FILE:385:patches/patch-vendor_openssl_src_version.rs]
--- vendor/openssl/src/version.rs.orig	2019-09-23 23:15:03 UTC
+++ vendor/openssl/src/version.rs
@@ -14,7 +14,7 @@
 use std::ffi::CStr;
 
 cfg_if! {
-    if #[cfg(ossl110)] {
+    if #[cfg(any(ossl110, libressl271))] {
         use ffi::{
             OPENSSL_VERSION, OPENSSL_CFLAGS, OPENSSL_BUILT_ON, OPENSSL_PLATFORM, OPENSSL_DIR,
             OpenSSL_version_num, OpenSSL_version,


[FILE:559:files/special.mk]
.if "${OPSYS}" == "DragonFly"
BOOTSTRAP_RUST=		1.37.0
BOOTSTRAP_CARGO=	0.38.0
DF_INDEX+=		2 3 4
COMPEXT=		zst
.elif "${OPSYS}" == "FreeBSD"
BOOTSTRAP_RUST=		1.37.0
BOOTSTRAP_CARGO=	0.38.0
DF_INDEX+=		5 6 7
COMPEXT=		gz
.elif "${OPSYS}" == "Linux"
BOOTSTRAP_RUST=		1.37.0
BOOTSTRAP_CARGO=	0.38.0
DF_INDEX+=		8 9 10
COMPEXT=		gz
SFX=			${ARCH_STANDARD}-unknown-linux-gnu
.endif
SFX?=			${ARCH_STANDARD}-unknown-${OPSYS:tl}
SRC_RUSTC?=		rustc-${BOOTSTRAP_RUST}-${SFX}
SRC_RUSTSTD?=		rust-std-${BOOTSTRAP_RUST}-${SFX}
SRC_CARGO?=		cargo-${BOOTSTRAP_CARGO}-${SFX}

