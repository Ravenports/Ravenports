# Buildsheet autogenerated by ravenadm tool -- Do not edit.

NAMEBASE=		wayland
VERSION=		1.17.0
REVISION=		1
KEYWORDS=		graphics
VARIANTS=		standard
SDESC[standard]=	Wayland Display Protocol implementation
HOMEPAGE=		https://wayland.freedesktop.org/
CONTACT=		Peeter_Must[karu.pruun@gmail.com]

DOWNLOAD_GROUPS=	main
SITES[main]=		https://wayland.freedesktop.org/releases/
DISTFILE[1]=		wayland-1.17.0.tar.xz:main
DF_INDEX=		1
SPKGS[standard]=	complete
			primary
			docs

OPTIONS_AVAILABLE=	none
OPTIONS_STANDARD=	none

ONLY_FOR_OPSYS=		dragonfly

BUILD_DEPENDS=		libxslt:single:standard
			doxygen:single:standard
			xmlto:single:standard
			graphviz:primary:standard
			docbook-xsl:primary:standard
BUILDRUN_DEPENDS=	libffi:single:standard
			expat:shared:standard

USES=			autoreconf gmake libtool pkgconfig
GNOME_COMPONENTS=	libxml2

LICENSE=		MIT:complete
LICENSE_FILE=		MIT:{{WRKSRC}}/COPYING
LICENSE_SCHEME=		solo

FPC_EQUIVALENT=		graphics/wayland

INVALID_RPATH=		yes
MUST_CONFIGURE=		gnu

INSTALL_TARGET=		install-strip
INSTALL_REQ_TOOLCHAIN=	yes

[FILE:165:descriptions/desc.primary]
Wayland is intended as a simpler replacement for X, easier to develop
and maintain. GNOME and KDE are expected to be ported to it.

https://wayland.freedesktop.org/


[FILE:100:distinfo]
72aa11b8ac6e22f4777302c9251e8fec7655dc22f9d94ee676c6b276f95f91a4       437680 wayland-1.17.0.tar.xz


[FILE:1316:manifests/plist.primary]
bin/wayland-scanner
include/
 wayland-client-core.h
 wayland-client-protocol.h
 wayland-client.h
 wayland-cursor.h
 wayland-egl-backend.h
 wayland-egl-core.h
 wayland-egl.h
 wayland-server-core.h
 wayland-server-protocol.h
 wayland-server.h
 wayland-util.h
 wayland-version.h
lib/
 libwayland-client.so
 libwayland-client.so.0
 libwayland-client.so.0.3.0
 libwayland-cursor.so
 libwayland-cursor.so.0
 libwayland-cursor.so.0.0.0
 libwayland-egl.so
 libwayland-egl.so.1
 libwayland-egl.so.1.0.0
 libwayland-server.so
 libwayland-server.so.0
 libwayland-server.so.0.1.0
lib/pkgconfig/
 wayland-client.pc
 wayland-cursor.pc
 wayland-egl-backend.pc
 wayland-egl.pc
 wayland-scanner.pc
 wayland-server.pc
share/aclocal/wayland-scanner.m4
share/man/man3/
 wl_argument.3.gz
 wl_array.3.gz
 wl_client.3.gz
 wl_display.3.gz
 wl_display_connect.3.gz
 wl_display_connect_to_fd.3.gz
 wl_event_loop.3.gz
 wl_event_queue.3.gz
 wl_event_source.3.gz
 wl_global.3.gz
 wl_interface.3.gz
 wl_list.3.gz
 wl_listener.3.gz
 wl_message.3.gz
 wl_object.3.gz
 wl_protocol_logger.3.gz
 wl_protocol_logger_message.3.gz
 wl_proxy.3.gz
 wl_resource.3.gz
 wl_resource_iterator_context.3.gz
 wl_shm_buffer.3.gz
 wl_shm_pool.3.gz
 wl_shm_sigbus_data.3.gz
 wl_signal.3.gz
 wl_socket.3.gz
share/wayland/
 wayland-scanner.mk
 wayland.dtd
 wayland.xml


[FILE:607:patches/patch-config.h.in]
--- config.h.in.orig	2019-03-21 00:55:29 UTC
+++ config.h.in
@@ -36,12 +36,18 @@
 /* Define to 1 if you have the <string.h> header file. */
 #undef HAVE_STRING_H
 
+/* Define to 1 if you have the <sys/param.h> header file. */
+#undef HAVE_SYS_PARAM_H
+
 /* Define to 1 if you have the <sys/prctl.h> header file. */
 #undef HAVE_SYS_PRCTL_H
 
 /* Define to 1 if you have the <sys/stat.h> header file. */
 #undef HAVE_SYS_STAT_H
 
+/* Define to 1 if you have the <sys/ucred.h> header file. */
+#undef HAVE_SYS_UCRED_H
+
 /* Define to 1 if you have the <sys/types.h> header file. */
 #undef HAVE_SYS_TYPES_H
 


[FILE:378:patches/patch-cursor_wayland-cursor.c]
--- cursor/wayland-cursor.c.orig	2019-03-21 00:55:25 UTC
+++ cursor/wayland-cursor.c
@@ -98,7 +98,11 @@ shm_pool_resize(struct shm_pool *pool, i
 
 	pool->data = mmap(NULL, size, PROT_READ | PROT_WRITE, MAP_SHARED,
 			  pool->fd, 0);
+#if defined(__DragonFly__)
+	if (pool->data == MAP_FAILED)
+#else
 	if (pool->data == (void *)-1)
+#endif
 		return 0;
 	pool->size = size;
 


[FILE:376:patches/patch-src_scanner.c]
--- src/scanner.c.orig	2019-03-21 00:55:25 UTC
+++ src/scanner.c
@@ -1956,7 +1956,7 @@ int main(int argc, char *argv[])
 		buf = XML_GetBuffer(ctx.parser, XML_BUFFER_SIZE);
 		len = fread(buf, 1, XML_BUFFER_SIZE, input);
 		if (len < 0) {
-			fprintf(stderr, "fread: %m\n");
+			fprintf(stderr, "fread: %s\n", strerror(errno));
 			fclose(input);
 			exit(EXIT_FAILURE);
 		}


[FILE:2843:patches/patch-src_wayland-server.c]
--- src/wayland-server.c.orig	2019-03-21 00:55:25 UTC
+++ src/wayland-server.c
@@ -43,6 +43,13 @@
 #include <sys/file.h>
 #include <sys/stat.h>
 
+#include "../config.h"
+
+#ifdef HAVE_SYS_UCRED_H
+#include <sys/types.h>
+#include <sys/ucred.h>
+#endif
+
 #include "wayland-util.h"
 #include "wayland-private.h"
 #include "wayland-server.h"
@@ -77,7 +84,11 @@ struct wl_client {
 	struct wl_list link;
 	struct wl_map objects;
 	struct wl_priv_signal destroy_signal;
+#ifdef HAVE_SYS_UCRED_H
+	struct xucred xucred;
+#else
 	struct ucred ucred;
+#endif
 	int error;
 	struct wl_priv_signal resource_created_signal;
 };
@@ -312,7 +323,11 @@ wl_resource_post_error(struct wl_resourc
 static void
 destroy_client_with_error(struct wl_client *client, const char *reason)
 {
+#ifdef HAVE_SYS_UCRED_H
+	wl_log("%s (uid %u)\n", reason, client->xucred.cr_uid);
+#else
 	wl_log("%s (pid %u)\n", reason, client->ucred.pid);
+#endif
 	wl_client_destroy(client);
 }
 
@@ -511,7 +526,9 @@ WL_EXPORT struct wl_client *
 wl_client_create(struct wl_display *display, int fd)
 {
 	struct wl_client *client;
+#ifndef HAVE_SYS_UCRED_H
 	socklen_t len;
+#endif
 
 	client = zalloc(sizeof *client);
 	if (client == NULL)
@@ -526,10 +543,12 @@ wl_client_create(struct wl_display *disp
 	if (!client->source)
 		goto err_client;
 
+#ifndef HAVE_SYS_UCRED_H
 	len = sizeof client->ucred;
 	if (getsockopt(fd, SOL_SOCKET, SO_PEERCRED,
 		       &client->ucred, &len) < 0)
 		goto err_source;
+#endif
 
 	client->connection = wl_connection_create(fd);
 	if (client->connection == NULL)
@@ -583,12 +602,21 @@ WL_EXPORT void
 wl_client_get_credentials(struct wl_client *client,
 			  pid_t *pid, uid_t *uid, gid_t *gid)
 {
+#ifdef HAVE_SYS_UCRED_H
+	if (pid)
+		*pid = 0;
+	if (uid)
+		*uid = client->xucred.cr_uid;
+	if (gid)
+		*gid = client->xucred.cr_gid;
+#else
 	if (pid)
 		*pid = client->ucred.pid;
 	if (uid)
 		*uid = client->ucred.uid;
 	if (gid)
 		*gid = client->ucred.gid;
+#endif
 }
 
 /** Get the file descriptor for the client
@@ -1362,7 +1390,7 @@ socket_data(int fd, uint32_t mask, void
 	client_fd = wl_os_accept_cloexec(fd, (struct sockaddr *) &name,
 					 &length);
 	if (client_fd < 0)
-		wl_log("failed to accept: %m\n");
+		wl_log("failed to accept: %s\n", strerror(errno));
 	else
 		if (!wl_client_create(display, client_fd))
 			close(client_fd);
@@ -1467,12 +1495,12 @@ _wl_display_add_socket(struct wl_display
 
 	size = offsetof (struct sockaddr_un, sun_path) + strlen(s->addr.sun_path);
 	if (bind(s->fd, (struct sockaddr *) &s->addr, size) < 0) {
-		wl_log("bind() failed with error: %m\n");
+		wl_log("bind() failed with error: %s\n", strerror(errno));
 		return -1;
 	}
 
 	if (listen(s->fd, 128) < 0) {
-		wl_log("listen() failed with error: %m\n");
+		wl_log("listen() failed with error: %s\n", strerror(errno));
 		return -1;
 	}
 


[FILE:236:patches/patch-src_wayland-util.c]
--- src/wayland-util.c.orig	2019-03-21 00:55:25 UTC
+++ src/wayland-util.c
@@ -29,6 +29,7 @@
 #include <stdio.h>
 #include <string.h>
 #include <stdarg.h>
+#include <pthread.h>
 
 #include "wayland-util.h"
 #include "wayland-private.h"


[FILE:1205:patches/patch-tests_test-compositor.c]
--- tests/test-compositor.c.orig	2019-03-21 00:55:25 UTC
+++ tests/test-compositor.c
@@ -97,12 +97,33 @@ handle_client_destroy(void *data)
 {
 	struct client_info *ci = data;
 	struct display *d;
-	siginfo_t status;
+#ifdef __DragonFly__
+	int status;
+#else
+ 	siginfo_t status;
+#endif
 
 	d = ci->display;
 
-	assert(waitid(P_PID, ci->pid, &status, WEXITED) != -1);
+#ifdef __DragonFly__
+	assert(waitpid(ci->pid, &status, 0) != -1);
+#else
+ 	assert(waitid(P_PID, ci->pid, &status, WEXITED) != -1);
+#endif
 
+#ifdef __DragonFly__
+	if (WIFEXITED(status)) {
+		if (WEXITSTATUS(status) != EXIT_SUCCESS)
+			fprintf(stderr, "Client '%s' exited with code %d\n",
+				ci->name, WEXITSTATUS(status));
+
+		ci->exit_code = WEXITSTATUS(status);
+	} else if (WIFSIGNALED(status) || WCOREDUMP(status)) {
+		fprintf(stderr, "Client '%s' was killed by signal %d\n",
+			ci->name, WTERMSIG(status));
+		ci->exit_code = WEXITSTATUS(status);
+	}
+#else
 	switch (status.si_code) {
 	case CLD_KILLED:
 	case CLD_DUMPED:
@@ -118,6 +139,7 @@ handle_client_destroy(void *data)
 		ci->exit_code = status.si_status;
 		break;
 	}
+#endif
 
 	++d->clients_terminated_no;
 	if (d->clients_no == d->clients_terminated_no) {


[FILE:2492:patches/patch-tests_test-runner.c]
--- tests/test-runner.c.orig	2019-03-21 00:55:25 UTC
+++ tests/test-runner.c
@@ -28,6 +28,7 @@
 #include <unistd.h>
 #include <stdio.h>
 #include <stdlib.h>
+#include <signal.h>
 #include <sys/types.h>
 #include <sys/wait.h>
 #include <sys/stat.h>
@@ -37,7 +38,9 @@
 #include <errno.h>
 #include <limits.h>
 #include <sys/ptrace.h>
+#ifndef __DragonFly__
 #include <sys/prctl.h>
+#endif
 #ifndef PR_SET_PTRACER
 # define PR_SET_PTRACER 0x59616d61
 #endif
@@ -255,17 +258,22 @@ is_debugger_attached(void)
 		close(pipefd[0]);
 		if (buf == '-')
 			_exit(1);
+#ifndef __DragonFly__
 		if (ptrace(PTRACE_ATTACH, ppid, NULL, NULL) != 0)
 			_exit(1);
+#endif
 		if (!waitpid(-1, NULL, 0))
 			_exit(1);
+#ifndef __DragonFly__
 		ptrace(PTRACE_CONT, NULL, NULL);
 		ptrace(PTRACE_DETACH, ppid, NULL, NULL);
+#endif
 		_exit(0);
 	} else {
 		close(pipefd[0]);
 
 		/* Enable child to ptrace the parent process */
+#ifndef __DragonFly__
 		rc = prctl(PR_SET_PTRACER, pid);
 		if (rc != 0 && errno != EINVAL) {
 			/* An error prevents us from telling if a debugger is attached.
@@ -279,6 +287,7 @@ is_debugger_attached(void)
 			/* Signal to client that parent is ready by passing '+' */
 			write(pipefd[1], "+", 1);
 		}
+#endif
 		close(pipefd[1]);
 
 		waitpid(pid, &status, 0);
@@ -293,7 +302,11 @@ int main(int argc, char *argv[])
 	const struct test *t;
 	pid_t pid;
 	int total, pass;
+#ifdef __DragonFly__
+	int status;
+#else
 	siginfo_t info;
+#endif
 
 	if (isatty(fileno(stderr)))
 		is_atty = 1;
@@ -336,6 +349,12 @@ int main(int argc, char *argv[])
 		if (pid == 0)
 			run_test(t); /* never returns */
 
+#ifdef __DragonFly__
+		if (wait(&status)) {
+			fprintf(stderr, "waitid failed: %m\n");
+			abort();
+		}
+#else
 		if (waitid(P_PID, pid, &info, WEXITED)) {
 			stderr_set_color(RED);
 			fprintf(stderr, "waitid failed: %m\n");
@@ -343,7 +362,20 @@ int main(int argc, char *argv[])
 
 			abort();
 		}
+#endif
 
+		fprintf(stderr, "test \"%s\":\t", t->name);
+#ifdef __DragonFly__
+		if (WIFEXITED(status)) {
+			fprintf(stderr, "exit status %d", WEXITSTATUS(status));
+			if (WEXITSTATUS(status) == EXIT_SUCCESS)
+				success = 1;
+			break;
+		} else if (WIFSIGNALED(status) || WCOREDUMP(status)) {
+			fprintf(stderr, "signal %d", WTERMSIG(status));
+			break;
+		}
+#else
 		switch (info.si_code) {
 		case CLD_EXITED:
 			if (info.si_status == EXIT_SUCCESS)
@@ -367,6 +399,7 @@ int main(int argc, char *argv[])
 
 			break;
 		}
+#endif
 
 		if (success) {
 			pass++;


[FILE:805:dragonfly/patch-Makefile.am]
--- Makefile.am.orig	2019-03-21 00:55:25 UTC
+++ Makefile.am
@@ -170,7 +170,6 @@ built_test_programs =				\
 	interface-test				\
 	list-test				\
 	map-test				\
-	os-wrappers-test			\
 	sanity-test				\
 	socket-test				\
 	queue-test				\
@@ -227,7 +226,7 @@ libtest_runner_la_LIBADD =			\
 	libwayland-client.la			\
 	libwayland-server.la			\
 	libtest-helpers.la			\
-	-lrt -ldl $(FFI_LIBS)
+	-lrt -ldl $(FFI_LIBS) $(KVM_LIBS)
 
 array_test_SOURCES = tests/array-test.c
 array_test_LDADD = libtest-runner.la
@@ -283,9 +282,6 @@ endif
 
 fixed_benchmark_SOURCES = tests/fixed-benchmark.c
 
-os_wrappers_test_SOURCES = tests/os-wrappers-test.c
-os_wrappers_test_LDADD = libtest-runner.la
-
 exec_fd_leak_checker_SOURCES = tests/exec-fd-leak-checker.c
 exec_fd_leak_checker_LDADD = libtest-helpers.la
 


[FILE:2102:dragonfly/patch-configure.ac]
--- configure.ac.orig	2019-03-21 00:55:25 UTC
+++ configure.ac
@@ -65,6 +65,12 @@ AC_SUBST(GCC_CFLAGS)
 AC_CHECK_HEADERS([sys/prctl.h])
 AC_CHECK_FUNCS([accept4 mkostemp posix_fallocate prctl])
 
+# Credential support on BSD
+AC_CHECK_HEADERS([sys/ucred.h])
+
+# Defines __FreeBSD__ if we're on FreeBSD, same for other *BSD
+AC_CHECK_HEADERS([sys/param.h])
+
 AC_ARG_ENABLE([libraries],
 	      [AC_HELP_STRING([--disable-libraries],
 			      [Disable compilation of wayland libraries])],
@@ -100,15 +106,15 @@ AC_SUBST([ICONDIR])
 
 if test "x$enable_libraries" = "xyes"; then
 	PKG_CHECK_MODULES(FFI, [libffi])
-	AC_CHECK_DECL(SFD_CLOEXEC,[],
-		      [AC_MSG_ERROR("SFD_CLOEXEC is needed to compile wayland libraries")],
-		      [[#include <sys/signalfd.h>]])
-	AC_CHECK_DECL(TFD_CLOEXEC,[],
-		      [AC_MSG_ERROR("TFD_CLOEXEC is needed to compile wayland libraries")],
-		      [[#include <sys/timerfd.h>]])
-	AC_CHECK_DECL(CLOCK_MONOTONIC,[],
-		      [AC_MSG_ERROR("CLOCK_MONOTONIC is needed to compile wayland libraries")],
-		      [[#include <time.h>]])
+#	AC_CHECK_DECL(SFD_CLOEXEC,[],
+#		      [AC_MSG_ERROR("SFD_CLOEXEC is needed to compile wayland libraries")],
+#		      [[#include <sys/signalfd.h>]])
+#	AC_CHECK_DECL(TFD_CLOEXEC,[],
+#		      [AC_MSG_ERROR("TFD_CLOEXEC is needed to compile wayland libraries")],
+#		      [[#include <sys/timerfd.h>]])
+#	AC_CHECK_DECL(CLOCK_MONOTONIC,[],
+#		      [AC_MSG_ERROR("CLOCK_MONOTONIC is needed to compile wayland libraries")],
+#		      [[#include <time.h>]])
 fi
 
 PKG_CHECK_MODULES(EXPAT, [expat])
@@ -124,7 +130,7 @@ AC_PATH_PROG(XSLTPROC, xsltproc)
 AM_CONDITIONAL([HAVE_XSLTPROC], [test "x$XSLTPROC" != "x"])
 
 AC_MSG_CHECKING([for docbook manpages stylesheet])
-MANPAGES_STYLESHEET=http://docbook.sourceforge.net/release/xsl/current/manpages/docbook.xsl
+MANPAGES_STYLESHEET=http://cdn.docbook.org/release/xsl/current/manpages/docbook.xsl
 AC_PATH_PROGS_FEATURE_CHECK([XSLTPROC_TMP], [xsltproc],
 			    AS_IF([`"$ac_path_XSLTPROC_TMP" --nonet "$MANPAGES_STYLESHEET" > /dev/null 2>&1`],
 				  [HAVE_MANPAGES_STYLESHEET=yes]))


[FILE:1381:dragonfly/patch-src_connection.c]
--- src/connection.c.orig	2019-03-21 00:55:25 UTC
+++ src/connection.c
@@ -38,6 +38,7 @@
 #include <sys/types.h>
 #include <sys/socket.h>
 #include <time.h>
+#include <poll.h>
 #include <ffi.h>
 
 #include "wayland-util.h"
@@ -307,7 +308,10 @@ wl_connection_flush(struct wl_connection
 		msg.msg_namelen = 0;
 		msg.msg_iov = iov;
 		msg.msg_iovlen = count;
-		msg.msg_control = (clen > 0) ? cmsg : NULL;
+		if (clen == 0)
+			msg.msg_control = NULL;
+		else
+			msg.msg_control = cmsg;
 		msg.msg_controllen = clen;
 		msg.msg_flags = 0;
 
@@ -378,11 +382,25 @@ int
 wl_connection_write(struct wl_connection *connection,
 		    const void *data, size_t count)
 {
-	if (connection->out.head - connection->out.tail +
+	struct pollfd pfd;
+
+	while (connection->out.head - connection->out.tail +
 	    count > ARRAY_LENGTH(connection->out.data)) {
-		connection->want_flush = 1;
-		if (wl_connection_flush(connection) < 0)
-			return -1;
+		if (wl_connection_flush(connection) < 0) {
+			if (errno == EAGAIN) {
+				pfd.fd = connection->fd;
+				pfd.events = POLLWRNORM;
+				pfd.revents = 0;
+				int ret;
+				do {
+					ret = poll(&pfd, 1, -1);
+				} while (ret == -1 && errno == EINTR);
+			} else {
+				wl_log("%s: wl_connection_flush failed: %s\n",
+				    __func__, strerror(errno));
+				return -1;
+			}
+		}
 	}
 
 	if (wl_buffer_put(&connection->out, data, count) < 0)


[FILE:14391:dragonfly/patch-src_event-loop.c]
--- src/event-loop.c.orig	2019-03-21 00:55:25 UTC
+++ src/event-loop.c
@@ -25,6 +25,7 @@
 
 #include <stddef.h>
 #include <stdio.h>
+#include <err.h>
 #include <errno.h>
 #include <signal.h>
 #include <stdlib.h>
@@ -34,9 +35,9 @@
 #include <fcntl.h>
 #include <sys/socket.h>
 #include <sys/un.h>
-#include <sys/epoll.h>
-#include <sys/signalfd.h>
-#include <sys/timerfd.h>
+#include <sys/types.h>
+#include <sys/event.h>
+#include <sys/time.h>
 #include <unistd.h>
 #include "wayland-util.h"
 #include "wayland-private.h"
@@ -46,7 +47,7 @@
 /** \cond INTERNAL */
 
 struct wl_event_loop {
-	int epoll_fd;
+	int event_fd;
 	struct wl_list check_list;
 	struct wl_list idle_list;
 	struct wl_list destroy_list;
@@ -56,7 +57,7 @@ struct wl_event_loop {
 
 struct wl_event_source_interface {
 	int (*dispatch)(struct wl_event_source *source,
-			struct epoll_event *ep);
+			struct kevent *ev);
 };
 
 struct wl_event_source {
@@ -77,22 +78,22 @@ struct wl_event_source_fd {
 
 static int
 wl_event_source_fd_dispatch(struct wl_event_source *source,
-			    struct epoll_event *ep)
+			    struct kevent *ev)
 {
 	struct wl_event_source_fd *fd_source = (struct wl_event_source_fd *) source;
 	uint32_t mask;
 
 	mask = 0;
-	if (ep->events & EPOLLIN)
+	if (ev->filter == EVFILT_READ)
 		mask |= WL_EVENT_READABLE;
-	if (ep->events & EPOLLOUT)
+	if (ev->filter == EVFILT_WRITE)
 		mask |= WL_EVENT_WRITABLE;
-	if (ep->events & EPOLLHUP)
+	if (ev->flags & EV_EOF)
 		mask |= WL_EVENT_HANGUP;
-	if (ep->events & EPOLLERR)
+	if (ev->flags & EV_ERROR)
 		mask |= WL_EVENT_ERROR;
 
-	return fd_source->func(fd_source->fd, mask, source->data);
+	return fd_source->func(source->fd, mask, source->data);
 }
 
 struct wl_event_source_interface fd_source_interface = {
@@ -103,30 +104,10 @@ static struct wl_event_source *
 add_source(struct wl_event_loop *loop,
 	   struct wl_event_source *source, uint32_t mask, void *data)
 {
-	struct epoll_event ep;
-
-	if (source->fd < 0) {
-		free(source);
-		return NULL;
-	}
-
 	source->loop = loop;
 	source->data = data;
 	wl_list_init(&source->link);
 
-	memset(&ep, 0, sizeof ep);
-	if (mask & WL_EVENT_READABLE)
-		ep.events |= EPOLLIN;
-	if (mask & WL_EVENT_WRITABLE)
-		ep.events |= EPOLLOUT;
-	ep.data.ptr = source;
-
-	if (epoll_ctl(loop->epoll_fd, EPOLL_CTL_ADD, source->fd, &ep) < 0) {
-		close(source->fd);
-		free(source);
-		return NULL;
-	}
-
 	return source;
 }
 
@@ -162,6 +143,9 @@ wl_event_loop_add_fd(struct wl_event_loo
 {
 	struct wl_event_source_fd *source;
 
+	struct kevent events[2];
+	unsigned int num_events = 0;
+
 	source = malloc(sizeof *source);
 	if (source == NULL)
 		return NULL;
@@ -170,8 +154,36 @@ wl_event_loop_add_fd(struct wl_event_loo
 	source->base.fd = wl_os_dupfd_cloexec(fd, 0);
 	source->func = func;
 	source->fd = fd;
+	add_source(loop, &source->base, mask, data);
 
-	return add_source(loop, &source->base, mask, data);
+	if (source->base.fd < 0) {
+		fprintf(stderr, "Could not add source\n: %s\n",
+		        strerror(errno));
+		free(source);
+		return NULL;
+	}
+
+	if (mask & WL_EVENT_READABLE) {
+		EV_SET(&events[num_events], source->base.fd, EVFILT_READ,
+		      EV_ADD | EV_ENABLE, 0, 0, &source->base);
+		num_events++;
+	}
+
+	if (mask & WL_EVENT_WRITABLE) {
+		EV_SET(&events[num_events], source->base.fd, EVFILT_WRITE,
+		      EV_ADD | EV_ENABLE, 0, 0, &source->base);
+		num_events++;
+	}
+
+	if (kevent(loop->event_fd, events, num_events, NULL, 0, NULL) < 0) {
+		fprintf(stderr, "Error adding source %i (%p) to loop %p: %s\n",
+		       source->fd, source, loop, strerror(errno));
+		close(source->base.fd);
+		free(source);
+		return NULL;
+	}
+
+	return &source->base;
 }
 
 /** Update a file descriptor source's event mask
@@ -198,16 +210,22 @@ WL_EXPORT int
 wl_event_source_fd_update(struct wl_event_source *source, uint32_t mask)
 {
 	struct wl_event_loop *loop = source->loop;
-	struct epoll_event ep;
+	struct kevent events[2];
+	unsigned int num_events = 0;
 
-	memset(&ep, 0, sizeof ep);
-	if (mask & WL_EVENT_READABLE)
-		ep.events |= EPOLLIN;
-	if (mask & WL_EVENT_WRITABLE)
-		ep.events |= EPOLLOUT;
-	ep.data.ptr = source;
+	if (mask & WL_EVENT_READABLE) {
+		EV_SET(&events[num_events], source->fd, EVFILT_READ,
+		       EV_ADD | EV_ENABLE, 0, 0, source);
+		num_events++;
+	}
 
-	return epoll_ctl(loop->epoll_fd, EPOLL_CTL_MOD, source->fd, &ep);
+	if (mask & WL_EVENT_WRITABLE) {
+		EV_SET(&events[num_events], source->fd, EVFILT_WRITE,
+		       EV_ADD | EV_ENABLE, 0, 0, source);
+		num_events++;
+	}
+
+	return kevent(loop->event_fd, events, num_events, NULL, 0, NULL);
 }
 
 /** \cond INTERNAL */
@@ -221,18 +239,13 @@ struct wl_event_source_timer {
 
 static int
 wl_event_source_timer_dispatch(struct wl_event_source *source,
-			       struct epoll_event *ep)
+			       struct kevent *ev)
 {
 	struct wl_event_source_timer *timer_source =
 		(struct wl_event_source_timer *) source;
 	uint64_t expires;
-	int len;
-
-	len = read(source->fd, &expires, sizeof expires);
-	if (!(len == -1 && errno == EAGAIN) && len != sizeof expires)
-		/* Is there anything we can do here?  Will this ever happen? */
-		wl_log("timerfd read error: %m\n");
 
+	expires = ev->data;    /* XXX unused?! */
 	return timer_source->func(timer_source->base.data);
 }
 
@@ -258,18 +271,36 @@ wl_event_loop_add_timer(struct wl_event_
 			wl_event_loop_timer_func_t func,
 			void *data)
 {
+	static int timer_id = 0;
 	struct wl_event_source_timer *source;
+	struct kevent ev;
 
 	source = malloc(sizeof *source);
 	if (source == NULL)
 		return NULL;
-
 	source->base.interface = &timer_source_interface;
-	source->base.fd = timerfd_create(CLOCK_MONOTONIC,
-					 TFD_CLOEXEC | TFD_NONBLOCK);
+	source->base.fd = timer_id;
+	timer_id++;
+	source->base.loop = loop;
+	source->base.data = data;
 	source->func = func;
+	wl_list_init(&source->base.link);
+
+	/*
+	 * We need to add timer filter already here. This avoids error messages
+	 * when the timer filter is removed before ever updating it.
+	 * Note the timer will not be enabled, this happens only in the update
+	 * routine which arms/disarms the timer.)
+	 */
+	EV_SET(&ev, source->base.fd, EVFILT_TIMER, EV_ADD | EV_DISABLE,
+	       0, 0, NULL);
+	if (kevent(loop->event_fd, &ev, 1, NULL, 0, NULL) < 0) {
+		fprintf(stderr, "Could not add timer: %s\n",
+		        strerror(errno));
+		return NULL;
+	}
 
-	return add_source(loop, &source->base, WL_EVENT_READABLE, data);
+	return &source->base;
 }
 
 /** Arm or disarm a timer
@@ -291,14 +322,21 @@ wl_event_loop_add_timer(struct wl_event_
 WL_EXPORT int
 wl_event_source_timer_update(struct wl_event_source *source, int ms_delay)
 {
-	struct itimerspec its;
+	struct kevent ev;
 
-	its.it_interval.tv_sec = 0;
-	its.it_interval.tv_nsec = 0;
-	its.it_value.tv_sec = ms_delay / 1000;
-	its.it_value.tv_nsec = (ms_delay % 1000) * 1000 * 1000;
-	if (timerfd_settime(source->fd, 0, &its, NULL) < 0)
+	if (ms_delay == 0) {
+		EV_SET(&ev, source->fd, EVFILT_TIMER, EV_ADD | EV_DISABLE,
+		       0, ms_delay, source);
+	} else {
+		EV_SET(&ev, source->fd, EVFILT_TIMER,
+		       EV_ADD | EV_ENABLE | EV_ONESHOT, 0, ms_delay, source);
+	}
+
+	if (kevent(source->loop->event_fd, &ev, 1, NULL, 0, NULL) < 0) {
+		fprintf(stderr, "Could not set kqueue timer: %s\n",
+		        strerror(errno));
 		return -1;
+	}
 
 	return 0;
 }
@@ -315,19 +353,13 @@ struct wl_event_source_signal {
 
 static int
 wl_event_source_signal_dispatch(struct wl_event_source *source,
-				struct epoll_event *ep)
+				struct kevent *ev)
 {
-	struct wl_event_source_signal *signal_source =
-		(struct wl_event_source_signal *) source;
-	struct signalfd_siginfo signal_info;
-	int len;
-
-	len = read(source->fd, &signal_info, sizeof signal_info);
-	if (!(len == -1 && errno == EAGAIN) && len != sizeof signal_info)
-		/* Is there anything we can do here?  Will this ever happen? */
-		wl_log("signalfd read error: %m\n");
+	struct wl_event_source_signal *signal_source;
 
-	return signal_source->func(signal_source->signal_number,
+	signal_source = (struct wl_event_source_signal *) source;
+
+	return signal_source->func(signal_source->base.fd,
 				   signal_source->base.data);
 }
 
@@ -362,6 +394,7 @@ wl_event_loop_add_signal(struct wl_event
 {
 	struct wl_event_source_signal *source;
 	sigset_t mask;
+	struct kevent ev;
 
 	source = malloc(sizeof *source);
 	if (source == NULL)
@@ -369,15 +402,26 @@ wl_event_loop_add_signal(struct wl_event
 
 	source->base.interface = &signal_source_interface;
 	source->signal_number = signal_number;
+	source->func = func;
 
 	sigemptyset(&mask);
 	sigaddset(&mask, signal_number);
-	source->base.fd = signalfd(-1, &mask, SFD_CLOEXEC | SFD_NONBLOCK);
 	sigprocmask(SIG_BLOCK, &mask, NULL);
 
-	source->func = func;
+	source->base.fd = 0;
+	add_source(loop, &source->base, WL_EVENT_READABLE, data);
+
+	EV_SET(&ev, signal_number, EVFILT_SIGNAL, EV_ADD | EV_ENABLE, 0, 0,
+	       source);
 
-	return add_source(loop, &source->base, WL_EVENT_READABLE, data);
+	if (kevent(loop->event_fd, &ev, 1, NULL, 0, NULL) < 0) {
+		fprintf(stderr, "Error adding signal for %i (%p), %p: %s\n",
+			signal_number, source, loop, strerror(errno));
+		free(source);
+		return NULL;
+	}
+
+	return &source->base;
 }
 
 /** \cond INTERNAL */
@@ -474,15 +518,85 @@ WL_EXPORT int
 wl_event_source_remove(struct wl_event_source *source)
 {
 	struct wl_event_loop *loop = source->loop;
+	int ret = 0, saved_errno = 0;
+
+	/*
+	 * Since BSD doesn't treat all event sources as FDs, we need to
+	 * differentiate by source interface.
+	 */
+	if (source->interface == &fd_source_interface && source->fd >= 0) {
+		struct kevent ev[2];
+		int _ret[2], _saved_errno[2];
+
+		/*
+		 * We haven't stored state about the mask used when adding the
+		 * source, so we have to try and remove both READ and WRITE
+		 * filters. One may fail, which is OK. Removal of the source has
+		 * only failed if _both_ kevent() calls fail. We have to do two
+		 * kevent() calls so that we can get independent return values
+		 * for the two kevents.
+		 */
+		EV_SET(&ev[0], source->fd, EVFILT_READ, EV_DELETE, 0, 0,
+		      source);
+		EV_SET(&ev[1], source->fd, EVFILT_WRITE, EV_DELETE, 0, 0,
+		      source);
+
+		_ret[0] = kevent(loop->event_fd, &ev[0], 1, NULL, 0, NULL);
+		_saved_errno[0] = errno;
+		_ret[1] = kevent(loop->event_fd, &ev[1], 1, NULL, 0, NULL);
+		_saved_errno[1] = errno;
+
+		if (_ret[0] >= _ret[1]) {
+			ret = _ret[0];
+			saved_errno = _saved_errno[0];
+		} else {
+			ret = _ret[1];
+			saved_errno = _saved_errno[1];
+		}
+
+		if ((_ret[0] < 0) && (_ret[1] < 0)) {
+			fprintf(stderr,
+			        "Error removing fd = %i from kqueue: %s\n",
+			        source->fd, strerror(saved_errno));
+		}
 
-	/* We need to explicitly remove the fd, since closing the fd
-	 * isn't enough in case we've dup'ed the fd. */
-	if (source->fd >= 0) {
-		epoll_ctl(loop->epoll_fd, EPOLL_CTL_DEL, source->fd, NULL);
 		close(source->fd);
-		source->fd = -1;
+	} else if (source->interface == &timer_source_interface) {
+		struct kevent ev;
+
+		EV_SET(&ev, source->fd, EVFILT_TIMER, EV_DELETE, 0, 0, source);
+		ret = kevent(loop->event_fd, &ev, 1, NULL, 0, NULL);
+		saved_errno = errno;
+
+		if (ret < 0) {
+			fprintf(stderr,
+			        "Error removing timer = %i from kqueue: %s\n",
+			        source->fd, strerror(saved_errno));
+	}
+	} else if (source->interface == &signal_source_interface) {
+		struct kevent ev;
+		int signal_number;
+		struct wl_event_source_signal *_source;
+
+		/* Only one kevent() call needed. */
+		_source = (struct wl_event_source_signal *) source;
+		signal_number = _source->signal_number;
+
+		EV_SET(&ev, signal_number, EVFILT_SIGNAL, EV_DELETE, 0, 0,
+		      source);
+		ret = kevent(loop->event_fd, &ev, 1, NULL, 0, NULL);
+		saved_errno = errno;
+
+		if (ret < 0) {
+			fprintf(stderr,
+			        "Error removing signal = %i from kqueue: %s\n",
+			        source->fd, strerror(saved_errno));
+		}
 	}
 
+	/* Tidy up the source. */
+	source->fd = -1;
+
 	wl_list_remove(&source->link);
 	wl_list_insert(&loop->destroy_list, &source->link);
 
@@ -523,8 +637,8 @@ wl_event_loop_create(void)
 	if (loop == NULL)
 		return NULL;
 
-	loop->epoll_fd = wl_os_epoll_create_cloexec();
-	if (loop->epoll_fd < 0) {
+	loop->event_fd = wl_os_kqueue_create_cloexec();
+	if (loop->event_fd < 0) {
 		free(loop);
 		return NULL;
 	}
@@ -556,22 +670,21 @@ wl_event_loop_destroy(struct wl_event_lo
 	wl_signal_emit(&loop->destroy_signal, loop);
 
 	wl_event_loop_process_destroy_list(loop);
-	close(loop->epoll_fd);
+	close(loop->event_fd);
 	free(loop);
 }
 
 static bool
 post_dispatch_check(struct wl_event_loop *loop)
 {
-	struct epoll_event ep;
+	struct kevent ev;
 	struct wl_event_source *source, *next;
 	bool needs_recheck = false;
 
-	ep.events = 0;
 	wl_list_for_each_safe(source, next, &loop->check_list, link) {
 		int dispatch_result;
 
-		dispatch_result = source->interface->dispatch(source, &ep);
+		dispatch_result = source->interface->dispatch(source, &ev);
 		if (dispatch_result < 0) {
 			wl_log("Source dispatch function returned negative value!");
 			wl_log("This would previously accidentally suppress a follow-up dispatch");
@@ -625,20 +738,27 @@ wl_event_loop_dispatch_idle(struct wl_ev
 WL_EXPORT int
 wl_event_loop_dispatch(struct wl_event_loop *loop, int timeout)
 {
-	struct epoll_event ep[32];
+	struct kevent ev[64];
 	struct wl_event_source *source;
 	int i, count;
+	struct timespec timeout_spec;
 
 	wl_event_loop_dispatch_idle(loop);
 
-	count = epoll_wait(loop->epoll_fd, ep, ARRAY_LENGTH(ep), timeout);
+	/* timeout is provided in milliseconds */
+	timeout_spec.tv_sec = timeout / 1000;
+	timeout_spec.tv_nsec = (timeout % 1000) * 1000000;
+
+	count = kevent(loop->event_fd, NULL, 0, ev, ARRAY_LENGTH(ev),
+	               (timeout != -1) ? &timeout_spec : NULL);
 	if (count < 0)
 		return -1;
 
 	for (i = 0; i < count; i++) {
-		source = ep[i].data.ptr;
-		if (source->fd != -1)
-			source->interface->dispatch(source, &ep[i]);
+		source = ev[i].udata;
+		if (source->fd != -1) {
+		       source->interface->dispatch(source, &ev[i]);
+		}
 	}
 
 	wl_event_loop_process_destroy_list(loop);
@@ -669,7 +789,7 @@ wl_event_loop_dispatch(struct wl_event_l
 WL_EXPORT int
 wl_event_loop_get_fd(struct wl_event_loop *loop)
 {
-	return loop->epoll_fd;
+	return loop->event_fd;
 }
 
 /** Register a destroy listener for an event loop context


[FILE:1277:dragonfly/patch-src_wayland-os.c]
--- src/wayland-os.c.orig	2019-03-21 00:55:25 UTC
+++ src/wayland-os.c
@@ -30,7 +30,7 @@
 #include <unistd.h>
 #include <fcntl.h>
 #include <errno.h>
-#include <sys/epoll.h>
+#include <sys/event.h>
 
 #include "../config.h"
 #include "wayland-os.h"
@@ -62,11 +62,13 @@ wl_os_socket_cloexec(int domain, int typ
 {
 	int fd;
 
+#ifdef SOCK_CLOEXEC
 	fd = socket(domain, type | SOCK_CLOEXEC, protocol);
 	if (fd >= 0)
 		return fd;
 	if (errno != EINVAL)
 		return -1;
+#endif
 
 	fd = socket(domain, type, protocol);
 	return set_cloexec_or_close(fd);
@@ -121,6 +123,7 @@ recvmsg_cloexec_fallback(int sockfd, str
 ssize_t
 wl_os_recvmsg_cloexec(int sockfd, struct msghdr *msg, int flags)
 {
+#ifdef MSG_CMSG_CLOEXEC
 	ssize_t len;
 
 	len = recvmsg(sockfd, msg, flags | MSG_CMSG_CLOEXEC);
@@ -128,24 +131,17 @@ wl_os_recvmsg_cloexec(int sockfd, struct
 		return len;
 	if (errno != EINVAL)
 		return -1;
+#endif
 
 	return recvmsg_cloexec_fallback(sockfd, msg, flags);
 }
 
 int
-wl_os_epoll_create_cloexec(void)
+wl_os_kqueue_create_cloexec(void)
 {
 	int fd;
 
-#ifdef EPOLL_CLOEXEC
-	fd = epoll_create1(EPOLL_CLOEXEC);
-	if (fd >= 0)
-		return fd;
-	if (errno != EINVAL)
-		return -1;
-#endif
-
-	fd = epoll_create(1);
+	fd = kqueue();
 	return set_cloexec_or_close(fd);
 }
 


[FILE:327:dragonfly/patch-src_wayland-os.h]
--- src/wayland-os.h.orig	2019-03-21 00:55:25 UTC
+++ src/wayland-os.h
@@ -36,7 +36,7 @@ ssize_t
 wl_os_recvmsg_cloexec(int sockfd, struct msghdr *msg, int flags);
 
 int
-wl_os_epoll_create_cloexec(void);
+wl_os_kqueue_create_cloexec(void);
 
 int
 wl_os_accept_cloexec(int sockfd, struct sockaddr *addr, socklen_t *addrlen);


[FILE:3227:dragonfly/patch-src_wayland-shm.c]
--- src/wayland-shm.c.orig	2019-03-21 00:55:25 UTC
+++ src/wayland-shm.c
@@ -30,6 +30,10 @@
 
 #define _GNU_SOURCE
 
+#if defined(__DragonFly__)
+#include <sys/param.h>
+#endif
+
 #include <stdbool.h>
 #include <stdio.h>
 #include <stdlib.h>
@@ -40,6 +44,7 @@
 #include <assert.h>
 #include <signal.h>
 #include <pthread.h>
+#include <errno.h>
 
 #include "wayland-util.h"
 #include "wayland-private.h"
@@ -59,6 +64,9 @@ struct wl_shm_pool {
 	char *data;
 	int32_t size;
 	int32_t new_size;
+#if defined(__DragonFly__)
+	int fd;
+#endif
 };
 
 struct wl_shm_buffer {
@@ -84,7 +92,24 @@ shm_pool_finish_resize(struct wl_shm_poo
 	if (pool->size == pool->new_size)
 		return;
 
-	data = mremap(pool->data, pool->size, pool->new_size, MREMAP_MAYMOVE);
+#if defined(__DragonFly__)
+	int32_t osize = (pool->size + PAGE_SIZE - 1) & ~PAGE_MASK;
+	if (pool->new_size <= osize) {
+		pool->size = pool->new_size;
+		return;
+	}
+	data = mmap(pool->data + osize, pool->new_size - osize, PROT_READ,
+	    MAP_SHARED | MAP_TRYFIXED, pool->fd, osize);
+	if (data == MAP_FAILED) {
+		munmap(pool->data, pool->size);
+		data = mmap(NULL, pool->new_size, PROT_READ, MAP_SHARED, pool->fd, 0);
+	} else {
+		pool->size = pool->new_size;
+		return;
+	}
+#else
+ 	data = mremap(pool->data, pool->size, size, MREMAP_MAYMOVE);
+#endif
 	if (data == MAP_FAILED) {
 		wl_resource_post_error(pool->resource,
 				       WL_SHM_ERROR_INVALID_FD,
@@ -111,6 +136,9 @@ shm_pool_unref(struct wl_shm_pool *pool,
 		return;
 
 	munmap(pool->data, pool->size);
+#if defined(__DragonFly__)
+	close(pool->fd);
+#endif
 	free(pool);
 }
 
@@ -235,6 +263,8 @@ shm_pool_resize(struct wl_client *client
 				       "shrinking pool invalid");
 		return;
 	}
+	if (size == pool->size)
+		return;
 
 	pool->new_size = size;
 
@@ -276,21 +306,28 @@ shm_create_pool(struct wl_client *client
 	pool->external_refcount = 0;
 	pool->size = size;
 	pool->new_size = size;
-	pool->data = mmap(NULL, size,
-			  PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);
+	pool->data = mmap(NULL, size, PROT_READ, MAP_SHARED, fd, 0);
 	if (pool->data == MAP_FAILED) {
 		wl_resource_post_error(resource,
 				       WL_SHM_ERROR_INVALID_FD,
-				       "failed mmap fd %d: %m", fd);
+				       "failed mmap fd %d: %s", fd,
+				       strerror(errno));
 		goto err_free;
 	}
-	close(fd);
+#if defined(__DragonFly__)
+	pool->fd = fd;
+#else
+ 	close(fd);
+#endif
 
 	pool->resource =
 		wl_resource_create(client, &wl_shm_pool_interface, 1, id);
 	if (!pool->resource) {
 		wl_client_post_no_memory(client);
 		munmap(pool->data, pool->size);
+#if defined(__DragonFly__)
+		close(fd);
+#endif
 		free(pool);
 		return;
 	}
@@ -495,6 +532,14 @@ sigbus_handler(int signum, siginfo_t *in
 	sigbus_data->fallback_mapping_used = 1;
 
 	/* This should replace the previous mapping */
+#if defined(__DragonFly__)
+	if (mmap(pool->data, pool->size,
+		 PROT_READ, MAP_PRIVATE | MAP_FIXED | MAP_ANON,
+		 0, 0) == MAP_FAILED) {
+		reraise_sigbus();
+		return;
+	}
+#else
 	if (mmap(pool->data, pool->size,
 		 PROT_READ | PROT_WRITE,
 		 MAP_PRIVATE | MAP_FIXED | MAP_ANONYMOUS,
@@ -502,6 +547,7 @@ sigbus_handler(int signum, siginfo_t *in
 		reraise_sigbus();
 		return;
 	}
+#endif
 }
 
 static void

