# Buildsheet autogenerated by ravenadm tool -- Do not edit.

NAMEBASE=		libva
VERSION=		1.8.2
KEYWORDS=		multimedia
VARIANTS=		standard
SDESC[standard]=	VAAPI wrapper and dummy driver
HOMEPAGE=		https://github.com/01org/libva
CONTACT=		nobody

DOWNLOAD_GROUPS=	main
SITES[main]=		GITHUB/01org:libva:1.8.2
DISTFILE[1]=		generated:main
DF_INDEX=		1
SPKGS[standard]=	single

OPTIONS_AVAILABLE=	none
OPTIONS_STANDARD=	none

BUILDRUN_DEPENDS=	libdrm:single:standard
			video4linux:headers:standard

USES=			autoreconf gmake libtool pkgconfig
XORG_COMPONENTS=	glproto pciaccess xext xfixes

LICENSE=		MIT:single
LICENSE_SCHEME=		solo
LICENSE_FILE=		MIT:{{WRKSRC}}/COPYING

MUST_CONFIGURE=		gnu
CONFIGURE_ARGS=		--program-prefix=va
			--disable-glx
			--disable-egl
			--disable-wayland

INSTALL_TARGET=		install-strip
INSTALL_REQ_TOOLCHAIN=	yes

CFLAGS=			-DHAVE_LINUX_INTEGER_TYPES
LDFLAGS=		-lpthread

post-patch:
	${REINPLACE_CMD} -e 's|\($$libdir\)/dri|\1/va|' ${WRKSRC}/configure.ac
	${REINPLACE_CMD} '/^export VA_HEADER_/d' ${WRKSRC}/doc/Makefile.am

[FILE:274:descriptions/desc.single]
The main motivation for VAAPI (Video Acceleration API) is to enable
hardware accelerated video decode/encode at various entry-points (VLD,
IDCT, Motion Compensation etc.) for the prevailing coding standards
today (MPEG-2, MPEG-4 ASP/H.263, MPEG-4 AVC/H.264, and VC-1/VMW3).


[FILE:103:distinfo]
bce8a3b8f1274dcae3e42146416fd9d1231bab5c40666b7b8aa9e534faa9d400       195281 01org-libva-1.8.2.tar.gz


[FILE:1005:manifests/plist.single]
@comment include/va/va_backend_egl.h
@comment include/va/va_backend_glx.h
@comment include/va/va_egl.h
@comment include/va/va_glx.h
@comment lib/libva-egl.so
@comment lib/libva-egl.so.1
@comment lib/libva-egl.so.1.4000.0
@comment lib/libva-glx.so
@comment lib/libva-glx.so.1
@comment lib/libva-glx.so.1.4000.0
@comment lib/pkgconfig/libva-egl.pc
@comment lib/pkgconfig/libva-glx.pc
include/va/
 va.h
 va_backend.h
 va_backend_tpi.h
 va_backend_vpp.h
 va_compat.h
 va_dec_hevc.h
 va_dec_jpeg.h
 va_dec_vp8.h
 va_dec_vp9.h
 va_dri2.h
 va_dricommon.h
 va_drm.h
 va_drmcommon.h
 va_enc_h264.h
 va_enc_hevc.h
 va_enc_jpeg.h
 va_enc_mpeg2.h
 va_enc_vp8.h
 va_enc_vp9.h
 va_tpi.h
 va_version.h
 va_vpp.h
 va_x11.h
lib/
 libva-drm.so
 libva-drm.so.1
 libva-drm.so.1.4000.0
 libva-tpi.so
 libva-tpi.so.1
 libva-tpi.so.1.4000.0
 libva-x11.so
 libva-x11.so.1
 libva-x11.so.1.4000.0
 libva.so
 libva.so.1
 libva.so.1.4000.0
lib/pkgconfig/
 libva-drm.pc
 libva-tpi.pc
 libva-x11.pc
 libva.pc
lib/va/dummy_drv_video.so


[FILE:521:patches/patch-va__glx__va_glx_private.h]
--- va/glx/va_glx_private.h.orig	2015-07-01 07:54:24 UTC
+++ va/glx/va_glx_private.h
@@ -38,7 +38,7 @@ typedef void (*PFNGLXBINDTEXIMAGEEXTPROC
 typedef void (*PFNGLXRELEASETEXIMAGEEXTPROC)(Display *, GLXDrawable, int);
 #endif
 
-#if GLX_GLXEXT_VERSION < 27
+#if GLX_GLXEXT_VERSION < 21
 /* XXX: this is not exactly that version but this is the only means to
    make sure we have the correct <GL/glx.h> with those signatures */
 typedef GLXPixmap (*PFNGLXCREATEPIXMAPPROC)(Display *, GLXFBConfig, Pixmap, const int *);


[FILE:438:patches/patch-va__va.c]
--- va/va.c.orig	2014-09-30 01:48:34 UTC
+++ va/va.c
@@ -227,7 +227,7 @@
         strncat( driver_path, DRIVER_EXTENSION, strlen(DRIVER_EXTENSION) );
         
         va_infoMessage("Trying to open %s\n", driver_path);
-#ifndef ANDROID
+#if !defined(ANDROID) && defined(RTLD_NODELETE)
         handle = dlopen( driver_path, RTLD_NOW | RTLD_GLOBAL | RTLD_NODELETE );
 #else
         handle = dlopen( driver_path, RTLD_NOW| RTLD_GLOBAL);


[FILE:2183:patches/patch-va_va__trace.c]
--- va/va_trace.c.orig	2016-06-21 01:29:25 UTC
+++ va/va_trace.c
@@ -48,6 +48,9 @@
 #include <sys/stat.h>
 #include <sys/syscall.h>
 #include <pthread.h>
+#ifdef __FreeBSD__
+#include <pthread_np.h>
+#endif
 #include <unistd.h>
 #include <time.h>
 #include <errno.h>
@@ -294,7 +297,13 @@ static void add_trace_config_info(
 {
     struct trace_config_info *pconfig_info;
     int idx = 0;
+#ifdef __FreeBSD__
+    pid_t thd_id = pthread_getthreadid_np();
+#elif defined __DragonFly__
+    pid_t thd_id = syscall(SYS_lwp_gettid);
+#else
     pid_t thd_id = syscall(__NR_gettid);
+#endif
 
     LOCK_RESOURCE(pva_trace);
 
@@ -318,7 +327,13 @@ static void delete_trace_config_info(
 {
     struct trace_config_info *pconfig_info;
     int idx = 0;
+#ifdef __FreeBSD__
+    pid_t thd_id = pthread_getthreadid_np();
+#elif defined __DragonFly__
+    pid_t thd_id = syscall(SYS_lwp_gettid);
+#else
     pid_t thd_id = syscall(__NR_gettid);
+#endif
 
     LOCK_RESOURCE(pva_trace);
 
@@ -663,7 +678,13 @@ static struct trace_log_file *start_trac
 {
     struct trace_log_files_manager *plog_files_mgr = NULL;
     struct trace_log_file *plog_file = NULL;
+#ifdef __FreeBSD__
+    pid_t thd_id = pthread_getthreadid_np();
+#elif defined __DragonFly__
+    pid_t thd_id = syscall(SYS_lwp_gettid);
+#else
     pid_t thd_id = syscall(__NR_gettid);
+#endif
     int i = 0;
 
     LOCK_RESOURCE(pva_trace);
@@ -702,7 +723,13 @@ static void refresh_log_file(
     struct trace_context *ptra_ctx)
 {
     struct trace_log_file *plog_file = NULL;
+#ifdef __FreeBSD__
+    pid_t thd_id = pthread_getthreadid_np();
+#elif defined __DragonFly__
+    pid_t thd_id = syscall(SYS_lwp_gettid);
+#else
     pid_t thd_id = syscall(__NR_gettid);
+#endif
     int i = 0;
 
     plog_file = ptra_ctx->plog_file;
@@ -1226,7 +1253,13 @@ static void internal_TraceUpdateContext 
 {
     struct trace_context *trace_ctx = NULL;
     int i = 0, delete = 1;
+#ifdef __FreeBSD__
+    pid_t thd_id = pthread_getthreadid_np();
+#elif defined __DragonFly__
+    pid_t thd_id = syscall(SYS_lwp_gettid);
+#else
     pid_t thd_id = syscall(__NR_gettid);
+#endif
 
     if(tra_ctx_idx >= MAX_TRACE_CTX_NUM)
         return;

