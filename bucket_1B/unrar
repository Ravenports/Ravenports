# Buildsheet autogenerated by ravenadm tool -- Do not edit.

NAMEBASE=		unrar
VERSION=		5.6.7
KEYWORDS=		archivers
VARIANTS=		standard
SDESC[standard]=	RAR uncompression program and library
HOMEPAGE=		https://www.rarlab.com/
CONTACT=		nobody

DOWNLOAD_GROUPS=	main
SITES[main]=		https://www.rarlab.com/rar/
DISTFILE[1]=		unrarsrc-5.6.7.tar.gz:main
DF_INDEX=		1
SPKGS[standard]=	single

OPTIONS_AVAILABLE=	none
OPTIONS_STANDARD=	none

USES=			ssl c++:single

DISTNAME=		unrar

LICENSE=		CUSTOM1:single
LICENSE_NAME=		CUSTOM1:"unRAR License"
LICENSE_FILE=		CUSTOM1:{{WRKSRC}}/license.txt
LICENSE_SCHEME=		solo

BUILD_TARGET=		unrar lib
MAKEFILE=		makefile

CPPFLAGS=		-I{{OPENSSLINC}}
			-DOPENSSL_AES
LDFLAGS=		-L{{OPENSSLLIB}}
			-lcrypto

do-install:
	@${MKDIR} ${STAGEDIR}${PREFIX}/include/unrar
	${INSTALL_PROGRAM} ${WRKSRC}/unrar ${STAGEDIR}${PREFIX}/bin/
	${INSTALL_DATA} ${WRKSRC}/libunrar.a ${STAGEDIR}${PREFIX}/lib/
	${INSTALL_LIB} ${WRKSRC}/libunrar.so ${STAGEDIR}${PREFIX}/lib/libunrar.so.5
	${LN} -s libunrar.so.5 ${STAGEDIR}${PREFIX}/lib/libunrar.so
	${INSTALL_DATA} ${WRKSRC}/dll.hpp ${STAGEDIR}${PREFIX}/include/unrar/dll.hpp

[FILE:428:descriptions/desc.single]
The unRAR utility is a freeware program, distributed with source code and
developed for extracting, testing and viewing the contents of archives
created with the RAR archiver, version 1.50 and above.

The UnRAR library and utility are a minor part of the RAR archiver and
contain the RAR uncompression algorithm. UnRAR requires a very small
amount of memory to operate. It can be used by other programs to extract
RAR archives.


[FILE:100:distinfo]
ff4613db80a7177da660b20225b2a5162409d4b6a5c5c4dc072e43a3dcf2226b       226579 unrarsrc-5.6.7.tar.gz


[FILE:77:manifests/plist.single]
bin/unrar
include/unrar/dll.hpp
lib/
 libunrar.a
 libunrar.so
 libunrar.so.5


[FILE:1557:patches/patch-makefile]
--- makefile.orig	2017-11-22 06:53:39 UTC
+++ makefile
@@ -2,14 +2,13 @@
 # Makefile for UNIX - unrar
 
 # Linux using GCC
-CXX=c++
-CXXFLAGS=-O2 -Wno-logical-op-parentheses -Wno-switch -Wno-dangling-else
-LIBFLAGS=-fPIC
-DEFINES=-D_FILE_OFFSET_BITS=64 -D_LARGEFILE_SOURCE -DRAR_SMP
-STRIP=strip
-AR=ar
-LDFLAGS=-pthread
-DESTDIR=/usr
+CXX?=		c++
+CXXFLAGS?=	-O2 -Wno-logical-op-parentheses -Wno-switch -Wno-dangling-else
+DEFINES=	-D_FILE_OFFSET_BITS=64 -D_LARGEFILE_SOURCE -DRAR_SMP
+STRIP?=		strip
+AR?=		ar
+LDFLAGS+=	-pthread
+DESTDIR?=	/usr
 
 # Linux using LCC
 #CXX=lcc
@@ -128,9 +127,16 @@ OBJECTS=rar.o strlist.o strfn.o pathfn.o
 	rijndael.o getbits.o sha1.o sha256.o blake2s.o hash.o extinfo.o extract.o volume.o \
   list.o find.o unpack.o headers.o threadpool.o rs16.o cmddata.o ui.o
 
+.SUFFIXES:	.so
+
+SOBJECTS=	${OBJECTS:.o=.so} ${LIB_OBJ:.o=.so}
+
 .cpp.o:
 	$(COMPILE) -D$(WHAT) -c $<
 
+.cpp.so:
+	$(COMPILE) -DRARDLL -fPIC -o ${.TARGET} -c ${.IMPSRC}
+
 all:	unrar
 
 install:	install-unrar
@@ -151,13 +157,11 @@ sfx:	clean $(OBJECTS)
 	$(LINK) -o default.sfx $(LDFLAGS) $(OBJECTS)
 	$(STRIP) default.sfx
 
-lib:	WHAT=RARDLL
-lib:	CXXFLAGS+=$(LIBFLAGS)
-lib:	clean $(OBJECTS) $(LIB_OBJ)
+lib:	$(SOBJECTS)
 	@rm -f libunrar.so
 	@rm -f libunrar.a
-	$(LINK) -shared -o libunrar.so $(LDFLAGS) $(OBJECTS) $(LIB_OBJ)
-	$(AR) rcs libunrar.a $(OBJECTS) $(LIB_OBJ)
+	$(LINK) -shared -o libunrar.so $(LDFLAGS) -Wl,-soname,libunrar.so.5 $(SOBJECTS) 
+	$(AR) rcs libunrar.a $(SOBJECTS)
 
 install-unrar:
 			install -D unrar $(DESTDIR)/bin/unrar


[FILE:213:patches/patch-os.hpp]
--- os.hpp.orig	2018-06-24 15:10:31 UTC
+++ os.hpp
@@ -161,6 +161,10 @@
 #include <locale.h>
 
 
+#ifdef OPENSSL_AES
+#include <openssl/evp.h>
+#endif // OPENSSL_AES
+
 #ifdef  S_IFLNK
 #define SAVE_LINKS
 #endif


[FILE:3006:patches/patch-rijndael.cpp]
--- rijndael.cpp.orig	2018-06-24 15:10:31 UTC
+++ rijndael.cpp
@@ -7,6 +7,8 @@
  ***************************************************************************/
 #include "rar.hpp"
 
+#ifndef OPENSSL_AES
+
 #ifdef USE_SSE
 #include <wmmintrin.h>
 #endif
@@ -56,6 +58,7 @@ inline void Copy128(byte *dest,const byt
 #endif
 }
 
+#endif // OPENSSL_AES
 
 //////////////////////////////////////////////////////////////////////////////////////////////////////////////////
 // API
@@ -63,14 +66,35 @@ inline void Copy128(byte *dest,const byt
 
 Rijndael::Rijndael()
 {
+#ifndef OPENSSL_AES
   if (S[0]==0)
     GenerateTables();
+#endif // OPENSSL_AES
   CBCMode = true; // Always true for RAR.
 }
 
 
 void Rijndael::Init(bool Encrypt,const byte *key,uint keyLen,const byte * initVector)
 {
+#ifdef OPENSSL_AES
+  const EVP_CIPHER *cipher;
+  switch(keyLen)
+  {
+    case 128:
+      cipher = EVP_aes_128_cbc();
+      break;
+    case 192:
+      cipher = EVP_aes_192_cbc();
+      break;
+    case 256:
+      cipher = EVP_aes_256_cbc();
+      break;
+  }
+
+  EVP_CIPHER_CTX_init(&ctx);
+  EVP_CipherInit_ex(&ctx, cipher, NULL, key, initVector, Encrypt);
+  EVP_CIPHER_CTX_set_padding(&ctx, 0);
+#else // OPENSSL_AES
 #ifdef USE_SSE
   // Check SSE here instead of constructor, so if object is a part of some
   // structure memset'ed before use, this variable is not lost.
@@ -111,6 +135,7 @@ void Rijndael::Init(bool Encrypt,const b
 
   if(!Encrypt)
     keyEncToDec();
+#endif // OPENSSL_AES
 }
 
 void Rijndael::blockEncrypt(const byte *input,size_t inputLen,byte *outBuffer)
@@ -118,6 +143,11 @@ void Rijndael::blockEncrypt(const byte *
   if (inputLen <= 0)
     return;
 
+#ifdef OPENSSL_AES
+  int outLen;
+  EVP_CipherUpdate(&ctx, outBuffer, &outLen, input, inputLen);
+  return;
+#else // OPENSSL_AES
   size_t numBlocks = inputLen/16;
 #ifdef USE_SSE
   if (AES_NI)
@@ -176,6 +206,7 @@ void Rijndael::blockEncrypt(const byte *
     input += 16;
   }
   Copy128(m_initVector,prevBlock);
+#endif // OPENSSL_AES
 }
 
 
@@ -217,6 +248,11 @@ void Rijndael::blockDecrypt(const byte *
   if (inputLen <= 0)
     return;
 
+#ifdef OPENSSL_AES
+  int outLen;
+  EVP_CipherUpdate(&ctx, outBuffer, &outLen, input, inputLen);
+  return;
+#else // OPENSSL_AES
   size_t numBlocks=inputLen/16;
 #ifdef USE_SSE
   if (AES_NI)
@@ -279,6 +315,8 @@ void Rijndael::blockDecrypt(const byte *
   }
 
   memcpy(m_initVector,iv,16);
+
+#endif // OPENSSL_AES
 }
 
 
@@ -314,7 +352,7 @@ void Rijndael::blockDecryptSSE(const byt
 }
 #endif
 
-
+#ifndef OPENSSL_AES
 //////////////////////////////////////////////////////////////////////////////////////////////////////////////////
 // ALGORITHM
 //////////////////////////////////////////////////////////////////////////////////////////////////////////////////
@@ -454,7 +492,7 @@ void Rijndael::GenerateTables()
     U1[b][0]=U2[b][1]=U3[b][2]=U4[b][3]=T5[i][0]=T6[i][1]=T7[i][2]=T8[i][3]=FFmul0e(b);
   }
 }
-
+#endif // OPENSSL_AES
 
 #if 0
 static void TestRijndael();


[FILE:662:patches/patch-rijndael.hpp]
--- rijndael.hpp.orig	2018-06-24 15:10:31 UTC
+++ rijndael.hpp
@@ -16,6 +16,9 @@
 class Rijndael
 { 
   private:
+#ifdef OPENSSL_AES
+    EVP_CIPHER_CTX ctx;
+#else // OPENSSL_AES
 #ifdef USE_SSE
     void blockEncryptSSE(const byte *input,size_t numBlocks,byte *outBuffer);
     void blockDecryptSSE(const byte *input, size_t numBlocks, byte *outBuffer);
@@ -25,6 +28,7 @@ class Rijndael
     void keySched(byte key[_MAX_KEY_COLUMNS][4]);
     void keyEncToDec();
     void GenerateTables();
+#endif // OPENSSL_AES
 
     // RAR always uses CBC, but we may need to turn it off when calling
     // this code from other archive formats with CTR and other modes.

