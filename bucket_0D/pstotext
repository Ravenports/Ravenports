# Buildsheet autogenerated by ravenadm tool -- Do not edit.

NAMEBASE=		pstotext
VERSION=		1.9
KEYWORDS=		print
VARIANTS=		std
SDESC[std]=		Extract text from PostScript or PDF files
HOMEPAGE=		none
CONTACT=		Michael_Reim[kraileth@elderlinux.org]

DOWNLOAD_GROUPS=	main
SITES[main]=		http://ravenports.elderlinux.org/distcache/
DISTFILE[1]=		pstotext-1.9.tar.gz:main
DF_INDEX=		1
SPKGS[std]=		single

OPTIONS_AVAILABLE=	none
OPTIONS_STANDARD=	none

RUN_DEPENDS=		ghostscript:primary:std

USES=			gmake

LICENSE=		CUSTOM1:single
LICENSE_NAME=		CUSTOM1:"DEC EULA"
LICENSE_FILE=		CUSTOM1:{{WRKDIR}}/EULA
LICENSE_SCHEME=		solo

FPC_EQUIVALENT=		print/pstotext

post-extract:
	${AWK} '/GRANT/,EOF { print $0 }' ${WRKSRC}/pstotext.txt > \
		${WRKDIR}/EULA

do-install:
	${INSTALL_PROGRAM} ${WRKSRC}/pstotext \
		${STAGEDIR}${PREFIX}/bin/pstotext
	${INSTALL_MAN} ${WRKSRC}/pstotext.1 \
		${STAGEDIR}${PREFIX}/share/man/man1/pstotext.1
	${MKDIR} ${STAGEDIR}${PREFIX}/share/pstotext
	${INSTALL_DATA} ${WRKSRC}/pstotext.txt \
		${STAGEDIR}${PREFIX}/share/pstotext/pstotext.txt

[FILE:200:descriptions/desc.single]
pstotext extracts ASCII text from PostScript and PDF files. It uses
Ghostscript, but does a more careful job with kerned characters and
nonstandard font encodings than Ghostscript's ps2ascii utility.


[FILE:98:distinfo]
cfe0a251d0d43982a7d3bdf1d1670c854432739d00cb593c9beaca4b2cc36c27        37461 pstotext-1.9.tar.gz


[FILE:70:manifests/plist.single]
bin/pstotext
share/man/man1/pstotext.1.gz
share/pstotext/pstotext.txt


[FILE:3419:patches/patch-main.c]
--- main.c.orig	2004-01-09 11:17:38.000000000 +0100
+++ main.c	2020-06-07 18:29:44.026073000 +0200
@@ -126,12 +126,14 @@
 static int cleanup(void) {
   int gsstatus, status = 0;
   pstotextExit(instance);
-  if (gs!=NULL) {
 #ifdef VMS
+  if (gs!=NULL) {
     gsstatus = fclose(gs);
+  }
 #else
-    gsstatus = pclose(gs);
+  waitpid(-1, &gsstatus, 0);
 #endif
+  if (gsstatus) {
     if (WIFEXITED(gsstatus)) {
       if (WEXITSTATUS(gsstatus)!=0) status = 3;
       else if (WIFSIGNALED(gsstatus)) status = 4;
@@ -166,8 +168,13 @@
 
 static int do_it(char *path) {
   /* If "path" is NULL, then "stdin" should be processed. */
-  char *gs_cmdline;
-  char *input;
+  char *gs_argv[32];
+  int gs_argc=0;
+#ifdef DEBUG
+  int i;
+#endif
+  int fd[2];
+  pid_t p;
   int status;
   char norotate[] = "";
   FILE *fileout;
@@ -201,47 +208,31 @@
     exit(1);
   }
 
-  if (path==NULL) {
-    input = (char*)malloc(2);
-    if (input == NULL) {
-      fprintf(stderr,"No memory available\n");
-      cleanup();
-      exit(1);
-    }
-    strcpy(input, "-");
-  } else {
-    input = (char*)malloc(strlen(path) + 6);
-    if (input == NULL) {
-      fprintf(stderr,"No memory available\n");
-      cleanup();
-      exit(1);
-    }
-    strcpy(input, "-- '"); strcat(input, path); strcat(input, "'");
+  gs_argv[gs_argc++] = "gs";
+  gs_argv[gs_argc++] = "-r72";
+  gs_argv[gs_argc++] = "-dNODISPLAY";
+  gs_argv[gs_argc++] = "-dFIXEDMEDIA";
+  gs_argv[gs_argc++] = "-dDELAYBIND";
+  gs_argv[gs_argc++] = "-dWRITESYSTEMDICT";
+  if (!debug) {
+    gs_argv[gs_argc++] = "-q";
+  }
+  gs_argv[gs_argc++] = "-dNOPAUSE";
+  gs_argv[gs_argc++] = "-dSAFER";
+  if (rotate_path && strcmp(rotate_path, "")) {
+    gs_argv[gs_argc++] = rotate_path;
+  }
+  if (ocr_path && strcmp(ocr_path, "")) {
+    gs_argv[gs_argc++] = ocr_path;
+  }
+  if (path == NULL ) {
+    gs_argv[gs_argc++] = "-";
+  }
+  else {
+    gs_argv[gs_argc++] = "--";
+    gs_argv[gs_argc++] = path;
   }
-
-  gs_cmdline = (char*)malloc(strlen(gs_cmd)+strlen(rotate_path)+
-	strlen(ocr_path) + strlen(input) + 128);
-
-  if (gs_cmdline == NULL) {
-    fprintf(stderr, "No memory available\n");
-    cleanup();
-    exit(1);
-  }
-
-  sprintf(
-    gs_cmdline,
-#ifdef VMS
-    "%s -r72 \"-dNODISPLAY\" \"-dFIXEDMEDIA\" \"-dDELAYBIND\" \"-dWRITESYSTEMDICT\" %s \"-dNOPAUSE\" %s %s %s",
-#else
-    "%s -r72 -dNODISPLAY -dFIXEDMEDIA -dDELAYBIND -dWRITESYSTEMDICT %s -dNOPAUSE %s %s %s",
-#endif
-    gs_cmd,
-    (debug ? "" : "-q"),
-    rotate_path,
-    ocr_path,
-    input
-    );
-  if (debug) fprintf(stderr, "%s\n", gs_cmdline);
+  gs_argv[gs_argc++] = NULL;
 #ifdef VMS
   cmdfile = tempnam("SYS$SCRATCH:","PS2TGS");
   gsoutfile = tempnam("SYS$SCRATCH:","GSRES");
@@ -259,8 +250,25 @@
 	exit(1);
   }
 #else
-  gs = popen(gs_cmdline, "r");
-  if (gs==0) {perror(cmd); exit(1);}
+  if (pipe(fd)) {
+	perror("pipe failed: "); exit(1);
+  };
+  p = fork();
+  if (p == -1) {
+	perror("fork failed: "); exit(1);
+  }
+  if (p == 0) { /* child */
+    close(fd[0]);
+    dup2(fd[1], 1); /* Redirect stdout into pipe to parent */
+    execvp("%%LOCALBASE%%/bin/gs", gs_argv);
+    perror("execvp: "); status=cleanup(); exit(1);
+  } else { /* parent */
+    close(fd[1]);
+    gs = fdopen(fd[0], "r");
+    if (gs == NULL) {
+      perror("fdopen: "); status=cleanup(); exit(1);
+    }
+  }
 #endif
   status = pstotextInit(&instance);
   if (status!=0) {

