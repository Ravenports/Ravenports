# Buildsheet autogenerated by ravenadm tool -- Do not edit.

NAMEBASE=		sndio
VERSION=		1.2.0
KEYWORDS=		audio
VARIANTS=		standard
SDESC[standard]=	Small audio and MIDI framework from OpenBSD
HOMEPAGE=		http://www.sndio.org/
CONTACT=		nobody

DOWNLOAD_GROUPS=	main
SITES[main]=		http://www.sndio.org/
DISTFILE[1]=		sndio-1.2.0.tar.gz:main
DF_INDEX=		1
SPKGS[standard]=	single

OPTIONS_AVAILABLE=	none
OPTIONS_STANDARD=	none

USERS=			_sndio
GROUPS=			_sndio
USERGROUP_SPKG=		single

LICENSE=		ISCL:single
LICENSE_SCHEME=		solo
LICENSE_FILE=		ISCL:{{WRKDIR}}/ISC_LICENSE

FPC_EQUIVALENT=		audio/sndio

MUST_CONFIGURE=		yes
CONFIGURE_ARGS=		--prefix={{PREFIX}}
			--mandir={{MANPREFIX}}/man

SINGLE_JOB=		yes

RC_SUBR=		sndiod:single

post-patch:
	# Make sure sndiod can be started inside jails as root
	@${REINPLACE_CMD} 's|err(1, "setpriority")|warn("setpriority")|' \
		${WRKSRC}/sndiod/sndiod.c

post-patch-dragonfly:
	${REINPLACE_CMD} -e 's@\(FreeBSD\))@\1|DragonFly)@g' \
		${WRKSRC}/configure

post-install:
	${STRIP_CMD} \
		${STAGEDIR}${PREFIX}/lib/libsndio.so.6.1 \
		${STAGEDIR}${PREFIX}/bin/sndiod \
		${STAGEDIR}${PREFIX}/bin/aucat \
		${STAGEDIR}${PREFIX}/bin/midicat

post-extract:
	${AWK} '/^#ifndef/ {exit}; {print}' ${WRKSRC}/libsndio/sndio.h \
		> ${WRKDIR}/ISC_LICENSE

[FILE:449:descriptions/desc.single]
Sndio is a small audio and MIDI framework part of the OpenBSD project.

It provides an lightweight audio & MIDI server and a fully documented
user-space API to access either the server or directly the hardware in
a uniform way.  Sndio is designed to work for desktop applications,
but pays special attention to synchronization mechanisms and
reliability required by music applications.  Reliability through
simplicity are part of the project goals.


[FILE:97:distinfo]
b9808e189481904a4404b0c1715ad0c4b301e72abca8e49653bb526ff4e16cdc       123703 sndio-1.2.0.tar.gz


[FILE:593:manifests/plist.single]
bin/
 aucat
 midicat
 sndiod
include/sndio.h
lib/
 libsndio.so
 libsndio.so.6.1
share/man/man1/
 aucat.1.gz
 midicat.1.gz
share/man/man3/
 mio_close.3.gz
 mio_eof.3.gz
 mio_nfds.3.gz
 mio_open.3.gz
 mio_pollfd.3.gz
 mio_read.3.gz
 mio_revents.3.gz
 mio_write.3.gz
 sio_close.3.gz
 sio_eof.3.gz
 sio_getcap.3.gz
 sio_getpar.3.gz
 sio_initpar.3.gz
 sio_nfds.3.gz
 sio_onmove.3.gz
 sio_onvol.3.gz
 sio_open.3.gz
 sio_pollfd.3.gz
 sio_read.3.gz
 sio_revents.3.gz
 sio_setpar.3.gz
 sio_setvol.3.gz
 sio_start.3.gz
 sio_stop.3.gz
 sio_write.3.gz
share/man/man7/sndio.7.gz
share/man/man8/sndiod.8.gz


[FILE:395:patches/patch-libsndio_sio.c]
--- libsndio/sio.c.orig	2016-11-06 11:21:59 UTC
+++ libsndio/sio.c
@@ -65,7 +65,7 @@ sio_open(const char *str, unsigned int m
 #if defined(USE_SUN)
 		return _sio_sun_open("rsnd/0", mode, nbio);
 #elif defined(USE_OSS)
-		return _sio_oss_open("rsnd/0", mode, nbio);
+		return _sio_oss_open(SIO_DEVANY, mode, nbio);
 #elif defined(USE_ALSA)
 		return _sio_alsa_open("rsnd/0", mode, nbio);
 #else


[FILE:4054:patches/patch-libsndio_sio__oss.c]
--- libsndio/sio_oss.c.orig	2016-11-06 11:21:59 UTC
+++ libsndio/sio_oss.c
@@ -108,6 +108,8 @@ static int sio_oss_xrun(struct sio_oss_hdl *);
 static size_t sio_oss_read(struct sio_hdl *, void *, size_t);
 static size_t sio_oss_write(struct sio_hdl *, const void *, size_t);
 static void sio_oss_close(struct sio_hdl *);
+static int sio_oss_setvol(struct sio_hdl *, unsigned int);
+static void sio_oss_getvol(struct sio_hdl *);
 
 static struct sio_ops sio_oss_ops = {
 	sio_oss_close,
@@ -121,8 +123,8 @@ static struct sio_ops sio_oss_ops = {
 	sio_oss_nfds,
 	sio_oss_pollfd,
 	sio_oss_revents,
-	NULL, /* setvol */
-	NULL, /* getvol */
+	sio_oss_setvol,
+	sio_oss_getvol,
 };
 
 /*
@@ -228,12 +230,10 @@ sio_oss_getcap(struct sio_hdl *sh, struct sio_cap *cap
 }
 
 static int
-sio_oss_getfd(const char *str, unsigned int mode, int nbio)
+_sio_oss_getdev(const char *str, char *path, size_t len)
 {
 	const char *p;
-	char path[DEVPATH_MAX];
 	unsigned int devnum;
-	int fd, flags, val;
 
 	p = _sndio_parsetype(str, "rsnd");
 	if (p == NULL) {
@@ -253,7 +253,24 @@ sio_oss_getfd(const char *str, unsigned int mode, int 
 		DPRINTF("sio_oss_getfd: %s: number expected after '/'\n", str);
 		return -1;
 	}
-	snprintf(path, sizeof(path), DEVPATH_PREFIX "%u", devnum);
+	snprintf(path, len, DEVPATH_PREFIX "%u", devnum);
+	return 0;
+}
+
+static int
+sio_oss_getfd(const char *str, unsigned int mode, int nbio)
+{
+	char path[DEVPATH_MAX];
+	int fd, flags, val;
+	audio_buf_info bi;
+
+	if (strcmp(str, SIO_DEVANY) == 0) {
+		/* Use /dev/dsp (the default device) directly */
+		snprintf(path, sizeof(path), DEVPATH_PREFIX);
+	} else if (_sio_oss_getdev(str, path, sizeof(path)) < 0) {
+		return -1;
+	}
+
 	if (mode == (SIO_PLAY | SIO_REC))
 		flags = O_RDWR;
 	else
@@ -264,6 +281,19 @@ sio_oss_getfd(const char *str, unsigned int mode, int 
 		DPERROR(path);
 		return -1;
 	}
+	/*
+	 * Check if the device supports playing/recording.
+	 * Unfortunately, it's possible for devices to be opened RDWR
+	 * even when they don't support playing/recording.
+	 */
+	if (mode & SIO_PLAY && ioctl(fd, SNDCTL_DSP_GETOSPACE, &bi) < 0) {
+		close(fd);
+		return -1;
+	}
+	if (mode & SIO_REC && ioctl(fd, SNDCTL_DSP_GETISPACE, &bi) < 0) {
+		close(fd);
+		return -1;
+	}
 	val = 1;
 	if (ioctl(fd, SNDCTL_DSP_LOW_WATER, &val) < 0) {
 		DPERROR("sio_oss_start: LOW_WATER");
@@ -383,13 +413,25 @@ sio_oss_setpar(struct sio_hdl *sh, struct sio_par *par
 	struct sio_oss_hdl *hdl = (struct sio_oss_hdl *)sh;
 	unsigned int i, round, bufsz;
 	int frag_max, frag_shift, frag_count, frag;
+	unsigned int le, sig, msb;
 
+	le = par->le;
+	sig = par->sig;
+	msb = par->msb;
+
+	if (le == ~0U)
+		le = 0;
+	if (sig == ~0U)
+		sig = 0;
+	if (msb == ~0U)
+		msb = 0;
+
 	hdl->fmt = AFMT_S16_LE;
 	for (i = 0; i < sizeof(formats)/sizeof(formats[0]); i++) {
 		if (formats[i].bits == par->bits &&
-		    formats[i].le == par->le &&
-		    formats[i].sig == par->sig &&
-		    formats[i].msb == par->msb) {
+		    formats[i].le == le &&
+		    formats[i].sig == sig &&
+		    formats[i].msb == msb) {
 			hdl->fmt = formats[i].fmt;
 			break;
 		}
@@ -734,6 +776,42 @@ sio_oss_revents(struct sio_hdl *sh, struct pollfd *pfd
 		hdl->odelta -= delta;
 	}
 	return revents;
+}
+
+static int
+sio_oss_setvol(struct sio_hdl *sh, unsigned int vol)
+{
+	struct sio_oss_hdl *hdl = (struct sio_oss_hdl *)sh;
+	int newvol;
+
+	/* Scale to 0..100 */
+	newvol = 1.0 * 100 * vol / SIO_MAXVOL;
+	newvol = newvol | (newvol << 8);
+
+	if (ioctl(hdl->fd, SNDCTL_DSP_SETPLAYVOL, &newvol) < 0) {
+		DPERROR("sio_oss_setvol");
+		hdl->sio.eof = 1;
+		return 0;
+	}
+
+	return 1;
+}
+
+static void
+sio_oss_getvol(struct sio_hdl *sh)
+{
+	struct sio_oss_hdl *hdl = (struct sio_oss_hdl *)sh;
+	int vol;
+
+	if (ioctl(hdl->fd, SNDCTL_DSP_GETPLAYVOL, &vol) < 0) {
+		DPERROR("sio_oss_getvol");
+		hdl->sio.eof = 1;
+		return;
+	}
+
+	/* Use left channel volume and scale to SIO_MAXVOL */
+	vol = SIO_MAXVOL * 1.0 * (vol & 0x7f) / 100;
+	_sio_onvol_cb(&hdl->sio, vol);
 }
 
 #endif /* defined USE_OSS */


[FILE:465:files/sndiod.in]
#!/bin/sh
#
# $FreeBSD: head/audio/sndio/files/sndiod.in 427071 2016-11-25 01:11:41Z cpm $
#
# PROVIDE: sndiod
# REQUIRE: NETWORKING sysctl
# BEFORE:  DAEMON
# KEYWORD: shutdown

. /etc/rc.subr

name=sndiod
rcvar=sndiod_enable

load_rc_config $name

: ${sndiod_dev="rsnd/$($SYSCTL -n hw.snd.default_unit)"}
: ${sndiod_enable="NO"}
: ${sndiod_flags="-f ${sndiod_dev} -c 0:7 -j off -s default -m mon -s monitor"}

command="%%PREFIX%%/bin/sndiod"

run_rc_command "$1"

