# Buildsheet autogenerated by ravenadm tool -- Do not edit.

NAMEBASE=		apr1
VERSION=		1.7.3
KEYWORDS=		devel
VARIANTS=		standard
SDESC[standard]=	Apache Portable Runtime library
HOMEPAGE=		https://apr.apache.org/
CONTACT=		nobody

DOWNLOAD_GROUPS=	main
SITES[main]=		APACHE/apr
DISTFILE[1]=		apr-1.7.3.tar.gz:main
DF_INDEX=		1
SPKGS[standard]=	complete
			primary
			dev

OPTIONS_AVAILABLE=	none
OPTIONS_STANDARD=	none

USES=			cpe iconv libtool ssl

DISTNAME=		apr-1.7.3

LICENSE=		APACHE20:primary
LICENSE_TERMS=		primary:{{WRKDIR}}/TERMS
LICENSE_FILE=		APACHE20:{{WRKSRC}}/LICENSE
LICENSE_AWK=		TERMS:"^$$"
LICENSE_SOURCE=		TERMS:{{WRKSRC}}/include/apr.h.in
LICENSE_SCHEME=		solo

CPE_PRODUCT=		portable_runtime
CPE_VENDOR=		apache

MUST_CONFIGURE=		gnu
CONFIGURE_ARGS=		--with-installbuilddir={{PREFIX}}/share/apr1/build-1
			--enable-threads
			--enable-posix-shm
			--enable-ipv6
			--with-devrandom
			--with-crypto
			--with-openssl={{OPENSSLBASE}}

PLIST_SUB=		SOVERSION=0.7.3
			SOMAJOR=0

CPPFLAGS=		-I{{OPENSSLINC}}
LDFLAGS=		-L{{OPENSSLLIB}}

post-patch:
	${REINPLACE_CMD} -e 's/OSVERSION/${OSVERSION}/g' \
		${WRKSRC}/configure
	${REINPLACE_CMD} -e '/recursive:/s/$$/ .MAKE/' \
		${WRKSRC}/build/apr_rules.mk.in

post-install:
	${STRIP_CMD} ${STAGEDIR}${PREFIX}/lib/libapr-1.so

post-extract:
	# cleanup files not used on this platform
	${FIND} ${WRKDIR} -type f \( -name 'NWGNU*' -o -name '*.ds?' -o -name '*.dep' -o -name '*.mak' -o -name '*.win' \) -delete

[FILE:203:descriptions/desc.primary]
The Apache Portable Runtime is a library of C data structures and routines,
forming a system portability layer that covers as many operating systems as
possible, including Unices, Win32, BeOS, and OS/2.


[FILE:95:distinfo]
af9bfd5b8a04425d6b419673f3e0a7656fade226aae78180d93f8a6f2d3d1c09      1097690 apr-1.7.3.tar.gz


[FILE:83:manifests/plist.primary]
bin/apr-1-config
lib/
 apr.exp
 libapr-1.so.%%SOMAJOR%%
 libapr-1.so.%%SOVERSION%%


[FILE:754:manifests/plist.dev]
include/apr-1/
 apr.h
 apr_allocator.h
 apr_atomic.h
 apr_cstr.h
 apr_dso.h
 apr_encode.h
 apr_env.h
 apr_errno.h
 apr_escape.h
 apr_file_info.h
 apr_file_io.h
 apr_fnmatch.h
 apr_general.h
 apr_getopt.h
 apr_global_mutex.h
 apr_hash.h
 apr_inherit.h
 apr_lib.h
 apr_mmap.h
 apr_network_io.h
 apr_perms_set.h
 apr_poll.h
 apr_pools.h
 apr_portable.h
 apr_proc_mutex.h
 apr_random.h
 apr_ring.h
 apr_shm.h
 apr_signal.h
 apr_skiplist.h
 apr_strings.h
 apr_support.h
 apr_tables.h
 apr_thread_cond.h
 apr_thread_mutex.h
 apr_thread_proc.h
 apr_thread_rwlock.h
 apr_time.h
 apr_user.h
 apr_version.h
 apr_want.h
lib/
 libapr-1.a
 libapr-1.so
lib/pkgconfig/apr-1.pc
share/apr1/build-1/
 apr_rules.mk
 libtool
 make_exports.awk
 make_var_export.awk
 mkdir.sh


[FILE:876:patches/patch-configure]
--- configure.orig	2023-03-27 08:01:20 UTC
+++ configure
@@ -7597,11 +7597,7 @@ if test "x$apr_preload_done" != "xyes" ;
     apr_lock_method="USE_FLOCK_SERIALIZE"
   fi
 
-        if test -x /sbin/sysctl; then
-            os_version=`/sbin/sysctl -n kern.osreldate`
-        else
-            os_version=000000
-        fi
+            os_version="OSVERSION"
         # 502102 is when libc_r switched to libpthread (aka libkse).
         if test $os_version -ge "502102"; then
           apr_cv_pthreads_cflags="none"
@@ -20557,11 +20553,7 @@ fi
 # comparisons.
 case $host in
     *freebsd*)
-        if test -x /sbin/sysctl; then
-            os_version=`/sbin/sysctl -n kern.osreldate`
-        else
-            os_version=000000
-        fi
+            os_version="OSVERSION"
         ;;
     *linux*)
         os_major=`uname -r | sed -e 's/\([1-9][0-9]*\)\..*/\1/'`


[FILE:3025:freebsd/patch-poll_unix_kqueue.c]
# upstram PR: https://bz.apache.org/bugzilla/show_bug.cgi?id=59914
# FreeBSD PR: 211430
========================================================================
--- poll/unix/kqueue.c.orig	2022-01-19 23:17:18 UTC
+++ poll/unix/kqueue.c
@@ -25,21 +25,40 @@
 
 #ifdef HAVE_KQUEUE
 
-static apr_int16_t get_kqueue_revent(apr_int16_t event, apr_int16_t flags)
+static apr_int16_t get_kqueue_revent(apr_int16_t event, apr_int16_t flags,
+                                     int fflags, intptr_t data)
 {
     apr_int16_t rv = 0;
 
-    if (event == EVFILT_READ)
-        rv |= APR_POLLIN;
-    else if (event == EVFILT_WRITE)
-        rv |= APR_POLLOUT;
-    if (flags & EV_EOF)
-        rv |= APR_POLLHUP;
-    /* APR_POLLPRI, APR_POLLERR, and APR_POLLNVAL are not handled by this
-     * implementation.
+    /* APR_POLLPRI and APR_POLLNVAL are not handled by this implementation.
      * TODO: See if EV_ERROR + certain system errors in the returned data field
      * should map to APR_POLLNVAL.
      */
+    if (event == EVFILT_READ) {
+	if (data > 0 || fflags == 0)
+	    rv |= APR_POLLIN;
+	else
+	    rv |= APR_POLLERR;
+        /*
+	 * Don't return POLLHUP if connect fails.  Apparently Linux
+         * does not, and this is expected by serf in order for IPv6 to
+	 * IPv4 or multihomed host fallback to work.
+         *
+	 * ETIMEDOUT is ambiguous here since we don't know if a
+	 * connection was established.  We don't want to return
+	 * POLLHUP here if the connection attempt timed out, but
+	 * we do if the connection was successful but later dropped.
+	 * For now, favor the latter.
+	 */
+	if ((flags & EV_EOF) != 0 && fflags != ECONNREFUSED &&
+	    fflags != ENETUNREACH && fflags != EHOSTUNREACH)
+	    rv |= APR_POLLHUP;
+    } else if (event == EVFILT_WRITE) {
+	if (data > 0 || fflags == 0)
+	    rv |= APR_POLLOUT;
+	else
+	    rv |= APR_POLLERR;
+    }
     return rv;
 }
 
@@ -293,7 +312,9 @@ static apr_status_t impl_pollset_poll(ap
                 pollset->p->result_set[j] = *fd;
                 pollset->p->result_set[j].rtnevents =
                         get_kqueue_revent(pollset->p->ke_set[i].filter,
-                                          pollset->p->ke_set[i].flags);
+                                          pollset->p->ke_set[i].flags,
+                                          pollset->p->ke_set[i].fflags,
+                                          pollset->p->ke_set[i].data);
                 j++;
             }
         }
@@ -478,7 +499,9 @@ static apr_status_t impl_pollcb_poll(apr
             }
 
             pollfd->rtnevents = get_kqueue_revent(pollcb->pollset.ke[i].filter,
-                                                  pollcb->pollset.ke[i].flags);
+                                                  pollcb->pollset.ke[i].flags,
+                                                  pollcb->pollset.ke[i].fflags,
+                                                  pollcb->pollset.ke[i].data);
             
             rv = func(baton, pollfd);
             

